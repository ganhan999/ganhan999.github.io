<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java Mybatis | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1618573423900">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1618573423900" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java Mybatis
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-12-30 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="mybatis">MyBatis</h1>
<h2 id="1-简介">1、简介</h2>
<h3 id="11-什么是mybatis">1.1 什么是Mybatis</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020062316463790.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><strong>MyBatis 是一款优秀的持久层框架;</strong></li>
<li>它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<h3 id="12-持久化">1.2 持久化</h3>
<p>数据持久化</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>内存：<strong>断电即失</strong></li>
<li>数据库（Jdbc）,io文件持久化。</li>
</ul>
<p><strong>为什么要持久化？</strong></p>
<ul>
<li>有一些对象，不能让他丢掉</li>
<li>内存太贵</li>
</ul>
<h3 id="13-持久层">1.3 持久层</h3>
<p>Dao层、Service层、Controller层</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界限十分明显</li>
</ul>
<h3 id="14-为什么需要mybatis">1.4 为什么需要MyBatis</h3>
<ul>
<li>帮助程序员将数据存入到数据库中</li>
<li>方便</li>
<li>传统的JDBC代码太复杂了，简化，框架，自动化</li>
<li>不用MyBatis也可以，技术没有高低之分</li>
<li>优点：
<ul>
<li>简单易学</li>
<li>灵活</li>
<li>sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql</li>
</ul>
</li>
</ul>
<h2 id="2-第一个mybatis程序">2、第一个Mybatis程序</h2>
<p>思路：搭建环境 --&gt; 导入MyBatis --&gt; 编写代码 --&gt; 测试</p>
<h3 id="21-搭建环境">2.1 搭建环境</h3>
<p>新建项目</p>
<ol>
<li>
<p>创建一个普通的maven项目</p>
</li>
<li>
<p>删除src目录 （就可以把此工程当做父工程了，然后创建子工程）</p>
</li>
<li>
<p>导入maven依赖</p>
<pre><code class="language-xml">&lt;!--导入依赖--&gt;
&lt;dependencies&gt;
    &lt;!--mysqlq驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.12&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li>
<p>创建一个Module</p>
</li>
</ol>
<h3 id="22-创建一个模块">2.2 创建一个模块</h3>
<ul>
<li>
<p>编写mybatis的核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!--configuration核心配置文件--&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li>
<p>编写mybatis工具类</p>
<pre><code class="language-java">//sqlSessionFactory --&gt; sqlSession
public class MybatisUtils {

    static SqlSessionFactory sqlSessionFactory = null;

    static {
        try {
            //使用Mybatis第一步 ：获取sqlSessionFactory对象
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例.
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
    public static SqlSession getSqlSession(){
        return sqlSessionFactory.openSession();
    }
}
</code></pre>
</li>
</ul>
<h3 id="23-编写代码">2.3 编写代码</h3>
<ul>
<li>
<p>实体类</p>
</li>
<li>
<p>Dao接口</p>
<pre><code class="language-java">public interface UserDao {
    public List&lt;User&gt; getUserList();
}
</code></pre>
</li>
<li>
<p>接口实现类 （由原来的UserDaoImpl转变为一个Mapper配置文件）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!--namespace=绑定一个指定的Dao/Mapper接口--&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt;
    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select * from USER
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<p><strong>注意点：</strong></p>
<p>org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.</p>
<p><strong>MapperRegistry是什么?</strong></p>
<p>核心配置文件中注册mappers</p>
<ul>
<li>
<p>junit测试</p>
<pre><code class="language-java">    @Test
    public void test(){

        //1.获取SqlSession对象
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        //2.执行SQL
        // 方式一：getMapper
        UserDao userDao = sqlSession.getMapper(UserDao.class);
        List&lt;User&gt; userList = userDao.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }

        //关闭sqlSession
        sqlSession.close();
    }
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>可能会遇到的问题：</strong></p>
<ol>
<li>配置文件没有注册</li>
<li>绑定接口错误</li>
<li>方法名不对</li>
<li>返回类型不对</li>
<li>Maven导出资源问题</li>
</ol>
<h2 id="3-curd">3、CURD</h2>
<h3 id="1-namespace">1. namespace</h3>
<p>namespace中的包名要和Dao/Mapper接口的包名一致</p>
<h3 id="2-select">2. select</h3>
<p>选择，查询语句；</p>
<ul>
<li>
<p>id：就是对应的namespace中的方法名；</p>
</li>
<li>
<p>resultType : Sql语句执行的返回值；</p>
</li>
<li>
<p>parameterType : 参数类型；</p>
<ol>
<li>
<p>编写接口</p>
<pre><code class="language-java">public interface UserMapper {
    //查询所有用户
    public List&lt;User&gt; getUserList();
    //插入用户
    public void addUser(User user);
}
</code></pre>
</li>
<li>
<p>编写对应的mapper中的sql语句</p>
<pre><code class="language-xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
    insert into user (id,name,password) values (#{id}, #{name}, #{password})
&lt;/insert&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">@Test
public void test2() {
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    User user  = new User(3,&quot;黑子&quot;,&quot;666&quot;);
    mapper.addUser(user);
    //增删改一定要提交事务
    sqlSession.commit();

    //关闭sqlSession
    sqlSession.close();
}
</code></pre>
<p><strong>注意：增删改查一定要提交事务：</strong></p>
<pre><code class="language-java">sqlSession.commit();
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="3-insert">3. Insert</h3>
<h3 id="4-update">4. update</h3>
<h3 id="5-delete">5. Delete</h3>
<h3 id="6-万能map">6. 万能Map</h3>
<p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应该考虑使用Map!</p>
<ol>
<li>UserMapper接口</li>
</ol>
<pre><code class="language-java">//用万能Map插入用户
public void addUser2(Map&lt;String,Object&gt; map);
</code></pre>
<ol>
<li>UserMapper.xml</li>
</ol>
<pre><code class="language-xml">&lt;!--对象中的属性可以直接取出来 传递map的key--&gt;
&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt;
    insert into user (id,name,password) values (#{userid},#{username},#{userpassword})
&lt;/insert&gt;
</code></pre>
<ol>
<li>测试</li>
</ol>
<pre><code class="language-java">    @Test
    public void test3(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;userid&quot;,4);
        map.put(&quot;username&quot;,&quot;王虎&quot;);
        map.put(&quot;userpassword&quot;,789);
        mapper.addUser2(map);
        //提交事务
        sqlSession.commit();
        //关闭资源
        sqlSession.close();
    }
</code></pre>
<blockquote>
<p>Map传递参数，直接在sql中取出key即可！ 【parameter=“map”】</p>
<p>对象传递参数，直接在sql中取出对象的属性即可！ 【parameter=“Object”】</p>
<p>只有一个基本类型参数的情况下，可以直接在sql中取到</p>
<p>多个参数用Map , <strong>或者注解！</strong></p>
</blockquote>
<h3 id="7-模糊查询">7. 模糊查询</h3>
<p>模糊查询这么写？</p>
<ol>
<li>
<p>Java代码执行的时候，传递通配符% %</p>
<pre><code class="language-java">List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;);
</code></pre>
</li>
<li>
<p>在sql拼接中使用通配符</p>
<pre><code class="language-xml">select * from user where name like &quot;%&quot;#{value}&quot;%&quot;
</code></pre>
</li>
</ol>
<h2 id="4-配置解析">4、配置解析</h2>
<h3 id="1-核心配置文件">1. 核心配置文件</h3>
<ul>
<li>
<p>mybatis-config.xml</p>
</li>
<li>
<p>Mybatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。</p>
<pre><code class="language-xml">configuration（配置）
    properties（属性）
    settings（设置）
    typeAliases（类型别名）
    typeHandlers（类型处理器）
    objectFactory（对象工厂）
    plugins（插件）
    environments（环境配置）
    	environment（环境变量）
    		transactionManager（事务管理器）
    		dataSource（数据源）
    databaseIdProvider（数据库厂商标识）
    mappers（映射器）
</code></pre>
</li>
</ul>
<h3 id="2-环境配置-environments">2. 环境配置 environments</h3>
<p>MyBatis 可以配置成适应多种环境</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境</strong></p>
<p>学会使用配置多套运行环境！</p>
<p>MyBatis默认的事务管理器就是JDBC ，连接池：POOLED</p>
<h3 id="3-属性-properties">3. 属性 properties</h3>
<p>我们可以通过properties属性来实现引用配置文件</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.poperties】</p>
<ol>
<li>
<p>编写一个配置文件</p>
<p>db.properties</p>
<pre><code class="language-properties">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
username=root
password=root
</code></pre>
</li>
<li>
<p>在核心配置文件中引入</p>
<pre><code class="language-xml">&lt;!--引用外部配置文件--&gt;
&lt;properties resource=&quot;db.properties&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/properties&gt;
</code></pre>
<ul>
<li>可以直接引入外部文件</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一个字段，优先使用外部配置文件的</li>
</ul>
</li>
</ol>
<h3 id="4-类型别名-typealiases">4. 类型别名 typeAliases</h3>
<ul>
<li>
<p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置.</p>
</li>
<li>
<p>意在降低冗余的全限定类名书写。</p>
<pre><code class="language-xml">&lt;!--可以给实体类起别名--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>也可以指定一个包，每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>,；若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<blockquote>
<p>在实体类比较少的时候，使用第一种方式。</p>
<p>如果实体类十分多，建议用第二种扫描包的方式。</p>
<p>第一种可以DIY别名，第二种不行，如果非要改，需要在实体上增加注解。</p>
</blockquote>
<pre><code class="language-java">@Alias(&quot;author&quot;)
public class Author {
    ...
}
</code></pre>
</li>
</ul>
<h3 id="5-设置-settings">5. 设置 Settings</h3>
<p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020062316474822.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="6-其他配置">6. 其他配置</h3>
<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li>plugins 插件
<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h3 id="7-映射器-mappers">7. 映射器 mappers</h3>
<p>MapperRegistry：注册绑定我们的Mapper文件；</p>
<p>方式一：【推荐使用】</p>
<pre><code class="language-xml">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>方式二：使用class文件绑定注册</p>
<pre><code class="language-xml">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>注意点：</strong></p>
<ul>
<li>接口和他的Mapper配置文件必须同名</li>
<li>接口和他的Mapper配置文件必须在同一个包下</li>
</ul>
<p>方式三：使用包扫描进行注入</p>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;package name=&quot;com.kuang.dao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<h3 id="8-作用域和生命周期">8. 作用域和生命周期</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200623164809990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>
<p><strong>SqlSessionFactoryBuilder:</strong></p>
<ul>
<li>一旦创建了SqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory:</strong></p>
<ul>
<li>说白了就可以想象为：数据库连接池</li>
<li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建一个实例。</strong></li>
<li>因此SqlSessionFactory的最佳作用域是应用作用域（ApplocationContext）。</li>
<li>最简单的就是使用<strong>单例模式</strong>或静态单例模式。</li>
</ul>
<p><strong>SqlSession：</strong></p>
<ul>
<li>连接到连接池的一个请求</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li>
<li>用完之后需要赶紧关闭，否则资源被占用！</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200623164833872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="5-解决属性名和字段名不一致的问题">5、解决属性名和字段名不一致的问题</h2>
<h3 id="1-问题">1. 问题</h3>
<p>数据库中的字段</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200623164845962.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200623164853569.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>测试出现问题<br>
<img src="https://img-blog.csdnimg.cn/20200623164901861.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-xml">// select * from user where id = #{id}
// 类型处理器
// select id,name,pwd from user where id = #{id}
</code></pre>
<p>解决方法：</p>
<ul>
<li>起别名</li>
</ul>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select id,name,pwd as password from USER where id = #{id}
&lt;/select&gt;
</code></pre>
<h3 id="2-resultmap">2. resultMap</h3>
<p>结果集映射</p>
<blockquote>
<p>id name pwd</p>
<p>id name password</p>
</blockquote>
<pre><code class="language-xml">&lt;!--结果集映射--&gt;
&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!--column数据库中的字段，property实体类中的属性--&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from USER
&lt;/select&gt;
</code></pre>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</li>
<li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li>
<li><code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。</li>
<li>如果这个世界总是这么简单就好了。</li>
</ul>
<h2 id="6-日志">6、日志</h2>
<h3 id="61-日志工厂">6.1 日志工厂</h3>
<p>如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！</p>
<p>曾经：sout、debug</p>
<p>现在：日志工厂</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200623164920502.png" alt="img" loading="lazy"></figure>
<ul>
<li>SLF4J</li>
<li>LOG4J 【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING 【掌握】</li>
<li>NO_LOGGING</li>
</ul>
<p>在MyBatis中具体使用哪一个日志实现，在设置中设定</p>
<p><strong>STDOUT_LOGGING</strong></p>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/2020062316493391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="62-log4j">6.2 Log4j</h3>
<p>什么是Log4j？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件；</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；</li>
<li>最令人感兴趣的就是，这些可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<ol>
<li>
<p>先导入log4j的包</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>log4j.properties</p>
<pre><code class="language-xml">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n
#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/rzp.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n
#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sq1.PreparedStatement=DEBUG
</code></pre>
</li>
<li>
<p>配置settings为log4j实现</p>
</li>
<li>
<p>测试运行</p>
</li>
</ol>
<p><strong>Log4j简单使用</strong></p>
<ol>
<li>
<p>在要使用Log4j的类中，导入包 import org.apache.log4j.Logger;</p>
</li>
<li>
<p>日志对象，参数为当前类的class对象</p>
<pre><code class="language-java">Logger logger = Logger.getLogger(UserDaoTest.class);
</code></pre>
</li>
<li>
<p>日志级别</p>
<pre><code class="language-java">logger.info(&quot;info: 测试log4j&quot;);
logger.debug(&quot;debug: 测试log4j&quot;);
logger.error(&quot;error:测试log4j&quot;);
</code></pre>
<ol>
<li>info</li>
<li>debug</li>
<li>error</li>
</ol>
</li>
</ol>
<h2 id="7-分页">7、分页</h2>
<p><strong>思考：为什么分页？</strong></p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h3 id="71-使用limit分页">7.1 <strong>使用Limit分页</strong></h3>
<pre><code class="language-sql">SELECT * from user limit startIndex,pageSize 
</code></pre>
<p><strong>使用MyBatis实现分页，核心SQL</strong></p>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">//分页
List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);
</code></pre>
</li>
<li>
<p>Mapper.xml</p>
<pre><code class="language-xml">&lt;!--分页查询--&gt;
&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from user limit #{startIndex},#{pageSize}
&lt;/select&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">    @Test
    public void getUserByLimit(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;startIndex&quot;,1);
        map.put(&quot;pageSize&quot;,2);
        List&lt;User&gt; list = mapper.getUserByLimit(map);
        for (User user : list) {
            System.out.println(user);
        }
    }
</code></pre>
</li>
</ol>
<h3 id="72-rowbounds分页">7.2 RowBounds分页</h3>
<p>不再使用SQL实现分页</p>
<ol>
<li>
<p>接口</p>
<pre><code class="language-xml">//分页2
List&lt;User&gt; getUserByRowBounds();
</code></pre>
</li>
<li>
<p>mapper.xml</p>
<pre><code class="language-xml">&lt;!--分页查询2--&gt;
&lt;select id=&quot;getUserByRowBounds&quot;&gt;
    select * from user limit #{startIndex},#{pageSize}
&lt;/select&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">    public void getUserByRowBounds(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        //RowBounds实现
        RowBounds rowBounds = new RowBounds(1, 2);
        //通过Java代码层面实现分页
        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kaung.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds);
        for (User user : userList) {
            System.out.println(user);
        }
        sqlSession.close();
    }
</code></pre>
</li>
</ol>
<h3 id="73-分页插件">7.3 分页插件</h3>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200623164958936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="8-使用注解开发">8、使用注解开发</h2>
<h3 id="81-面向接口开发">8.1 面向接口开发</h3>
<p><strong>三个面向区别</strong></p>
<ul>
<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；</li>
<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；</li>
<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；</li>
</ul>
<h3 id="82-使用注解开发">8.2 使用注解开发</h3>
<ol>
<li>
<p>注解在接口上实现</p>
<pre><code class="language-java">@Select(&quot;select * from user&quot;)
List&lt;User&gt; getUsers();
</code></pre>
</li>
<li>
<p>需要在核心配置文件中绑定接口</p>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li>
<p>测试</p>
</li>
</ol>
<p>本质：反射机制实现</p>
<p>底层：动态代理<br>
<img src="https://img-blog.csdnimg.cn/20200623165014965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>MyBatis详细执行流程</strong><br>
<img src="https://img-blog.csdnimg.cn/20200623165030775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="83-注解curd">8.3 注解CURD</h3>
<pre><code class="language-java">//方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解
@Delete(&quot;delete from user where id = ${uid}&quot;)
int deleteUser(@Param(&quot;uid&quot;) int id);
</code></pre>
<p><strong>关于@Param( )注解</strong></p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上</li>
<li>我们在SQL中引用的就是我们这里的@Param()中设定的属性名</li>
</ul>
<p><strong>#{} 和 ${}</strong></p>
<h2 id="9-lombok">9、Lombok</h2>
<p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p>
<p>使用步骤：</p>
<ol>
<li>
<p>在IDEA中安装Lombok插件</p>
</li>
<li>
<p>在项目中导入lombok的jar包</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在程序上加注解</p>
</li>
</ol>
<pre><code class="language-java">@Getter and @Setter
@FieldNameConstants
@ToString
@EqualsAndHashCode
@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog
@Data
@Builder
@SuperBuilder
@Singular
@Delegate
@Value
@Accessors
@Wither
@With
@SneakyThrows
@val
</code></pre>
<p>说明：</p>
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private int id;
    private String name;
    private String password;
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200623165052167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="10-多对一处理">10、多对一处理</h2>
<blockquote>
<p>多个学生一个老师；</p>
</blockquote>
<pre><code class="language-sql">alter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)
</code></pre>
<h3 id="1-测试环境搭建"><strong>1. 测试环境搭建</strong></h3>
<ol>
<li>导入lombok</li>
<li>新建实体类Teacher,Student</li>
<li>建立Mapper接口</li>
<li>建立Mapper.xml文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或者文件 【方式很多，随心选】</li>
<li>测试查询是否能够成功</li>
</ol>
<h3 id="2-按照查询嵌套处理">2. 按照查询嵌套处理</h3>
<pre><code class="language-xml">&lt;!--
     思路：
        1. 查询所有的学生信息
        2. 根据查询出来的学生的tid寻找特定的老师 (子查询)
    --&gt;
&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    select * from student
&lt;/select&gt;
&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;student&quot;&gt;
    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
    &lt;!--复杂的属性，我们需要单独出来 对象：association 集合：collection--&gt;
    &lt;collection property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;
    select * from teacher where id = #{id}
&lt;/select&gt;
</code></pre>
<h3 id="3按照结果嵌套处理">3.按照结果嵌套处理</h3>
<pre><code class="language-xml">    &lt;!--按照结果进行查询--&gt;
    &lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;
        select s.id sid , s.name sname, t.name tname
        from student s,teacher t
        where s.tid=t.id
    &lt;/select&gt;
    &lt;!--结果封装，将查询出来的列封装到对象属性中--&gt;
    &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt;
            &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
</code></pre>
<p>回顾Mysql多对一查询方式:</p>
<ul>
<li>子查询 （按照查询嵌套）</li>
<li>联表查询 （按照结果嵌套）</li>
</ul>
<h2 id="11-一对多处理">11、一对多处理</h2>
<blockquote>
<p>一个老师多个学生；</p>
<p>对于老师而言，就是一对多的关系；</p>
</blockquote>
<h3 id="1-环境搭建">1. 环境搭建</h3>
<p><strong>实体类</strong></p>
<pre><code class="language-java">@Data
public class Student {
    private int id;
    private String name;
    private int tid;
}
@Data
public class Teacher {
    private int id;
    private String name;

    //一个老师拥有多个学生
    private List&lt;Student&gt; students;
}
</code></pre>
<h3 id="2-按照结果嵌套嵌套处理">2. <strong>按照结果嵌套嵌套处理</strong></h3>
<pre><code class="language-xml">&lt;!--按结果嵌套查询--&gt;
&lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt;
    SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t
    WHERE s.tid = t.id AND tid = #{tid}
&lt;/select&gt;
&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt;
    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
    &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection
    javaType=&quot;&quot;指定属性的类型！
    集合中的泛型信息，我们使用ofType获取
    --&gt;
    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="小结">小结</h3>
<ol>
<li>关联 - association 【多对一】</li>
<li>集合 - collection 【一对多】</li>
<li>javaType &amp; ofType
<ol>
<li>JavaType用来指定实体类中的类型</li>
<li>ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型</li>
</ol>
</li>
</ol>
<p><strong>注意点：</strong></p>
<ul>
<li>保证SQL的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一，属性名和字段的问题</li>
<li>如果问题不好排查错误，可以使用日志，建议使用Log4j</li>
</ul>
<p>面试高频</p>
<ul>
<li>Mysql引擎</li>
<li>InnoDB底层原理</li>
<li>索引</li>
<li>索引优化</li>
</ul>
<h2 id="12-动态sql">12、动态SQL</h2>
<p><strong>什么是动态SQL：动态SQL就是根据不同的条件生成不同的SQL语句</strong></p>
<p><strong>所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码</strong></p>
<hr>
<blockquote>
<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
</blockquote>
<h3 id="搭建环境">搭建环境</h3>
<pre><code class="language-sql">CREATE TABLE `mybatis`.`blog`  (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '博客id',
  `title` varchar(30) NOT NULL COMMENT '博客标题',
  `author` varchar(30) NOT NULL COMMENT '博客作者',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  `views` int(30) NOT NULL COMMENT '浏览量',
  PRIMARY KEY (`id`)
)
</code></pre>
<p>创建一个基础工程</p>
<ol>
<li>
<p>导包</p>
</li>
<li>
<p>编写配置文件</p>
</li>
<li>
<p>编写实体类</p>
<pre><code class="language-java">@Data
public class Blog {
    private int id;
    private String title;
    private String author;

    private Date createTime;// 属性名和字段名不一致
    private int views;
}
</code></pre>
</li>
<li>
<p>编写实体类对应Mapper接口和Mapper.xml文件</p>
</li>
</ol>
<h3 id="if">IF</h3>
<pre><code class="language-xml">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
    select * from blog
    &lt;where&gt;
        &lt;if test=&quot;title!=null&quot;&gt;
            and title = #{title}
        &lt;/if&gt;
        &lt;if test=&quot;author!=null&quot;&gt;
            and author = #{author}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h3 id="choose-when-otherwise">choose (when, otherwise)</h3>
<h3 id="trim-where-set">trim、where、set</h3>
<h3 id="sql片段">SQL片段</h3>
<p>有的时候，我们可能会将一些功能的部分抽取出来，方便服用！</p>
<ol>
<li>
<p>使用SQL标签抽取公共部分可</p>
<pre><code class="language-xml">&lt;sql id=&quot;if-title-author&quot;&gt;
    &lt;if test=&quot;title!=null&quot;&gt;
        title = #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author!=null&quot;&gt;
        and author = #{author}
    &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
</li>
<li>
<p>在需要使用的地方使用Include标签引用即可</p>
<pre><code class="language-xml">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;
    select * from blog
    &lt;where&gt;
        &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>最好基于单标来定义SQL片段</li>
<li>不要存在where标签</li>
</ul>
<p><strong>动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了</strong></p>
<p>建议：</p>
<ul>
<li>先在Mysql中写出完整的SQL，再对应的去修改成我们的动态SQL实现通用即可</li>
</ul>
<h2 id="13-缓存">13、缓存</h2>
<h3 id="131-简介">13.1 简介</h3>
<blockquote>
<p>查询 ： 连接数据库，耗资源</p>
<p>一次查询的结果，给他暂存一个可以直接取到的地方 --&gt; 内存：缓存</p>
<p>我们再次查询的相同数据的时候，直接走缓存，不走数据库了</p>
</blockquote>
<ol>
<li>什么是缓存[Cache]？
<ul>
<li>存在内存中的临时数据</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>
</ul>
</li>
<li>为什么使用缓存？
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>
</ul>
</li>
<li>什么样的数据可以使用缓存？
<ul>
<li>经常查询并且不经常改变的数据 【可以使用缓存】</li>
</ul>
</li>
</ol>
<h3 id="132-mybatis缓存">13.2 MyBatis缓存</h3>
<ul>
<li>
<p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。</p>
</li>
<li>
<p>MyBatis系统中默认定义了两级缓存：</p>
<p>一级缓存</p>
<p>和</p>
<p>二级缓存</p>
<ul>
<li>默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。</li>
</ul>
</li>
</ul>
<h3 id="133-一级缓存">13.3 一级缓存</h3>
<ul>
<li>一级缓存也叫本地缓存：SqlSession
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>
</ul>
</li>
</ul>
<p>测试步骤：</p>
<ol>
<li>
<p>开启日志</p>
</li>
<li>
<p>测试在一个Session中查询两次记录</p>
<pre><code class="language-java">    @Test
    public void test1() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User user = mapper.getUserById(1);
        System.out.println(user);

        System.out.println(&quot;=====================================&quot;);

        User user2 =  mapper.getUserById(1);
        System.out.println(user2 == user);
    }
</code></pre>
</li>
<li>
<p>查看日志输出</p>
</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200623165129955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>缓存失效的情况：</strong></p>
<ol>
<li>
<p>查询不同的东西</p>
</li>
<li>
<p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</p>
</li>
<li>
<p>查询不同的Mapper.xml</p>
</li>
<li>
<p>手动清理缓存</p>
<pre><code class="language-java">sqlSession.clearCache();
</code></pre>
</li>
</ol>
<h3 id="134-二级缓存">13.4 二级缓存</h3>
<ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</li>
<li>工作机制
<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>
<li>如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容</li>
<li>不同的mapper查询出的数据会放在自己对应的缓存（map）中</li>
</ul>
</li>
</ul>
<p>一级缓存开启（SqlSession级别的缓存，也称为本地缓存）</p>
<ul>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。</li>
</ul>
<p>步骤：</p>
<ol>
<li>
<p>开启全局缓存</p>
<pre><code class="language-xml">&lt;!--显示的开启全局缓存--&gt;
&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
</li>
<li>
<p>在Mapper.xml中使用缓存</p>
<pre><code class="language-xml">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;
&lt;cache
       eviction=&quot;FIFO&quot;
       flushInterval=&quot;60000&quot;
       size=&quot;512&quot;
       readOnly=&quot;true&quot;/&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<ol>
<li>问题：我们需要将实体类序列化，否则就会报错</li>
</ol>
</li>
</ol>
<p><strong>小结：</strong></p>
<ul>
<li>只要开启了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会放在一级缓存中</li>
<li>只有当前会话提交，或者关闭的时候，才会提交到二级缓存中</li>
</ul>
<h3 id="135-缓存原理">13.5 缓存原理</h3>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200623165404113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true”</p>
<pre><code class="language-xml">    &lt;select id=&quot;getUserById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;
        select * from user where id = #{id}
    &lt;/select&gt;
</code></pre>
</li>
</ul>
<h3 id="136-自定义缓存-ehcache">13.6 自定义缓存-ehcache</h3>
<blockquote>
<p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存</p>
</blockquote>
<ol>
<li>
<p>导包</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在mapper中指定使用我们的ehcache缓存实现</p>
<pre><code class="language-xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;
</code></pre>
</li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/34、在排序数组中查找元素的第一个和最后一个位置 - 副本/" class="post-title gt-a-link">
                    中等34. 在排序数组中查找元素的第一个和最后一个位置
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

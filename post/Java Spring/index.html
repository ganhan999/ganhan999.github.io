<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java Spring5 | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1618392173076">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1618392173076" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java Spring5
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-01-01 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h3 id="11-简介">1.1、简介</h3>
<ul>
<li>Spring：春天—&gt; 给软件行业带来了春天</li>
<li>2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。</li>
<li>2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。</li>
<li>很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</li>
<li>Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术</li>
<li>SSH : Struct2 + Spring + Hibernate!</li>
<li>SSM : SpringMvc + Spring + Mybatis!</li>
<li>官网 : http://spring.io/</li>
<li>官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/</li>
<li>GitHub : https://github.com/spring-projects</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-优点">1.2、优点</h3>
<ul>
<li>Spring是一个开源免费的框架 , 容器</li>
<li>Spring是一个轻量级的框架 , 非侵入式的 .</li>
<li><strong>控制反转 IoC , 面向切面 Aop</strong></li>
<li>对事物的支持 , 对框架的支持</li>
</ul>
<p><strong>总结一句话：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p>
<h3 id="13-组成">1.3、组成</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/img_convert/a68d24b29f6b295ede163f919b81fd76.gif" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h3 id="14-拓展">1.4、拓展</h3>
<p>在Spring的官网有这个介绍：现代化的java开发！说白就是基于Spring的开发！</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/img_convert/95e19c5abf4ab637158d884b0b59e63e.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速开发单个微服务</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>Spring CLoud是基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>因为现在大所述公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用</p>
<p><strong>弊端：发展太久了之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”！</strong></p>
<h2 id="2-ioc理论推导">2、IOC理论推导</h2>
<h3 id="21-ioc基础">2.1、IoC基础</h3>
<p>1.UserDao接口</p>
<p>2.UserDaoImpl实现类</p>
<p>3.UserService业务接口</p>
<p>4.UserServiceImpl业务实现类</p>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要更具用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p>我们使用一个Set接口实现，已经发生了革命性的变化！</p>
<pre><code class="language-java"> private UserDao userDao;

// 利用set进行动态实现值的注入
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
</code></pre>
<ul>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入之后，程序不再有主动性，而是变成了被动的接受对象！</li>
</ul>
<p>这种思想从本质上实现了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上！这是IOC的原型！</p>
<p>\</p>
<h3 id="22-ioc本质">2.2、IOC本质</h3>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="3-hellospring">3、HelloSpring</h2>
<p><strong>导入Jar包</strong></p>
<p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>编写代码</strong></p>
<p>1、编写一个Hello实体类</p>
<pre><code class="language-java">package Com.Sun.pojo;

public class Hello {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Hello{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--bean就是java对象 , 由Spring创建和管理

    类型 变量名 = new 类型();
    Hello hello = new Hello();
    bean = 对象   new Hello();
    id = 变量名
    class = new的对象
    property 相当于给对象中的属性设置一个变量
    --&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;Com.Sun.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;你好Spring&quot;&gt;

       &lt;/property&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、我们可以去进行测试了 .</p>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        // 获取Spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以
        Hello hello = (Hello)context.getBean(&quot;hello&quot;);
        System.out.println(hello);
    }
}
</code></pre>
<p><strong>思考问题？</strong></p>
<ul>
<li>Hello 对象是谁创建的 ?</li>
<li>hello 对象是由Spring创建的</li>
<li>Hello 对象的属性是怎么设置的 ?</li>
<li>hello 对象的属性是由Spring容器设置的</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象</li>
<li>依赖注入 : 就是利用set方法来进行注入的.</li>
</ul>
<p>IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>可以通过new ClassPathXmlApplicationContext去浏览一下底层源码</p>
<p>**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! **</p>
<h2 id="4-ioc创建对象的方式">4、IOC创建对象的方式</h2>
<p>1.使用无参构造创建对象，默认！</p>
<pre><code class="language-xml">&lt;!--无参构造器--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Sun&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>2.假设我们要使用有参构造创建对象。</p>
<ol>
<li>
<p>下标赋值</p>
<pre><code class="language-xml">&lt;!--有参构造器1，下标赋值--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;Sun&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>类型</p>
<pre><code class="language-xml">&lt;!--有参构造器2，类型，但同类型只能一个，不建议使用--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt;
    &lt;constructor-arg  type=&quot;java.lang.String&quot; value=&quot;Sun&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>参数名</p>
<pre><code class="language-xml">&lt;!--有参构造器3，参数名--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;Sun&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
<p>总结：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="5-spring配置">5、Spring配置</h2>
<h3 id="51-别名">5.1、别名</h3>
<pre><code class="language-xml">&lt;!--别名，如果添加了别名也可以使用别名获取到这个对象--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h3 id="52-bean的配置">5.2、Bean的配置</h3>
<pre><code class="language-xml">&lt;!--
        id:bean的唯一标识符，也就是相当于我们学的对象名
        class：bean 对象所对应的权限定名：包名 + 类型
        name: 也是别名,而且name更高级，可以起多个别名，通过逗号空格分号等分割
--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; name=&quot;user2,u3,u4&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;Sun&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="53-import">5.3、import</h3>
<p>团队的合作通过import来实现 ,可以将多个配置文件，导入合并为一个</p>
<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的</p>
<ul>
<li>张三 beans.xml</li>
<li>李四 beans2.xml</li>
<li>王五 beans3.xml</li>
<li>applicationContext</li>
</ul>
<pre><code class="language-xml">&lt;import resource=&quot;beans.xml&quot;/&gt;
&lt;import resource=&quot;beans2.xml&quot;/&gt;
&lt;import resource=&quot;beans3.xml&quot;/&gt;
</code></pre>
<p>使用的时候，直接使用总的配置就可以了</p>
<h2 id="6-依赖注入">6、依赖注入</h2>
<h3 id="61-构造器注入">6.1、构造器注入</h3>
<p>前面已经说过了</p>
<h3 id="62-set方式注入重点">6.2、set方式注入【重点】</h3>
<ul>
<li>依赖注入（Dependency Injection,DI）。
<ul>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li>
<p>复杂类型 Address.java</p>
<pre><code class="language-java">public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
</li>
<li>
<p>真实测试对象 Student.java</p>
<pre><code class="language-java">public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public String[] getBooks() {
        return books;
    }

    public void setBooks(String[] books) {
        this.books = books;
    }

    public List&lt;String&gt; getHobbies() {
        return hobbies;
    }

    public void setHobbies(List&lt;String&gt; hobbies) {
        this.hobbies = hobbies;
    }

    public Map&lt;String, String&gt; getCard() {
        return card;
    }

    public void setCard(Map&lt;String, String&gt; card) {
        this.card = card;
    }

    public Set&lt;String&gt; getGames() {
        return games;
    }

    public void setGames(Set&lt;String&gt; games) {
        this.games = games;
    }

    public String getWife() {
        return wife;
    }

    public void setWife(String wife) {
        this.wife = wife;
    }

    public Properties getInfo() {
        return info;
    }

    public void setInfo(Properties info) {
        this.info = info;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, address=&quot; + address.toString +
                &quot;, books=&quot; + Arrays.toString(books) +
                &quot;, hobbies=&quot; + hobbies +
                &quot;, card=&quot; + card +
                &quot;, games=&quot; + games +
                &quot;, wife='&quot; + wife + '\'' +
                &quot;, info=&quot; + info +
                '}';
    }
}
</code></pre>
</li>
<li>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;Com.Sun.pojo.Address&quot; &gt;
        &lt;property name=&quot;address&quot; value=&quot;福州&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;student&quot; class=&quot;Com.Sun.pojo.Student&quot;&gt;
        &lt;!--第一种，普通值注入 value--&gt;
        &lt;property name=&quot;name&quot; value=&quot;小程&quot;/&gt;

        &lt;!--第二种： Bean注入 ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--第三种： 数组注入 --&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;Java&lt;/value&gt;
                &lt;value&gt;C++&lt;/value&gt;
                &lt;value&gt;Python&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--第四种：list注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;学习&lt;/value&gt;
                &lt;value&gt;敲代码&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--第五种：map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;1234567890&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;1987654320&quot;&gt;&lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--第六种：set注入--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;和平精英&lt;/value&gt;
                &lt;value&gt;王者荣耀&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--第七种：null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--第七种：Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;url&quot;&gt;1234567hgfdxcvb&lt;/prop&gt;
                &lt;prop key=&quot;passwoed&quot;&gt;123456&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>测试类</p>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        Student student = (Student)context.getBean(&quot;student&quot;);
        System.out.println(student);
    }
}
</code></pre>
</li>
</ol>
<h3 id="63-拓展方式注入">6.3、拓展方式注入</h3>
<p>我们可以使用p命令空间和c命令空间进行注入</p>
<p>官方解释：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/img_convert/4986fdb3e422b12003fb942a3ff74bfb.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<p>使用！</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--p命名空间可以直接注入属性的值 property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot;/&gt;
    
    &lt;!--c命名空间可以通过构造器注入 construct-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;Com.Sun.pojo.User&quot; c:name=&quot;小李&quot; c:age=&quot;22&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;UserBeans.xml&quot;);
    User user = context.getBean(&quot;user2&quot;, User.class);
    System.out.println(user.toString());
}
</code></pre>
<p>注意点：p命名和c命名空间不能直接使用，需要引入xml约束!</p>
<pre><code class="language-xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<h3 id="64-bean的作用域">6.4、Bean的作用域</h3>
<ol>
<li>
<p>单例模式(Spring默认机制)（适用于单线程）</p>
<pre><code class="language-xml">&lt;!--p命名空间可以直接注入属性的值 property--&gt;
&lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
</li>
<li>
<p>原型模式：每次从容器中get的时候，都会产生一个现对象！(适用于多线程)</p>
<pre><code class="language-xml">&lt;!--c命名空间可以通过构造器注入 construct-args--&gt;
&lt;bean id=&quot;user2&quot; class=&quot;Com.Sun.pojo.User&quot; c:name=&quot;小李&quot; c:age=&quot;22&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
</li>
<li>
<p>其余的request、session、application这些个只能在web开发中使用到</p>
</li>
</ol>
<h2 id="7-bean的自动装配">7、Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文自动寻找，并自动给bean装配属性！</li>
</ul>
<p>在Spring中有三种自动装配的方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配bean【重要】</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<h3 id="71-测试">7.1、测试</h3>
<p>环境搭建：一个人有两个宠物</p>
<h3 id="72-byname自动装配">7.2、ByName自动装配</h3>
<pre><code class="language-xml">&lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
&lt;!--
 byName:会自动在容器上下文中套接，和自己对象的set方法后面的值相对应的beanid
    --&gt;
&lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="73-bytype自动装配">7.3、ByType自动装配</h3>
<pre><code class="language-xml">&lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;

&lt;!--
    byType:会自动在容器上下文中套接，和自己对象属性类型相同的beanid
--&gt;
&lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>小结：</p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</li>
</ul>
<h3 id="74-使用注解实现自动装配">7.4、使用注解实现自动装配</h3>
<p>jdk1.5支持的注解，Spring2.5就支持注解了！</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.</p>
<p>要使用注解需知：</p>
<ol>
<li>
<p>导入约束：context支持</p>
</li>
<li>
<p>配置注解的支持：context:annotation-config/</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="autowired注解">@Autowired注解</h4>
<ul>
<li>
<p>需要导入 spring-aop的包！</p>
</li>
<li>
<p>直接在属性上使用即可！也可以在set方式上使用！</p>
</li>
<li>
<p>使用Autowired我们可以不用编写set方法，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName和类型byType！</p>
<ul>
<li>
<p>正常1（byName）</p>
<pre><code class="language-xml">&lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>正常2（byType）</p>
<pre><code class="language-xml">     &lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
     &lt;bean id=&quot;dog1&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
     &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt;
</code></pre>
<ul>
<li>
<p>正常3（混合使用，先类型后名字）</p>
<pre><code class="language-xml">&lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt;
</code></pre>
</li>
<li>
<p>不正常（多种类型且名字也不匹配，报错）</p>
</li>
</ul>
<pre><code class="language-xml">     &lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt;
     &lt;bean id=&quot;dog1&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
     &lt;bean id=&quot;dog2&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt;
     &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt;
</code></pre>
<ul>
<li>
<p>科普：</p>
<pre><code class="language-xm">@Nullable 字段标记了这个注解，说明这个字段可以为null
1
</code></pre>
<pre><code class="language-java">public @interface Autowired {
    boolean required() default true;
}
</code></pre>
</li>
<li>
<p>测试代码</p>
<pre><code class="language-java">public class People {
    //如果显示的定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空
 @Autowired(required = false)
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
}
</code></pre>
</li>
<li>
<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifilter(value=“xxx”)去配合@Autowired的使用，指定一个唯一的bean对象注入</p>
<pre><code class="language-java">public class People {
    @Autowired
 @Qualifier(value=&quot;dog1&quot;)
    private Dog dog;
    @Autowired
    @Qualifier(value=&quot;cat1&quot;)
    private Cat cat;
}
</code></pre>
</li>
</ul>
<h4 id="resource注解">Resource注解</h4>
<pre><code class="language-java">public class People {
 @Resource(name = &quot;cat1&quot;)
    private Cat cat;
 @Resource
    private Dog dog;
    private String name;
}
</code></pre>
<p>小结：</p>
<p>@Resource和@Autowired</p>
</li>
<li>
<p>都是用来自动装配的，都可以放在属性字段上</p>
<ul>
<li>实现方式不同</li>
<li>@Autowired默认通过bytype的方式实现，如果有多个类型，则通过byname实现，如果两个都找不到，就报错！
<ul>
<li>@Resource默认通过byname的方式实现，如果找不到名字，则通过bytype实现，如果两个都找不到，就报错！</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行的顺序不同：</p>
<ul>
<li>@Autowired默认通过bytype的方式实现</li>
<li>@Resource默认通过byname的方式实现</li>
<li>类型重复的话，如果名字不是默认的（如cat11，cat111，而没有默认的cat）
<ul>
<li>@Autowired配合@Qualifier(value = “cat11”)使用</li>
<li>@Resource直接使用@Resource(name = “cat11”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8使用注解开发">8.使用注解开发</h2>
<p>在Spring4之后，要使用注解开发，必须要保证aop的包导入了</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/12/06/uBX4WAN51w2oaEf.png" alt="img" loading="lazy"></figure>
<p>使用注解需要导入context约束，增加注解的支持！</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<ol>
<li>
<p>bean</p>
<pre><code class="language-java">// 等价于 &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;/&gt;
@Component
</code></pre>
</li>
<li>
<p>属性如何注入@Value(“xxx”)</p>
<pre><code class="language-java">@Component
public class User {
    //相当于&lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    @Value(&quot;小明&quot;)
    public String name;
}
</code></pre>
</li>
<li>
<p>衍生的注解</p>
<p>@Component有几个衍生的注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>
<p>dao【@Repository】</p>
</li>
<li>
<p>service 【@Service】</p>
</li>
<li>
<p>controller 【@Controller】</p>
<p>这四个注解功能都是一样的，都是代表将某个注册类注入到Spring中，装配Bean</p>
</li>
</ul>
</li>
<li>
<p>自动装配置</p>
<ul>
<li>@Autowired：自动装配通过类型、名字
<ul>
<li>如果Autowired不能唯一自动装配上属性，则需要通过@Qualifilter(value=“xxx”)</li>
</ul>
</li>
<li>@Nullable：字段标记了这个注解，说明这个字段可以为null</li>
<li>@Resource：自动装配通过名字、类型</li>
</ul>
</li>
<li>
<p>作用域 @Scope</p>
<pre><code class="language-java">// 等价于 &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;/&gt;
@Component
@Scope(&quot;singleton&quot;)
public class User {

    //相当于&lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    @Value(&quot;小明&quot;)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name=name;
    }
}
</code></pre>
</li>
<li>
<p>小结</p>
<p>xml与注解</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便</li>
<li>注解不是自己的类用不了，维护相对复杂</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li>
<p>xml用来管理bean;</p>
</li>
<li>
<p>注解只负责完成属性的注入;</p>
</li>
<li>
<p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解支持</p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt;
&lt;context:component-scan base-package=&quot;Com.Sun&quot;/&gt;
&lt;context:annotation-config/&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="9使用java的方式配置spring">9.使用java的方式配置Spring</h2>
<p>我们现在要完全不适用Spring的xml配置了，全权交给java来做</p>
<p>javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！</p>
<p>实体类</p>
<pre><code class="language-java">//这里这个注解的意思，就是说明这个类被Spring接管了。注解到了容器中
@Component
public class User {

    @Value(&quot;小明&quot;)
    public String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name=name;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>配置文件</p>
<pre><code class="language-java">//这个也被Spring容器托管，注册到容器里，因为他本来就是一个@Component，
// @Component代表这是一个配置类，就和我们之前看的beans.xml是一样的
@Configuration
@ComponentScan(&quot;Com.Sun.pojo&quot;)
@Import(MyConfig2.class)
public class Appconfig_01 {
    //注册一个bean，就相当于我们之前写的一个bean标签，
    //这个方法的名字就相当于bean标签的id属性
    //这个方法的返回值,就相当于bean标签中的class属性
    @Bean
    public User  getUser(){
        return new User();
    }
}
</code></pre>
<p>测试类！</p>
<pre><code class="language-java">public class Mytest {
    public static void main(String[] args) {
        // 如果完全使用了配置类的方式去做,我们就只能通过AnnotationConfig 上下文来获取容器,通过配置类的class对象加载!
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Appconfig_01.class);
        User user = (User) context.getBean(&quot;getUser&quot;);
        System.out.println(user.toString());
    }
}
</code></pre>
<p>这种纯java的配置方式，在SpringBoot中随处可见！</p>
<h2 id="10-代理模式">10、代理模式</h2>
<p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/img_convert/9e18ec7dce863a537f0515a5db9b83a1.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<h3 id="101-静态代理">10.1、静态代理</h3>
<p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代码步骤：</p>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">public interface Rent {
    public void rent();
}
</code></pre>
</li>
<li>
<p>真实角色</p>
<pre><code class="language-java">//房东
public class Host implements Rent {

    public void rent() {
      
    }
}
</code></pre>
</li>
<li>
<p>代理角色</p>
<pre><code class="language-java">public class Proxy implements Rent {
    private Host host;

    public Proxy() {
    }

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent() {
        seeHouse();
        fare();
        contract();
        host.rent();
    }

    //看房
    public void seeHouse() {
        System.out.println(&quot;中介带你看房&quot;);
    }

    //收中介费
    public void fare() {
        System.out.println(&quot;收中介费&quot;);
    }

    //收中介费
    public void contract() {
        System.out.println(&quot;签租赁合同&quot;);
    }
}
</code></pre>
</li>
<li>
<p>客户端访问代理角色</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        //房东要租房子
        Host host = new Host();
        //代理，中介帮房东租房子，但是代理一般会有一些附属操作
        Proxy proxy = new Proxy(host);
        //你不用面对房东，直接面对中介
        proxy.rent();
    }
}
</code></pre>
</li>
</ol>
<p>静态代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色；</li>
<li>代码量会翻倍-开发效率会变低</li>
</ul>
<h3 id="102-加深理解">10.2 、加深理解</h3>
<p>代码：</p>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void query();
}
</code></pre>
</li>
<li>
<p>真实角色：改动原有的业务代码，在公司中是大忌！</p>
<pre><code class="language-java">//真实对象
public class UserServiceImpl implements UserService {
    public void add() {
        System.out.println(&quot;增加了一个用户&quot;);
    }

    public void delete() {
        System.out.println(&quot;删除了一个用户&quot;);
    }

    public void update() {
        System.out.println(&quot;修改了一个用户&quot;);
    }

    public void query() {
        System.out.println(&quot;查询了一个用户&quot;);
    }
}
</code></pre>
</li>
<li>
<p>需求来了，现在我们需要增加一个日志功能，怎么实现！</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li>
</ul>
</li>
<li>
<p>设置一个代理类来处理日志！代理角色</p>
<pre><code class="language-java">public class UserServiceProxy implements UserService {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void add() {
        log(&quot;add&quot;);
        userService.add();
    }

    public void delete() {
        log(&quot;delete&quot;);
        userService.delete();
    }

    public void update() {
        log(&quot;update&quot;);
        userService.update();
    }

    public void query() {
        log(&quot;query&quot;);
        userService.query();
    }

    //日志方法
    private void log(String msg) {
        System.out.println(&quot;使用了&quot; + msg + &quot;方法&quot;);
    }
}
</code></pre>
</li>
<li>
<p>客户端访问代理角色</p>
<pre><code class="language-java">public class Client {
    public static  main(String[] args) {
        UserService userService = new UserServiceImpl();

        UserServiceProxy proxy = new UserServiceProxy();
        proxy.setUserService(userService);

        proxy.add();
    }
}
</code></pre>
</li>
</ol>
<p><strong>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</strong></p>
<p>聊聊AOP：纵向开发，横向开发</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/img_convert/002ea9232da57e498befa4e8d792158f.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<h3 id="103-动态代理">10.3、动态代理</h3>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是 我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理、基于类的动态代理
<ul>
<li>基于接口：JDK动态代理【我们在这里使用】</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序</p>
<h4 id="1031invocationhandler调用处理程序">10.3.1【InvocationHandler：调用处理程序】</h4>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/img_convert/809a058b3e6590129671dba8939cb639.png" alt="image-20201206153440264" loading="lazy"></figure>
<pre><code class="language-java">Object invoke(Object proxy, Method method, Object[] args)；
//参数
//proxy - 调用该方法的代理实例
//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。
//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。
</code></pre>
<h4 id="1032proxy-代理">10.3.2【Proxy : 代理】</h4>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/img_convert/e8f2f19afe1bb5b0ad83ba231ebc0cf9.png" alt="image-20201206153731555" loading="lazy"></figure>
<pre><code class="language-java">//生成代理类
public Object getProxy(){
   return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                 rent.getClass().getInterfaces(),this);
}
</code></pre>
<p><strong>代码实现</strong></p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<pre><code class="language-java">//抽象角色：租房
public interface Rent {
   public void rent();
}
</code></pre>
<p>Host . java 即真实角色</p>
<pre><code class="language-java">//真实角色: 房东，房东要出租房子
public class Host implements Rent{
   public void rent() {
       System.out.println(&quot;房屋出租&quot;);
  }
}
</code></pre>
<p>ProxyInvocationHandler. java 即代理角色</p>
<pre><code class="language-java">public class ProxyInvocationHandler implements InvocationHandler {
   private Rent rent;

   public void setRent(Rent rent) {
       this.rent = rent;
  }

   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
   public Object getProxy(){
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               rent.getClass().getInterfaces(),this);
  }

   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.
   // 处理代理实例上的方法调用并返回结果
   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       seeHouse();
       //核心：本质利用反射实现！
       Object result = method.invoke(rent, args);
       fare();
       return result;
  }

   //看房
   public void seeHouse(){
       System.out.println(&quot;带房客看房&quot;);
  }
   //收中介费
   public void fare(){
       System.out.println(&quot;收中介费&quot;);
  }

}
</code></pre>
<p>Client . java</p>
<pre><code class="language-java">//租客
public class Client {

   public static void main(String[] args) {
       //真实角色
       Host host = new Host();
       //代理实例的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setRent(host); //将真实角色放置进去！
       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！
       proxy.rent();
  }

}
</code></pre>
<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！</strong></p>
<h4 id="1033深化理解">10.3.3深化理解</h4>
<p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<pre><code class="language-java">public class ProxyInvocationHandler implements InvocationHandler {
   private Object target;

   public void setTarget(Object target) {
       this.target = target;
  }

   //生成代理类
   public Object getProxy(){
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  }

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  }

   public void log(String methodName){
       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
  }

}
</code></pre>
<p>测试！</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       pih.setTarget(userService); //设置要代理的对象
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       proxy.delete();
  }
}
</code></pre>
<p>测试，增删改查，查看结果！</p>
<p><strong>动态代理的好处</strong>：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
<li>一个动态</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可【核心】</li>
</ul>
<h2 id="11-aop">11、AOP</h2>
<h3 id="111-什么是aop">11.1、什么是AOP</h3>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/img_convert/ee34cd64f1c2c8d3ec19672d218e259c.png" alt="img" loading="lazy"></figure>
<h3 id="112-aop在spring中的作用">11.2、Aop在Spring中的作用</h3>
<p><strong>提供声明式事务；允许用户自定义切面</strong></p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。Log</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。Log方法</li>
<li>目标（Target）：被通知对象。接口</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。代理类</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。method</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。invoke</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/img_convert/e477db4596574f54604c9297a2e40f4c.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<table>
<thead>
<tr>
<th>通知类型</th>
<th>连接点</th>
<th>实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置通知</td>
<td>方法前</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
</tr>
<tr>
<td>后置通知</td>
<td>方法后</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
</tr>
<tr>
<td>环绕通知</td>
<td>方法前后</td>
<td>org.aopalliance.intercept.MethodInterceptor</td>
</tr>
<tr>
<td>异常抛出通知</td>
<td>方法抛出异常</td>
<td>org.springframework.aop.ThrowsAdvice</td>
</tr>
<tr>
<td>引介通知</td>
<td>类中增加新的方法属性</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
</tr>
</tbody>
</table>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="113-使用spring实现aop">11.3、使用Spring实现Aop</h3>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;   
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>方式一：使用Spring的API接口【主要SpringAPI接口实现】</p>
<ol>
<li>
<p>首先编写我们的业务接口和实现类</p>
<pre><code class="language-java">public interface UserService {

   public void add();

   public void delete();

   public void update();

   public void select();

}
</code></pre>
<pre><code class="language-java">public class UserServiceImpl implements UserService{

   @Override
   public void add() {
       System.out.println(&quot;增加用户&quot;);
  }

   @Override
   public void delete() {
       System.out.println(&quot;删除用户&quot;);
  }

   @Override
   public void update() {
       System.out.println(&quot;更新用户&quot;);
  }

   @Override
   public void select() {
       System.out.println(&quot;查询用户&quot;);
  }
}
</code></pre>
</li>
<li>
<p>写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="language-java">public class log implements MethodBeforeAdvice {

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable {
       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  }
}
</code></pre>
<pre><code class="language-java">public class AfterLog implements AfterReturningAdvice {
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  }
}
</code></pre>
</li>
<li>
<p>在spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--注册bean--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;Com.Sun.Service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;Com.Sun.Log.log&quot;/&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;Com.Sun.Log.AfterLog&quot;/&gt;

    &lt;!--aop的配置--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;/&gt;
        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.select();
  }
}
</code></pre>
</li>
</ol>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>**Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . **</p>
<p>方式二：自定义来实现【主要是切面定义】</p>
<p>目标业务类不变依旧是userServiceImpl</p>
<ol>
<li>
<p>写我们自己的一个切入类</p>
<pre><code class="language-java">public class DiyPointCut {
    public void before() {
        System.out.println(&quot;==========方法执行前============&quot;);
    }

    public void after() {
        System.out.println(&quot;==========方法执行后============&quot;);
    }
}
</code></pre>
</li>
<li>
<p>去spring中配置</p>
<pre><code class="language-xml">&lt;!--方式二：自定义类--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;Com.Sun.Diy.DiyPointCut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
    &lt;!--自定义切面，ref要引用的类--&gt;
    &lt;aop:aspect ref=&quot;diy&quot;&gt;
        &lt;!--切入点--&gt;
        &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;/&gt;
        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
        &lt;!--通知--&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
<li>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test1() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    UserService userService = (UserService)context.getBean(&quot;userService&quot;);

    userService.add();
}
</code></pre>
</li>
</ol>
<p>方式三：使用注解实现！</p>
<ol>
<li>
<p>编写一个注解实现的增强类</p>
<pre><code class="language-java">//方式三：使用注解的方式实现AOP
@Aspect//标注这个类是一个切面
public class AnnotationPointCut {
    @Before(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;)
    public void before() {
        System.out.println(&quot;==========方法执行前============&quot;);
    }

    @After(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;)
    public void after() {
        System.out.println(&quot;==========方法执行后============&quot;);
    }

    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点
    @Around(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint jp) throws Throwable {
        System.out.println(&quot;==========环绕前============&quot;);

        //获取签名
        //Signature signature = jp.getSignature();
        //System.out.println(&quot;signature:&quot; + signature);

        //执行方法
        Object proceed = jp.proceed();

        System.out.println(&quot;==========环绕后============&quot;);
    }
}
</code></pre>
</li>
<li>
<p>在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="language-xml">&lt;!--方式三：注解--&gt;
&lt;bean id=&quot;annotationPointCut&quot; class=&quot;Com.Sun.Annotation.AnnotationPointCut&quot;/&gt;
&lt;!--开启注解支持: JDK（默认proxy-target-class=&quot;false&quot;） cglib(&quot;true“)--&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot;/&gt; 
</code></pre>
</li>
</ol>
<h2 id="12-整合mybatis">12、整合Mybatis</h2>
<p>步骤：</p>
<ol>
<li>
<p>导入相关jar包</p>
<ul>
<li>
<p>junit</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;junit&lt;/groupId&gt;
   &lt;artifactId&gt;junit&lt;/artifactId&gt;
   &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>mybatis</p>
<pre><code class="language-xml">&lt;!--mybatis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>mysql数据库：mysql-connector-java</p>
<pre><code class="language-xml">&lt;!--mysqlq驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.22&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>spring相关的：spring-webmvc</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>aspectJ AOP 织入器</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>mybatis-spring整合包【重点】</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
   &lt;version&gt;2.0.2&lt;/version&gt;
&lt;&gt;
</code></pre>
</li>
<li>
<p>配置Maven静态资源过滤问题！【约定大于配置】</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>编写配置文件</p>
</li>
<li>
<p>测试</p>
</li>
</ol>
<h3 id="121-回忆mybatis">12.1、回忆mybatis</h3>
<ol>
<li>
<p>编写实体类</p>
<pre><code class="language-java">import lombok.Data;

@Data
public class User {
    public int id;
    public String name;
    public String pwd;
}
</code></pre>
</li>
<li>
<p>编写核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=ture&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;Com/Sun/Dao/UserMapper.xml&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li>
<p>编写接口</p>
<pre><code class="language-java">public interface UserMapper {
   public List&lt;User&gt; selectUser();
}
</code></pre>
</li>
<li>
<p>编写Mapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;Com.Sun.Dao.UserMapper&quot;&gt;

    &lt;select id=&quot;getAllUser&quot; resultType=&quot;Com.Sun.pojo.User&quot;&gt;
        select * from mybatis.user;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li>
<p>MybatisUtils</p>
<pre><code class="language-java">package com.Sun.Uitls;
//sqlSessionFactory --&gt; sqlSession

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils {
    static SqlSessionFactory sqlSessionFactory = null;
    static {
        try {
            //使用Mybatis第一步 ：获取sqlSessionFactory对象
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例.
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
    public static SqlSession getSqlSession(){
        //SqlSession sqlSession = sqlSessionFactory.openSession();
        //return  sqlSession;
        return sqlSessionFactory.openSession();
    }
}
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">package Com.Sun.Test;

import Com.Sun.Dao.UserMapper;
import Com.Sun.Until.MybatisUtils;
import Com.Sun.pojo.User;
import org.apache.ibatis.session.SqlSession;
import java.util.List;

public class MyTest {
    public static void main(String[] args) {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; allUser =mapper.getAllUser();
        for (User user : allUser) {
            System.out.println(user);
        }
        sqlSession.close();
    }
}
</code></pre>
</li>
</ol>
<h3 id="122-mybatis-spring">12.2、Mybatis-Spring</h3>
<p>引入Spring之前需要了解mybatis-spring包中的一些重要类；</p>
<p><a href="http://www.mybatis.org/spring/zh/index.html">mybatis-spring官网</a></p>
<p><strong>什么是 MyBatis-Spring？</strong></p>
<p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p>
<p><strong>知识基础</strong></p>
<p>在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要</p>
<p>MyBatis-Spring 需要以下版本：</p>
<table>
<thead>
<tr>
<th>MyBatis-Spring</th>
<th>MyBatis</th>
<th>Spring 框架</th>
<th>Spring Batch</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.0</td>
<td>3.5+</td>
<td>5.0+</td>
<td>4.0+</td>
<td>Java 8+</td>
</tr>
<tr>
<td>1.3</td>
<td>3.4+</td>
<td>3.2.2+</td>
<td>2.1+</td>
<td>Java 6+</td>
</tr>
</tbody>
</table>
<p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
   &lt;version&gt;2.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>整合方式一</strong></p>
<ol>
<li>
<p>引入配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>编写数据源配置</p>
<pre><code class="language-xml">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=ture&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;cgj532416&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>sqlSessionFactory</p>
<pre><code class="language-xml">&lt;!--配置SqlSessionFactory--&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!--关联Mybatis--&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:Com/Sun/Dao/UserMapper.xml&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>sqlSessionTemplate</p>
<pre><code class="language-xml">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;
&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;!--利用构造器注入,没有set注入，只能使用构造器注入--&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>需要给接口加实现类【新加的】</p>
<pre><code class="language-java">public class UserDaoImpl implements UserMapper {
    //sqlSession不用我们自己创建了，Spring来管理
    private SqlSessionTemplate sqlSession;
    public void setSqlSession(SqlSessionTemplate sqlSession) {
        this.sqlSession = sqlSession;
    }
    public List&lt;User&gt; getAllUser() {
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getAllUser();
    }
}
</code></pre>
</li>
<li>
<p>将自己写的实现类，注入到Spring中</p>
<pre><code class="language-xml">&lt;bean id=&quot;userDao&quot; class=&quot;Com.Sun.Dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>测试使用即可</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception{
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);
    UserMapper userDao = (UserMapper) context.getBean(&quot;userDao&quot;);
    List&lt;User&gt; allUser = userDao.getAllUser();
    for (User user : allUser) {
        System.out.println(user.toString());
    }
}
</code></pre>
</li>
</ol>
<p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p>
<p>为了给mybatis-config.xml留点面子(使用方便)，在其中将别名和设置留下来</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
 &lt;typeAliases&gt;
     &lt;package name=&quot;Com.Sun.pojo&quot;/&gt;
 &lt;/typeAliases&gt;

&lt;!-- &lt;settings&gt;
 	&lt;setting&gt;&lt;/setting&gt;
 &lt;/settings&gt; --&gt;
&lt;/configuration&gt;
</code></pre>
<p>**整合实现二 **</p>
<p>mybatis-spring1.2.3版以上的才有这个 .</p>
<p>官方文档截图 :</p>
<p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/img_convert/a978fb20eb1c6136f624f14a91fbe811.png" alt="1078856-20170205160357354-490660449" loading="lazy"></figure>
<p>测试：</p>
<ol>
<li>
<p>将我们上面写的UserDaoImpl修改一下</p>
<pre><code class="language-java">public class UserDaoImpl2 extends SqlSessionDaoSupport implements UserMapper {
    @Override
    public List&lt;User&gt; getAllUser() {
        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
        List&lt;User&gt; allUser = mapper.getAllUser();
        return allUser;
    }
}
</code></pre>
</li>
<li>
<p>修改bean的配置</p>
<pre><code class="language-xml">&lt;bean id=&quot;userDao&quot; class=&quot;Com.Sun.Dao.UserDaoImpl2&quot;&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">@Test
public void test(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserMapper userDao = (UserMapper) context.getBean(&quot;userDao&quot;);
    for (User user : userDao.getAllUser()) {
        System.out.println(user);
    }
}
</code></pre>
</li>
</ol>
<p><strong>总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！</strong></p>
<h2 id="13-声明式事务">13、声明式事务</h2>
<h3 id="131-回顾事务">13.1、回顾事务</h3>
<ul>
<li>把一组业务当成一个业务来做；要么都成功，要么都失败！</li>
<li>事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎</li>
<li>确保完整性和一致性</li>
</ul>
<p><strong>事务的ACID原则</strong></p>
<ul>
<li>原子性（atomicity）
<ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li>一致性（consistency）
<ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li>隔离性（isolation）
<ul>
<li>多个业务可能操作同一个资源，防止数据损坏</li>
</ul>
</li>
<li>持久性（durability）
<ul>
<li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中！</li>
</ul>
</li>
</ul>
<h3 id="132-spring中的事务管理">13.2、Spring中的事务管理</h3>
<ul>
<li>
<p><strong>声明式事务</strong>：AOP</p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理</li>
</ul>
</li>
<li>
<p><strong>编程式事务</strong>：需要在代码中，进行事务的管理</p>
<ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
</li>
<li>
<p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<pre><code class="language-xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
</li>
<li>
<p><strong>JDBC事务</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p><strong>配置事务的通知</strong></p>
<pre><code class="language-xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
123456789101112
</code></pre>
</li>
<li>
<p><strong>spring事务传播特性：</strong></p>
<p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li><strong>propagation_requierd</strong>：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li><strong>propagation_nested</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
</li>
<li>
<p><strong>配置AOP</strong>（导入aop的头文件！）</p>
<pre><code class="language-xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointcut&quot;  expression=&quot;execution(* Com.Sun.dao.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ul>
<p>思考：</p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置，可能存在数据提交不一致的情况；</li>
<li>如果我们不在Spring中去配置声明式事务，我们需要在代码中手动配置事务！</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/39、组合总数/" class="post-title gt-a-link">
                    中等39. 组合总和
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

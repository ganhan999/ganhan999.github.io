<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java Redis | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1615810301479">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1615810301479" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java Redis
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-01-22 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="nosql">nosql</h1>
<h2 id="为什么要用nosql">为什么要用nosql</h2>
<p>2020年，大数据时代；</p>
<blockquote>
<p>单机MySQL</p>
</blockquote>
<p>大数据，一般的数据库无法进行处理了！2006，Hadoop发布</p>
<ol>
<li>数据量太大，一个机器放不下</li>
<li>数据的索引（B+ Tree）,一个机器内存也放不下</li>
<li>访问量，一个服务器承受不了</li>
</ol>
<blockquote>
<p>2.Memcached（缓存）+MySQL+垂直拆分（读写分离）</p>
</blockquote>
<p>发展过程：</p>
<ol>
<li>优化数据结构和索引–》文件缓存（IO）–》Memcached（当时最热门的技术）</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/img_convert/b3b274b6a5b00a2df0cf95c6cd7023ee.png" alt="image-20201015114333233" loading="lazy"></figure>
<blockquote>
<p>分库分表+水平差分+Mysql集群</p>
</blockquote>
<p>本质：数据库（读，写）</p>
<p>MySQL，早些年MyISAM：表锁（100w，张三–密码），十分影响效率，高并发下就会出现严重的问题</p>
<p>Innodb：行锁，每次查询只锁一行</p>
<p>每个不同的业务使用不同的数据库进行单独管理</p>
<p>慢慢的就开始使用分库分表解决写的压力！MySQL在那个年代推出了表分区！这个并没有多少公司使用</p>
<p>MYSQL的集群，很好满足了那个年代的所有需求<img src="https://img-blog.csdnimg.cn/img_convert/c1763c1e27df326ad5068e402dc3ea4d.png" alt="image-20201015120050036" loading="lazy"></p>
<blockquote>
<p>最近的年代</p>
</blockquote>
<p>技术爆炸</p>
<p>MySQL等关系型数据库就不够用了，数据量大，变化快！</p>
<p>如果有一种数据库专门处理大文件数据，mysql压力就会变小</p>
<p>研究如何处理这些问题，大数据IO压力下，表基本上无法更改 1亿</p>
<blockquote>
<p>目前一个基本的互联网项目</p>
</blockquote>
<p>用户的个人信息，社交网络，地理位置，用户自己产生的数据，用户日志等等爆发性增长</p>
<p>这时候我们就需要用到nosql。nosql可以很好的处理以上的情况</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/img_convert/deebe6a3d5c2a36a336863479b863696.png" alt="image-20201015122940653" loading="lazy"></figure>
<h2 id="什么是nosql">什么是NOSQL</h2>
<p>NoSQL： not only sql</p>
<p>泛指非关系型数据库，随着web2.0互联网的诞生；传统的关系型数据库很难对付web2.0时代！尤其是大规模高并发的社区！暴露出来难以克服的问题，NoSQL在当今大数据环境下发展十分迅速，Redis是发展最快的，当下要掌握的东西</p>
<p>关系型数据库：表格，行，列（POI技术），</p>
<p>很多的数据类型用户的个人信息，社交网络，地理位置，这些数据类型的存储不需要一个固定格式！不需要多余的操作就可以横向扩展！Map&lt;String,Object&gt;,使用键值对来控制</p>
<h2 id="nosql特点">NoSQL特点：</h2>
<p>解耦</p>
<ol>
<li>
<p>方便扩展（数据之间没有关系，很好扩展）</p>
</li>
<li>
<p>大数据量高性能（Redis一秒可以写八万次，读取11w次，NoSQL的缓存记录级，是一种细粒度的缓存，性能比较高）</p>
</li>
<li>
<p>数据类型是多样型的（不需要事先设计数据库，随取随用！如果是数据库量十分大的表，无法设计）</p>
</li>
<li>
<p>传统的RDBMS和NoSQL</p>
<pre><code>传统的RDBMS
- 结构化组织
- SQL
- 数据和关系都存在单独的表中 row col
- 数据操作，数据定义语言
- 严格的一致性
- 。。。。
1234567
</code></pre>
<pre><code>NoSQL
- 不仅仅是数据
- 没有固定的查询语言
- 键值对存储，列存储，文档存储，图形数据库（社交关系）
- 最终一致性
- CAP定理和BASE（异地多活） 初级架构师
- 高性能，高可用，高可扩展
- 。。。。
12345678
</code></pre>
</li>
</ol>
<h2 id="了解3v3高">了解：3V+3高</h2>
<p>大数据的3V：主要是描述问题的</p>
<ol>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>三高：对程序的要求</p>
<ol>
<li>高并发</li>
<li>高可扩（随时水平拆分，机器不够了，可以扩展机器来解决）</li>
<li>高性能（保证用户体验和性能）</li>
</ol>
<p>真正在公司中的实践，一定是nosql + RDBMS，一起使用才是最强的</p>
<p>技术没有高低之分，就看你如何使用。（内功，思维的提高）</p>
<h1 id="alibaba架构演进">alibaba架构演进</h1>
<p>思考问题：这么多的问题都是在一个数据库中的吗？</p>
<p>技术不能急，慢慢学才能扎实。</p>
<p>敏捷开发，极限编程</p>
<p>开源才是技术的王道</p>
<p>如果未来想当一个架构师，没有什么是加一层解决不了的</p>
<pre><code>1.商品的基本信息
名称，价格，商家信息
关系型数据库就可以解决了，MySQL/Oracle
淘宝内部的mysql不是我们用的mysql
2.商品的描述。评论（文字比较多）
文档型数据库中，MongoDB
3，图片
分布式文件系统，FastDFS
- 淘宝自己的 TFS
- Google的 GFS
- Hadoop的HDFS
- 阿里云的 oss
4.商品关键字
- 搜索引擎 solr elasticsearch
- ISearch：多隆
5. 商品热门的波段信息
- 内存数据库
- Redis，Tair，Memacache
6。商品的交易，外部的支付接口
- 三方应用
1234567891011121314151617181920
</code></pre>
<p>大型互联网应用问题：</p>
<ol>
<li>数据类型太多了</li>
<li>数据源太多了，经常重构</li>
<li>数据要改造需要大面积改动</li>
</ol>
<p>解决问题：</p>
<h1 id="nosql数据类型">nosql数据类型</h1>
<h1 id="nosql四大分类">nosql四大分类</h1>
<h2 id="kv键值对">KV键值对：</h2>
<ul>
<li>新浪：Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里，百度：Redis + Memacache</li>
</ul>
<h3 id="文档型数据库bson格式和json一样">文档型数据库（bson格式，和json一样）：</h3>
<ul>
<li>MongoDB（一般必须要掌握）
<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li>
<li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<p>列存储数据库</p>
<ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<p>图关系数据库</p>
<ul>
<li>不是存图形的，放的是关系</li>
<li>Neo4j，InfoGrid</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/img_convert/94831069fe316c7af32f84feae62e7ec.png" alt="img" loading="lazy"></figure>
<h1 id="cap">CAP</h1>
<h1 id="base">BASE</h1>
<h1 id="redis入门">Redis入门</h1>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。</p>
<p>免费和开源！是当下最热门的nosql技术</p>
<p>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<h2 id="redis能干嘛">Redis能干嘛：</h2>
<ol>
<li>内存存储，持久化，内存中是断电即失，所以说持久化很重要，（rdb，aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器，计数器（浏览量）</li>
</ol>
<h2 id="特性">特性：</h2>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ol>
<h2 id="学习中需要用到的东西">学习中需要用到的东西：</h2>
<ol>
<li>狂神的公众号</li>
<li>官网：https://redis.io/</li>
<li>中文网 ：http://www.redis.cn/</li>
<li>下载地址，通过官网下载即可</li>
</ol>
<p>注意：windows版本的在github上下载（停更很久了）</p>
<p>Redis推荐都是在linux上搭建的</p>
<h1 id="redis安装">Redis安装</h1>
<h2 id="windows下安装">Windows下安装</h2>
<ol>
<li>
<p>下载安装包https://github.com/dmajkic/redis/releases</p>
</li>
<li>
<p>下载完毕得到压缩包<img src="https://img-blog.csdnimg.cn/img_convert/6a6ea6c70217b185322b00c7ae1dd821.png" alt="image-20201015181310051" loading="lazy"></p>
</li>
<li>
<p>解压到自己电脑下的环境目录即可，Redis十分的小<img src="https://img-blog.csdnimg.cn/img_convert/4d21aefd32119c61fa11530b1b7d690b.png" alt="image-20201015181503909" loading="lazy"></p>
</li>
<li>
<p>开启Redis，双击运行服务即可，默认端口号：6379<img src="https://img-blog.csdnimg.cn/img_convert/05e3b5ac7de329c051e1e21f67f432af.png" alt="image-20201015183108341" loading="lazy"></p>
</li>
<li>
<p>使用redis客户端来连接redis</p>
</li>
<li>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/img_convert/a82b0e48e00247e01ac2f872b9c40a7e.png" alt="image-20201015183413390" loading="lazy"></figure>
<pre><code class="language-redis">ping 测试连接
set name yangjian key-value键值对

123
</code></pre>
<p>记住一句话，Windows下使用确实简单，但是Redis推荐我们使用linux去开发使用<img src="https://img-blog.csdnimg.cn/img_convert/6e93fcf46ce3cd8a9658eecf3017e87b.png" alt="image-20201015183844238" loading="lazy"></p>
</li>
</ol>
<h2 id="linux下安装">Linux下安装</h2>
<ol>
<li>
<p>下载安装包，官网下载 http://www.redis.cn/<code>redis-6.0.6.tar.gz</code></p>
</li>
<li>
<p>解压redis安装包，程序/opt</p>
<pre><code class="language-linux">tar -zxvf redis-6.0.6.tar.gz
1
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/img_convert/879fd1fd07ebb9ed8c8eaee5b4766fe0.png" alt="image-20201015191253901" loading="lazy"></figure>
</li>
<li>
<p>进入解压后的文件，可以看到redis的配置文件</p>
</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/img_convert/7081b0d4827623d8cf42052151eb1bfa.png" alt="image-20201015191419342" loading="lazy"></figure>
<p>https://blog.csdn.net/qq_39135287/article/details/83474865?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160427974219724813256379%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160427974219724813256379&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v28-1-83474865.pc_search_result_cache&amp;utm_term=linux%E4%B8%8B%E5%AE%89%E8%A3%85redis&amp;spm=1018.2118.3001.4449</p>
<p>注意：新版本需要升级gcc</p>
<h3 id="通过指定的配置文件启动服务">通过指定的配置文件启动服务</h3>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/img_convert/02b40f2527208ed95e05032212fda96d.png" alt="image-20201102101058193" loading="lazy"></figure>
<h3 id="使用redis-cli客户端连接">使用redis-cli客户端连接</h3>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/img_convert/9caac0d2f3bbba242609021f1bddf9ab.png" alt="image-20201102101741551" loading="lazy"></figure>
<h3 id="查看redis进程是否开启">查看redis进程是否开启</h3>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/img_convert/7adc9fc365d7eef857fdae850f3b0046.png" alt="image-20201102102014348" loading="lazy"></figure>
<h3 id="如何关闭redis服务呢shutdown">如何关闭redis服务呢？shutdown</h3>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/img_convert/ccc74f1c1cb917a268f7ee9e1026261a.png" alt="image-20201102102124065" loading="lazy"></figure>
<p>后面我们会使用单机多redis集群进行测试</p>
<h2 id="测试性能">测试性能</h2>
<p>redis-benchmark是一个压力测试工具</p>
<p>官方自带的性能测试工具</p>
<h3 id="命令参数">命令参数</h3>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/img_convert/fea09ddf2bd6acecbdb7db2ddc420faa.png" alt="image-20201102100512051" loading="lazy"></figure>
<p><strong>自己来测试一下</strong></p>
<pre><code class="language-bash"># 测试100个并发连接，100000请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
12
</code></pre>
<h3 id="如何查看分析">如何查看分析</h3>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/img_convert/2c22a9f8a1cc97ab1e9aa9d6cc426808.png" alt="image-20201102102737332" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/img_convert/479a2863740a879c3f62a786d3a53eee.png" alt="image-20201102102938949" loading="lazy"></figure>
<h2 id="基础知识">基础知识</h2>
<p>redis默认有16个数据库</p>
<p>默认使用的是第0个</p>
<p>可以使用select 进行切换数据库</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; select 3  # 切换数据库
OK
127.0.0.1:6379[3]&gt; dbsize  # 查看db大小
(integer) 0

keys * # 查看当前数据库所有的key

flushdb  # 清空当前库

flushall # 清空所有数据库
12345678910
</code></pre>
<p>为什么redis的端口号为6379（了解即可，一个女人的姓名（手机</p>
<blockquote>
<p>redis是单线程的</p>
</blockquote>
<p>明白redis是很快的，官方表示，redis是基于内存操作的，cpu不是redis的性能瓶颈，redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，那就使用了单线程了！所以就使用了单线程，</p>
<p>Redis是由c语言写的，官方提供的数据为 100000+的QPS，说明这个完全不比memecache差！</p>
<p>Redis 为什么单线程还更快？</p>
<ol>
<li>误区：高性能的服务器一定是多线程的？</li>
<li>误区：多线程一定比单线程效率高（上下文切换）</li>
</ol>
<p>CPU&gt;内存&gt;硬盘的速度要有所了解</p>
<p>核心：redis是将所有的数据全部放在内存里面的，所以说使用单线程操作效率就是最高的（CPU上下文切换是一个耗时的操作）</p>
<p>对于内存系统来说，如果没有上下文切换，效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/img_convert/0a2aabfa7475eb7d3427a5d3b57abb5d.png" alt="image-20201102103753647" loading="lazy"></figure>
<h1 id="五大基本数据类型">五大基本数据类型</h1>
<blockquote>
<p>官方文档</p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）</p>
</blockquote>
<blockquote>
<p>现在的命令一定要全部记住，后面使用springboot，jredis，所有的都是基于此</p>
</blockquote>
<h2 id="redis-key">Redis-Key</h2>
<h3 id="基本命令">基本命令</h3>
<pre><code class="language-bash">set key value # set值

keys * #查看当前db的所有key

get key # 得到key的value

exists key # 是否存在key（键）

move key db # 移动键到另外一个数据库，共有16个数据库，默认为0

expire key 秒数 # 设置过期时间，单位是秒

ttl key # 查看还有多少时间过期

type key # 查看key的具体类型
123456789101112131415
</code></pre>
<p>不会的命令去官网查http://www.redis.cn/commands.html</p>
<h2 id="string">String</h2>
<p>九成的java程序员使用redis只会一个String类型！</p>
<pre><code class="language-bash">append key &quot;字符串&quot; # 向key后追加一个字符串，如果当前key不存在，就相当于set

strlen key # 获取字符串长度

incr key # 加一

decr key # 自减1

incrby value #增加value，可以设置步长，指定增量

decrby value # 减少value

############################################################
字符串范围 range 

getrange key start end # 下标从0开始，start-end
getrange key 0 -1 # 查看整个字符串,获取全部字符串，和get key是一样的

# 替换
# 替换指定位置开始的字符串
setrange key offset string # offset：偏移量，string：要替换的字符串

###########################################################
# setex(set with expire) # 设置过期时间

# setnx(set if not exist) # 不存在设置，在分布式锁中会经常使用，保证当前这个值存在
127.0.0.1:6379&gt; setex key3 30 hello  # 设置key3的值30s后过期
OK
127.0.0.1:6379&gt; ttl key3
(integer) 27
127.0.0.1:6379&gt; get key3
&quot;hello&quot;
127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey不存在，创建mykey
(integer) 1
127.0.0.1:6379&gt; keys *
1) &quot;mykey&quot;
2) &quot;key2&quot;
3) &quot;key1&quot;
127.0.0.1:6379&gt; ttl key3
(integer) -2
127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，则创建失败
(integer) 0
127.0.0.1:6379&gt; get mykey
&quot;redis&quot;
########################################################
# 批量set，get
mset k1 v1 k2 v2 ... # 同时设置多个值

mget k1 k2 ... # 同时获取多个值

msetnx k1 v1 k2 v2 ... # msetnx是一个原子性的操作，要么一起成功，要么一起失败

# 对象
set user:1 {name:zhangsan,age:3} # 设置一个user:1对象，值为json字符串来保存一个对象

mset user:1:name zhangsan user:1:age 20 # 这里的key是一个巧妙的设计，user:{id}:{field}，如此设计在redis中是完全可以的

getset # 先get后se
getset key value # 如果不存在值则返回nil，如果存在值则获取原来的值，然后set
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859
</code></pre>
<p>数据结构是相通的</p>
<p>String类似的使用场景：value除了是我们的字符串还可以是数字</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量 uid</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h2 id="list">List</h2>
<p>基本的数据类型，列表</p>
<p>在redis里面，我们可以把list玩成栈，队列</p>
<p>所有的list命令都是用<code>l</code>来开头的，不区分大小写命令</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; lpush list one # 将一个值或多个值插入到列表的头部
(integer) 1
127.0.0.1:6379&gt; lpush list two
(integer) 2
127.0.0.1:6379&gt; lpush list three
(integer) 3
127.0.0.1:6379&gt; lrange list 0 -1 # 获取所有元素
1) &quot;three&quot;
2) &quot;two&quot;
3) &quot;one&quot;
127.0.0.1:6379&gt; lrange list 0 1 # 获取0-1，通过区间获取具体的值
1) &quot;three&quot;
2) &quot;two&quot;
127.0.0.1:6379&gt; rpush list right # 将一个值放在链表的尾部
(integer) 4
127.0.0.1:6379&gt; lrange list  0  -1
1) &quot;three&quot;
2) &quot;two&quot;
3) &quot;one&quot;
4) &quot;right&quot;

##############################################################

lpop key # 移除列表的第一个元素
rpop key # 移除列表的最后一个元素

lindex key index # 获取key的index下标处的值，index从0开始

llen key # 获取list的长度

# 移除指定的值
lrme key count value # 删除count个value，从前往后删除，精确匹配

#############################################################
trim 修剪操作：list截断
ltrim key start stop # 截取list的start到stop之间的所有元素，左右都闭合，这个list就已经被改变了，只剩下截取的元素

rpoplpush source destination # 移除列表的最后一个元素并添加到目的列表的第一个

exists key # 判断里面有没有值

lset key index element # 设置key的index下标位置的值为element ，只有存在这个index下标才可以使用

linsert key before|after pivot element # 在pivot之前或之后插入值
1234567891011121314151617181920212223242526272829303132333435363738394041424344
</code></pre>
<p>小结：</p>
<ul>
<li>list实际上一个链表，before Node after，左右都可以插入</li>
<li>如果key不存在，创建新的链表</li>
<li>如果存在，新增内容</li>
<li>如果移除了所有值，空链表，不存在</li>
<li>在两边改动效率最高，中间元素效率会低一点</li>
</ul>
<p>消息排队！消息队列，</p>
<h2 id="set">Set</h2>
<p>set中的值是不能重复的</p>
<pre><code class="language-bash">sadd key value # 向set集合中添加

smembers key # 查看key里面的所有值

scard key # 获取set的元素个数

sismember key value # 判断value值是否在key中

srem key value # 移除value元素

set # 无序不重复集合，抽随机

srandmember myset count # 随机抽出指定个数元素

spop key count # 随机删除一些set集合中的元素

smove source destination # 将一个集合中的元素移动到另一个集合中

数字集合类：
 - 差集 sdiff key1 key2
 - 交集 sinter key1 key2 # 共同好友就可以这样实现
 - 并集 sunion key1 key2 
12345678910111213141516171819202122
</code></pre>
<p>共同关注，共同爱好，二度好友</p>
<h2 id="hash哈希">Hash（哈希）</h2>
<p>Map集合，key-,key-map,这时候这个值是一个map集合，本质和string没有太大区别</p>
<pre><code class="language-bash">hset key filed value [field value] # 存放hash As of Redis 4.0.0, HSET is variadic and allows for multiple field/value pairs.
# As per Redis 4.0.0, HMSET is considered deprecated. Please use HSET in new code.

hget key field # 获取key中filed键的值

hgetall key # 获取所有的键值对

hdel key filed # 删除hash指定的字段，对应的value也就没有了

hlen key # 获取hash的内容长度

hexists key field # 判断hash中的某个filed是否存在

hkeys key # 获取hash的所有键（key）

hvals key # 获取hash的所有值

hincrby key filed count # 自增count

hdecrby key field count  # 自减
1234567891011121314151617181920
</code></pre>
<h2 id="zset有序集合">Zset(有序集合)</h2>
<p>在set的基础上，增加了一个值, zset k1 score1 v1</p>
<pre><code class="language-bash">zadd key score value # 添加值，score代表优先级，可以一次添加多个

zrange key start end # 获取start-end的值，0 -1代表获取所有值

# 排序如何实现
zrangebyscore key startscore endscore # 对集合通过score排序， 默认升序

zrangebyscore key -inf inf withscores # 显示score

zrevrange salary 0 -1 [withscores] # 降序排列所有值

zrem key member [member] # 移除元素

zcard key # 获取有序集合中的个数

zcount key start end # 获取start-end之间的个数
12345678910111213141516
</code></pre>
<p>多查官方文档</p>
<p>案例思路：set 排序 存储班级成绩表，工资表排序</p>
<p>普通消息：1.重要消息 2.带权重进行判断</p>
<p>排行榜应用实现，取top n测试</p>
<h1 id="三种特殊数据类型">三种特殊数据类型</h1>
<h2 id="geospatial-地理位置">geospatial 地理位置</h2>
<p>朋友的定位，附近的人，打车距离计算。</p>
<p>两地之间的距离，方圆几里的人</p>
<p>可以查询一些测试数据</p>
<p>只有六个命令</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/img_convert/579ecfb5f79518c8509056805825f924.png" alt="image-20201103190205816" loading="lazy"></figure>
<blockquote>
<p>geoadd，添加地理位置的经度纬度</p>
</blockquote>
<pre><code class="language-bash"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入
# 
geoadd key 纬度 经度  名称 # 添加地理位置信息
127.0.0.1:6379&gt; geoadd China:city 116.23128 40.22077 beijing
(integer) 1
127.0.0.1:6379&gt; geoadd China:city 121.48941 31.40527 shanghai
(integer) 1
127.0.0.1:6379&gt; geoadd China:city 106.54041 29.40268 chongqing
12345678
</code></pre>
<blockquote>
<p>geopos，获取指定的经度纬度</p>
</blockquote>
<pre><code class="language-bash">geopos key position # 获取position的经度纬度
1
</code></pre>
<blockquote>
<p>geodist：返回两个位置的绝对距离</p>
</blockquote>
<p>返回两个给定位置之间的距离。</p>
<p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<pre><code class="language-bash">geodist key member1 member2 [m|km|ft|mi] # 查看member1到member2的直线距离
1
</code></pre>
<blockquote>
<p>georadius</p>
</blockquote>
<p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
<p>范围可以使用以下其中一个单位：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>我附近的人？（获得附近所有人的地址，定位！）通过半径来查询</p>
<pre><code class="language-bash">georadius key longitude latitude radius [m|km|ft|mi] [withcoord] [withdist] # 查询坐标半径的所有元素,后面可以跟很多参数，具体参数查看官方文档
1
</code></pre>
<blockquote>
<p>georadiusbymember</p>
</blockquote>
<p>这个命令和 <a href="http://www.redis.cn/commands/georadius.html">GEORADIUS</a> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <a href="http://www.redis.cn/commands/georadius.html">GEORADIUS</a> 那样， 使用输入的经度和纬度来决定中心点</p>
<p>指定成员的位置被用作查询的中心。</p>
<pre><code class="language-bash"># 找出指定元素周围的其他元素
georadiusbymember key member radius [m|km|ft|mi]
12
</code></pre>
<blockquote>
<p>geohash</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串，所以没有精度Geohash，损失相比，使用内部52位表示。返回的geohashes具有以下特性：</p>
<ol>
<li>他们可以缩短从右边的字符。它将失去精度，但仍将指向同一地区。</li>
<li>它可以在 <code>geohash.org</code> 网站使用，网址 <code>http://geohash.org/&lt;geohash-string&gt;</code>。查询例子：http://geohash.org/sqdtr74hyu0.</li>
<li>与类似的前缀字符串是附近，但相反的是不正确的，这是可能的，用不同的前缀字符串附近。</li>
</ol>
<pre><code class="language-bash">geohash key member [member] # 获取指定元素坐标的hash表示,如果两个字符串越接近，离的越近
1
</code></pre>
<blockquote>
<p>geo底层的实现原理其实就是Zset！我们可以使用Zset命令操作geo</p>
</blockquote>
<pre><code class="language-bash">zrange key 0 -1 #查看所有元素

zrem key member # 删除指定元素
123
</code></pre>
<h2 id="hyperloglog">hyperloglog</h2>
<blockquote>
<p>什么是基数</p>
</blockquote>
<p>不重复的元素</p>
<p>Redis2.8.9版本就更新了Hyperloglog数据结构</p>
<p>Redis Hyperloglog 基数统计的算法</p>
<p>网页的 UA（一个访问一个网站多次，但是还是算做一个人）</p>
<p>传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断，存在误差</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是计数，而不是保存用户id</p>
<p>优点：占用的内存是固定的，2^64不同元素，只需要废12kb的内存，如果要从内存角度来比较的话，Hyperloglog是首选</p>
<p>0.81%的错误率！统计UA的任务，是可以忽略不计的</p>
<pre><code class="language-bash">pfadd key member [member] # 添加元素

pfcount key # 查看个数

pfmerge destkey sourcekey [sourcekey] # 合并多个sourcekey

# 注意：不会有重复数据
1234567
</code></pre>
<h2 id="bitmap">bitmap</h2>
<blockquote>
<p>位存储</p>
</blockquote>
<p>统计疫情感染人数：0 1 0 1，统计用户信息，活跃，不活跃，打开，365打卡，两个状态的，都可以使用bitmaps来存储</p>
<p>bitmap 位图，也是一种数据结构！都是操作二进制位来进行记录，都只有 0 1两种状态</p>
<p>365天 = 365 bit， 1字节 = 8bit， 46个字节左右！</p>
<blockquote>
<p>测试</p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/img_convert/bcf88e67b570869a0f08649b9693b441.png" alt="image-20201103211923600" loading="lazy"></figure>
<p>使用bitmaps记录周一到周日的打卡，查看某一天</p>
<pre><code class="language-bash">setbit key offset value # 设置

getbit key offset # 得到结果

# 统计操作，打卡的天数
bitcount key [start end] # 统计打卡天数
123456
</code></pre>
<h1 id="事务">事务</h1>
<p>MYSQL：ACID！</p>
<p>要么同时成功，要么同时失败：原子性，redis没有原子性</p>
<p>Redis单条命令保证原子性，但是事务不保证原子性</p>
<p>Redis事务本质：一组命令的集合,一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行</p>
<p>一次性，顺序性，排他性！执行一系列的命令</p>
<p>Redis事务没有隔离级别的概念</p>
<p>所有的命令在事务中，并没有被直接被执行，只有发起执行命令的时候才会被执行！Exec</p>
<p>redis的事务</p>
<ul>
<li>开启事务(multi)</li>
<li>命令入队(……)</li>
<li>执行事务(exec)</li>
</ul>
<p>锁：redis可以实现乐观锁，watch</p>
<blockquote>
<p>正常执行事务</p>
</blockquote>
<pre><code class="language-bash">127.0.0.1:6379&gt; multi   # 开启事务
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; get k2
QUEUED
127.0.0.1:6379&gt; set k3 v3
QUEUED
127.0.0.1:6379&gt; exec  # 执行事务
1) OK
2) OK
3) &quot;v2&quot;
4) OK
123456789101112131415
</code></pre>
<blockquote>
<p>放弃事务</p>
</blockquote>
<pre><code class="language-bash">127.0.0.1:6379&gt; multi     # 开启事务
OK
127.0.0.1:6379&gt; set k1 v1 
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; set k4 v4
QUEUED
127.0.0.1:6379&gt; discard 	# 放弃事务	
OK
127.0.0.1:6379&gt; get k4	# 事务中的命令都不会被执行
(nil)

12345678910111213
</code></pre>
<blockquote>
<p>编译型异常（代码有问题，命令有错 ），事务中所有的命令都不会执行</p>
</blockquote>
<pre><code class="language-bash">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 v2 
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; set k3 v3
QUEUED
127.0.0.1:6379&gt; getset k3     # 错误的命令
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379&gt; set k4 v4
QUEUED
127.0.0.1:6379&gt; set k5 v5
QUEUED
127.0.0.1:6379&gt; exec	# 执行事务报错
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379&gt; get k5	# 所有的命令都不会被执行
(nil)
123456789101112131415161718
</code></pre>
<blockquote>
<p>运行时异常（1/0），如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常</p>
</blockquote>
<pre><code class="language-bash">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 &quot;v1&quot;
QUEUED
127.0.0.1:6379&gt; incr k1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; set k3 v3
QUEUED
127.0.0.1:6379&gt; get k3
QUEUED
127.0.0.1:6379&gt; exec
1) OK
2) (error) ERR value is not an integer or out of range  # 虽然这条命令报错，但是依旧执行成功
3) OK
4) OK
5) &quot;v3&quot;

12345678910111213141516171819
</code></pre>
<blockquote>
<p>监控！Watch ：（ ，面试常问</p>
</blockquote>
<p>悲观锁：</p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会加锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<blockquote>
<p>Redis测试监视测试</p>
</blockquote>
<p><strong>正常执行成功</strong></p>
<pre><code class="language-bash">watch key # 监视值

unwatch # 放弃监视

exec	# 执行事务

multi	# 开启事务


127.0.0.1:6379&gt; set money 100
OK
127.0.0.1:6379&gt; set out 0
OK
127.0.0.1:6379&gt; watch money 	# 监视money对象
OK
127.0.0.1:6379&gt; multi 			# 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功
OK
127.0.0.1:6379&gt; decrby money 20
QUEUED
127.0.0.1:6379&gt; incrby out 20
QUEUED
127.0.0.1:6379&gt; exec
1) (integer) 80
2) (integer) 20
123456789101112131415161718192021222324
</code></pre>
<p><strong>执行失败</strong>，使用watch可以当redis的乐观锁操作</p>
<pre><code class="language-bash"># 主线程
127.0.0.1:6379&gt; watch money
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; decrby money 10
QUEUED
127.0.0.1:6379&gt; incrby out 10
QUEUED
127.0.0.1:6379&gt; exec	# 执行之前，另外一个线程修改了值，就会导致执行失败
(nil)

# 线程2
127.0.0.1:6379&gt; get money
&quot;80&quot;
127.0.0.1:6379&gt; set money 1000
OK
1234567891011121314151617
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/img_convert/f05dbe700a8856a77ea5a2c340250b7d.png" alt="image-20201104090306929" loading="lazy"></figure>
<p>如果修改失败，获取最新的值就好</p>
<h1 id="jedis">Jedis</h1>
<p>我们要用java来操作Redis</p>
<blockquote>
<p>什么是Jedis 是 Redis官方推荐的java连接开发工具！使用java操作redis中间件！如果要使用java操作redis，那么一定要对jedis十分的熟悉</p>
</blockquote>
<p>知其然并知其所以然</p>
<ol>
<li>代入Jedis的包</li>
</ol>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.74&lt;/version&gt;
&lt;/dependency&gt;
12345678910111213
</code></pre>
<ol>
<li>
<p>编码测试</p>
<ul>
<li>
<p>连接数据库</p>
<pre><code class="language-java">public class TestPing {
    public static void main(String[] args) {
//        1.new Jedis对象
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);
        // jedis所有的命令就是之前学习的所有指令,所以之间的指令很重要
        System.out.println(jedis.ping());
    }
}

// 输出，pong
12345678910
</code></pre>
</li>
<li>
<p>操作命令</p>
</li>
<li>
<p>断开连接</p>
</li>
</ul>
</li>
</ol>
<h2 id="常用api">常用API</h2>
<p>String</p>
<p>List</p>
<p>Set</p>
<p>Hash</p>
<p>Zset</p>
<blockquote>
<p>所有的API命令就是上面对应的指令，一个都没有变化</p>
</blockquote>
<h2 id="事务-2">事务</h2>
<pre><code class="language-java">public class TestTX {


    public static void main(String[] args) {
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);
        jsonObject.put(&quot;name&quot;, &quot;杨剑&quot;);
        jedis.flushDB();
        //开启事务
        Transaction multi = jedis.multi();
        String s = jsonObject.toJSONString();
        try {
            multi.set(&quot;user1&quot;, s);
            multi.set(&quot;user2&quot;, s);
            int i = 1/0;    //代码抛出异常，事务执行失败
            multi.exec();//执行事务
        } catch (Exception e) {
            multi.discard(); //放弃事务
            e.printStackTrace();
        } finally {
            System.out.println(jedis.get(&quot;user1&quot;));
            System.out.println(jedis.get(&quot;user2&quot;));
            jedis.close();
        }

    }
}
12345678910111213141516171819202122232425262728
</code></pre>
<h1 id="springboot整合">SpringBoot整合</h1>
<p>Springboot操作数据：spring-data jpa jdbc mongodb redis</p>
<p>SpringData也是和SpringBoot齐名的项目</p>
<p>说明：在springboot2.x之后，原来使用的jedis被替换成了lettuce？</p>
<p>jedis：采用的是直连，多个线程操作是不安全的，如果想要避免，使用jedis pool连接池！BIO</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p>
<blockquote>
<p>整合测试一下</p>
</blockquote>
<pre><code class="language-java">/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.boot.autoconfigure.data.redis;

import java.net.UnknownHostException;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;

/**
 * {@link EnableAutoConfiguration Auto-configuration} for Spring Data's Redis support.
 *
 * @author Dave Syer
 * @author Andy Wilkinson
 * @author Christian Dupuis
 * @author Christoph Strobl
 * @author Phillip Webb
 * @author Eddú Meléndez
 * @author Stephane Nicoll
 * @author Marco Aust
 * @author Mark Paluch
 * @since 1.0.0
 */
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

   @Bean
   @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)   //我们可以自己定义一个RedisTemplate来替换默认的
    // 默认的template没有过多的设置，redis对象都是需要序列化的
    //两个泛型都是object类型，我们后面使用需要强制转换&lt;String,Object&gt;
   public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)
         throws UnknownHostException {
      RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

   @Bean
   @ConditionalOnMissingBean	//由于String类型是Redis中最常使用的类型，所以单独提出来了一个bean
   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)
         throws UnknownHostException {
      StringRedisTemplate template = new StringRedisTemplate();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

}
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273
</code></pre>
<ol>
<li>
<p>导入连接</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;65	
   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
1234
</code></pre>
</li>
<li>
<p>配置连接</p>
<pre><code class="language-properties"># springboot所有的配置类，都有一个自动配置类 RedisAutoConfiguration
# 自动配置类都会绑定一个properties配置文件 RedisProperties

# 配置redis
spring.redis.host=localhost
spring.redis.port=6379
123456
</code></pre>
</li>
<li>
<p>测试！</p>
<pre><code class="language-java">@SpringBootTest
class Redis02SpringbootApplicationTests {
   @Autowired
   private RedisTemplate redisTemplate;
   @Test
   void contextLoads() {
      //redisTemplate 操作不同的数据类型，api和我们的指令是一样的
      // 操作字符串，类似String类型
//    redisTemplate.opsForValue();
//    // 操作List
//    redisTemplate.opsForList();
//    //opsforset
//    redisTemplate.opsForSet();
//    //opsforhash
//    redisTemplate.opsForHash();
//    //地图
//    redisTemplate.opsForGeo();
//    //Zset
//    redisTemplate.opsForZSet();
//    //基数：hyperloglog
//    redisTemplate.opsForHyperLogLog();

      //除了基本的操作，常用的方法都可以直接使用,事务和基本的crud

      //获取redis连接对象
//    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();

      redisTemplate.opsForValue().set(&quot;name&quot;,&quot;yangjian&quot;);
      System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));
   }

}
1234567891011121314151617181920212223242526272829303132
</code></pre>
</li>
</ol>
<h2 id="序列化配置">序列化配置</h2>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/img_convert/5564164fe50d39b6911766a0ea4b8069.png" alt="image-20201104153459661" loading="lazy"></figure>
<h2 id="自定义redistemplate拿过来可以直接用">自定义RedisTemplate(拿过来可以直接用)</h2>
<pre><code class="language-java">package com.yang.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.net.UnknownHostException;

@Configuration
public class RedisConfig {

    //编写自己的RedisTemplate
    //自己定义了一个RedisTemplate

    //这是一个固定模板，拿去可以直接使用
    @Bean
    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)
            throws UnknownHostException {
        //为了我们自己开发方便，一般直接使用&lt;String,Object&gt;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);
        //json序列化配置
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        objectJackson2JsonRedisSerializer.setObjectMapper(om);
        //String的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        //key采用String序列化方式
        template.setKeySerializer(stringRedisSerializer);
        //hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        //value的序列化方式采用jackson
        template.setValueSerializer(objectJackson2JsonRedisSerializer);
        //hash的value序列化方式采用jackson
        template.setHashValueSerializer(objectJackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;
    }
}
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950
</code></pre>
<h2 id="redisutil工具类">RedisUtil工具类</h2>
<pre><code class="language-java">package com.yang.utils;

import org.springframework.data.redis.connection.DataType;
import org.springframework.data.redis.core.Cursor;
import org.springframework.data.redis.core.ScanOptions;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ZSetOperations.TypedTuple;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * Redis工具类
 *
 * @author WangFan
 * @date 2018-02-24 下午03:09:50
 * @version 1.1 (GitHub文档: https://github.com/whvcse/RedisUtil )
 */
@Component
public class RedisUtil {
    private StringRedisTemplate redisTemplate;

    public void setRedisTemplate(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public StringRedisTemplate getRedisTemplate() {
        return this.redisTemplate;
    }

    /** -------------------key相关操作--------------------- */

    /**
     * 删除key
     *
     * @param key
     */
    public void delete(String key) {
        redisTemplate.delete(key);
    }

    /**
     * 批量删除key
     *
     * @param keys
     */
    public void delete(Collection&lt;String&gt; keys) {
        redisTemplate.delete(keys);
    }

    /**
     * 序列化key
     *
     * @param key
     * @return
     */
    public byte[] dump(String key) {
        return redisTemplate.dump(key);
    }

    /**
     * 是否存在key
     *
     * @param key
     * @return
     */
    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    /**
     * 设置过期时间
     *
     * @param key
     * @param timeout
     * @param unit
     * @return
     */
    public Boolean expire(String key, long timeout, TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 设置过期时间
     *
     * @param key
     * @param date
     * @return
     */
    public Boolean expireAt(String key, Date date) {
        return redisTemplate.expireAt(key, date);
    }

    /**
     * 查找匹配的key
     *
     * @param pattern
     * @return
     */
    public Set&lt;String&gt; keys(String pattern) {
        return redisTemplate.keys(pattern);
    }

    /**
     * 将当前数据库的 key 移动到给定的数据库 db 当中
     *
     * @param key
     * @param dbIndex
     * @return
     */
    public Boolean move(String key, int dbIndex) {
        return redisTemplate.move(key, dbIndex);
    }

    /**
     * 移除 key 的过期时间，key 将持久保持
     *
     * @param key
     * @return
     */
    public Boolean persist(String key) {
        return redisTemplate.persist(key);
    }

    /**
     * 返回 key 的剩余的过期时间
     *
     * @param key
     * @param unit
     * @return
     */
    public Long getExpire(String key, TimeUnit unit) {
        return redisTemplate.getExpire(key, unit);
    }

    /**
     * 返回 key 的剩余的过期时间
     *
     * @param key
     * @return
     */
    public Long getExpire(String key) {
        return redisTemplate.getExpire(key);
    }

    /**
     * 从当前数据库中随机返回一个 key
     *
     * @return
     */
    public String randomKey() {
        return redisTemplate.randomKey();
    }

    /**
     * 修改 key 的名称
     *
     * @param oldKey
     * @param newKey
     */
    public void rename(String oldKey, String newKey) {
        redisTemplate.rename(oldKey, newKey);
    }

    /**
     * 仅当 newkey 不存在时，将 oldKey 改名为 newkey
     *
     * @param oldKey
     * @param newKey
     * @return
     */
    public Boolean renameIfAbsent(String oldKey, String newKey) {
        return redisTemplate.renameIfAbsent(oldKey, newKey);
    }

    /**
     * 返回 key 所储存的值的类型
     *
     * @param key
     * @return
     */
    public DataType type(String key) {
        return redisTemplate.type(key);
    }

    /** -------------------string相关操作--------------------- */

    /**
     * 设置指定 key 的值
     * @param key
     * @param value
     */
    public void set(String key, String value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 获取指定 key 的值
     * @param key
     * @return
     */
    public String get(String key) {
        return redisTemplate.opsForValue().get(key);
    }

    /**
     * 返回 key 中字符串值的子字符
     * @param key
     * @param start
     * @param end
     * @return
     */
    public String getRange(String key, long start, long end) {
        return redisTemplate.opsForValue().get(key, start, end);
    }

    /**
     * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)
     *
     * @param key
     * @param value
     * @return
     */
    public String getAndSet(String key, String value) {
        return redisTemplate.opsForValue().getAndSet(key, value);
    }

    /**
     * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)
     *
     * @param key
     * @param offset
     * @return
     */
    public Boolean getBit(String key, long offset) {
        return redisTemplate.opsForValue().getBit(key, offset);
    }

    /**
     * 批量获取
     *
     * @param keys
     * @return
     */
    public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) {
        return redisTemplate.opsForValue().multiGet(keys);
    }

    /**
     * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value
     *
     * @param key
     * @param postion
     *            位置
     * @param value
     *            值,true为1, false为0
     * @return
     */
    public boolean setBit(String key, long offset, boolean value) {
        return redisTemplate.opsForValue().setBit(key, offset, value);
    }

    /**
     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout
     *
     * @param key
     * @param value
     * @param timeout
     *            过期时间
     * @param unit
     *            时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES
     *            秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS
     */
    public void setEx(String key, String value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }

    /**
     * 只有在 key 不存在时设置 key 的值
     *
     * @param key
     * @param value
     * @return 之前已经存在返回false,不存在返回true
     */
    public boolean setIfAbsent(String key, String value) {
        return redisTemplate.opsForValue().setIfAbsent(key, value);
    }

    /**
     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始
     *
     * @param key
     * @param value
     * @param offset
     *            从指定位置开始覆写
     */
    public void setRange(String key, String value, long offset) {
        redisTemplate.opsForValue().set(key, value, offset);
    }

    /**
     * 获取字符串的长度
     *
     * @param key
     * @return
     */
    public Long size(String key) {
        return redisTemplate.opsForValue().size(key);
    }

    /**
     * 批量添加
     *
     * @param maps
     */
    public void multiSet(Map&lt;String, String&gt; maps) {
        redisTemplate.opsForValue().multiSet(maps);
    }

    /**
     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在
     *
     * @param maps
     * @return 之前已经存在返回false,不存在返回true
     */
    public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) {
        return redisTemplate.opsForValue().multiSetIfAbsent(maps);
    }

    /**
     * 增加(自增长), 负数则为自减
     *
     * @param key
     * @param value
     * @return
     */
    public Long incrBy(String key, long increment) {
        return redisTemplate.opsForValue().increment(key, increment);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Double incrByFloat(String key, double increment) {
        return redisTemplate.opsForValue().increment(key, increment);
    }

    /**
     * 追加到末尾
     *
     * @param key
     * @param value
     * @return
     */
    public Integer append(String key, String value) {
        return redisTemplate.opsForValue().append(key, value);
    }

    /** -------------------hash相关操作------------------------- */

    /**
     * 获取存储在哈希表中指定字段的值
     *
     * @param key
     * @param field
     * @return
     */
    public Object hGet(String key, String field) {
        return redisTemplate.opsForHash().get(key, field);
    }

    /**
     * 获取所有给定字段的值
     *
     * @param key
     * @return
     */
    public Map&lt;Object, Object&gt; hGetAll(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 获取所有给定字段的值
     *
     * @param key
     * @param fields
     * @return
     */
    public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) {
        return redisTemplate.opsForHash().multiGet(key, fields);
    }

    public void hPut(String key, String hashKey, String value) {
        redisTemplate.opsForHash().put(key, hashKey, value);
    }

    public void hPutAll(String key, Map&lt;String, String&gt; maps) {
        redisTemplate.opsForHash().putAll(key, maps);
    }

    /**
     * 仅当hashKey不存在时才设置
     *
     * @param key
     * @param hashKey
     * @param value
     * @return
     */
    public Boolean hPutIfAbsent(String key, String hashKey, String value) {
        return redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);
    }

    /**
     * 删除一个或多个哈希表字段
     *
     * @param key
     * @param fields
     * @return
     */
    public Long hDelete(String key, Object... fields) {
        return redisTemplate.opsForHash().delete(key, fields);
    }

    /**
     * 查看哈希表 key 中，指定的字段是否存在
     *
     * @param key
     * @param field
     * @return
     */
    public boolean hExists(String key, String field) {
        return redisTemplate.opsForHash().hasKey(key, field);
    }

    /**
     * 为哈希表 key 中的指定字段的整数值加上增量 increment
     *
     * @param key
     * @param field
     * @param increment
     * @return
     */
    public Long hIncrBy(String key, Object field, long increment) {
        return redisTemplate.opsForHash().increment(key, field, increment);
    }

    /**
     * 为哈希表 key 中的指定字段的整数值加上增量 increment
     *
     * @param key
     * @param field
     * @param delta
     * @return
     */
    public Double hIncrByFloat(String key, Object field, double delta) {
        return redisTemplate.opsForHash().increment(key, field, delta);
    }

    /**
     * 获取所有哈希表中的字段
     *
     * @param key
     * @return
     */
    public Set&lt;Object&gt; hKeys(String key) {
        return redisTemplate.opsForHash().keys(key);
    }

    /**
     * 获取哈希表中字段的数量
     *
     * @param key
     * @return
     */
    public Long hSize(String key) {
        return redisTemplate.opsForHash().size(key);
    }

    /**
     * 获取哈希表中所有值
     *
     * @param key
     * @return
     */
    public List&lt;Object&gt; hValues(String key) {
        return redisTemplate.opsForHash().values(key);
    }

    /**
     * 迭代哈希表中的键值对
     *
     * @param key
     * @param options
     * @return
     */
    public Cursor&lt;Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) {
        return redisTemplate.opsForHash().scan(key, options);
    }

    /** ------------------------list相关操作---------------------------- */

    /**
     * 通过索引获取列表中的元素
     *
     * @param key
     * @param index
     * @return
     */
    public String lIndex(String key, long index) {
        return redisTemplate.opsForList().index(key, index);
    }

    /**
     * 获取列表指定范围内的元素
     *
     * @param key
     * @param start
     *            开始位置, 0是开始位置
     * @param end
     *            结束位置, -1返回所有
     * @return
     */
    public List&lt;String&gt; lRange(String key, long start, long end) {
        return redisTemplate.opsForList().range(key, start, end);
    }

    /**
     * 存储在list头部
     *
     * @param key
     * @param value
     * @return
     */
    public Long lLeftPush(String key, String value) {
        return redisTemplate.opsForList().leftPush(key, value);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Long lLeftPushAll(String key, String... value) {
        return redisTemplate.opsForList().leftPushAll(key, value);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Long lLeftPushAll(String key, Collection&lt;String&gt; value) {
        return redisTemplate.opsForList().leftPushAll(key, value);
    }

    /**
     * 当list存在的时候才加入
     *
     * @param key
     * @param value
     * @return
     */
    public Long lLeftPushIfPresent(String key, String value) {
        return redisTemplate.opsForList().leftPushIfPresent(key, value);
    }

    /**
     * 如果pivot存在,再pivot前面添加
     *
     * @param key
     * @param pivot
     * @param value
     * @return
     */
    public Long lLeftPush(String key, String pivot, String value) {
        return redisTemplate.opsForList().leftPush(key, pivot, value);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Long lRightPush(String key, String value) {
        return redisTemplate.opsForList().rightPush(key, value);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Long lRightPushAll(String key, String... value) {
        return redisTemplate.opsForList().rightPushAll(key, value);
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    public Long lRightPushAll(String key, Collection&lt;String&gt; value) {
        return redisTemplate.opsForList().rightPushAll(key, value);
    }

    /**
     * 为已存在的列表添加值
     *
     * @param key
     * @param value
     * @return
     */
    public Long lRightPushIfPresent(String key, String value) {
        return redisTemplate.opsForList().rightPushIfPresent(key, value);
    }

    /**
     * 在pivot元素的右边添加值
     *
     * @param key
     * @param pivot
     * @param value
     * @return
     */
    public Long lRightPush(String key, String pivot, String value) {
        return redisTemplate.opsForList().rightPush(key, pivot, value);
    }

    /**
     * 通过索引设置列表元素的值
     *
     * @param key
     * @param index
     *            位置
     * @param value
     */
    public void lSet(String key, long index, String value) {
        redisTemplate.opsForList().set(key, index, value);
    }

    /**
     * 移出并获取列表的第一个元素
     *
     * @param key
     * @return 删除的元素
     */
    public String lLeftPop(String key) {
        return redisTemplate.opsForList().leftPop(key);
    }

    /**
     * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
     *
     * @param key
     * @param timeout
     *            等待时间
     * @param unit
     *            时间单位
     * @return
     */
    public String lBLeftPop(String key, long timeout, TimeUnit unit) {
        return redisTemplate.opsForList().leftPop(key, timeout, unit);
    }

    /**
     * 移除并获取列表最后一个元素
     *
     * @param key
     * @return 删除的元素
     */
    public String lRightPop(String key) {
        return redisTemplate.opsForList().rightPop(key);
    }

    /**
     * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
     *
     * @param key
     * @param timeout
     *            等待时间
     * @param unit
     *            时间单位
     * @return
     */
    public String lBRightPop(String key, long timeout, TimeUnit unit) {
        return redisTemplate.opsForList().rightPop(key, timeout, unit);
    }

    /**
     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回
     *
     * @param sourceKey
     * @param destinationKey
     * @return
     */
    public String lRightPopAndLeftPush(String sourceKey, String destinationKey) {
        return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,
                destinationKey);
    }

    /**
     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
     *
     * @param sourceKey
     * @param destinationKey
     * @param timeout
     * @param unit
     * @return
     */
    public String lBRightPopAndLeftPush(String sourceKey, String destinationKey,
                                        long timeout, TimeUnit unit) {
        return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,
                destinationKey, timeout, unit);
    }

    /**
     * 删除集合中值等于value得元素
     *
     * @param key
     * @param index
     *            index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素;
     *            index&lt;0, 从尾部开始删除第一个值等于value的元素;
     * @param value
     * @return
     */
    public Long lRemove(String key, long index, String value) {
        return redisTemplate.opsForList().remove(key, index, value);
    }

    /**
     * 裁剪list
     *
     * @param key
     * @param start
     * @param end
     */
    public void lTrim(String key, long start, long end) {
        redisTemplate.opsForList().trim(key, start, end);
    }

    /**
     * 获取列表长度
     *
     * @param key
     * @return
     */
    public Long lLen(String key) {
        return redisTemplate.opsForList().size(key);
    }

    /** --------------------set相关操作-------------------------- */

    /**
     * set添加元素
     *
     * @param key
     * @param values
     * @return
     */
    public Long sAdd(String key, String... values) {
        return redisTemplate.opsForSet().add(key, values);
    }

    /**
     * set移除元素
     *
     * @param key
     * @param values
     * @return
     */
    public Long sRemove(String key, Object... values) {
        return redisTemplate.opsForSet().remove(key, values);
    }

    /**
     * 移除并返回集合的一个随机元素
     *
     * @param key
     * @return
     */
    public String sPop(String key) {
        return redisTemplate.opsForSet().pop(key);
    }

    /**
     * 将元素value从一个集合移到另一个集合
     *
     * @param key
     * @param value
     * @param destKey
     * @return
     */
    public Boolean sMove(String key, String value, String destKey) {
        return redisTemplate.opsForSet().move(key, value, destKey);
    }

    /**
     * 获取集合的大小
     *
     * @param key
     * @return
     */
    public Long sSize(String key) {
        return redisTemplate.opsForSet().size(key);
    }

    /**
     * 判断集合是否包含value
     *
     * @param key
     * @param value
     * @return
     */
    public Boolean sIsMember(String key, Object value) {
        return redisTemplate.opsForSet().isMember(key, value);
    }

    /**
     * 获取两个集合的交集
     *
     * @param key
     * @param otherKey
     * @return
     */
    public Set&lt;String&gt; sIntersect(String key, String otherKey) {
        return redisTemplate.opsForSet().intersect(key, otherKey);
    }

    /**
     * 获取key集合与多个集合的交集
     *
     * @param key
     * @param otherKeys
     * @return
     */
    public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) {
        return redisTemplate.opsForSet().intersect(key, otherKeys);
    }

    /**
     * key集合与otherKey集合的交集存储到destKey集合中
     *
     * @param key
     * @param otherKey
     * @param destKey
     * @return
     */
    public Long sIntersectAndStore(String key, String otherKey, String destKey) {
        return redisTemplate.opsForSet().intersectAndStore(key, otherKey,
                destKey);
    }

    /**
     * key集合与多个集合的交集存储到destKey集合中
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,
                                   String destKey) {
        return redisTemplate.opsForSet().intersectAndStore(key, otherKeys,
                destKey);
    }

    /**
     * 获取两个集合的并集
     *
     * @param key
     * @param otherKeys
     * @return
     */
    public Set&lt;String&gt; sUnion(String key, String otherKeys) {
        return redisTemplate.opsForSet().union(key, otherKeys);
    }

    /**
     * 获取key集合与多个集合的并集
     *
     * @param key
     * @param otherKeys
     * @return
     */
    public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) {
        return redisTemplate.opsForSet().union(key, otherKeys);
    }

    /**
     * key集合与otherKey集合的并集存储到destKey中
     *
     * @param key
     * @param otherKey
     * @param destKey
     * @return
     */
    public Long sUnionAndStore(String key, String otherKey, String destKey) {
        return redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);
    }

    /**
     * key集合与多个集合的并集存储到destKey中
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys,
                               String destKey) {
        return redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);
    }

    /**
     * 获取两个集合的差集
     *
     * @param key
     * @param otherKey
     * @return
     */
    public Set&lt;String&gt; sDifference(String key, String otherKey) {
        return redisTemplate.opsForSet().difference(key, otherKey);
    }

    /**
     * 获取key集合与多个集合的差集
     *
     * @param key
     * @param otherKeys
     * @return
     */
    public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) {
        return redisTemplate.opsForSet().difference(key, otherKeys);
    }

    /**
     * key集合与otherKey集合的差集存储到destKey中
     *
     * @param key
     * @param otherKey
     * @param destKey
     * @return
     */
    public Long sDifference(String key, String otherKey, String destKey) {
        return redisTemplate.opsForSet().differenceAndStore(key, otherKey,
                destKey);
    }

    /**
     * key集合与多个集合的差集存储到destKey中
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Long sDifference(String key, Collection&lt;String&gt; otherKeys,
                            String destKey) {
        return redisTemplate.opsForSet().differenceAndStore(key, otherKeys,
                destKey);
    }

    /**
     * 获取集合所有元素
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Set&lt;String&gt; setMembers(String key) {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 随机获取集合中的一个元素
     *
     * @param key
     * @return
     */
    public String sRandomMember(String key) {
        return redisTemplate.opsForSet().randomMember(key);
    }

    /**
     * 随机获取集合中count个元素
     *
     * @param key
     * @param count
     * @return
     */
    public List&lt;String&gt; sRandomMembers(String key, long count) {
        return redisTemplate.opsForSet().randomMembers(key, count);
    }

    /**
     * 随机获取集合中count个元素并且去除重复的
     *
     * @param key
     * @param count
     * @return
     */
    public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) {
        return redisTemplate.opsForSet().distinctRandomMembers(key, count);
    }

    /**
     *
     * @param key
     * @param options
     * @return
     */
    public Cursor&lt;String&gt; sScan(String key, ScanOptions options) {
        return redisTemplate.opsForSet().scan(key, options);
    }

    /**------------------zSet相关操作--------------------------------*/

    /**
     * 添加元素,有序集合是按照元素的score值由小到大排列
     *
     * @param key
     * @param value
     * @param score
     * @return
     */
    public Boolean zAdd(String key, String value, double score) {
        return redisTemplate.opsForZSet().add(key, value, score);
    }

    /**
     *
     * @param key
     * @param values
     * @return
     */
    public Long zAdd(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values) {
        return redisTemplate.opsForZSet().add(key, values);
    }

    /**
     *
     * @param key
     * @param values
     * @return
     */
    public Long zRemove(String key, Object... values) {
        return redisTemplate.opsForZSet().remove(key, values);
    }

    /**
     * 增加元素的score值，并返回增加后的值
     *
     * @param key
     * @param value
     * @param delta
     * @return
     */
    public Double zIncrementScore(String key, String value, double delta) {
        return redisTemplate.opsForZSet().incrementScore(key, value, delta);
    }

    /**
     * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列
     *
     * @param key
     * @param value
     * @return 0表示第一位
     */
    public Long zRank(String key, Object value) {
        return redisTemplate.opsForZSet().rank(key, value);
    }

    /**
     * 返回元素在集合的排名,按元素的score值由大到小排列
     *
     * @param key
     * @param value
     * @return
     */
    public Long zReverseRank(String key, Object value) {
        return redisTemplate.opsForZSet().reverseRank(key, value);
    }

    /**
     * 获取集合的元素, 从小到大排序
     *
     * @param key
     * @param start
     *            开始位置
     * @param end
     *            结束位置, -1查询所有
     * @return
     */
    public Set&lt;String&gt; zRange(String key, long start, long end) {
        return redisTemplate.opsForZSet().range(key, start, end);
    }

    /**
     * 获取集合元素, 并且把score值也获取
     *
     * @param key
     * @param start
     * @param end
     * @return
     */
    public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start,
                                                    long end) {
        return redisTemplate.opsForZSet().rangeWithScores(key, start, end);
    }

    /**
     * 根据Score值查询集合元素
     *
     * @param key
     * @param min
     *            最小值
     * @param max
     *            最大值
     * @return
     */
    public Set&lt;String&gt; zRangeByScore(String key, double min, double max) {
        return redisTemplate.opsForZSet().rangeByScore(key, min, max);
    }

    /**
     * 根据Score值查询集合元素, 从小到大排序
     *
     * @param key
     * @param min
     *            最小值
     * @param max
     *            最大值
     * @return
     */
    public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,
                                                           double min, double max) {
        return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);
    }

    /**
     *
     * @param key
     * @param min
     * @param max
     * @param start
     * @param end
     * @return
     */
    public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,
                                                           double min, double max, long start, long end) {
        return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,
                start, end);
    }

    /**
     * 获取集合的元素, 从大到小排序
     *
     * @param key
     * @param start
     * @param end
     * @return
     */
    public Set&lt;String&gt; zReverseRange(String key, long start, long end) {
        return redisTemplate.opsForZSet().reverseRange(key, start, end);
    }

    /**
     * 获取集合的元素, 从大到小排序, 并返回score值
     *
     * @param key
     * @param start
     * @param end
     * @return
     */
    public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key,
                                                           long start, long end) {
        return redisTemplate.opsForZSet().reverseRangeWithScores(key, start,
                end);
    }

    /**
     * 根据Score值查询集合元素, 从大到小排序
     *
     * @param key
     * @param min
     * @param max
     * @return
     */
    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,
                                            double max) {
        return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);
    }

    /**
     * 根据Score值查询集合元素, 从大到小排序
     *
     * @param key
     * @param min
     * @param max
     * @return
     */
    public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(
            String key, double min, double max) {
        return redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,
                min, max);
    }

    /**
     *
     * @param key
     * @param min
     * @param max
     * @param start
     * @param end
     * @return
     */
    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,
                                            double max, long start, long end) {
        return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max,
                start, end);
    }

    /**
     * 根据score值获取集合元素数量
     *
     * @param key
     * @param min
     * @param max
     * @return
     */
    public Long zCount(String key, double min, double max) {
        return redisTemplate.opsForZSet().count(key, min, max);
    }

    /**
     * 获取集合大小
     *
     * @param key
     * @return
     */
    public Long zSize(String key) {
        return redisTemplate.opsForZSet().size(key);
    }

    /**
     * 获取集合大小
     *
     * @param key
     * @return
     */
    public Long zZCard(String key) {
        return redisTemplate.opsForZSet().zCard(key);
    }

    /**
     * 获取集合中value元素的score值
     *
     * @param key
     * @param value
     * @return
     */
    public Double zScore(String key, Object value) {
        return redisTemplate.opsForZSet().score(key, value);
    }

    /**
     * 移除指定索引位置的成员
     *
     * @param key
     * @param start
     * @param end
     * @return
     */
    public Long zRemoveRange(String key, long start, long end) {
        return redisTemplate.opsForZSet().removeRange(key, start, end);
    }

    /**
     * 根据指定的score值的范围来移除成员
     *
     * @param key
     * @param min
     * @param max
     * @return
     */
    public Long zRemoveRangeByScore(String key, double min, double max) {
        return redisTemplate.opsForZSet().removeRangeByScore(key, min, max);
    }

    /**
     * 获取key和otherKey的并集并存储在destKey中
     *
     * @param key
     * @param otherKey
     * @param destKey
     * @return
     */
    public Long zUnionAndStore(String key, String otherKey, String destKey) {
        return redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);
    }

    /**
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys,
                               String destKey) {
        return redisTemplate.opsForZSet()
                .unionAndStore(key, otherKeys, destKey);
    }

    /**
     * 交集
     *
     * @param key
     * @param otherKey
     * @param destKey
     * @return
     */
    public Long zIntersectAndStore(String key, String otherKey,
                                   String destKey) {
        return redisTemplate.opsForZSet().intersectAndStore(key, otherKey,
                destKey);
    }

    /**
     * 交集
     *
     * @param key
     * @param otherKeys
     * @param destKey
     * @return
     */
    public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,
                                   String destKey) {
        return redisTemplate.opsForZSet().intersectAndStore(key, otherKeys,
                destKey);
    }

    /**
     *
     * @param key
     * @param options
     * @return
     */
    public Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) {
        return redisTemplate.opsForZSet().scan(key, options);
    }
}
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367
</code></pre>
<p>所有的Redis操作，其实对于java开发人员来说十分的简单，更重要的是理解思想和应用场景</p>
<h1 id="redisconf详解">Redis.conf详解</h1>
<p>启动的时候就是通过配置文件启动的</p>
<h2 id="对大小写不敏感">对大小写不敏感</h2>
<h2 id="包含">包含</h2>
<p>好比学习spring的时候，import，include<img src="https://img-blog.csdnimg.cn/img_convert/8f8c0d69b1adf80a6eb73e482e1a85d2.png" alt="img" loading="lazy"></p>
<h2 id="网络重要">网络：重要</h2>
<pre><code class="language-bash">bind 127.0.0.1   # 绑定的ip
protected-mode yes # 保护模式
port 6379		# 端口设置
123
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/img_convert/5634c8d64d5dada672d5a3b5c7727c8f.png" alt="image-20201104162912798" loading="lazy"></figure>
<h2 id="通用">通用</h2>
<pre><code class="language-bash">daemonize yes	# 以守护进程的方式运行，默认是no，需要自己开启为yes

pidfile /var/run/redis_6379.pid # 如果以后台方式运行，我们需要指定一个pid文件

# 日志
loglevel notice
logfile &quot;&quot;  # 日志的文件位置名
databases 16 #数据库的数量，默认为16个
always-show-logo yes # 是否显示logo
123456789
</code></pre>
<h2 id="快照">快照</h2>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p>
<p>redis是内存数据库，如果没有持久化，那么数据断电即失去</p>
<pre><code class="language-bash"># 如果900秒内至少有一个key进行了修改，我们就进行持久化操作
save 900 1
# 如果300秒内至少有10key进行了修改，我们就进行持久化操作
save 300 10
# 如果60秒内至少有10000key进行了修改，我们就进行持久化操作
save 60 10000
# 我们之后学习持久化，会自己定义这个配置

stop-writes-on-bgsave-error yes # 持久化出错后是否继续工作

rdbcompression yes # 是否压缩rdb文件，需要消耗一些cpu的资源

rdbchecksum yes	# 报错rdb文件时候进行错误的检查校验

dir ./ # rdb文件保存的目录，默认为当前目录
123456789101112131415
</code></pre>
<h2 id="replication-复制主从复制">REPLICATION 复制，主从复制</h2>
<h2 id="security">SECURITY</h2>
<p>可以在这里设置redis的密码，默认是没有密码的</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; config get requirepass	# 获取redis的密码
1) &quot;requirepass&quot;
2) &quot;&quot;
127.0.0.1:6379&gt; config set requirepass &quot;123456&quot;	# 设置redis密码
OK
auth 123456 # 输入密码后才可以登录
123456
</code></pre>
<h2 id="限制clients">限制CLIENTS</h2>
<pre><code class="language-bash">maxclients 10000	# 设置能连接上的最大客户端的数量

maxmemory &lt;bytes&gt;	# redis最大的内存容量

maxmemory-policy noeviction	# 内存达到上限的处理策略
	# 移除一些过期的key
	# 报错
	# 。。。
noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。（默认值）
allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
allkeys-random: 所有key通用; 随机删除一部分 key。
volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取maxmeory-samples个键，删除这三个键中最近最少使用的键。
12345678910111213141516
</code></pre>
<h2 id="append-only-模式-aof配置">APPEND ONLY 模式 aof配置</h2>
<pre><code class="language-bash">appendonly no	# 默认不开启aof模式，默认使用rdb方式持久化，几乎在所有情况下rdb够用

appendfilename &quot;appendonly.aof&quot; # 持久化文件的名字

# appendfsync always	# 每次修改都会同步，消耗性能
appendfsync everysec	# 每秒都同步一次 sync，可能会丢失这1s数据
# appendfsync no		# 不执行同步，这时候操作系统自己同步数据，速度最快
1234567
</code></pre>
<h1 id="redis持久化">Redis持久化</h1>
<h2 id="rdbredis-database">RDB（Redis Database）</h2>
<p>在主从复制中，rdb就是备用的！在从机上面</p>
<p>面试和工作，持久化必须是重点</p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能</p>
<p>在指定时间间隔内将内存中的数据集写入磁盘，也就是Snapshot快照，它恢复时是将文件直接读到内存里</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将书局写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效，RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<p>RDB保存的文件是dump.rdb都是在我们配置文件中的快照中进行配置的</p>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/img_convert/490e34c578bff1f061a953356ab55865.png" alt="image-20201104175635326" loading="lazy"></figure>
<p>自己测试一次，60s内修改5次，就会触发rdb操作</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/img_convert/1b9128e01b714fbfdf56c11a5bd29699.png" alt="image-20201104175830756" loading="lazy"></figure>
<p>flushall默认产生一个dump.rdb文件</p>
<h3 id="触发机制">触发机制</h3>
<ol>
<li>save规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令也会触发rdb规则</li>
<li>退出redis，也会产生rdb</li>
</ol>
<p>备份就自动生成dump.rdb<img src="https://img-blog.csdnimg.cn/img_convert/c6c0d341d5904b5708753742517786f9.png" alt="image-20201104181156646" loading="lazy"></p>
<h3 id="如何恢复rdb文件">如何恢复rdb文件</h3>
<ol>
<li>
<p>只需要将rdb文件放在redis的启动目录下就可以了，redis启动的时候会自动检查dump.rdb文件恢复</p>
</li>
<li>
<p>查看需要存在的位置</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; config get dir
1) &quot;dir&quot;
2) &quot;/usr/local/redis-6.0.6/bin&quot;	#如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据
123
</code></pre>
<p>几乎他自己的默认配置就够用了，但是我们还是学习</p>
<p>有时候在生产环境，我们会将这个文件进行备份</p>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>适合大规模的数据恢复！dump.rdb</li>
<li>如果对数据完整性不高！</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，那么最后一次修改的数据就没有了</li>
<li>fork进程的时候会占用一定的内存空间</li>
</ol>
<h2 id="aofappend-only-file">AOF（Append Only File）</h2>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/img_convert/3eb0e5a9501dfa3228e646cb18d34e44.png" alt="img" loading="lazy"></figure>
<p>将我们的所有命令都记录下来，history，恢复的时候把这个文件全部再执行一遍</p>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从签到后执行一次以完成数据的恢复工作</p>
<p>AOF保存的是appendonly.aof文件</p>
<p>默认是不开启的，我们需要手动进行配置，我们只需要将appendonly改为yes即可</p>
<p>重启redis就可以生效了</p>
<p>如果这个aof文件有错位，这时候redis是启动不起来的，我们需要修复这个aof文件</p>
<p>redis给我们提供了<code>redis-check-aof --fix appendonly.aof</code>来进行appendonly.aof的修复</p>
<p>如果文件正常，重启就可以直接恢复了<img src="https://img-blog.csdnimg.cn/img_convert/0d004c953c67eb5e72b536d4229866ff.png" alt="image-20201105102513952" loading="lazy"></p>
<h3 id="优点和缺点">优点和缺点</h3>
<p><strong>优点：</strong></p>
<ol>
<li>每一次修改都同步，文件完整性更加好</li>
<li>每同步一次，可能会丢失一秒的数据</li>
<li>从不同步</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢</li>
<li>AOF运行效率也要比rdb慢，redis默认的配置就是rdb持久化</li>
</ol>
<h3 id="重写规则说明">重写规则说明</h3>
<p>如果aof文件大于64MB，太大了，！fork一个新的进程来将我们文件进行重写</p>
<p>aof默认就是文件的无限追加，文件会越来越大</p>
<h2 id="扩展">扩展：</h2>
<h3 id="redis-持久化">Redis 持久化</h3>
<p>Redis 提供了不同级别的持久化方式:</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</li>
</ul>
<h4 id="rdb的优点"><strong>RDB的优点</strong></h4>
<ul>
<li>
<p>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.</p>
</li>
<li>
<p>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.</p>
</li>
<li>
<p>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.</p>
</li>
<li>
<p>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</p>
</li>
<li>
<h4 id="rdb的缺点"><strong>RDB的缺点</strong></h4>
</li>
<li>
<p>如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.</p>
</li>
<li>
<p>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</p>
</li>
<li>
<h4 id="aof-优点"><strong>AOF 优点</strong></h4>
</li>
<li>
<p>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.</p>
</li>
<li>
<p>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.</p>
</li>
<li>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
</li>
<li>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
</li>
<li>
<h4 id="aof-缺点"><strong>AOF 缺点</strong></h4>
</li>
<li>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
</li>
<li>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
</li>
</ul>
<h1 id="redis发布订阅">Redis发布订阅</h1>
<p>消息队列</p>
<p>通信，队列 发送者 订阅者</p>
<p>Redis 发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。微信，微博</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<p>订阅/发布消息图：</p>
<p>第一个：消息发送者，第二个：频道 第三个：消息订阅者！</p>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/img_convert/dd6b8ef093cf55e0aa316e0a4f94a200.png" alt="image-20201105104248223" loading="lazy"></figure>
<h2 id="命令">命令：</h2>
<p><code>psubcribe pattern [pattern]</code> 订阅一个或多个符合给定模式的频道</p>
<p><code>pubsub subcommand [argument [argument]]</code> 查看订阅与发布系统状态</p>
<p><code>publish channel message</code> 将信息发送到指定的频道</p>
<p><code>punsubscribe [pattern [pattern]]</code> 退订所有给定模式的频道</p>
<p><code>subscribe channel [channel</code> 订阅一个或多个频道的信息</p>
<p><code>unsubscribe [channel [channel]]</code> 退订给定的频道</p>
<h2 id="测试">测试</h2>
<h3 id="订阅端">订阅端</h3>
<pre><code class="language-bash">127.0.0.1:6379&gt; SUBSCRIBE yangjianChannel 	# 订阅一个频道
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;yangjianChannel&quot;
3) (integer) 1
# 等待读取推送的信息
1) &quot;message&quot;	#消息
2) &quot;yangjianChannel&quot;	# 哪个频道的消息
3) &quot;hello,yangjianChannel&quot;	# 具体内容
1) &quot;message&quot;
2) &quot;yangjianChannel&quot;
3) &quot;hello,Redis&quot;
123456789101112
</code></pre>
<h3 id="发送端">发送端</h3>
<pre><code class="language-bash">127.0.0.1:6379&gt; PUBLISH yangjianChannel &quot;hello,yangjianChannel&quot;	# 发布者发布消息到指定的频道
(integer) 1
127.0.0.1:6379&gt; PUBLISH yangjianChannel &quot;hello,Redis&quot;
(integer) 1
1234
</code></pre>
<h2 id="原理">原理</h2>
<p>Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis 的理解。Redis通过PUBLISH 、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。<br>
微信:<br>
通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。</p>
<p>通过PUBLSH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub/Sub从字面上理解就是发布(Publish)与订阅( Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<h2 id="使用场景">使用场景：</h2>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当做聊天室）</li>
<li>订阅关注系统</li>
</ol>
<p>稍微复杂的场景，消息中间件MQ（）</p>
<h1 id="redis主从复制">Redis主从复制</h1>
<h2 id="概念">概念</h2>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(masterleader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p><strong>主从复制的作用主要包括:</strong><br>
1、数据冗余∶主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>
2、故障恢复∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。<br>
3、负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载﹔尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>
4、高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的(宕机，最少3个），原因如下:<br>
1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;<br>
2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>
电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是&quot;多读少写&quot;。对于这种场景，我们可以使如下这种架构︰</p>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/img_convert/d8f97ed2519b086a298024d5c7675343.png" alt="image-20201105111148557" loading="lazy"></figure>
<p>主从复制，读写分离！80%情况下都是在进行读操作！减缓服务器压力，架构经常使用！一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中，不可能单机使用redis！</p>
<h2 id="环境配置">环境配置</h2>
<p>只配置从库，不用配置主库</p>
<h3 id="主从复制信息">主从复制信息</h3>
<pre><code class="language-bash">info replication # 查看当前库的信息

127.0.0.1:6379&gt; info replication
# Replication
role:master		#	角色：master
connected_slaves:0	# 没有从机
master_replid:85e0dc3072e2b2d876b7ff4a0cb53f961d7fd5e6
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
1234567891011121314
</code></pre>
<p>复制三个配置文件，修改对应的信息</p>
<ol>
<li>端口号</li>
<li>pid</li>
<li>日志名字</li>
<li>备份文件名字 dump.rdb</li>
</ol>
<p>修改完毕之后启动三个redis服务<img src="https://img-blog.csdnimg.cn/img_convert/f39ce1210976bd51f427e88aee4ec562.png" alt="img" loading="lazy"></p>
<h2 id="一主二从">一主二从</h2>
<p>默认情况下，每台Redis服务器都是主节点，我们一般情况下只用配置从机就好了</p>
<p>认老大，一主（79）二从（80,81）</p>
<pre><code class="language-bash">slaveof host port # 设置这个主机的主人

127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379	# 认定这个主机下的6379端口为主
OK
127.0.0.1:6380&gt; info replication
# Replication
role:slave
master_host:127.0.0.1	# 可以看到主机的信息
master_port:6379
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:14
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14


# 在主机中查看
[root@iZbp17e1mp4a0cgbw1358xZ bin]# redis-cli -p 6379
127.0.0.1:6379&gt; info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=1
master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:126
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:126
1234567891011121314151617181920212223242526272829303132333435363738394041
</code></pre>
<p>如果两个都配置完了，就会有两个从机的</p>
<p>真实的主从配置应该在配置文件中配置，这样的话是永久的，使用命令是暂时的</p>
<h2 id="细节">细节</h2>
<p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存</p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，如果主机回来，从机依旧可以直接获取到主机写的信息</p>
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机!只要变为从机，立马就会从主机中获取值</p>
<h2 id="复制原理">复制原理</h2>
<p>Slave启动成功连接到master后会发送一个sync命令<br>
Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p>全量复制︰而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制:Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p>
<p>但是只要是重新连接master，一次完全同步(全量复制）将被自动执行。我们的数据一定可以在从机中看到</p>
<h2 id="层层链路">层层链路</h2>
<p>上一个M连接下一个S，这时候也可以完成我们的主从复制</p>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/img_convert/1d90bc1c207338cae0e414051f4bfe8e.png" alt="image-20201105122218386" loading="lazy"></figure>
<h2 id="如果没有老大能不能选择一个老大出来呢手动">如果没有老大，能不能选择一个老大出来呢，手动</h2>
<p>谋朝篡位</p>
<p><code>salveof no one</code>,如果主机断开了连接，可以使用这个命令来让自己成为主节点，其他的结点就可以手动连接到最新的这个主节点</p>
<p>如果这个时候老大修复了，那就只能重新连接</p>
<h1 id="redis哨兵模式自动选取老大的模式">Redis哨兵模式（自动选取老大的模式）</h1>
<h2 id="概述">概述：</h2>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务器不可用。这不是一种推荐方式，更多时候，我们优先考虑哨兵模式，Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong><img src="https://img-blog.csdnimg.cn/img_convert/c1ba98cbc27441ca87553f823873fac2.png" alt="image-20201105125043998" loading="lazy"></p>
<p><strong>哨兵有两个作用</strong></p>
<ol>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机</li>
</ol>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<img src="https://img-blog.csdnimg.cn/img_convert/3cad6f6728ec2c403ae6d074bbc51823.png" alt="image-20201105125638471" loading="lazy"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。</p>
<h2 id="测试-2">测试</h2>
<p>我们目前的状态是一主二从</p>
<ol>
<li>配置哨兵配置文件<code>sentinel.conf</code></li>
</ol>
<pre><code class="language-bash"># sentinel monitor 被监控的名称 host port 1
sentinel monitor myredis 127.0.0.1 6379 1
# 1是有多少哨兵认为挂了，master才是真的挂了
123
</code></pre>
<p>后面的这个数字1代表主机挂了，slave投票看让谁来接替成为主机，票数最多的就会成为主机</p>
<ol>
<li>启动哨兵</li>
</ol>
<pre><code class="language-bash">redis-sentinel ../etc/sentinal.conf

[root@iZbp17e1mp4a0cgbw1358xZ bin]# redis-sentinel ../etc/sentinal.conf 
20615:X 05 Nov 2020 13:05:15.181 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
20615:X 05 Nov 2020 13:05:15.181 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=20615, just started
20615:X 05 Nov 2020 13:05:15.181 # Configuration loaded
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 6.0.6 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 20615
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

20615:X 05 Nov 2020 13:05:15.182 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
20615:X 05 Nov 2020 13:05:15.185 # Sentinel ID is ee900e749cf585634b3bc2860471d28dcd1ec109
20615:X 05 Nov 2020 13:05:15.185 # +monitor master myredis 127.0.0.1 6379 quorum 1
20615:X 05 Nov 2020 13:05:15.186 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
20615:X 05 Nov 2020 13:05:15.188 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379

123456789101112131415161718192021222324252627282930
</code></pre>
<p>如果master结点断开了，这个时候就会从从机中随机选择一个服务器,这里面有一个投票算法</p>
<p><strong>哨兵日志</strong></p>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/img_convert/09a06ab2d386b69dc6e093379c3dfbbe.png" alt="image-20201105130939012" loading="lazy"></figure>
<h2 id="哨兵模式">哨兵模式</h2>
<p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵模式，基于主从复制模式，所有主从配置的优点它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置是非常麻烦的，里面有很多选择</li>
</ol>
<h2 id="哨兵模式全部配置">哨兵模式全部配置</h2>
<pre><code class="language-bash"># Example sentinel.conf
 
# 哨兵sentinel实例运行的端口 默认26379
port 26379
 
# 哨兵sentinel的工作目录
dir /tmp
 
# 哨兵sentinel监控的redis主节点的 ip port 
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。
# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了
# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;
sentinel monitor mymaster 127.0.0.1 6379 1
 
# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 
 
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒
# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;
sentinel down-after-milliseconds mymaster 30000
 
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;
sentinel parallel-syncs mymaster 1
 
 
 
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： 
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了
# 默认三分钟
# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;
sentinel failover-timeout mymaster 180000
 
# SCRIPTS EXECUTION
 
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。
 
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，
#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，
#一个是事件的类型，
#一个是事件的描述。
#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;
  sentinel notification-script mymaster /var/redis/notify.sh
 
# 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本:
# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;
# 目前&lt;state&gt;总是“failover”,
# &lt;role&gt;是“leader”或者“observer”中的一个。 
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh


123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172
</code></pre>
<h1 id="redis缓存穿透与雪崩面试高频工作常用">Redis缓存穿透与雪崩（面试高频，工作常用）</h1>
<p>服务的高可用问题</p>
<p>不会详细分析解决方案的底层（专题）</p>
<figure data-type="image" tabindex="27"><img src="https://img-blog.csdnimg.cn/img_convert/0a4034ed3249cfd5dcf1b4801c603ac3.png" alt="image-20201105132544362" loading="lazy"></figure>
<h2 id="缓存穿透查不到">缓存穿透（查不到）</h2>
<h3 id="概念-2">概念</h3>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h3 id="解决方案">解决方案</h3>
<h4 id="布隆过滤器">布隆过滤器</h4>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力﹔</p>
<figure data-type="image" tabindex="28"><img src="https://img-blog.csdnimg.cn/img_convert/711f719d7387385ef19084f732aa266e.png" alt="image-20201105132801112" loading="lazy"></figure>
<h4 id="缓存空对象">缓存空对象</h4>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源;</p>
<figure data-type="image" tabindex="29"><img src="https://img-blog.csdnimg.cn/img_convert/14c9e14245bae4a3e49226c416376c8c.png" alt="image-20201105132900180" loading="lazy"></figure>
<p>但是这种方法会存在两个问题:<br>
1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键;<br>
2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h2 id="缓存击穿查的太多量大缓存过期">缓存击穿（查的太多，量大，缓存过期）</h2>
<p>微博服务器宕机（60 60.1 0.1）</p>
<h3 id="概述-2">概述：</h3>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>
当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<h3 id="解决方案-2">解决方案</h3>
<h4 id="设置热点数据永不过期">设置热点数据永不过期</h4>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题</p>
<h4 id="加互斥锁">加互斥锁</h4>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁考验很大</p>
<h2 id="缓存雪崩">缓存雪崩</h2>
<h3 id="概念-3">概念</h3>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机<br>
产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<h3 id="解决方案-3">解决方案</h3>
<h4 id="redis高可用">Redis高可用</h4>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。(异地多活）</p>
<h4 id="限流降级在springcloud中有">限流降级（在SpringCloud中有）</h4>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<h4 id="数据预热">数据预热</h4>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/77、 组合/" class="post-title gt-a-link">
                    中等77. 组合
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

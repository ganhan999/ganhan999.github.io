<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java JUC并发编程 | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1615810100798">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1615810100798" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java JUC并发编程
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-12-11 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="1-什么是juc">1. 什么是JUC</h2>
<p>JUC就是java.util.concurrent下面的类包，专门用于多线程的开发。</p>
<h2 id="2-线程和进程">2. 线程和进程</h2>
<blockquote>
<p>进程是操作系统中的应用程序、是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位</p>
<p>一个进程往往可以包含多个线程，至少包含一个</p>
</blockquote>
<h3 id="1进程">1）进程</h3>
<p><strong>一个程序，QQ.EXE Music.EXE；数据+代码+pcb</strong></p>
<p>一个进程可以包含多个线程，至少包含一个线程！</p>
<p>Java默认有几个线程？<strong>2个线程！</strong> main线程、GC线程</p>
<h3 id="2线程">2）线程</h3>
<p><strong>开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的)</strong></p>
<p>对于Java而言：Thread、Runable、Callable进行开启线程的。</p>
<p><strong>提问？JAVA真的可以开启线程吗？ 开不了的！</strong></p>
<p>Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。</p>
<pre><code class="language-java">    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	//这是一个C++底层，Java是没有权限操作底层硬件的
    private native void start0();

</code></pre>
<h3 id="3并发">3）并发</h3>
<p>多线程操作同一个资源。</p>
<ul>
<li>CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。</li>
<li>并发编程的本质：<strong>充分利用CPU的资源！</strong></li>
</ul>
<h3 id="4并行">4）并行</h3>
<p><strong>并行：</strong> 多个人一起行走</p>
<ul>
<li>CPU多核，多个线程可以同时执行。 我们可以使用线程池！</li>
</ul>
<p><strong>获取cpu的核数</strong></p>
<pre><code class="language-java">public class Test1 {
    public static void main(String[] args) {
        //获取cpu的核数
        System.out.println(Runtime.getRuntime().availableProcessors());
    }
}
</code></pre>
<h3 id="5线程的状态">5）线程的状态</h3>
<pre><code class="language-java">public enum State {

    	//运行
        NEW,

    	//运行
        RUNNABLE,

    	//阻塞
        BLOCKED,

    	//等待
        WAITING,

    	//超时等待
        TIMED_WAITING,

    	//终止
        TERMINATED;
    }

</code></pre>
<h3 id="6waitsleep">6）wait/sleep</h3>
<p><strong>1、来自不同的类</strong></p>
<p>wait =&gt; Object</p>
<p>sleep =&gt; Thread</p>
<p>一般情况企业中使用休眠是：</p>
<pre><code class="language-java">TimeUnit.DAYS.sleep(1); //休眠1天
TimeUnit.SECONDS.sleep(1); //休眠1s
</code></pre>
<p><strong>2、关于锁的释放</strong></p>
<p>wait 会释放锁；</p>
<p>sleep睡觉了，不会释放锁；</p>
<p><strong>3、使用的范围是不同的</strong></p>
<p>wait 必须在同步代码块中；</p>
<p>sleep 可以在任何地方睡；</p>
<p><strong>4、是否需要捕获异常</strong></p>
<p>wait是不需要捕获异常；</p>
<p>sleep必须要捕获异常；</p>
<h2 id="3lock">3.Lock</h2>
<h3 id="1传统的-synchronized">1）传统的 synchronized</h3>
<pre><code class="language-java">package com.marchsoft.juctest;

import lombok.Synchronized;

/**
 * Description：synchronized
 *
 * @author jiaoqianjin
 * Date: 2020/8/10 21:36
 **/

public class Demo01 {
    public static void main(String[] args) {
        final Ticket ticket = new Ticket();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        },&quot;A&quot;).start();
        new Thread(()-&gt;{
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        },&quot;B&quot;).start();
        new Thread(()-&gt;{
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        },&quot;C&quot;).start();
    }
}
// 资源类 OOP 属性、方法
class Ticket {
    private int number = 30;

    //卖票的方式
    public synchronized void sale() {
        if (number &gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张票剩余&quot; + number + &quot;张票&quot;);
        }
    }
}
</code></pre>
<h3 id="2lock">2）Lock</h3>
<p><img src="https://ganhan999.github.io//post-images/1607650819475.png" alt="" loading="lazy"><br>
<strong>公平锁：</strong> 十分公平，必须先来后到~；</p>
<p><strong>非公平锁：</strong> 十分不公平，可以插队；<strong>(默认为非公平锁)</strong></p>
<pre><code class="language-java">package com.marchsoft.juctest;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/10 22:05
 **/

public class LockDemo {
    public static void main(String[] args) {
        final Ticket2 ticket = new Ticket2();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, &quot;C&quot;).start();
    }
}
//lock三部曲
//1、    Lock lock=new ReentrantLock();
//2、    lock.lock() 加锁
//3、    finally=&gt; 解锁：lock.unlock();
class Ticket2 {
    private int number = 30;
	
    // 创建锁
    Lock lock = new ReentrantLock();
    //卖票的方式
    public synchronized void sale() {
        lock.lock(); // 开启锁
        try {
            if (number &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张票剩余&quot; + number + &quot;张票&quot;);
            }
        }finally {
            lock.unlock(); // 关闭锁
        }

    }
}
</code></pre>
<h3 id="3-synchronized-与lock-的区别">3. Synchronized 与Lock 的区别</h3>
<p>1、Synchronized 内置的Java关键字，Lock是一个Java类</p>
<p>2、Synchronized 无法判断获取锁的状态，Lock可以判断</p>
<p>3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！<strong>可能会遇到死锁</strong></p>
<p>4、Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，<strong>lock会有一个trylock去尝试获取锁</strong>，不会造成长久的等待。</p>
<p>5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁；</p>
<p>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；</p>
<h2 id="4-生产者和消费者的关系">4. 生产者和消费者的关系</h2>
<h3 id="1synchronzied-版本">1）Synchronzied 版本</h3>
<pre><code class="language-java">package com.marchsoft.juctest;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/10 22:33
 **/

public class ConsumeAndProduct {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();
    }
}

class Data {
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        // 判断等待
        if (num != 0) {
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        // 通知其他线程 +1 执行完毕
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        // 判断等待
        if (num == 0) {
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        // 通知其他线程 -1 执行完毕
        this.notifyAll();
    }
}
</code></pre>
<h3 id="2存在问题虚假唤醒">2）存在问题（虚假唤醒）</h3>
<p><strong>问题，如果有四个线程</strong>，会出现虚假唤醒<br>
<img src="https://ganhan999.github.io//post-images/1607651545171.png" alt="" loading="lazy"><br>
<img src="https://ganhan999.github.io//post-images/1607650837273.png" alt="" loading="lazy"></p>
<p>解决方式 ，<strong>if 改为while即可，防止虚假唤醒</strong></p>
<blockquote>
<p>结论：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。</p>
<p>这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后</p>
</blockquote>
<pre><code class="language-java">package com.marchsoft.juctest;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/10 22:33
 **/

public class ConsumeAndProduct {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();
    }
}

class Data {
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        // 判断等待
        while (num != 0) {
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        // 通知其他线程 +1 执行完毕
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        // 判断等待
        while (num == 0) {
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        // 通知其他线程 -1 执行完毕
        this.notifyAll();
    }
}
</code></pre>
<h3 id="3lock版">3）Lock版</h3>
<figure data-type="image" tabindex="1"><img src="https://ganhan999.github.io//post-images/1607651558541.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package com.marchsoft.juctest;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/11 9:48
 **/

public class LockCAP {
    public static void main(String[] args) {
        Data2 data = new Data2();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {

                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();
    }
}

class Data2 {
    private int num = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    // +1
    public  void increment() throws InterruptedException {
        lock.lock();
        try {
            // 判断等待
            while (num != 0) {
                condition.await();
            }
            num++;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            // 通知其他线程 +1 执行完毕
            condition.signalAll();
        }finally {
            lock.unlock();
        }

    }

    // -1
    public  void decrement() throws InterruptedException {
        lock.lock();
        try {
            // 判断等待
            while (num == 0) {
                condition.await();
            }
            num--;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            // 通知其他线程 +1 执行完毕
            condition.signalAll();
        }finally {
            lock.unlock();
        }

    }
}
</code></pre>
<h3 id="4condition的优势">4）Condition的优势</h3>
<p>精准的通知和唤醒的线程！</p>
<p><strong>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</strong></p>
<pre><code class="language-java">package com.marchsoft.juctest;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Description：
 * A 执行完 调用B
 * B 执行完 调用C
 * C 执行完 调用A
 *
 * @author jiaoqianjin
 * Date: 2020/8/11 9:58
 **/

public class ConditionDemo {
    public static void main(String[] args) {
        Data3 data3 = new Data3();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data3.printA();
            }
        },&quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data3.printB();
            }
        },&quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data3.printC();
            }
        },&quot;C&quot;).start();
    }

}
class Data3 {
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int num = 1; // 1A 2B 3C

    public void printA() {
        lock.lock();
        try {
            // 业务代码 判断 -&gt; 执行 -&gt; 通知
            while (num != 1) {
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;==&gt; AAAA&quot; );
            num = 2;
            condition2.signal();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printB() {
        lock.lock();
        try {
            // 业务代码 判断 -&gt; 执行 -&gt; 通知
            while (num != 2) {
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;==&gt; BBBB&quot; );
            num = 3;
            condition3.signal();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printC() {
        lock.lock();
        try {
            // 业务代码 判断 -&gt; 执行 -&gt; 通知
            while (num != 3) {
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;==&gt; CCCC&quot; );
            num = 1;
            condition1.signal();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
/*
A==&gt; AAAA
B==&gt; BBBB
C==&gt; CCCC
A==&gt; AAAA
B==&gt; BBBB
C==&gt; CCCC
...
*/
</code></pre>
<h2 id="5-8锁现象">5. 8锁现象</h2>
<p>如何判断锁的是谁！锁到底锁的是谁？</p>
<p>锁会锁住：对象、Class</p>
<p>深刻理解我们的锁</p>
<p><strong>问题1</strong></p>
<p>两个同步方法，先执行发短信还是打电话</p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -&gt; { phone.sendMs(); }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone.call(); }).start();
    }
}

class Phone {
    public synchronized void sendMs() {
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<p>输出结果为</p>
<p>发短信</p>
<p>打电话</p>
<p><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
<p><strong>问题2：</strong></p>
<p><strong>我们再来看：我们让发短信 延迟4s</strong></p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();

        new Thread(() -&gt; {
            try {
                phone.sendMs();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone.call(); }).start();
    }
}

class Phone {
    public synchronized void sendMs() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<p>现在结果是什么呢？</p>
<p>结果：<strong>还是先发短信，然后再打电话！</strong></p>
<p><strong>why？</strong></p>
<blockquote>
<p>原因：并不是顺序执行，而是synchronized 锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待</p>
</blockquote>
<p><strong>问题三</strong></p>
<p>加一个普通方法</p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();

        new Thread(() -&gt; {
            try {
                phone.sendMs();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone.hello(); }).start();
    }
}

class Phone {
    public synchronized void sendMs() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<p>输出结果为</p>
<p>hello</p>
<p>发短信</p>
<blockquote>
<p>原因：hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放</p>
</blockquote>
<p><strong>问题四</strong></p>
<p><strong>如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？</strong></p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();

        new Thread(() -&gt; {
            try {
                phone1.sendMs();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone2.call(); }).start();
    }
}

class Phone {
    public synchronized void sendMs() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>原因：两个对象两把锁，不会出现等待的情况，发短信睡了4s,所以先执行打电话</p>
</blockquote>
<p><strong>问题五、六</strong></p>
<p><strong>如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？</strong></p>
<p>（1）我们先来使用一个对象调用两个方法！</p>
<p>答案是：<strong>先发短信,后打电话</strong></p>
<p>（2）如果我们使用两个对象调用两个方法！</p>
<p>答案是：<strong>还是先发短信，后打电话</strong></p>
<p>原因是什么呢？ <strong>为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？</strong></p>
<p>原因是：<strong>对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！</strong></p>
<hr>
<p><strong>问题七</strong></p>
<p><strong>如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？</strong></p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
//        Phone phone2 = new Phone();

        new Thread(() -&gt; {
            try {
                phone1.sendMs();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone1.call(); }).start();
    }
}

class Phone {
    public static synchronized void sendMs() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>原因：因为一个锁的是Class类的模板，一个锁的是对象的调用者。所以不存在等待，直接运行。</p>
</blockquote>
<p><strong>问题八</strong></p>
<p><strong>如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么？</strong></p>
<pre><code class="language-java">public class dome01 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();

        new Thread(() -&gt; {
            try {
                phone1.sendMs();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; { phone2.call(); }).start();
    }
}

class Phone {
    public static synchronized void sendMs() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println(&quot;发短信&quot;);
    }
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>原因：两把锁锁的不是同一个东西</p>
</blockquote>
<p><strong>小解</strong></p>
<p><strong>new</strong> 出来的 this 是具体的一个对象</p>
<p><strong>static Class</strong> 是唯一的一个模板</p>
<h2 id="6-集合不安全">6. 集合不安全</h2>
<h3 id="1list-不安全">1）List 不安全</h3>
<pre><code class="language-java">//java.util.ConcurrentModificationException 并发修改异常！
public class ListTest {
    public static void main(String[] args) {

        List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();

        for(int i=1;i&lt;=10;i++){
            new Thread(()-&gt;{
                arrayList.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(arrayList);
            },String.valueOf(i)).start();
        }

    }
}
</code></pre>
<p>会导致 java.util.ConcurrentModificationException 并发修改异常！</p>
<p><strong>ArrayList 在并发情况下是不安全的</strong></p>
<p>解决方案：</p>
<pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        /**
         * 解决方案
         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();
         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
         */
        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
        

        for (int i = 1; i &lt;=10; i++) {
            new Thread(() -&gt; {
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
</code></pre>
<p><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong></p>
<p>核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
<p>多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；</p>
<blockquote>
<p><strong>CopyOnWriteArrayList</strong>比<strong>Vector</strong>厉害在哪里？</p>
</blockquote>
<p><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。</p>
<figure data-type="image" tabindex="2"><img src="https://ganhan999.github.io//post-images/1607651614788.png" alt="" loading="lazy"></figure>
<p><strong>CopyOnWriteArrayList</strong>使用的是Lock锁，效率会更加高效！</p>
<figure data-type="image" tabindex="3"><img src="https://ganhan999.github.io//post-images/1607651623059.png" alt="" loading="lazy"></figure>
<h3 id="2set-不安全">2）set 不安全</h3>
<p><strong>Set和List同理可得:</strong> 多线程情况下，普通的Set集合是线程不安全的；</p>
<p>解决方案还是两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong>包装的Set类</li>
<li>使用CopyOnWriteArraySet 写入复制的<strong>JUC</strong>解决方案</li>
</ul>
<pre><code class="language-java">public class SetTest {
    public static void main(String[] args) {
        /**
         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();
         */
//        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();

        for (int i = 1; i &lt;= 30; i++) {
            new Thread(() -&gt; {
                set.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(set);
            },String.valueOf(i)).start();
        }
    }
}
</code></pre>
<p><strong>HashSet底层是什么？</strong></p>
<p>hashSet底层就是一个<strong>HashMap</strong>；</p>
<figure data-type="image" tabindex="4"><img src="https://ganhan999.github.io//post-images/1607651662007.png" alt="" loading="lazy"></figure>
<h3 id="3map不安全">3）Map不安全</h3>
<p>默认<strong>加载因子是0.75</strong>,默认的<strong>初始容量是16</strong></p>
<figure data-type="image" tabindex="5"><img src="https://ganhan999.github.io//post-images/1607651666937.png" alt="" loading="lazy"></figure>
<p>同样的HashMap基础类也存在<strong>并发修改异常</strong>！</p>
<pre><code class="language-java">public class MapTest {
    public static void main(String[] args) {
        //map 是这样用的吗？  不是，工作中不使用这个
        //默认等价什么？ new HashMap&lt;&gt;(16,0.75);
        /**
         * 解决方案
         * 1. Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
         *  Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
         */
        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
        //加载因子、初始化容量
        for (int i = 1; i &lt; 100; i++) {
            new Thread(()-&gt;{
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
</code></pre>
<p><strong>TODO:研究ConcurrentHashMap底层原理：</strong></p>
<h2 id="7-callable">7. Callable</h2>
<p><strong>1、可以有返回值；<br>
2、可以抛出异常；<br>
3、方法不同，run()/call()</strong></p>
<pre><code class="language-java">public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        for (int i = 1; i &lt; 10; i++) {
            MyThread1 myThread1 = new MyThread1();

            FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread1);
            // 放入Thread中使用，结果会被缓存
            new Thread(futureTask,String.valueOf(i)).start();
            // 这个get方法可能会被阻塞，如果在call方法中是一个耗时的方法，所以一般情况我们会把这个放在最后，或者使用异步通信
            int a = futureTask.get();
            System.out.println(&quot;返回值:&quot; + s);
        }

    }

}
class MyThread1 implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;call()&quot;);
        return 1024;
    }
}
</code></pre>
<h2 id="8-常用的辅助类">8. 常用的辅助类</h2>
<h3 id="1countdownlatch">1）CountDownLatch</h3>
<pre><code class="language-java">public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 总数是6
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot;==&gt; Go Out&quot;);
                countDownLatch.countDown(); // 每个线程都数量 -1
            },String.valueOf(i)).start();
        }
        countDownLatch.await(); // 等待计数器归零 然后向下执行
        System.out.println(&quot;close door&quot;);
    }
}
</code></pre>
<p>主要方法：</p>
<ul>
<li>countDown 减一操作；</li>
<li>await 等待计数器归零</li>
</ul>
<p>await 等待计数器归零，就唤醒，再继续向下运行</p>
<h3 id="2cyclickbarrier">2）CyclickBarrier</h3>
<figure data-type="image" tabindex="6"><img src="https://ganhan999.github.io//post-images/1607651753153.png" alt="" loading="lazy"></figure>
<p>其实</p>
<pre><code class="language-java">public class CyclicBarrierDemo {
    public static void main(String[] args) {
        // 主线程
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -&gt; {
            System.out.println(&quot;召唤神龙&quot;);
        });

        for (int i = 1; i &lt;= 7; i++) {
            // 子线程
            int finalI = i;
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot;收集了第&quot; + finalI + &quot;颗龙珠&quot;);
                try {
                    cyclicBarrier.await(); // 加法计数 等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
</code></pre>
<h3 id="3semaphore">3）Semaphore</h3>
<pre><code class="language-java">public class SemaphoreDemo {
    public static void main(String[] args) {

        // 线程数量，停车位，限流
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                // acquire() 得到
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);
                }catch (Exception e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release(); // release() 释放
                }
            }).start();
        }
    }
}
Thread-1抢到车位
Thread-0抢到车位
Thread-2抢到车位
Thread-0离开车位
Thread-2离开车位
Thread-1离开车位
Thread-5抢到车位
Thread-3抢到车位
Thread-4抢到车位
Thread-5离开车位
Thread-3离开车位
Thread-6抢到车位
Thread-4离开车位
Thread-6离开车位

Process finished with exit code 0
</code></pre>
<p>原理：</p>
<p><strong>semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！</strong></p>
<p><strong>semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！</strong></p>
<p>作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！</p>
<h2 id="9-读写锁">9. 读写锁</h2>
<pre><code class="language-java">public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        int num = 6;
        for (int i = 1; i &lt;= num; i++) {
            int finalI = i;
            new Thread(() -&gt; {

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            },String.valueOf(i)).start();
        }

        for (int i = 1; i &lt;= num; i++) {
            int finalI = i;
            new Thread(() -&gt; {

                myCache.read(String.valueOf(finalI));

            },String.valueOf(i)).start();
        }
    }
}

/**
 *  方法未加锁，导致写的时候被插队
 */
class MyCache {
    private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

    public void write(String key, String value) {
        System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;);
    }

    public void read(String key) {
        System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;);
        map.get(key);
        System.out.println(Thread.currentThread().getName() + &quot;线程写读取ok&quot;);
    }
}

2线程开始写入
2线程写入ok
3线程开始写入
3线程写入ok
1线程开始写入    # 插入了其他线程的写入，导致数据不一致
4线程开始写入
4线程写入ok
1线程写入ok
6线程开始写入
6线程写入ok
5线程开始写入
5线程写入ok
1线程开始读取
1线程写读取ok
2线程开始读取
2线程写读取ok
3线程开始读取
3线程写读取ok
4线程开始读取
4线程写读取ok
5线程开始读取
6线程开始读取
6线程写读取ok
5线程写读取ok

Process finished with exit code 0
</code></pre>
<p>所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。</p>
<p>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。</p>
<p>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证<br>
<img src="https://ganhan999.github.io//post-images/1607651717429.png" alt="" loading="lazy"></p>
<pre><code class="language-java">public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache2 myCache = new MyCache2();
        int num = 6;
        for (int i = 1; i &lt;= num; i++) {
            int finalI = i;
            new Thread(() -&gt; {

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            },String.valueOf(i)).start();
        }

        for (int i = 1; i &lt;= num; i++) {
            int finalI = i;
            new Thread(() -&gt; {

                myCache.read(String.valueOf(finalI));

            },String.valueOf(i)).start();
        }
    }

}
class MyCache2 {
    private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    public void write(String key, String value) {
        lock.writeLock().lock(); // 写锁
        try {
            System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;);

        }finally {
            lock.writeLock().unlock(); // 释放写锁
        }
    }

    public void read(String key) {
        lock.readLock().lock(); // 读锁
        try {
            System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;);
            map.get(key);
            System.out.println(Thread.currentThread().getName() + &quot;线程写读取ok&quot;);
        }finally {
            lock.readLock().unlock(); // 释放读锁
        }
    }
}

1线程开始写入
1线程写入ok
6线程开始写入
6线程写入ok
3线程开始写入
3线程写入ok
2线程开始写入
2线程写入ok
5线程开始写入
5线程写入ok
4线程开始写入
4线程写入ok
    
1线程开始读取
5线程开始读取
2线程开始读取
1线程写读取ok
3线程开始读取
2线程写读取ok
6线程开始读取
6线程写读取ok
5线程写读取ok
4线程开始读取
4线程写读取ok
3线程写读取ok

Process finished with exit code 0
</code></pre>
<h2 id="10-阻塞队列">10. 阻塞队列</h2>
<p><img src="https://ganhan999.github.io//post-images/1607652061395.png" alt="" loading="lazy"><br>
<img src="https://ganhan999.github.io//post-images/1607652078817.png" alt="" loading="lazy"></p>
<h3 id="1blockqueue">1）BlockQueue</h3>
<p>是Collection的一个子类</p>
<p>什么情况下我们会使用阻塞队列</p>
<blockquote>
<p>多线程并发处理、线程池</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://ganhan999.github.io//post-images/1607651994683.png" alt="" loading="lazy"></figure>
<p>BlockingQueue 有四组api</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不会抛出异常，有返回值</th>
<th>阻塞，等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer(timenum.timeUnit)</td>
</tr>
<tr>
<td>移出</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll(timenum,timeUnit)</td>
</tr>
<tr>
<td>判断队首元素</td>
<td>element</td>
<td>peek</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">/**
     * 抛出异常
     */
    public static void test1(){
        //需要初始化队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(blockingQueue.add(&quot;a&quot;));
        System.out.println(blockingQueue.add(&quot;b&quot;));
        System.out.println(blockingQueue.add(&quot;c&quot;));
        //抛出异常：java.lang.IllegalStateException: Queue full
//        System.out.println(blockingQueue.add(&quot;d&quot;));
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        //如果多移除一个
        //这也会造成 java.util.NoSuchElementException 抛出异常
        System.out.println(blockingQueue.remove());
    }
=======================================================================================
/**
     * 不抛出异常，有返回值
     */
    public static void test2(){
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);
        System.out.println(blockingQueue.offer(&quot;a&quot;));
        System.out.println(blockingQueue.offer(&quot;b&quot;));
        System.out.println(blockingQueue.offer(&quot;c&quot;));
        //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常
        System.out.println(blockingQueue.offer(&quot;d&quot;));

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        //弹出 如果没有元素 只会返回null 不会抛出异常
        System.out.println(blockingQueue.poll());
    }
=======================================================================================
/**
     * 等待 一直阻塞
     */
    public static void test3() throws InterruptedException {
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        //一直阻塞 不会返回
        blockingQueue.put(&quot;a&quot;);
        blockingQueue.put(&quot;b&quot;);
        blockingQueue.put(&quot;c&quot;);

        //如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止
//        blockingQueue.put(&quot;d&quot;);

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        //如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞
        System.out.println(blockingQueue.take());
    }
=======================================================================================
/**
     * 等待 超时阻塞
     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束
     */
    public static void test4() throws InterruptedException {
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);
        blockingQueue.offer(&quot;a&quot;);
        blockingQueue.offer(&quot;b&quot;);
        blockingQueue.offer(&quot;c&quot;);
        System.out.println(&quot;开始等待&quot;);
        blockingQueue.offer(&quot;d&quot;,2, TimeUnit.SECONDS);  //超时时间2s 等待如果超过2s就结束等待
        System.out.println(&quot;结束等待&quot;);
        System.out.println(&quot;===========取值==================&quot;);
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(&quot;开始等待&quot;);
        blockingQueue.poll(2,TimeUnit.SECONDS); //超过两秒 我们就不要等待了
        System.out.println(&quot;结束等待&quot;);
    }


</code></pre>
<h3 id="2同步队列">2）同步队列</h3>
<p>同步队列 没有容量，也可以视为<strong>容量为1的队列</strong>；</p>
<p>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；</p>
<p><strong>put</strong>方法 和 <strong>take</strong>方法；</p>
<p><strong>Synchronized</strong> 和 其他的<strong>BlockingQueue</strong> 不一样 它不存储元素；</p>
<p>put了一个元素，就必须从里面先take出来，否则不能再put进去值！</p>
<p>并且SynchronousQueue 的take是使用了<strong>lock锁保证线程安全</strong>的。</p>
<pre><code class="language-java">package com.marchsoft.queue;

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/12 10:02
 **/

public class SynchronousQueue {
    public static void main(String[] args) {
        BlockingQueue&lt;String&gt; synchronousQueue = new java.util.concurrent.SynchronousQueue&lt;&gt;();
        // 网queue中添加元素
        new Thread(() -&gt; {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;put 01&quot;);
                synchronousQueue.put(&quot;1&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;put 02&quot;);
                synchronousQueue.put(&quot;2&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;put 03&quot;);
                synchronousQueue.put(&quot;3&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        // 取出元素
        new Thread(()-&gt; {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());
                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());
                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());
            }catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}


Thread-0put 01
Thread-1take1
Thread-0put 02
Thread-1take2
Thread-0put 03
Thread-1take3

Process finished with exit code 0

</code></pre>
<h2 id="11-线程池">11. 线程池</h2>
<p>线程池：三大方式、七大参数、四种拒绝策略</p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 ===&gt; 池化技术</p>
<p>线程池、JDBC的连接池、内存池、对象池 等等。。。。</p>
<p>资源的创建、销毁十分消耗资源</p>
<p><strong>池化技术</strong>：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。</p>
<h3 id="1线程池的好处">1）线程池的好处：</h3>
<p>1、降低资源的消耗；</p>
<p>2、提高响应的速度；</p>
<p>3、方便管理；</p>
<p><strong>线程复用、可以控制最大并发数、管理线程；</strong></p>
<h3 id="2线程池三大方法">2）线程池：三大方法</h3>
<ul>
<li><strong>ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</strong></li>
<li><strong>ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小</strong></li>
<li><strong>ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的</strong></li>
</ul>
<pre><code class="language-java">//工具类 Executors 三大方法；
public class Demo01 {
    public static void main(String[] args) {

        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
        ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小
        ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的

        //线程池用完必须要关闭线程池
        try {

            for (int i = 1; i &lt;=100 ; i++) {
                //通过线程池创建线程
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName()+ &quot; ok&quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
</code></pre>
<h3 id="3七大参数">3）七大参数</h3>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小
                          int maximumPoolSize, //最大的线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit, //超时单位
                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列
                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动
                          RejectedExecutionHandler handler //拒绝策略
                         ) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://ganhan999.github.io//post-images/1607652138743.png" alt="" loading="lazy"></figure>
<p>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的<strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<pre><code class="language-java">public class PollDemo {
    public static void main(String[] args) {
        // 获取cpu 的核数
        int max = Runtime.getRuntime().availableProcessors();
        ExecutorService service =new ThreadPoolExecutor(
                2,
                max,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque&lt;&gt;(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        try {
            for (int i = 1; i &lt;= 10; i++) {
                service.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + &quot;ok&quot;);
                });
            }
        }catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            service.shutdown();
        }
    }
}
</code></pre>
<h3 id="4拒绝策略">4）拒绝策略</h3>
<p><strong>1. new ThreadPoolExecutor.AbortPolicy()：</strong> //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常</p>
<p>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize</p>
<p><strong>2. new ThreadPoolExecutor.CallerRunsPolicy()：</strong> //该拒绝策略为：哪来的去哪里 main线程进行处理</p>
<p><strong>3. new ThreadPoolExecutor.DiscardPolicy():</strong> //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</p>
<p><strong>4. new ThreadPoolExecutor.DiscardOldestPolicy()：</strong> //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常</p>
<h3 id="5如何设置线程池的大小">5）如何设置线程池的大小</h3>
<p><strong>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小</strong></p>
<pre><code class="language-java">// 获取cpu 的核数
        int max = Runtime.getRuntime().availableProcessors();
        ExecutorService service =new ThreadPoolExecutor(
                2,
                max,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque&lt;&gt;(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
</code></pre>
<p><strong>2、I/O密集型：</strong></p>
<p>在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。</p>
<h2 id="12-四大函数式接口">12. 四大函数式接口</h2>
<p>新时代的程序员：<strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p>
<p>函数式接口：只有一个方法的接口<br>
<img src="https://ganhan999.github.io//post-images/1607652155646.png" alt="" loading="lazy"></p>
<h3 id="1function-函数型接口">1）Function 函数型接口</h3>
<figure data-type="image" tabindex="9"><img src="https://ganhan999.github.io//post-images/1607652160660.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class FunctionDemo {
    public static void main(String[] args) {
        Function&lt;String, String&gt; function = (str) -&gt; {return str;};
        System.out.println(function.apply(&quot;aaaaaaaaaa&quot;));
    }
}
</code></pre>
<h3 id="2predicate-断定型接口">2）Predicate 断定型接口</h3>
<figure data-type="image" tabindex="10"><img src="https://ganhan999.github.io//post-images/1607652166530.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class PredicateDemo {
    public static void main(String[] args) {
        Predicate&lt;String&gt; predicate = (str) -&gt; {return str.isEmpty();};
        // false
        System.out.println(predicate.test(&quot;aaa&quot;));
        // true
        System.out.println(predicate.test(&quot;&quot;));
    }
}
</code></pre>
<h3 id="3suppier-供给型接口">3）Suppier 供给型接口</h3>
<figure data-type="image" tabindex="11"><img src="https://ganhan999.github.io//post-images/1607652174930.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 供给型接口，只返回，不输入
 */
public class Demo4 {
    public static void main(String[] args) {
        Supplier&lt;String&gt; supplier = ()-&gt;{return &quot;1024&quot;;};
        System.out.println(supplier.get());
    }
}

</code></pre>
<h3 id="4consummer-消费型接口">4）Consummer 消费型接口</h3>
<figure data-type="image" tabindex="12"><img src="https://ganhan999.github.io//post-images/1607652179906.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 消费型接口 没有返回值！只有输入！
 */
public class Demo3 {
    public static void main(String[] args) {
        Consumer&lt;String&gt; consumer = (str)-&gt;{
            System.out.println(str);
        };
        consumer.accept(&quot;abc&quot;);
    }
}

</code></pre>
<h2 id="13-stream-流式计算">13. Stream 流式计算</h2>
<pre><code class="language-java">/**
 * Description：
 * 题目要求： 用一行代码实现
 * 1. Id 必须是偶数
 * 2.年龄必须大于23
 * 3. 用户名转为大写
 * 4. 用户名倒序
 * 5. 只能输出一个用户
 *
 * @author jiaoqianjin
 * Date: 2020/8/12 14:55
 **/

public class StreamDemo {
    public static void main(String[] args) {
        User u1 = new User(1, &quot;a&quot;, 23);
        User u2 = new User(2, &quot;b&quot;, 23);
        User u3 = new User(3, &quot;c&quot;, 23);
        User u4 = new User(6, &quot;d&quot;, 24);
        User u5 = new User(4, &quot;e&quot;, 25);

        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);
        // lambda、链式编程、函数式接口、流式计算
        list.stream()
                .filter(user -&gt; {return user.getId()%2 == 0;})
                .filter(user -&gt; {return user.getAge() &gt; 23;})
                .map(user -&gt; {return user.getName().toUpperCase();})
                .sorted((user1, user2) -&gt; {return user2.compareTo(user1);})
                .limit(1)
                .forEach(System.out::println);
    }
}
</code></pre>
<h2 id="14-forkjoin">14. ForkJoin</h2>
<p>ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！</p>
<p>大数据中：<strong>MapReduce 核心思想-&gt;把大任务拆分为小任务！</strong></p>
<figure data-type="image" tabindex="13"><img src="https://ganhan999.github.io//post-images/1607652187342.png" alt="" loading="lazy"></figure>
<h3 id="1forkjoin-特点-工作窃取">1）ForkJoin 特点： 工作窃取！</h3>
<p>实现原理是：<strong>双端队列</strong>！从上面和下面都可以去拿到任务进行执行！</p>
<figure data-type="image" tabindex="14"><img src="https://ganhan999.github.io//post-images/1607652197084.png" alt="" loading="lazy"></figure>
<h3 id="2如何使用forkjoin">2）如何使用ForkJoin?</h3>
<ul>
<li>
<p>1、通过<strong>ForkJoinPool</strong>来执行</p>
</li>
<li>
<p>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></p>
</li>
<li>
<p>3、计算类要去继承ForkJoinTask；</p>
<p><strong>ForkJoin 的计算类</strong></p>
</li>
</ul>
<pre><code class="language-java">package com.marchsoft.forkjoin;

import java.util.concurrent.RecursiveTask;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/13 8:33
 **/

public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; {
    private long star;
    private long end;
    /** 临界值 */
    private long temp = 1000000L;

    public ForkJoinDemo(long star, long end) {
        this.star = star;
        this.end = end;
    }

    /**
     * 计算方法
     * @return
     */
    @Override
    protected Long compute() {
        if ((end - star) &lt; temp) {
            Long sum = 0L;
            for (Long i = star; i &lt; end; i++) {
                sum += i;
            }
            return sum;
        }else {
            // 使用ForkJoin 分而治之 计算
            //1 . 计算平均值
            long middle = (star + end) / 2;
            ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(star, middle);
            // 拆分任务，把线程压入线程队列
            forkJoinDemo1.fork();
            ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle, end);
            forkJoinDemo2.fork();

            long taskSum = forkJoinDemo1.join() + forkJoinDemo2.join();
            return taskSum;
        }
    }
}
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="language-java">package com.marchsoft.forkjoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.stream.LongStream;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/13 8:43
 **/

public class ForkJoinTest {
    private static final long SUM = 20_0000_0000;

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test1();
        test2();
        test3();
    }

    /**
     * 使用普通方法
     */
    public static void test1() {
        long star = System.currentTimeMillis();
        long sum = 0L;
        for (long i = 1; i &lt; SUM ; i++) {
            sum += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(sum);
        System.out.println(&quot;时间：&quot; + (end - star));
        System.out.println(&quot;----------------------&quot;);
    }
    /**
     * 使用ForkJoin 方法
     */
    public static void test2() throws ExecutionException, InterruptedException {
        long star = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, SUM);
        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);
        Long along = submit.get();

        System.out.println(along);
        long end = System.currentTimeMillis();
        System.out.println(&quot;时间：&quot; + (end - star));
        System.out.println(&quot;-----------&quot;);
    }
    /**
     * 使用 Stream 流计算
     */
    public static void test3() {
        long star = System.currentTimeMillis();

        long sum = LongStream.range(0L, 20_0000_0000L).parallel().reduce(0, Long::sum);
        System.out.println(sum);
        long end = System.currentTimeMillis();
        System.out.println(&quot;时间：&quot; + (end - star));
        System.out.println(&quot;-----------&quot;);
    }
}

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://ganhan999.github.io//post-images/1607652211199.png" alt="" loading="lazy"></figure>
<p><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong></p>
<figure data-type="image" tabindex="16"><img src="https://ganhan999.github.io//post-images/1607652216426.png" alt="" loading="lazy"></figure>
<h2 id="15-异步回调">15. 异步回调</h2>
<blockquote>
<p>Future 设计的初衷：对将来的某个事件结果进行建模！</p>
</blockquote>
<p>其实就是前端 --&gt; 发送ajax异步请求给后端</p>
<p><img src="https://ganhan999.github.io//post-images/1607652291764.png" alt="" loading="lazy"><br>
但是我们平时都使用<strong>CompletableFuture</strong></p>
<h4 id="1没有返回值的runasync异步回调">（1）没有返回值的runAsync异步回调</h4>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException 
{
        // 发起 一个 请求

        System.out.println(System.currentTimeMillis());
        System.out.println(&quot;---------------------&quot;);
        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;{
            //发起一个异步任务
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;);
        });
        System.out.println(System.currentTimeMillis());
        System.out.println(&quot;------------------------------&quot;);
        //输出执行结果
        System.out.println(future.get());  //获取执行结果
 }
</code></pre>
<h4 id="2有返回值的异步回调supplyasync">（2）有返回值的异步回调supplyAsync</h4>
<pre><code class="language-java">//有返回值的异步回调
CompletableFuture&lt;Integer&gt; completableFuture=CompletableFuture.supplyAsync(()-&gt;{
    System.out.println(Thread.currentThread().getName());
    try {
        TimeUnit.SECONDS.sleep(2);
        int i=1/0;
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return 1024;
});
System.out.println(completableFuture.whenComplete((t, u) -&gt; {
    //success 回调
    System.out.println(&quot;t=&gt;&quot; + t); //正常的返回结果
    System.out.println(&quot;u=&gt;&quot; + u); //抛出异常的 错误信息
}).exceptionally((e) -&gt; {
    //error回调
    System.out.println(e.getMessage());
    return 404;
}).get());
</code></pre>
<p><strong>whenComplete</strong>: 有两个参数，一个是t 一个是u</p>
<p>T：是代表的 <strong>正常返回的结果</strong>；</p>
<p>U：是代表的 <strong>抛出异常的错误信息</strong>；</p>
<p>如果发生了异常，get可以获取到<strong>exceptionally</strong>返回的值；</p>
<h2 id="16-jmm">16. JMM</h2>
<h3 id="1对volatile-的理解">1）对Volatile 的理解</h3>
<p><strong>Volatile</strong> 是 Java 虚拟机提供 <strong>轻量级的同步机制</strong></p>
<p><strong>1、保证可见性<br>
2、不保证原子性<br>
3、禁止指令重排</strong></p>
<p><strong>如何实现可见性</strong></p>
<p>volatile变量修饰的共享变量在进行写操作的时候回多出一行汇编：</p>
<p>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24**:lock** addl $0×0,(%esp);</p>
<p>Lock前缀的指令在多核处理器下会引发两件事情。</p>
<p>1）将当前处理器缓存行的数据写回到系统内存。</p>
<p>2）这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。</p>
<p><strong>多处理器总线嗅探：</strong></p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在<strong>多处理器下</strong>，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，<strong>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态</strong>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
<h3 id="2什么是jmm">2）什么是JMM？</h3>
<p>JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！</p>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<p>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；</p>
<p>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；</p>
<p>3、加锁和解锁是同一把锁；</p>
<p>线程中分为 <strong>工作内存、主内存</strong></p>
<p><strong>8种操作</strong>:</p>
<ul>
<li>
<p><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</p>
</li>
<li>
<p><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</p>
</li>
<li>
<p><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</p>
</li>
<li>
<p><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</p>
</li>
<li>
<p><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</p>
</li>
<li>
<p><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</p>
</li>
<li>
<p><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</p>
</li>
<li>
<p><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；<br>
<img src="https://ganhan999.github.io//post-images/1607651252203.png" alt="" loading="lazy"><br>
<img src="https://ganhan999.github.io//post-images/1607651261771.png" alt="" loading="lazy"></p>
<p><strong>JMM对这8种操作给了相应的规定</strong>：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://ganhan999.github.io//post-images/1607651270053.png" alt="" loading="lazy"></figure>
<p>遇到问题：<strong>程序不知道主存中的值已经被修改过了！；</strong></p>
<h2 id="17-volatile">17. volatile</h2>
<h3 id="1保证可见性">1）保证可见性</h3>
<pre><code class="language-java">public class JMMDemo01 {

    // 如果不加volatile 程序会死循环
    // 加了volatile是可以保证可见性的
    private volatile static Integer number = 0;

    public static void main(String[] args) {
        //main线程
        //子线程1
        new Thread(()-&gt;{
            while (number==0){
            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //子线程2
        new Thread(()-&gt;{
            while (number==0){
            }

        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        number=1;
        System.out.println(number);
    }
}
</code></pre>
<h3 id="2不保证原子性">2）不保证原子性</h3>
<p>原子性：不可分割；</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</p>
<pre><code class="language-java">/**
 * 不保证原子性
 * number &lt;=2w
 * 
 */
public class VDemo02 {

    private static volatile int number = 0;

    public static void add(){
        number++; 
        //++ 不是一个原子性操作，是两个~3个操作
        //
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i &lt;= 20; i++) {
            new Thread(()-&gt;{
                for (int j = 1; j &lt;= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()&gt;2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number);
    }
}
</code></pre>
<p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong></p>
<figure data-type="image" tabindex="18"><img src="https://ganhan999.github.io//post-images/1607651277935.png" alt="" loading="lazy"></figure>
<p><strong>使用原子类</strong></p>
<figure data-type="image" tabindex="19"><img src="https://ganhan999.github.io//post-images/1607651283329.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class VDemo02 {

    private static volatile AtomicInteger number = new AtomicInteger();

    public static void add(){
//        number++;
        number.incrementAndGet();  //底层是CAS保证的原子性
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i &lt;= 20; i++) {
            new Thread(()-&gt;{
                for (int j = 1; j &lt;= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()&gt;2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number);
    }
}
</code></pre>
<p>这些类的底层都直接和操作系统挂钩！是在内存中修改值。</p>
<p>Unsafe类是一个很特殊的存在；</p>
<blockquote>
<p>原子类为什么这么高级？</p>
</blockquote>
<h3 id="3禁止指令重排">3）禁止指令重排</h3>
<p><strong>什么是指令重排？</strong></p>
<p>我们写的程序，计算机并不是按照我们自己写的那样去执行的</p>
<p>源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<pre><code class="language-java">int x=1; //1
int y=2; //2
x=x+5;   //3
y=x*x;   //4

//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324
//可不可能是 4123？ 不可能的

</code></pre>
<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody>
</table>
<p>正常的结果： x = 0; y =0;</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody>
</table>
<p>可能在线程A中会出现，先执行b=1,然后再执行x=a；</p>
<p>在B线程中可能会出现，先执行a=2，然后执行y=b；</p>
<p>那么就有可能结果如下：x=2; y=1.</p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p><strong>volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</strong></p>
<p>内存屏障：CPU指令。作用：</p>
<p>1、保证特定的操作的执行顺序；</p>
<p>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）</p>
<figure data-type="image" tabindex="20"><img src="https://ganhan999.github.io//post-images/1607651292826.png" alt="" loading="lazy"></figure>
<h3 id="4总结">4）总结</h3>
<ul>
<li><strong>volatile可以保证可见性；</strong></li>
<li><strong>不能保证原子性</strong></li>
<li><strong>由于内存屏障，可以保证避免指令重排的现象产生</strong></li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h2 id="18-玩转单例模式">18. 玩转单例模式</h2>
<p>饿汉式、DCL懒汉式</p>
<h3 id="1饿汉式">1）饿汉式</h3>
<pre><code class="language-java">/**
 * 饿汉式单例
 */
public class Hungry {

    /**
     * 可能会浪费空间
     */
    private byte[] data1=new byte[1024*1024];
    private byte[] data2=new byte[1024*1024];
    private byte[] data3=new byte[1024*1024];
    private byte[] data4=new byte[1024*1024];



    private Hungry(){

    }
    private final static Hungry hungry = new Hungry();

    public static Hungry getInstance(){
        return hungry;
    }

}

</code></pre>
<h3 id="2dcl懒汉式">2）DCL懒汉式</h3>
<pre><code class="language-java">//懒汉式单例模式
public class LazyMan {

    private static boolean key = false;

    private LazyMan(){
        synchronized (LazyMan.class){
            if (key==false){
                key=true;
            }
            else{
                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);
            }
        }
        System.out.println(Thread.currentThread().getName()+&quot; ok&quot;);
    }
    private volatile static LazyMan lazyMan;

    //双重检测锁模式 简称DCL懒汉式
    public static LazyMan getInstance(){
        //需要加锁
        if(lazyMan==null){
            synchronized (LazyMan.class){
                if(lazyMan==null){
                    lazyMan=new LazyMan();
                    /**
                     * 1、分配内存空间
                     * 2、执行构造方法，初始化对象
                     * 3、把这个对象指向这个空间
                     *
                     *  就有可能出现指令重排问题
                     *  比如执行的顺序是1 3 2 等
                     *  我们就可以添加volatile保证指令重排问题
                     */
                }
            }
        }
        return lazyMan;
    }
    //单线程下 是ok的
    //但是如果是并发的
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {
        //Java中有反射
//        LazyMan instance = LazyMan.getInstance();
        Field key = LazyMan.class.getDeclaredField(&quot;key&quot;);
        key.setAccessible(true);
        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true); //无视了私有的构造器
        LazyMan lazyMan1 = declaredConstructor.newInstance();
        key.set(lazyMan1,false);
        LazyMan instance = declaredConstructor.newInstance();

        System.out.println(instance);
        System.out.println(lazyMan1);
        System.out.println(instance == lazyMan1);
    }
}

</code></pre>
<h3 id="3静态内部类">3）静态内部类</h3>
<pre><code class="language-java">//静态内部类
public class Holder {
    private Holder(){

    }
    public static Holder getInstance(){
        return InnerClass.holder;
    }
    public static class InnerClass{
        private static final Holder holder = new Holder();
    }
}

</code></pre>
<blockquote>
<p>单例不安全, 因为反射</p>
</blockquote>
<h3 id="4枚举">4）枚举</h3>
<pre><code class="language-java">//enum 是什么？ enum本身就是一个Class 类
public enum EnumSingle {
    INSTANCE;
    public EnumSingle getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class);
        declaredConstructor.setAccessible(true);
        //java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()

        EnumSingle instance2 = declaredConstructor.newInstance();
        System.out.println(instance1);
        System.out.println(instance2);
    }
}

</code></pre>
<p>使用枚举，我们就可以防止反射破坏了。</p>
<figure data-type="image" tabindex="21"><img src="https://ganhan999.github.io//post-images/1607651303652.png" alt="" loading="lazy"></figure>
<p>枚举类型的最终反编译源码：</p>
<pre><code class="language-java">public final class EnumSingle extends Enum
{

    public static EnumSingle[] values()
    {
        return (EnumSingle[])$VALUES.clone();
    }

    public static EnumSingle valueOf(String name)
    {
        return (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);
    }

    private EnumSingle(String s, int i)
    {
        super(s, i);
    }

    public EnumSingle getInstance()
    {
        return INSTANCE;
    }

    public static final EnumSingle INSTANCE;
    private static final EnumSingle $VALUES[];

    static 
    {
        INSTANCE = new EnumSingle(&quot;INSTANCE&quot;, 0);
        $VALUES = (new EnumSingle[] {
            INSTANCE
        });
    }
}
</code></pre>
<h2 id="19-深入理解cas">19. 深入理解CAS</h2>
<h3 id="1什么是cas">1）什么是CAS？</h3>
<p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络原理、组成原理、数据结构</strong></p>
<pre><code class="language-java">public class casDemo {
    //CAS : compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //boolean compareAndSet(int expect, int update)
        //期望值、更新值
        //如果实际值 和 我的期望值相同，那么就更新
        //如果实际值 和 我的期望值不同，那么就不更新
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        //因为期望值是2020  实际值却变成了2021  所以会修改失败
        //CAS 是CPU的并发原语
        atomicInteger.getAndIncrement(); //++操作
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}

</code></pre>
<p>Unsafe 类</p>
<p><img src="https://ganhan999.github.io//post-images/1607651316714.png" alt="" loading="lazy">!</p>
<h3 id="2总结">2）总结</h3>
<p>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<figure data-type="image" tabindex="22"><img src="https://ganhan999.github.io//post-images/1607652402164.png" alt="" loading="lazy"></figure>
<p>线程1：期望值是1，要变成2；</p>
<p>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p>
<pre><code class="language-java">public class casDemo {
    //CAS : compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        //boolean compareAndSet(int expect, int update)
        //期望值、更新值
        //如果实际值 和 我的期望值相同，那么就更新
        //如果实际值 和 我的期望值不同，那么就不更新
        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());

        //因为期望值是2020  实际值却变成了2021  所以会修改失败
        //CAS 是CPU的并发原语
//        atomicInteger.getAndIncrement(); //++操作
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}

</code></pre>
<h2 id="20-原子引用">20. 原子引用</h2>
<blockquote>
<p>解决ABA问题，对应的思想：就是使用了<strong>乐观锁~</strong></p>
</blockquote>
<p>带版本号的 原子操作！</p>
<p><strong>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong></p>
<p><img src="https://ganhan999.github.io//post-images/1607652423940.png" alt="" loading="lazy"><br>
<strong>带版本号的原子操作</strong></p>
<pre><code class="language-java">package com.marchsoft.lockdemo;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicStampedReference;

/**
 * Description：
 *
 * @author jiaoqianjin
 * Date: 2020/8/12 22:07
 **/

public class CASDemo {
    /**AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题
     * 正常在业务操作，这里面比较的都是一个个对象
     */
    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new
            AtomicStampedReference&lt;&gt;(1, 1);

    // CAS compareAndSet : 比较并交换！
    public static void main(String[] args) {
        new Thread(() -&gt; {
            int stamp = atomicStampedReference.getStamp(); // 获得版本号
            System.out.println(&quot;a1=&gt;&quot; + stamp);
            
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 修改操作时，版本号更新 + 1
            atomicStampedReference.compareAndSet(1, 2,
                    atomicStampedReference.getStamp(),
                    atomicStampedReference.getStamp() + 1);
            
            System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp());
            // 重新把值改回去， 版本号更新 + 1
            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(),
                    atomicStampedReference.getStamp() + 1));
            System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp());
        }, &quot;a&quot;).start();
        
        // 乐观锁的原理相同！
        new Thread(() -&gt; {
            int stamp = atomicStampedReference.getStamp(); // 获得版本号
            System.out.println(&quot;b1=&gt;&quot; + stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(atomicStampedReference.compareAndSet(1, 3,
                    stamp, stamp + 1));
            System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp());
        }, &quot;b&quot;).start();
    }
}


</code></pre>
<h2 id="21-各种锁的理解">21. 各种锁的理解</h2>
<h3 id="1公平锁非公平锁">1）公平锁，非公平锁</h3>
<ol>
<li>公平锁：非常公平，不能插队，必须先来后到</li>
</ol>
<pre><code class="language-java">/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
    sync = new NonfairSync();
}

</code></pre>
<ol>
<li>非公平锁：非常不公平，允许插队，可以改变顺序</li>
</ol>
<pre><code class="language-java">/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<h3 id="2可重入锁">2）可重入锁</h3>
<figure data-type="image" tabindex="23"><img src="https://ganhan999.github.io//post-images/1607652441152.png" alt="" loading="lazy"></figure>
<ol>
<li>Synchonized 锁</li>
</ol>
<pre><code class="language-java">public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(()-&gt;{
            phone.sms();
        },&quot;A&quot;).start();
        new Thread(()-&gt;{
            phone.sms();
        },&quot;B&quot;).start();
    }

}

class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+&quot;=&gt; sms&quot;);
        call();//这里也有一把锁
    }
    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+&quot;=&gt; call&quot;);
    }
}
</code></pre>
<ol>
<li>Lock 锁</li>
</ol>
<pre><code class="language-java">//lock
public class Demo02 {

    public static void main(String[] args) {
        Phone2 phone = new Phone2();
        new Thread(()-&gt;{
            phone.sms();
        },&quot;A&quot;).start();
        new Thread(()-&gt;{
            phone.sms();
        },&quot;B&quot;).start();
    }

}
class Phone2{

    Lock lock=new ReentrantLock();

    public void sms(){
        lock.lock(); //细节：这个是两把锁，两个钥匙
        //lock锁必须配对，否则就会死锁在里面
        try {
            System.out.println(Thread.currentThread().getName()+&quot;=&gt; sms&quot;);
            call();//这里也有一把锁
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void call(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; call&quot;);
        }catch (Exception e){
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}
</code></pre>
<ul>
<li>lock锁必须配对，相当于lock和 unlock 必须数量相同；</li>
<li>在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；</li>
</ul>
<h3 id="3自旋锁">3）自旋锁</h3>
<ol>
<li>spinlock</li>
</ol>
<pre><code class="language-java">public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}
</code></pre>
<ol>
<li>自我设计自旋锁</li>
</ol>
<pre><code class="language-java">public class SpinlockDemo {

    // 默认
    // int 0
    //thread null
    AtomicReference&lt;Thread&gt; atomicReference=new AtomicReference&lt;&gt;();

    //加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+&quot;===&gt; mylock&quot;);

        //自旋锁
        while (!atomicReference.compareAndSet(null,thread)){
            System.out.println(Thread.currentThread().getName()+&quot; ==&gt; 自旋中~&quot;);
        }
    }


    //解锁
    public void myUnlock(){
        Thread thread=Thread.currentThread();
        System.out.println(thread.getName()+&quot;===&gt; myUnlock&quot;);
        atomicReference.compareAndSet(thread,null);
    }

}

public class TestSpinLock {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();


        //使用CAS实现自旋锁
        SpinlockDemo spinlockDemo=new SpinlockDemo();
        new Thread(()-&gt;{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myUnlock();
            }
        },&quot;t1&quot;).start();

        TimeUnit.SECONDS.sleep(1);


        new Thread(()-&gt;{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myUnlock();
            }
        },&quot;t2&quot;).start();
    }
}
</code></pre>
<p>运行结果：</p>
<p><strong>t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。。。</strong></p>
<h3 id="4死锁">4）死锁</h3>
<figure data-type="image" tabindex="24"><img src="https://ganhan999.github.io//post-images/1607651379322.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package com.ogj.lock;

import java.util.concurrent.TimeUnit;

public class DeadLock {
    public static void main(String[] args) {
        String lockA= &quot;lockA&quot;;
        String lockB= &quot;lockB&quot;;

        new Thread(new MyThread(lockA,lockB),&quot;t1&quot;).start();
        new Thread(new MyThread(lockB,lockA),&quot;t2&quot;).start();
    }
}

class MyThread implements Runnable{

    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockA+&quot;===&gt;get&quot;+lockB);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockB+&quot;===&gt;get&quot;+lockA);
            }
        }
    }
}
</code></pre>
<p>如何解开死锁</p>
<p><strong>1、使用jps定位进程号，jdk的bin目录下： 有一个jps</strong></p>
<p>命令：<code>jps -l</code></p>
<figure data-type="image" tabindex="25"><img src="https://ganhan999.github.io//post-images/1607651436373.png" alt="" loading="lazy"></figure>
<p><strong>2、使用<code>jstack</code> 进程进程号 找到死锁信息</strong></p>
<figure data-type="image" tabindex="26"><img src="https://ganhan999.github.io//post-images/1607651442523.png" alt="" loading="lazy"></figure>
<p><strong>一般情况信息在最后：</strong></p>
<figure data-type="image" tabindex="27"><img src="https://ganhan999.github.io//post-images/1607651447853.png" alt="" loading="lazy"></figure>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/5、最长回文子串/" class="post-title gt-a-link">
                    中等5. 最长回文子串
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

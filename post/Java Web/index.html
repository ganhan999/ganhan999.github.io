<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java Web | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1617074346217">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1617074346217" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java Web
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-12-29 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="1-基本概念">1、基本概念</h2>
<h3 id="11-前言">1.1、前言</h3>
<p>web开发：</p>
<ul>
<li>web，网页的意思，www.baidu.com·</li>
<li>静态web
<ul>
<li>html,sss</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li>动态web
<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet/ISP，ASP，PHP</li>
</ul>
</li>
</ul>
<h3 id="12-web应用程序web应用程序">1.2、web应用程序web应用程序：</h3>
<p>可以提供浏览器访问的程序；</p>
<ul>
<li>a.html、b.html.….多个web资源，这些web资源可以被外界访问，对外界提供服务；</li>
<li>你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</li>
<li>URL</li>
<li>这个统一的web资源会被放在同一个文件夹下，web应用程序&gt;Tomcat：服务器</li>
<li>一个web应用由多部分组成（静态web，动态web)
<ul>
<li>html,sss,is</li>
<li>jsp,servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件（Properties)</li>
</ul>
</li>
</ul>
<p>Web酸用程序编写完毕后，若想提供给外界访问；需费一个服务蔬来统一管理</p>
<h3 id="13-静态web">1.3、静态web</h3>
<ul>
<li>*.htm， *.html这些都是网员的后境、如果服务器上一直存在这些东四，我们就可以直接进行读取、需要网络；</li>
<li><img src="https://img-blog.csdnimg.cn/20200506174751665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
<li>静态web存在的缺点
<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面
<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript[实际开发中，它用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h3 id="14-动态web">1.4、 动态web</h3>
<p>页面会动态展示，“web页面的展示效果因人而异”<br>
<img src="https://img-blog.csdnimg.cn/20200506175025436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布；
<ul>
<li>停机维护优点：</li>
</ul>
</li>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面</li>
<li>它可以与数据库交互（数据持久化：注册，商品信息，用户信息………）<br>
<img src="https://img-blog.csdnimg.cn/20200506175041602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<h2 id="2-web服务器">2、web服务器</h2>
<h3 id="21-技术讲解">2.1、技术讲解</h3>
<p><strong>ASP:</strong></p>
<ul>
<li>微软：国内最早流行的就是ASP；</li>
<li>·在HTML中嵌入了VB的脚本，ASP+COM；</li>
<li>·在ASP开发中，基本一个页面都有几干行的业务代码，页面极其换乱</li>
<li>·维护成本高！</li>
<li>C#</li>
<li>IIS</li>
</ul>
<p><strong>php:</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP）</li>
<li>·无法承载大访问量的情况（局限性）</li>
</ul>
<p><strong>jSP/Servlet:</strong><br>
B/S；浏览和服务器C/S：客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的（所有的大公司，或者一些开源的组件，都是用Java写的）</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP，ASP-&gt;JSP，加强市场强度；</li>
</ul>
<h3 id="22-web服务器">2.2、web服务器</h3>
<p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；<br>
<strong>lIS</strong><br>
微软的；ASP.,Windows中自带的<br>
<strong>Tomcat</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200423183331323.png" alt="在这里插入图片描述" loading="lazy"><br>
面向百度编程：<br>
Tomcat是Apache 软件基金会（Apache Software Foundation)的jakarta项目中的一个核心项目，最新的Servlet 和ISP 规范总是能在Tomcat中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受lava爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试ISP程序的首选。对于一个Java初学web的人来说，它是最佳的选择</p>
<p>Tomcat 实际上运行JSP页面和Serlet。Tornct最新版易9.0</p>
<p><strong>工作3-5年之后，可以尝试手写Tomcat服务器；</strong></p>
<p>下载tomcat：</p>
<ol>
<li>安装or解压</li>
<li>了解配置文件及目录结构</li>
<li>这个东西的作用</li>
</ol>
<h2 id="3-tomcat">3、Tomcat</h2>
<h3 id="31安装tomcat-tomcat">3.1安装tomcat tomcat</h3>
<p>官网：http://tomcat.apache.org/</p>
<p><img src="https://img-blog.csdnimg.cn/20200423183805916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200423183826267.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="32-tomcat启动和配置">3.2、Tomcat启动和配置</h3>
<p>文件夹作用:<br>
<img src="https://img-blog.csdnimg.cn/20200506175503686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img-blog.csdnimg.cn/20200423184021633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"><br>
访问测试：http://localhost:8080/<br>
可能遇到的问题：</p>
<ol>
<li>Java环境变量没有配置</li>
<li>闪退问题：需要配置兼容性</li>
<li>乱码问题：配置文件中设置</li>
</ol>
<p>可以修改 conf/logging.properties 中的 java.util.logging.ConsoleHandler.encoding = GBK <strong>解决乱码问题</strong></p>
<h3 id="33-配置">3.3、配置</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200506175624200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql:3306</li>
<li>http:80</li>
<li>https：443</li>
</ul>
<pre><code class="language-xml">&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;
      connectionTimeout=&quot;20000&quot;
      redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为：localhost-&gt;127.0.0.1</li>
<li>默认网站应用存放的位置为：webapps</li>
</ul>
<pre><code class="language-xml">  &lt;Host name=&quot;www.qinjiang.com&quot;  appBase=&quot;webapps&quot;
        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<p>高难度面试题：<br>
请你谈谈网站是如何进行访问的！</p>
<ol>
<li>
<p>输入一个域名；回车</p>
</li>
<li>
<p>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；</p>
<ol>
<li>
<p>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</p>
<pre><code class="language-php"> 127.0.0.1 www.qinjiang.com
</code></pre>
</li>
</ol>
</li>
<li>
<p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；<br>
<img src="https://img-blog.csdnimg.cn/20200423184922156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</li>
</ol>
<p>4.可以配置一下环境变量（可选性）</p>
<h3 id="34-发布一个web网站">3.4、发布一个web网站</h3>
<p>不会就先模仿</p>
<ul>
<li>将自己写的网站，放到服务器（Tomcat)中指定的web应用的文件夹（webapps)下，就可以访问了</li>
</ul>
<p>网站应该有的结构</p>
<pre><code>--webapps ：Tomcat服务器的web目录
	-ROOT
	-kuangstudy ：网站的目录名
		- WEB-INF
			-classes : java程序
			-lib：web应用所依赖的jar包
			-web.xml ：网站配置文件
		- index.html 默认的首页
		- static 
            -css
            	-style.css
            -js
            -img
         -.....
</code></pre>
<p>HTTP协议：面试<br>
Maven:构建工具</p>
<ul>
<li>Maven安装包</li>
</ul>
<p>Servlet入门</p>
<ul>
<li>HelloWorld!</li>
<li>Servlet配置 ·原理</li>
</ul>
<h2 id="4-http">4、Http</h2>
<h3 id="41-什么是httphttp">4.1、什么是HTTPHTTP</h3>
<p>(超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<ul>
<li>文本：html，字符串，…</li>
<li>超文本：图片，音乐，视频，定位，地图.……</li>
<li>端口:80</li>
</ul>
<p>Https:安全的</p>
<h3 id="42-两个时代">4.2、两个时代</h3>
<ul>
<li>http1.0
<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li>
</ul>
</li>
<li>http2.0
<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。</li>
</ul>
</li>
</ul>
<h3 id="43-http请求">4.3、Http请求</h3>
<ul>
<li>客户端–发请求（Request）–服务器</li>
</ul>
<p>百度：</p>
<pre><code class="language-html">Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443

Accept:text/html  
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive
</code></pre>
<h4 id="1-请求行">1、请求行</h4>
<ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：Get,Post,HEAD,DELETE,PUT,TRACT.…
<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</li>
</ul>
</li>
</ul>
<h4 id="2-消息头">2、消息头</h4>
<pre><code>Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
</code></pre>
<h3 id="44-http响应">4.4、Http响应</h3>
<ul>
<li>服务器–响应…….客户端</li>
</ul>
<p>百度：</p>
<pre><code>Cache-Control:private    缓存控制
Connection:Keep-Alive    连接
Content-Encoding:gzip    编码
Content-Type:text/html   类型  
</code></pre>
<h4 id="1-响应体">1、响应体</h4>
<pre><code>Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
Refresh：告诉客户端，多久刷新一次；
Location：让网页重新定位；
</code></pre>
<h4 id="2-响应状态码">2、响应状态码</h4>
<p>200：请求响应成功200<br>
3xx:请求重定向·重定向：你重新到我给你新位置去；<br>
4xx:找不到资源404·资源不存在；<br>
5xx:服务器代码错误 500 502:网关错误</p>
<p><strong>常见面试题：</strong><br>
当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<h2 id="5-maven">5、Maven</h2>
<p><strong>我为什么要学习这个技术？</strong></p>
<ol>
<li>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；</li>
<li>如何能够让一个东西自动帮我导入和配置这个jar包。</li>
</ol>
<p>由此，Maven诞生了！</p>
<h3 id="51-maven项目架构管理工具">5.1 Maven项目架构管理工具</h3>
<p>我们目前用来就是方便导入jar包的！<br>
Maven的核心思想：<strong>约定大于配置</strong></p>
<ul>
<li>有约束，不要去违反。</li>
</ul>
<p>Maven会规定好你该如何去编写我们Java代码，必须要按照这个规范来；</p>
<h3 id="52下载安装maven">5.2下载安装Maven</h3>
<p>官网：https://maven.apache.org/<br>
<img src="https://img-blog.csdnimg.cn/20200506180036622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>下载完成后，解压即可；<br>
小狂神友情建议：电脑上的所有环境都放在一个文件夹下，方便管理；</p>
<h3 id="53配置环境变量">5.3配置环境变量</h3>
<p>在我们的系统环境变量中配置如下配置：</p>
<ul>
<li>M2_HOME maven目录下的bin目录</li>
<li>MAVEN_HOME maven的目录</li>
<li>在系统的path中配置%MAVEN_HOME%\bin<br>
<img src="https://img-blog.csdnimg.cn/20200423213124579.png" alt="在这里插入图片描述" loading="lazy"><br>
测试Maven是否安装成功，保证必须配置完毕！</li>
</ul>
<h3 id="54阿里云镜像">5.4阿里云镜像</h3>
<ul>
<li>镜像：mirrors</li>
<li>作用：加速我们的下载</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;  
    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;  
    &lt;name&gt;Nexus aliyun&lt;/name&gt;  
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
&lt;/mirror&gt;
</code></pre>
<p><strong>D:Enmvironment\apache-maven-3.6.2conf\ettings.xml</strong><br>
（狂神老师配置源和仓库的文件位置）</p>
<h3 id="55本地仓库">5.5本地仓库</h3>
<p>在本地的仓库，远程仓库； 建立一个本地仓库：localRepository</p>
<pre><code class="language-php">&lt;localRepository&gt;D:\Environment\apache-maven-3.6.2\maven-repo&lt;/localRepository&gt;
</code></pre>
<h3 id="56-~-513笔记-下载地址">5.6 ~ 5.13笔记-下载地址</h3>
<p>（拒接度盘）下载地址：https://wo-bell.lanzous.com/ibuibxi</p>
<p>后面的 <strong>5.6 ~ 5.13 + 案例演示</strong> (图)</p>
<p><strong>后面第 5 剩下部分的笔记建议配合狂神的<br>
“javaweb-06：IDEA中Maven的操作”、“javaweb-07：解决大家遇到的一些问题”<br>
仔细（回）看</strong></p>
<h2 id="6-servlet">6、Servlet</h2>
<h3 id="61-servlet简介">6.1、Servlet简介</h3>
<ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些APi中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
<ul>
<li>编写一个类，实现Serlet接口</li>
<li>把开发好java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="62-helloservlet">6.2、HelloServlet</h3>
<p>Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServled</p>
<h3 id="62-helloservlet-2">6.2、HelloServlet</h3>
<ol>
<li>构建一个普通的Maven项目，等理面的sc目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就题Maven主工程；</li>
<li>关于Maven父子工程的理解；<br>
父项目中会有</li>
</ol>
<pre><code class="language-xml">      &lt;modules&gt;
          &lt;module&gt;servlet-01&lt;/module&gt;
      &lt;/modules&gt;
</code></pre>
<p>子项目会有</p>
<pre><code class="language-xml">    &lt;parent&gt;
        &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
</code></pre>
<p>父项目中的java子项目可以直接使用</p>
<pre><code class="language-java">son extends father
</code></pre>
<ol>
<li>Maven环境优化
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整<br>
.</li>
</ol>
</li>
<li>编写一个Servlet程序
<ol>
<li>编写一个普通类</li>
<li>实现Servlet接口，这里我们直接继承HttpServlet</li>
</ol>
</li>
</ol>
<pre><code class="language-java">     public class HelloServlet extends HttpServlet {
         
         //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             //ServletOutputStream outputStream = resp.getOutputStream();
             PrintWriter writer = resp.getWriter(); //响应流
             writer.print(&quot;Hello,Serlvet&quot;);
         }
     
         @Override
         protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             doGet(req, resp);
         }
     }
     
</code></pre>
<ol>
<li>编写Servlet的映射<br>
为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需<br>
要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</li>
</ol>
<pre><code class="language-xml">      &lt;!--注册Servlet--&gt;
      &lt;servlet&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;
      &lt;/servlet&gt;
      &lt;!--Servlet的请求路径--&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>配置Tomcat<br>
注意：配置项目发布的路径就可以了<br>
<img src="https://img-blog.csdnimg.cn/20200426163434449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200426163446264.png" alt="在这里插入图片描述" loading="lazy"></li>
<li>启动测试，OK！<br>
<img src="https://img-blog.csdnimg.cn/20200426163526430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ol>
<h3 id="63-servlet原理">6.3、Servlet原理</h3>
<p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：<br>
<img src="https://img-blog.csdnimg.cn/20200506180639329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="64-mapping问题">6.4、Mapping问题</h3>
<ol>
<li>一个Servlet可以指定一个映射路径<br>
.</li>
</ol>
<pre><code class="language-xml">      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>一个servlet可以指定多个映射路径</li>
</ol>
<pre><code class="language-xml">      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>一个servlet可以指定通用映射路径</li>
</ol>
<pre><code class="language-xml">      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
      &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>默认请求路径</li>
</ol>
<pre><code class="language-xml">       &lt;!--默认请求路径--&gt;
       &lt;servlet-mapping&gt;
           &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
           &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
       &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>指定一些后缀或者前缀等等…</li>
</ol>
<pre><code class="language-xml">  &lt;!--可以自定义后缀实现请求映射
      注意点，*前面不能加项目映射的路径
      hello/sajdlkajda.qinjiang
      --&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
      &lt;url-pattern&gt;*.qinjiang&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>优先级问题<br>
指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</li>
</ol>
<pre><code class="language-xml">  &lt;!--404--&gt;
  &lt;servlet&gt;
      &lt;servlet-name&gt;error&lt;/servlet-name&gt;
      &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;error&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<h3 id="65-servletcontext">6.5、ServletContext</h3>
<p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<h4 id="1-共享数据">1、共享数据</h4>
<p>我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();

        String username = &quot;秦疆&quot;; //数据
        context.setAttribute(&quot;username&quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username

    }

}

public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&quot;username&quot;);

        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字&quot;+username);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;


    &lt;servlet&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.GetServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p>测试访问结果；</p>
<h4 id="2-获取初始化参数">2、获取初始化参数</h4>
<pre><code class="language-xml">    &lt;!--配置一些web应用初始化参数--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
    &lt;/context-param&gt;

protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    String url = context.getInitParameter(&quot;url&quot;);
    resp.getWriter().print(url);
}
</code></pre>
<h4 id="3-请求转发">3、请求转发</h4>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    System.out.println(&quot;进入了ServletDemo04&quot;);
    //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径
    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；
    context.getRequestDispatcher(&quot;/gp&quot;).forward(req,resp);
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200505153728272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4、读取资源文件<br>
Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:<br>
思路：需要一个文件流</p>
<pre><code>username=root12312
password=zxczxczxc
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200505153908944.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-java">public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;);

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&quot;username&quot;);
        String pwd = prop.getProperty(&quot;password&quot;);

        resp.getWriter().print(user+&quot;:&quot;+pwd);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<p>访问测试即可ok;</p>
<h3 id="66-httpservletresponse">6.6、HttpServletResponse</h3>
<pre><code>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest
对象，代表响应的一个HttpServletResponse；
</code></pre>
<ul>
<li>
<p>如果要获取客户端请求过来的参数：找HttpServletRequest</p>
</li>
<li>
<p>如果要给客户端响应一些信息：找HttpServletResponse</p>
<h4 id="1-简单分类">1、简单分类</h4>
</li>
</ul>
<p>负责向浏览器发送数据的方法</p>
<pre><code class="language-java"> servletOutputstream getOutputstream() throws IOException;
    Printwriter getwriter() throws IOException;
</code></pre>
<p>负责向浏览器发送响应头的方法</p>
<pre><code class="language-java">void setCharacterEncoding(String var1)；
void setContentLength(int var1)；
void setContentLengthLong(long var1);
void setContentType(String var1)；
void setDateHeader(String varl,long var2)
void addDateHeader(String var1,long var2)
void setHeader(String var1,String var2);
void addHeader(String var1,String var2)；
void setIntHeader(String var1,int var2);
void addIntHeader(String varl,int var2);
</code></pre>
<p>响应的状态码<br>
<img src="https://img-blog.csdnimg.cn/20200505155751598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200505155821202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="2-下载文件">2、下载文件</h4>
<ol>
<li>向浏览器输出消息（一直在讲，就不说了）</li>
<li>下载文件
<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到bufer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 1. 要获取下载文件的路径
    String realPath = &quot;F:\\班级管理\\西开【19525】\\2、代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\秦疆.png&quot;;
    System.out.println(&quot;下载文件的路径：&quot;+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName,&quot;UTF-8&quot;));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))&gt;0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
</code></pre>
<h4 id="3-验证码功能">3、验证码功能</h4>
<p>验证怎么来的?</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到Java的图片类，生产一个图片</li>
</ul>
<pre><code class="language-java">package com.kuang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);

        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 7-num.length() ; i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

&lt;servlet&gt;
	&lt;servlet-name&gt;ImageServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.kuang.servlet.ImageServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;Imageservlet&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/img&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200505163538698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
常见场景:</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="language-java"> void sendRedirect(String var1) throws IOException;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@override
protected void doGet(HttpservletRequest req, HttpservletResponse resp) throws ServletException, IOException {

    resp. sendRedirect(&quot;/r/img&quot;);//重定向
    /*
    resp. setHeader(&quot;Location&quot;,&quot;/r/img&quot;);
    resp. setstatus (302);
    */
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200505163946136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200505163953854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<strong>index.jsp</strong></p>
<pre><code class="language-html">&lt;html&gt;
	&lt;body&gt;
		&lt;h2&gt;Hel1o World!&lt;/h2&gt;
		
		《%--这里超交的路径,需要寻找到项目的路径--%&gt;
		&lt;%--${pageContext. request, contextPath}代表当前的项目--%&gt;
		&lt;form action=&quot;${pageContext. request.contextPath}/login&quot; method=&quot;get&quot;&gt;
			用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
			密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;
			&lt;input type=&quot;submit&quot;&gt;
		&lt;/form&gt;
	
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>RequestTest.java</strong></p>
<pre><code class="language-java">public class RequestTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //处理方求
    String username = req.getParameter( s: &quot;username&quot;);
    String password  req.getParameter( s: &quot;password&quot;);

    System.out.println(username+&quot;:&quot;+password);

    resp.sendRedirect(s: &quot;/r/success.jsp&quot;);
}
</code></pre>
<p><strong>重定向页面success.jsp</strong></p>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
	    &lt;title&gt;Title&lt;/title&gt;
	    &lt;/head&gt;
    &lt;body&gt;
    	&lt;h1&gt;success&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>web.xml配置</strong></p>
<pre><code class="language-xml">    &lt;servlet&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com. kuang. servlet. RequestTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p><strong>导入依赖的jar包</strong></p>
<pre><code class="language-xml">    &lt;dependencies&gt;
    &lt;!-- https://mvnrepository. com/artifact/javax. servLet/javax. servlet-opi --&gt;
    &lt;dependency&gt;
    &lt;groupld&gt;javax.servlet&lt;/grouptd&gt;
    &lt;artifactId&gt;javax. servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/javax. servLet.jsp/javax. servLet.jsp-opi --&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupld&gt;
    &lt;artifactId&gt;javax. servlet.jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;/project&gt;
</code></pre>
<h3 id="67-httpservletrequest">6.7、HttpServletRequest</h3>
<p>HttpServletRequest代表客户端的请求,用户通过Http协议访问服务器, HTTP请求中的所有信息会被封装到HttpServletRequest,通过这个HttpServletRequest的方法,获得客户端的所有信息;<br>
<img src="https://img-blog.csdnimg.cn/20200505165609562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200505165618601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="获取参数请求转发">获取参数,请求转发</h4>
<p><img src="https://img-blog.csdnimg.cn/20200505165652729.png" alt="在这里插入图片描述" loading="lazy"><br>
<strong>自己创建类，且需要继承HttpServlet类</strong></p>
<pre><code class="language-java">@Override
protected void doGet(HttpservletRequest req. HttpservletResponse resp) throws ServletException, IOException {

	req. setcharacterEncoding(&quot;utf-8&quot;);
	resp.setcharacterEncoding(&quot;utf-8&quot;);
	String username = req.getParameter(&quot;username&quot;);
	String password = req.getParameter(&quot;password&quot;);
	String[] hobbys = req.getParameterValues(&quot;hobbys&quot;);
	System.out.println(&quot;==========&quot;);
	//后台接收中文乱码问题
	System. out.println(username);
	System. out.println(password);
	System. out.println(Arrays.tostring(hobbys));
	System. out.println(&quot;============&quot;);
	system. out.println(req.getContextPath());
	//通过请求转发
	//这里的/代表当前的web应用
	req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200505170535748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="7-cookie-session">7、Cookie、Session</h2>
<h3 id="71-会话">7.1、会话</h3>
<p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p><strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<p><strong>你能怎么证明你是西开的学生？</strong></p>
<p>你 西开</p>
<ol>
<li>发票 西开给你发票</li>
<li>学校登记 西开标记你来过了</li>
</ol>
<p><strong>一个网站，怎么证明你来过？</strong></p>
<p>客户端 服务端</p>
<ol>
<li>服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie</li>
<li>服务器登记你来过了，下次你来的时候我来匹配你； seesion</li>
</ol>
<h3 id="72-保存会话的两种技术">7.2、保存会话的两种技术</h3>
<p><strong>cookie</strong></p>
<ul>
<li>客户端技术 （响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<p>常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！</p>
<h3 id="73-cookie">7.3、Cookie</h3>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200506182559338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<pre><code class="language-java">Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
</code></pre>
<p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li>不设置有效期，关闭浏览器，自动失效；</li>
<li>设置有效期时间为 0 ；</li>
</ul>
<p><strong>编码解码：</strong></p>
<pre><code class="language-java">URLEncoder.encode(&quot;秦疆&quot;,&quot;utf-8&quot;)
URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;)
</code></pre>
<h3 id="74-session重点">7.4、Session（重点）</h3>
<p><img src="https://img-blog.csdnimg.cn/2020050618262991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
什么是Session：</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个Seesion对象；</li>
<li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</li>
<li>用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息……</li>
</ul>
<p>…<br>
…<br>
…</p>
<p>Session和cookie的区别：</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）</li>
<li>Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务创建；</li>
</ul>
<p>使用场景：</p>
<ul>
<li>保存一个登录用户的信息；</li>
<li>购物车信息；</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中；</li>
</ul>
<p>使用Session：</p>
<pre><code class="language-java">package com.kuang.servlet;

import com.kuang.pojo.Person;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute(&quot;name&quot;,new Person(&quot;秦疆&quot;,1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId);
        }else {
            resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId);
        }

        //Session创建的时候做了什么事情；
//        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);
//        resp.addCookie(cookie);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute(&quot;name&quot;);

System.out.println(person.toString());

HttpSession session = req.getSession();
session.removeAttribute(&quot;name&quot;);
//手动注销Session
session.invalidate();
</code></pre>
<p><strong>会话自动过期：web.xml配置</strong></p>
<pre><code class="language-xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2020050618301064.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="8-jsp">8、JSP</h2>
<h3 id="81-什么是jsp">8.1、什么是JSP</h3>
<p>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别：
<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
<h3 id="82-jsp原理">8.2、JSP原理</h3>
<p>思路：JSP到底怎么执行的！</p>
<ul>
<li>
<p>代码层面没有任何问题</p>
</li>
<li>
<p>服务器内部工作</p>
<p>tomcat中有一个work目录；</p>
<p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200506184154282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>我电脑的地址：</p>
<p><strong>C:\Users\Administrator.IntelliJIdea2018.1\system\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp</strong></p>
<p>发现页面转变成了Java程序！<br>
<img src="https://img-blog.csdnimg.cn/20200506184204931.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
</ul>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p>
<p>JSP最终也会被转换成为一个Java类！</p>
<p><strong>JSP 本质上就是一个Servlet</strong></p>
<pre><code class="language-java">//初始化
  public void _jspInit() {
      
  }
//销毁
  public void _jspDestroy() {
  }
//JSPService
  public void _jspService(.HttpServletRequest request,HttpServletResponse response)
</code></pre>
<ol>
<li>
<p>判断请求</p>
</li>
<li>
<p>内置一些对象</p>
<pre><code class="language-java">final javax.servlet.jsp.PageContext pageContext;  //页面上下文
javax.servlet.http.HttpSession session = null;    //session
final javax.servlet.ServletContext application;   //applicationContext
final javax.servlet.ServletConfig config;         //config
javax.servlet.jsp.JspWriter out = null;           //out
final java.lang.Object page = this;               //page：当前
HttpServletRequest request                        //请求
HttpServletResponse response                      //响应
</code></pre>
</li>
<li>
<p>输出页面前增加的代码</p>
<pre><code class="language-java">response.setContentType(&quot;text/html&quot;);       //设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this, request, response,
       null, true, 8192, true);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;
</code></pre>
</li>
<li>
<p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200506183804973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在JSP页面中；</p>
<p>只要是 JAVA代码就会原封不动的输出；</p>
<p>如果是HTML代码，就会被转换为：</p>
<pre><code class="language-java">out.write(&quot;&lt;html&gt;\r\n&quot;);
</code></pre>
<p>这样的格式，输出到前端！</p>
<h3 id="83-jsp基础语法">8.3、JSP基础语法</h3>
<p>任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</p>
<h4 id="jsp表达式">JSP表达式</h4>
<pre><code class="language-java">  &lt;%--JSP表达式
  作用：用来将程序的输出，输出到客户端
  &lt;%= 变量或者表达式%&gt;
  --%&gt;
  &lt;%= new java.util.Date()%&gt;
</code></pre>
<h4 id="jsp脚本片段">jsp脚本片段</h4>
<pre><code class="language-java">  &lt;%--jsp脚本片段--%&gt;
  &lt;%
    int sum = 0;
    for (int i = 1; i &lt;=100 ; i++) {
      sum+=i;
    }
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
  %&gt;
</code></pre>
<p><strong>脚本片段的再实现</strong></p>
<pre><code class="language-java">  &lt;%
    int x = 10;
    out.println(x);
  %&gt;
  &lt;p&gt;这是一个JSP文档&lt;/p&gt;
  &lt;%
    int y = 2;
    out.println(y);
  %&gt;

  &lt;hr&gt;


  &lt;%--在代码嵌入HTML元素--%&gt;
  &lt;%
    for (int i = 0; i &lt; 5; i++) {
  %&gt;
    &lt;h1&gt;Hello,World  &lt;%=i%&gt; &lt;/h1&gt;
  &lt;%
    }
  %&gt;
</code></pre>
<h4 id="jsp声明">JSP声明</h4>
<pre><code class="language-java">  &lt;%!
    static {
      System.out.println(&quot;Loading Servlet!&quot;);
    }

    private int globalVar = 0;

    public void kuang(){
      System.out.println(&quot;进入了方法Kuang！&quot;);
    }
  %&gt;
</code></pre>
<p>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</p>
<p>在JSP，嵌入Java代码即可！</p>
<pre><code class="language-java">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;

&lt;%--注释--%&gt;
</code></pre>
<p>JSP的注释，不会在客户端显示，HTML就会！</p>
<h3 id="84-jsp指令">8.4、JSP指令</h3>
<pre><code class="language-java">&lt;%@page args.... %&gt;
&lt;%@include file=&quot;&quot;%&gt;

&lt;%--@include会将两个页面合二为一--%&gt;

&lt;%@include file=&quot;common/header.jsp&quot;%&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;

&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;

&lt;hr&gt;


&lt;%--jSP标签
    jsp:include：拼接页面，本质还是三个
    --%&gt;
&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;
&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;
</code></pre>
<h3 id="85-9大内置对象">8.5、9大内置对象</h3>
<ul>
<li>PageContext 存东西</li>
<li>Request 存东西</li>
<li>Response</li>
<li>Session 存东西</li>
<li>Application 【SerlvetContext】 存东西</li>
<li>config 【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<pre><code class="language-java">pageContext.setAttribute(&quot;name1&quot;,&quot;秦疆1号&quot;); //保存的数据只在一个页面中有效
request.setAttribute(&quot;name2&quot;,&quot;秦疆2号&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据
session.setAttribute(&quot;name3&quot;,&quot;秦疆3号&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
application.setAttribute(&quot;name4&quot;,&quot;秦疆4号&quot;);  //保存的数据只在服务器中有效，从打开服务器到关闭服务器
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200507213158259.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</p>
<p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p>
<p>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p>
<h3 id="86-jsp标签-jstl标签-el表达式">8.6、JSP标签、JSTL标签、EL表达式</h3>
<pre><code class="language-xml">&lt;!-- JSTL表达式的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- standard标签库 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>EL表达式： ${ }</p>
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
<p><strong>JSP标签</strong></p>
<pre><code class="language-java">&lt;%--jsp:include--%&gt;

&lt;%--
http://localhost:8080/jsptag.jsp?name=kuangshen&amp;age=12
--%&gt;

&lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>JSTL表达式</strong></p>
<p>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</p>
<p><strong>格式化标签</strong></p>
<p><strong>SQL标签</strong></p>
<p><strong>XML 标签</strong></p>
<p><strong>核心标签</strong> （掌握部分）</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200508152235704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的 taglib</li>
<li>使用其中的方法</li>
<li><strong>在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误</strong></li>
</ul>
<p><strong>c：if</strong></p>
<pre><code class="language-java">&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;h4&gt;if测试&lt;/h4&gt;

&lt;hr&gt;

&lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
    EL表达式获取表单中的数据
    ${param.参数名}
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${param.username}&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;

&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;
&lt;c:if test=&quot;${param.username=='admin'}&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;
&lt;/c:if&gt;

&lt;%--自闭合标签--%&gt;
&lt;c:out value=&quot;${isAdmin}&quot;/&gt;

&lt;/body&gt;
</code></pre>
<p><strong>c:choose c:when</strong></p>
<pre><code class="language-java">&lt;body&gt;

&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;55&quot;/&gt;

&lt;c:choose&gt;
    &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=80}&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=70}&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&lt;=60}&quot;&gt;
        你的成绩为不及格
    &lt;/c:when&gt;
&lt;/c:choose&gt;

&lt;/body&gt;
</code></pre>
<p><strong>c:forEach</strong></p>
<pre><code class="language-java">&lt;%

    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();
    people.add(0,&quot;张三&quot;);
    people.add(1,&quot;李四&quot;);
    people.add(2,&quot;王五&quot;);
    people.add(3,&quot;赵六&quot;);
    people.add(4,&quot;田六&quot;);
    request.setAttribute(&quot;list&quot;,people);
%&gt;


&lt;%--
var , 每一次遍历出来的变量
items, 要遍历的对象
begin,   哪里开始
end,     到哪里
step,   步长
--%&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot;&gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;

&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;
</code></pre>
<h2 id="9-javabean">9、JavaBean</h2>
<p>实体类</p>
<p>JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法；</li>
</ul>
<p>一般用来和数据库的字段做映射 ORM；</p>
<p>ORM ：对象关系映射</p>
<ul>
<li>表—&gt;类</li>
<li>字段–&gt;属性</li>
<li>行记录----&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>秦疆1号</td>
<td>3</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>秦疆2号</td>
<td>18</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>秦疆3号</td>
<td>100</td>
<td>西安</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">class People{
    private int id;
    private String name;
    private int id;
    private String address;
}

class A{
    new People(1,&quot;秦疆1号&quot;,3，&quot;西安&quot;);
    new People(2,&quot;秦疆2号&quot;,3，&quot;西安&quot;);
    new People(3,&quot;秦疆3号&quot;,3，&quot;西安&quot;);
}
</code></pre>
<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC 复习 ： 如何使用JDBC , JDBC crud， jdbc 事务</li>
</ul>
<h2 id="10-mvc三层架构">10、MVC三层架构</h2>
<ul>
<li>什么是MVC： Model view Controller 模型、视图、控制器</li>
</ul>
<h3 id="101-以前的架构">10.1、以前的架构</h3>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200508154442187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="(img-NGdCSHqw-1588757845418)(JavaWeb.assets/1568423664332.png)" loading="lazy"></figure>
<p>用户直接访问控制层，控制层就可以直接操作数据库；</p>
<pre><code class="language-java">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
↑
JDBC （实现该接口）
↑
Mysql Oracle SqlServer ....（不同厂商）
</code></pre>
<h3 id="102-mvc三层架构">10.2、MVC三层架构</h3>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200508154512751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="[(img-BWDJGUCN-1588757845419)(JavaWeb.assets/1568424227281.png)]" loading="lazy"></figure>
<p>Model</p>
<ul>
<li>业务处理 ：业务逻辑（Service）</li>
<li>数据持久层：CRUD （Dao - 数据持久化对象）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求 （a，form，img…）</li>
</ul>
<p>Controller （Servlet）</p>
<ul>
<li>
<p>接收用户的请求 ：（req：请求参数、Session信息….）</p>
</li>
<li>
<p>交给业务层处理对应的代码</p>
</li>
<li>
<p>控制视图的跳转</p>
<pre><code class="language-java">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库
</code></pre>
</li>
</ul>
<h2 id="11-filter-重点">11、Filter （重点）</h2>
<p>比如 Shiro安全框架技术就是用Filter来实现的</p>
<p>Filter：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证….</li>
</ul>
<p>（比如用来过滤网上骂人的话，我***我自己 0-0）</p>
<p><img src="https://img-blog.csdnimg.cn/20200508154536177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="(img-QEq74VyV-1588757845420)(JavaWeb.assets/1568424858708.png)" loading="lazy"><br>
Filter开发步骤：</p>
<ol>
<li>导包</li>
<li>编写过滤器
<ol>
<li>导包不要错 <strong>（注意）</strong></li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200508154555952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="[(img-HHsC3JBD-1588757845420)(JavaWeb.assets/1568425162525.png)]" loading="lazy"></figure>
<p>实现Filter接口，重写对应的方法即可</p>
<pre><code>  ```java
  public class CharacterEncodingFilter implements Filter {
  
      //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
      public void init(FilterConfig filterConfig) throws ServletException {
          System.out.println(&quot;CharacterEncodingFilter初始化&quot;);
      }
  
      //Chain : 链
      /*
      1. 过滤中的所有代码，在过滤特定请求的时候都会执行
      2. 必须要让过滤器继续同行
          chain.doFilter(request,response);
       */
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
          request.setCharacterEncoding(&quot;utf-8&quot;);
          response.setCharacterEncoding(&quot;utf-8&quot;);
          response.setContentType(&quot;text/html;charset=UTF-8&quot;);
  
          System.out.println(&quot;CharacterEncodingFilter执行前....&quot;);
          chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！
          System.out.println(&quot;CharacterEncodingFilter执行后....&quot;);
      }
  
      //销毁：web服务器关闭的时候，过滤器会销毁
      public void destroy() {
          System.out.println(&quot;CharacterEncodingFilter销毁&quot;);
      }
  }
  
</code></pre>
<pre><code>
1. 在web.xml中配置 Filter

   ```xml
   &lt;filter&gt;
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
       &lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter-class&gt;
   &lt;/filter&gt;
   &lt;filter-mapping&gt;
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
       &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;
       &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
       &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
       &lt;!-- 别偷懒写个 /* --&gt;
   &lt;/filter-mapping&gt;
</code></pre>
<h2 id="12-监听器">12、监听器</h2>
<p>实现一个监听器的接口；（有n种监听器）</p>
<ol>
<li>
<p>编写一个监听器</p>
<p>实现监听器的接口…</p>
<p>依赖的jar包<img src="https://img-blog.csdnimg.cn/2020050820562995.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {

    //创建session监听： 看你的一举一动
    //一旦创建Session就会触发一次这个事件！
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        System.out.println(se.getSession().getId());

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(1);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count+1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }

    //销毁session监听
    //一旦销毁Session就会触发一次这个事件！
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(0);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count-1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }


    /*
    Session销毁：
    1. 手动销毁  getSession().invalidate();
    2. 自动销毁
     */
}

</code></pre>
</li>
<li>
<p>web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;!--注册监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
</li>
<li>
<p>看情况是否使用！</p>
</li>
</ol>
<h2 id="13-过滤器-监听器常见应用">13、过滤器、监听器常见应用</h2>
<p><strong>监听器：GUI编程中经常使用；</strong></p>
<pre><code class="language-java">public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;中秋节快乐&quot;);  //新建一个窗体
        Panel panel = new Panel(null); //面板
        frame.setLayout(null); //设置窗体的布局

        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255)); //设置背景颜色

        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0,255,0)); //设置背景颜色

        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
            }
        });

    }
}
</code></pre>
<p>用户登录之后才能进入主页！用户注销后就不能进入主页了！</p>
<ol>
<li>
<p>用户登录之后，向Sesison中放入用户的数据</p>
</li>
<li>
<p>进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！</p>
<pre><code class="language-java">HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;

if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
    response.sendRedirect(&quot;/error.jsp&quot;);
}

chain.doFilter(request,response);
</code></pre>
</li>
</ol>
<h2 id="14-jdbc">14、JDBC</h2>
<p>什么是JDBC ： Java连接数据库！</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200508154620734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="[(img-rZzTXmtn-1588757845422)(JavaWeb.assets/1568439601825.png)]" loading="lazy"></figure>
<p>需要jar包的支持：</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-conneter-java… 连接驱动（必须要导入）</li>
</ul>
<p><strong>实验环境搭建</strong></p>
<pre><code class="language-sql">CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);

INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,'张三','123456','zs@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,'李四','123456','ls@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,'王五','123456','ww@qq.com','2000-01-01');


SELECT	* FROM users;

</code></pre>
<p>导入数据库依赖</p>
<pre><code class="language-xml">&lt;!--mysql的驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>IDEA中连接数据库：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200508154638633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="[(img-XErw4ElS-1588757845423)(JavaWeb.assets/1568440926845.png)]" loading="lazy"></figure>
<p><strong>JDBC 固定步骤：</strong></p>
<ol>
<li>加载驱动</li>
<li>连接数据库,代表数据库</li>
<li>向数据库发送SQL的对象Statement : CRUD</li>
<li>编写SQL （根据业务，不同的SQL）</li>
<li>执行SQL</li>
<li>关闭连接（先开的后关）</li>
</ol>
<pre><code class="language-java">public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = &quot;select * from users&quot;;

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;));
            System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;));
            System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;));
            System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;));
            System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>预编译SQL</strong></p>
<pre><code class="language-java">public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = &quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;;

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；
        preparedStatement.setString(2,&quot;狂神说Java&quot;);//给第二个占位符？ 的值赋值为狂神说Java；
        preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？ 的值赋值为123456；
        preparedStatement.setString(4,&quot;24736743@qq.com&quot;);//给第四个占位符？ 的值赋值为1；
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i&gt;0){
            System.out.println(&quot;插入成功@&quot;);
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>事务</strong></p>
<p>要么都成功，要么都失败！</p>
<p>ACID原则：保证数据的安全。</p>
<pre><code class="language-java">开启事务
事务提交  commit()
事务回滚  rollback()
关闭事务

转账：
A:1000
B:1000
    
A(900)   --100--&gt;   B(1100) 
</code></pre>
<p><strong>Junit单元测试</strong></p>
<p>依赖</p>
<pre><code class="language-xml">&lt;!--单元测试--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>简单使用</p>
<p>@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！</p>
<pre><code class="language-java">@Test
public void test(){
    System.out.println(&quot;Hello&quot;);
}
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200508154657792.png" alt="[(img-OsUubVNQ-1588757845424)(JavaWeb.assets/1568442261610.png)]" loading="lazy"></figure>
<p>失败的时候是红色：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20200508154708211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="[(img-qv2oTEGI-1588757845425)(JavaWeb.assets/1568442289597.png)]" loading="lazy"></figure>
<p><strong>搭建一个环境</strong></p>
<pre><code class="language-sql">CREATE TABLE account(
   id INT PRIMARY KEY AUTO_INCREMENT,
   `name` VARCHAR(40),
   money FLOAT
);

INSERT INTO account(`name`,money) VALUES('A',1000);
INSERT INTO account(`name`,money) VALUES('B',1000);
INSERT INTO account(`name`,money) VALUES('C',1000);
6789
    @Test
    public void test() {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        Connection connection = null;

        //1.加载驱动
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //2.连接数据库,代表数据库
             connection = DriverManager.getConnection(url, username, password);

            //3.通知数据库开启事务,false 开启
            connection.setAutoCommit(false);

            String sql = &quot;update account set money = money-100 where name = 'A'&quot;;
            connection.prepareStatement(sql).executeUpdate();

            //制造错误
            //int i = 1/0;

            String sql2 = &quot;update account set money = money+100 where name = 'B'&quot;;
            connection.prepareStatement(sql2).executeUpdate();

            connection.commit();//以上两条SQL都执行成功了，就提交事务！
            System.out.println(&quot;success&quot;);
        } catch (Exception e) {
            try {
                //如果出现异常，就通知数据库回滚事务
                connection.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>
<h2 id="smbms超市管理项目">SMBMS(超市管理项目)</h2>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200516122458676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>数据库：<br>
<img src="https://img-blog.csdnimg.cn/20200516122532275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<strong>项目如何搭建？</strong><br>
考虑是不是用maven？ jar包，依赖</p>
<h3 id="搭建项目准备工作">搭建项目准备工作</h3>
<ol>
<li>
<p>搭建一个maven web 项目</p>
</li>
<li>
<p>配置Tomcat</p>
</li>
<li>
<p>测试项目是否能够跑起来</p>
</li>
<li>
<p>导入项目中需要的jar包;<br>
jsp，Servlet，mysql驱动jstl，stand…</p>
</li>
<li>
<p>构建项目包结构<br>
<img src="https://img-blog.csdnimg.cn/202005161230352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>编写实体类<br>
ROM映射:表-类映射</p>
</li>
<li>
<p>编写基础公共类<br>
1、数据库配置文件（mysql5.xx和8.xx的编写有差异）</p>
<pre><code class="language-xml">driver=com.mysql.jdbc.Driver
#在和mysql传递数据的过程中，使用unicode编码格式，并且字符集设置为utf-8
url=jdbc:mysql://127.0.0.1:3306/smbms?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8
user=root
password=root
12345
</code></pre>
<p>2、编写数据库的公共类</p>
</li>
</ol>
<pre><code class="language-java">package dao;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Properties;

/**
 * 操作数据库的基类--静态类
 * @author Administrator
 *
 */
public class BaseDao {
	
	static{//静态代码块,在类加载的时候执行
		init();
	}
	
	private static String driver;
	private static String url;
	private static String user;
	private static String password;
	
	//初始化连接参数,从配置文件里获得
	public static void init(){
		Properties params=new Properties();
		String configFile = &quot;database.properties&quot;;
		InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile);
		try {
			params.load(is);
		} catch (IOException e) {
			e.printStackTrace();
		}
		driver=params.getProperty(&quot;driver&quot;);
		url=params.getProperty(&quot;url&quot;);
		user=params.getProperty(&quot;user&quot;);
		password=params.getProperty(&quot;password&quot;);

	}   
	
	
	/**
	 * 获取数据库连接
	 * @return
	 */
	public static Connection getConnection(){
		Connection connection = null;
		try {
			Class.forName(driver);
			connection = DriverManager.getConnection(url, user, password);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return connection;
	}
	/**
	 * 查询操作
	 * @param connection
	 * @param pstm
	 * @param rs
	 * @param sql
	 * @param params
	 * @return
	 */
	public static ResultSet execute(Connection connection,PreparedStatement pstm,ResultSet rs,
			String sql,Object[] params) throws Exception{
		pstm = connection.prepareStatement(sql);
		for(int i = 0; i &lt; params.length; i++){
			pstm.setObject(i+1, params[i]);
		}
		rs = pstm.executeQuery();
		return rs;
	}
	/**
	 * 更新操作
	 * @param connection
	 * @param pstm
	 * @param sql
	 * @param params
	 * @return
	 * @throws Exception
	 */
	public static int execute(Connection connection,PreparedStatement pstm,
			String sql,Object[] params) throws Exception{
		int updateRows = 0;
		pstm = connection.prepareStatement(sql);
		for(int i = 0; i &lt; params.length; i++){
			pstm.setObject(i+1, params[i]);
		}
		updateRows = pstm.executeUpdate();
		return updateRows;
	}
	
	/**
	 * 释放资源
	 * @param connection
	 * @param pstm
	 * @param rs
	 * @return
	 */
	public static boolean closeResource(Connection connection,PreparedStatement pstm,ResultSet rs){
		boolean flag = true;
		if(rs != null){
			try {
				rs.close();
				rs = null;//GC回收
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				flag = false;
			}
		}
		if(pstm != null){
			try {
				pstm.close();
				pstm = null;//GC回收
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				flag = false;
			}
		}
		if(connection != null){
			try {
				connection.close();
				connection = null;//GC回收
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				flag = false;
			}
		}
		
		return flag;
	}

}
</code></pre>
<p>. 3、编写字符编码过滤器</p>
<ol>
<li>导入静态资源</li>
</ol>
<h3 id="登录功能实现">登录功能实现</h3>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20200516125301633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>编写前端页面</li>
<li>设置首页<br>
1.设置欢迎首页</li>
</ol>
<pre><code class="language-xml">  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
</code></pre>
<ol>
<li>编写dao层登录用户登录的接口</li>
</ol>
<pre><code class="language-java">public User getLoginUser(Connection connection, String userCode) throws Exception;
</code></pre>
<ol>
<li>编写dao层接口的实现类</li>
</ol>
<pre><code class="language-java">import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import dao.BaseDao;
import pojo.User;

public class UserDaoImpl implements UserDao{
	//持久层只做查询数据库的内容
	public User getLoginUser(Connection connection, String userCode) throws Exception{
		//准备三个对象
		PreparedStatement pstm = null;
		ResultSet rs = null;
		User user = null;
		//判断是否连接成功
		if(null != connection){
			String sql = &quot;select * from smbms_user where userCode=?&quot;;
			Object[] params = {userCode};
			rs = BaseDao.execute(connection, pstm, rs, sql, params);
			if(rs.next()){
				user = new User();
				user.setId(rs.getInt(&quot;id&quot;));
				user.setUserCode(rs.getString(&quot;userCode&quot;));
				user.setUserName(rs.getString(&quot;userName&quot;));
				user.setUserPassword(rs.getString(&quot;userPassword&quot;));
				user.setGender(rs.getInt(&quot;gender&quot;));
				user.setBirthday(rs.getDate(&quot;birthday&quot;));
				user.setPhone(rs.getString(&quot;phone&quot;));
				user.setAddress(rs.getString(&quot;address&quot;));
				user.setUserRole(rs.getInt(&quot;userRole&quot;));
				user.setCreatedBy(rs.getInt(&quot;createdBy&quot;));
				user.setCreationDate(rs.getTimestamp(&quot;creationDate&quot;));
				user.setModifyBy(rs.getInt(&quot;modifyBy&quot;));
				user.setModifyDate(rs.getTimestamp(&quot;modifyDate&quot;));
			}
			BaseDao.closeResource(null, pstm, rs);
		}
		return user;
	}	
}
</code></pre>
<ol>
<li>业务层接口</li>
</ol>
<pre><code class="language-java">//用户登录
public User login(String userCode, String userPassword);
</code></pre>
<ol>
<li>业务层实现类</li>
</ol>
<pre><code class="language-java">import java.sql.Connection;

//import org.junit.Test;

import dao.BaseDao;
import dao.user.UserDao;
import dao.user.UserDaoImpl;
import pojo.User;

public class UserServiceImpl implements UserService{
	//业务层都会调用dao层.所以我们要引入Dao层（重点）
	//只处理对应业务
	
	private UserDao userDao;
	public UserServiceImpl(){
		userDao = new UserDaoImpl();
	}
	
	public User login(String userCode,String userPassword) {
		// TODO Auto-generated method stub
		Connection connection = null;
		//通过业务层调用对应的具体数据库操作
		User user = null;
		try {
			connection = BaseDao.getConnection();
			user = userDao.getLoginUser(connection, userCode);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			BaseDao.closeResource(connection, null, null);
		}
		return user;
	}
	
	/*@Test
	public void test() {
		UserServiceImpl userService = new UserServiceImpl();
		String userCode = &quot;admin&quot;;
		String userPassword = &quot;12345678&quot;;
		User admin = userService.login(userCode, userPassword);
		System.out.println(admin.getUserPassword());

	}
	*/
}
</code></pre>
<ol>
<li>编写Servlet</li>
</ol>
<pre><code class="language-java">import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import pojo.User;
import util.Constants;
import service.user.UserService;
import service.user.UserServiceImpl;

@SuppressWarnings(&quot;serial&quot;)
public class LoginServlet extends HttpServlet{
	//接受用户参数、调用业务层、转发视图
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		
		System.out.println(&quot;login ============ &quot; );
		//获取用户名和密码
		String userCode = req.getParameter(&quot;userCode&quot;);
		String userPassword = req.getParameter(&quot;userPassword&quot;);
		//调用service方法，进行用户匹配
		UserService userService = new UserServiceImpl();
		User user = userService.login(userCode,userPassword);
		if(null != user){//登录成功
			//放入session
			req.getSession().setAttribute(Constants.USER_SESSION,user);
			//页面跳转（frame.jsp）
			resp.sendRedirect(&quot;jsp/frame.jsp&quot;);
		}else{
			//页面跳转（login.jsp）带出提示信息--转发
			req.setAttribute(&quot;error&quot;, &quot;用户名或密码不正确&quot;);
			req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req,resp);
		}
	}
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		doGet(req, resp);
	}
}
</code></pre>
<ol>
<li>注册Servlet</li>
</ol>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.kuang.servlet.user.LoginServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>测试访问,保证以上功能可以成功</li>
</ol>
<h3 id="登录功能优化">登录功能优化</h3>
<p>注销功能<br>
思路：移除session，返回登录页面</p>
<pre><code class="language-java">public class LogoutServlet extends HttpServlet {

	public void doPOST(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		//清除session
		request.getSession().removeAttribute(Constants.USER_SESSION);
		response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;);//返回登录页面
	}

}
</code></pre>
<p>注册xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;servlet.user.LogoutServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/jsp/logout.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
12345678
</code></pre>
<h3 id="登录拦截优化">登录拦截优化</h3>
<p>编写一个过滤器，并注册</p>
<pre><code class="language-java">import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import pojo.User;
import util.Constants;

public class SysFilter implements Filter{
	public void init(FilterConfig filterConfig) throws ServletException{
		
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
			throws IOException, ServletException {
		// TODO 自动生成的方法存根
		HttpServletRequest request =  (HttpServletRequest)req;
		HttpServletResponse response = (HttpServletResponse)resp;
		
		//过滤器，从session中获取用户
		User user = (User)request.getSession().getAttribute(Constants.USER_SESSION);
		if(user == null){//已经被移除或者注销了，或者未登录
			response.sendRedirect(&quot;/smbms/error.jsp&quot;);
		}else {
			chain.doFilter(req, resp);
		}
	}

	@Override
	public void destroy() {
		// TODO 自动生成的方法存根
		
	}
}
</code></pre>
<p>注册xml</p>
<pre><code class="language-xml">&lt;!-- 用户登录过滤器 --&gt;
&lt;filter&gt;
	&lt;filter-name&gt;SysFilter&lt;/filter-name&gt;
	&lt;filter-class&gt;filter.SysFilter&lt;/filter-class&gt;
&lt;/filter&gt; 
&lt;filter-mapping&gt;
	&lt;filter-name&gt;SysFilter&lt;/filter-name&gt;
	&lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>测试，登录，注销，权限，都要保证OK</p>
<h3 id="密码修改">密码修改</h3>
<ol>
<li>导入前端素材</li>
</ol>
<pre><code class="language-html">&lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath }/jsp/pwdmodify.jsp&quot;&gt;密码修改&lt;/a&gt;&lt;/li&gt;
</code></pre>
<ol>
<li>写项目，建议从底层向上写<br>
<img src="https://img-blog.csdnimg.cn/20200516180913135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
<li>UserDao接口</li>
</ol>
<pre><code class="language-java">//修改当前用户密码
	public int updatePwd(Connection connection,int id,int password)throws SQLException, Exception;
</code></pre>
<ol>
<li>UserDao接口实现类</li>
</ol>
<pre><code class="language-java">@Override//修改当前密码
	public int updatePwd(Connection connection, int id, int password) throws Exception {
		// TODO 自动生成的方法存根
		PreparedStatement pstm = null;
		int execute =0;
		if(connection!=null) {
			String sql = &quot;update smbms_user set = userPassword = ? where id = ?&quot;;
			Object[] params = {password,id};
			execute = BaseDao.execute(connection, pstm, sql, params);
			BaseDao.closeResource(null, pstm, null);
		}
		return execute;			
	}
</code></pre>
<ol>
<li>UserService层</li>
</ol>
<pre><code class="language-java">public boolean updatePwd(int id,int password)throws SQLException, Exception;
</code></pre>
<ol>
<li>UserService实现类</li>
</ol>
<pre><code class="language-java">public boolean updatePwd(int id, int password) throws SQLException, Exception {
		// TODO 自动生成的方法存根
		Connection connection = null;
		boolean flag = false;
		//修改密码
		try {
			connection = BaseDao.getConnection();
			if(userDao.updatePwd(connection, id, password)&gt;0) {
				flag = true;
			}
		} catch (SQLException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		} finally {
			BaseDao.closeResource(connection, null, null);
			
		}
		return flag;
	}
</code></pre>
<ol>
<li>servlet记得实现复用，要提取出方法！<br>
在 <strong>dao层</strong> 和 <strong>service层</strong> 自己写映射类和实现类<br>
下面是 <strong>servlet层</strong> 的主体</li>
</ol>
<pre><code class="language-java">public class UserServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		String method = req.getParameter(&quot;method&quot;);
		if (method != &quot;savepwd&quot; &amp;&amp; method != null) {
			this.updatePwd(req, resp);
		}
		//实现复用~~~~~~
		// 想添加新的增删改查，直接用if(method != &quot;savepwd&quot; &amp;&amp; method != null);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		doGet(req, resp);
	}

	public void updatePwd(HttpServletRequest req, HttpServletResponse resp) {
		// 通过session获得用户id
		Object o = req.getSession().getAttribute(Constants.USER_SESSION);
		String newpassword = req.getParameter(&quot;newpassword&quot;);
		boolean flag = false;
		if (o != null &amp;&amp; newpassword != null) {
			UserService userService = new UserServiceImpl();

			try {
				flag = userService.updatePwd(((User) o).getId(), newpassword);
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			} catch (Exception e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
			if (flag) {
				req.setAttribute(&quot;message&quot;, &quot;密码修改成功，请退出，使用新密码登录&quot;);
				// 密码修改成功,移除session(移除后不能再次修改密码,建议不移除)
				req.getSession().removeAttribute(Constants.USER_SESSION);
			} else {
				// 密码修改失败
				req.setAttribute(&quot;message&quot;, &quot;密码修改失败&quot;);
			}

		} else {
			// 密码修改有问题
			req.setAttribute(&quot;message&quot;, &quot;新密码有问题&quot;);
		}
		try {
			req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req, resp);
		} catch (ServletException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		} catch (IOException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		}
	}
}
</code></pre>
<p>注册xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
		&lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;servlet.user.UserServlet&lt;/servlet-class&gt;
	&lt;/servlet&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/jsp/user.do&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
</code></pre>
<ol>
<li>测试</li>
</ol>
<h3 id="优化密码修改使用ajax">优化密码修改使用Ajax</h3>
<ol>
<li>阿里巴巴的fastjson</li>
</ol>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.68&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>后台代码修改</li>
</ol>
<p>导入阿里的包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.68&lt;/version&gt;
&lt;/dependency&gt;
import java.io.IOException;
import java.io.PrintWriter;
//import java.io.Writer;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.mysql.cj.util.StringUtils;
import com.mysql.cj.xdevapi.JsonArray;

//import com.mysql.cj.util.StringUtils;

import pojo.User;
import service.user.UserService;
import service.user.UserServiceImpl;
import util.Constants;

@SuppressWarnings(&quot;serial&quot;)
public class UserServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		String method = req.getParameter(&quot;method&quot;);
		if (method.equals( &quot;savepwd&quot;) &amp;&amp; method != null) {
			this.updatePwd(req, resp);
		}else if (method.equals( &quot;pwdmodify&quot;) &amp;&amp; method != null) {
			
		}
		// 想添加新的增删改查，直接用if(method != &quot;savepwd&quot; &amp;&amp; method != null);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO 自动生成的方法存根
		doGet(req, resp);
	}

	public void updatePwd(HttpServletRequest req, HttpServletResponse resp) {
		// 通过session获得用户id
		Object o = req.getSession().getAttribute(Constants.USER_SESSION);
		String newpassword = req.getParameter(&quot;newpassword&quot;);
		boolean flag = false;
		if (o != null &amp;&amp; newpassword != null) {
			UserService userService = new UserServiceImpl();

			try {
				flag = userService.updatePwd(((User) o).getId(), newpassword);
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			} catch (Exception e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
			if (flag) {
				req.setAttribute(&quot;message&quot;, &quot;密码修改成功，请退出，使用新密码登录&quot;);
				// 密码修改成功,移除session(移除后不能再次修改密码,建议不移除)
				req.getSession().removeAttribute(Constants.USER_SESSION);
			} else {
				// 密码修改失败
				req.setAttribute(&quot;message&quot;, &quot;密码修改失败&quot;);
			}

		} else {
			// 密码修改有问题
			req.setAttribute(&quot;message&quot;, &quot;新密码有问题&quot;);
		}
		try {
			req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req, resp);
		} catch (ServletException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		} catch (IOException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		}
	}

	public void pqdmodify(HttpServletRequest req, HttpServletResponse resp) {
		// 通过session获得用户id
		Object o = req.getSession().getAttribute(Constants.USER_SESSION);
		String oldpassword = req.getParameter(&quot;oldpassword&quot;);
		
		Map&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;();
		if(o==null) {//session失效，session过期了
			resultMap.put(&quot;result&quot;,&quot;seesionerror&quot;);
		}else if(StringUtils.isNullOrEmpty(oldpassword)){//输入密码为空
			resultMap.put(&quot;result&quot;,&quot;error&quot;);
		}else {//
			String userPassword = ((User)o).getUserPassword();//seesion中的用户密码
			if(oldpassword.equals(userPassword)) {
				resultMap.put(&quot;result&quot;,&quot;true&quot;);
			}else {
				resultMap.put(&quot;result&quot;,&quot;false&quot;);
			}
		}
		
		
		try {
			resp.setContentType(&quot;application/josn&quot;);
			PrintWriter writer = resp.getWriter();
			/*
			 * resultMap = [&quot;result&quot;,&quot;sessionerror&quot;,&quot;result&quot;,error]
			 * josn格式={key,value
			 */
			//writer.write(JSONArray.toJSONString(resultMap));
			writer.write(JsonArray.class.toString());
			writer.flush();
			writer.close();
		} catch (IOException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		}
	}
}
</code></pre>
<ol>
<li>测试</li>
</ol>
<h3 id="用户管理实现">用户管理实现</h3>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20200517210107269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>导入分页的工具类-PageSupport</li>
<li>用户列表页面导入-userlist.jsp</li>
</ol>
<h4 id="1-获取用户数量">1、获取用户数量</h4>
<ol>
<li>UserDao</li>
</ol>
<pre><code class="language-java">//根据用户名或者角色查询用户总数
public int getUserCount(Connection connection,String username ,int userRole)throws SQLException, Exception;
</code></pre>
<ol>
<li>UserDaoImpl</li>
</ol>
<pre><code class="language-java">@Override
	public int getUserCount(Connection connection, String userName, int userRole)
			throws Exception {
		// TODO Auto-generated method stub
		PreparedStatement pstm = null;
		ResultSet rs = null;
		int count = 0;
		if(connection != null){
			StringBuffer sql = new StringBuffer();
			sql.append(&quot;select count(1) as count from smbms_user u,smbms_role r where u.userRole = r.id&quot;);
			List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
			if(!StringUtils.isNullOrEmpty(userName)){
				sql.append(&quot; and u.userName like ?&quot;);
				list.add(&quot;%&quot;+userName+&quot;%&quot;);
			}
			if(userRole &gt; 0){
				sql.append(&quot; and u.userRole = ?&quot;);
				list.add(userRole);
			}
			Object[] params = list.toArray();
			System.out.println(&quot;sql ----&gt; &quot; + sql.toString());
			rs = BaseDao.execute(connection, pstm, rs, sql.toString(), params);
			if(rs.next()){
				count = rs.getInt(&quot;count&quot;);
			}
			BaseDao.closeResource(null, pstm, rs);
		}
		return count;
	}
</code></pre>
<ol>
<li>UserService</li>
</ol>
<pre><code class="language-java">//查询记录数
	public int getUserCount(String username, int userRole);
</code></pre>
<ol>
<li>UserServiceImpl</li>
</ol>
<pre><code class="language-java">//查询记录数
	@Override
	public int getUserCount(String queryUserName, int queryUserRole) {
		// TODO Auto-generated method stub
		Connection connection = null;
		int count = 0;
		System.out.println(&quot;queryUserName ---- &gt; &quot; + queryUserName);
		System.out.println(&quot;queryUserRole ---- &gt; &quot; + queryUserRole);
		try {
			connection = BaseDao.getConnection();
			count = userDao.getUserCount(connection, queryUserName,queryUserRole);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			BaseDao.closeResource(connection, null, null);
		}
		//System.out.println(&quot;count&quot;+count);
		return count;
	}
</code></pre>
<h4 id="2-获取用户列表">2、获取用户列表</h4>
<p>1.UserDao</p>
<pre><code class="language-java">//通过条件查询-userList
	public List&lt;User&gt; getUserList(Connection connection, String userName, int userRole, int currentPageNo, int pageSize)throws Exception;
</code></pre>
<ol>
<li>UserDaoImpl</li>
</ol>
<pre><code class="language-java">@Override
	public List&lt;User&gt; getUserList(Connection connection, String userName,int userRole,int currentPageNo, int pageSize)
			throws Exception {
		// TODO Auto-generated method stub
		PreparedStatement pstm = null;
		ResultSet rs = null;
		List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
		if(connection != null){
			StringBuffer sql = new StringBuffer();
			sql.append(&quot;select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r where u.userRole = r.id&quot;);
			List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
			if(!StringUtils.isNullOrEmpty(userName)){
				sql.append(&quot; and u.userName like ?&quot;);
				list.add(&quot;%&quot;+userName+&quot;%&quot;);
			}
			if(userRole &gt; 0){
				sql.append(&quot; and u.userRole = ?&quot;);
				list.add(userRole);
			}
			//在数据库中，分页显示 limit startIndex，pageSize；总数
			//当前页  (当前页-1)*页面大小
			//0,5	1,0	 01234
			//5,5	5,0	 56789
			//10,5	10,0 10~
			sql.append(&quot; order by creationDate DESC limit ?,?&quot;);
			currentPageNo = (currentPageNo-1)*pageSize;
			list.add(currentPageNo);
			list.add(pageSize);
			
			Object[] params = list.toArray();
			System.out.println(&quot;sql ----&gt; &quot; + sql.toString());
			
			rs = BaseDao.execute(connection, pstm, rs, sql.toString(), params);
			while(rs.next()){
				User _user = new User();
				_user.setId(rs.getInt(&quot;id&quot;));
				_user.setUserCode(rs.getString(&quot;userCode&quot;));
				_user.setUserName(rs.getString(&quot;userName&quot;));
				_user.setGender(rs.getInt(&quot;gender&quot;));
				_user.setBirthday(rs.getDate(&quot;birthday&quot;));
				_user.setPhone(rs.getString(&quot;phone&quot;));
				_user.setUserRole(rs.getInt(&quot;userRole&quot;));
				_user.setUserRoleName(rs.getString(&quot;userRoleName&quot;));
				userList.add(_user);
			}
			BaseDao.closeResource(null, pstm, rs);
		}
		return userList;
	}
</code></pre>
<ol>
<li>UserService</li>
</ol>
<pre><code class="language-java">//根据条件查询用户列表
	public List&lt;User&gt; getUserList(String queryUserName, int queryUserRole, int currentPageNo, int pageSize);
</code></pre>
<ol>
<li>UserServiceImpl</li>
</ol>
<pre><code class="language-java">@Override
	public List&lt;User&gt; getUserList(String queryUserName,int queryUserRole,int currentPageNo, int pageSize) {
		// TODO Auto-generated method stub
		Connection connection = null;
		List&lt;User&gt; userList = null;
		System.out.println(&quot;queryUserName ---- &gt; &quot; + queryUserName);
		System.out.println(&quot;queryUserRole ---- &gt; &quot; + queryUserRole);
		System.out.println(&quot;currentPageNo ---- &gt; &quot; + currentPageNo);
		System.out.println(&quot;pageSize ---- &gt; &quot; + pageSize);
		try {
			connection = BaseDao.getConnection();
			userList = userDao.getUserList(connection, queryUserName,queryUserRole,currentPageNo,pageSize);
		} catch (Exception e) {
			// TODO Auto-generated catch block 
			e.printStackTrace();
		}finally{
			BaseDao.closeResource(connection, null, null);
		}
		return userList;
	}
</code></pre>
<h4 id="3-获取角色操作">3、获取角色操作</h4>
<p>为了我们的职责统一，我们可以把<strong>角色的操作</strong>单独放在一个包中，和pojo类对应。。。</p>
<ol>
<li>RoleDao</li>
</ol>
<pre><code class="language-java">//获取角色列表
		public List&lt;Role&gt; getRoleList(Connection connection)throws Exception;
</code></pre>
<ol>
<li>RoleDaoIpml</li>
</ol>
<pre><code class="language-java">public class RoleDaoImpl implements RoleDao {

	@Override
	public List&lt;Role&gt; getRoleList(Connection connection) throws Exception {
		PreparedStatement pstm = null;
		ResultSet rs = null;
		List&lt;Role&gt; roleList = new ArrayList&lt;Role&gt;();
		if (connection != null) {
			String sql = &quot;select * from smbms_role&quot;;
			Object[] params = {};
			rs = BaseDao.execute(connection, pstm, rs, sql, params);
			while (rs.next()) {
				Role _role = new Role();
				_role.setId(rs.getInt(&quot;id&quot;));
				_role.setRoleCode(rs.getString(&quot;roleCode&quot;));
				_role.setRoleName(rs.getString(&quot;roleName&quot;));
				roleList.add(_role);
			}
			BaseDao.closeResource(null, pstm, rs);
		}

		return roleList;
	}
}
</code></pre>
<ol>
<li>RoleService</li>
</ol>
<pre><code class="language-java">public interface RoleService {
	//角色列表查询
	public List&lt;Role&gt; getRoleList();  
	
}
</code></pre>
<ol>
<li>RoleServiceIpml</li>
</ol>
<pre><code class="language-java">public class RoleServiceImpl implements RoleService{
	
	private RoleDao roleDao;
	
	public RoleServiceImpl(){
		roleDao = new RoleDaoImpl();
	}
	
	@Override
	public List&lt;Role&gt; getRoleList() {
		Connection connection = null;
		List&lt;Role&gt; roleList = null;
		try {
			connection = BaseDao.getConnection();
			roleList = roleDao.getRoleList(connection);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			BaseDao.closeResource(connection, null, null);
		}
		return roleList;
	}
	
}
</code></pre>
<h4 id="4-用户显示的servlet">4、用户显示的Servlet</h4>
<ol>
<li>获取用户前端的数据（查询）</li>
<li>判断请求是否需要执行，看参数的值判断</li>
<li>为了实现分页，需要计算出当前页面和总页面，页面大小…</li>
<li>用户列表展示</li>
<li>返回前端</li>
</ol>
<pre><code class="language-java">//重点、难点
	private void query(HttpServletRequest req, HttpServletResponse resp) {
		// TODO 自动生成的方法存根
		//查询用户列表
		//从前端获取数据
		//查询用户列表
		String queryUserName = req.getParameter(&quot;queryname&quot;);
		String temp = req.getParameter(&quot;queryUserRole&quot;);
		String pageIndex = req.getParameter(&quot;pageIndex&quot;);
		int queryUserRole = 0;
		
		//获取用户列表
		UserServiceImpl userService = new UserServiceImpl();
		List&lt;User&gt; userList = null;
		
		//第一此请求肯定是走第一页，页面大小固定的
		//设置页面容量
    	int pageSize = 5;//把它设置在配置文件里,后面方便修改
    	//当前页码
    	int currentPageNo = 1;
		
		if(queryUserName == null){
			queryUserName = &quot;&quot;;
		}
		if(temp != null &amp;&amp; !temp.equals(&quot;&quot;)){
			queryUserRole = Integer.parseInt(temp);
		}
		if(pageIndex != null) {
			currentPageNo = Integer.parseInt(pageIndex);
		}
		//获取用户总数（分页	上一页：下一页的情况）
		//总数量（表）	
    	int totalCount	= userService.getUserCount(queryUserName,queryUserRole);
			
		//总页数支持
		PageSupport pageSupport = new PageSupport();
		pageSupport.setCurrentPageNo(currentPageNo);
		pageSupport.setPageSize(pageSize);
		pageSupport.setTotalCount(totalCount);
		
		int totalPageCount =pageSupport.getTotalPageCount();//总共有几页
		//(totalCount+pageSize-1/pageSize)取整
		// pageSupport.getTotalCount()
		
		//System.out.println(&quot;totalCount =&quot;+totalCount);
		//System.out.println(&quot;pageSize =&quot;+pageSize);
		//System.out.println(&quot;totalPageCount =&quot;+totalPageCount);
		//控制首页和尾页
		//如果页面小于 1 就显示第一页的东西
		if(currentPageNo &lt; 1) {
			currentPageNo = 1;
		}else if(currentPageNo &gt; totalPageCount) {//如果页面大于了最后一页就显示最后一页
			currentPageNo =totalPageCount;
		}
		
		userList = userService.getUserList(queryUserName, queryUserRole, currentPageNo, pageSize);
		req.setAttribute(&quot;userList&quot;, userList);
		
		RoleServiceImpl roleService = new RoleServiceImpl();
		List&lt;Role&gt; roleList = roleService.getRoleList();
		req.setAttribute(&quot;roleList&quot;, roleList);
		req.setAttribute(&quot;totalCount&quot;, totalCount); 
		req.setAttribute(&quot;currentPageNo&quot;, currentPageNo);
		req.setAttribute(&quot;totalPageCount&quot;, totalPageCount);
		req.setAttribute(&quot;queryUserName&quot;, queryUserName);
		req.setAttribute(&quot;queryUserRole&quot;, queryUserRole);
		
		//返回前端
		try {
			req.getRequestDispatcher(&quot;userlist.jsp&quot;).forward(req, resp);
		} catch (ServletException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		} catch (IOException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		}

	}
</code></pre>
<p>小黄鸭调试法：自言自语</p>
<p><strong>项目原理流程图：</strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMTkvbUNhOGxCTW9kaXBKd1FoLnBuZw?x-oss-process=image/format,png" alt="项目原理流程图" loading="lazy"><br>
<em>剩下的手打一遍，然后各种打错排查，，，<br>
虽然不建议 ，但还是直接导入文件算了，粘贴复制也行0-0</em>（前提是自己先码一遍）</p>
<h3 id="源码在最后">源码在最后</h3>
<p>SMBMS项目源码链接：<br>
<a href="https://www.lanzoux.com/iGLJTdusuyf">Eclipse版（个人手打版，已排错，可运行）<br>
https://www.lanzoux.com/iGLJTdusuyf</a></p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/33、搜索旋转排序数组/" class="post-title gt-a-link">
                    中等33. 搜索旋转排序数组
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

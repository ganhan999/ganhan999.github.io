<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Java JVM | Gridea</title>

<link rel="shortcut icon" href="https://ganhan999.github.io//favicon.ico?v=1615810100798">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ganhan999.github.io//styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Gridea
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1615810100798" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java JVM
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-12-12 ·
                    </time>
                    
                        <a href="https://ganhan999.github.io/tag/pVOKe1jE1_/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="jvm虚拟机狂神说">jvm虚拟机狂神说</h1>
<h2 id="jvm探究">JVM探究</h2>
<ul>
<li>请你谈谈对JVM的理解? java8虚拟机和之前的变化更新</li>
<li>什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?</li>
<li>JVM常用的调优参数有哪些?</li>
<li>内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?</li>
<li>谈谈JVM中,类加载器你的认识?</li>
</ul>
<h2 id="1jvm的位置"><strong>1.jvm的位置</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200926115505543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="2jvm的体系结构"><strong>2.jvm的体系结构</strong></h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200926115523922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020092611555012.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="3类加载器"><strong>3.类加载器</strong></h2>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200926115601139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="4双亲委派机制"><strong>4.双亲委派机制</strong></h2>
<ol>
<li>
<p>虚拟机自带的加载器</p>
</li>
<li>
<p>启动类 (根) 加载器</p>
</li>
<li>
<p>扩展类加载器</p>
</li>
<li>
<p>应用程序加载器</p>
<p>app—&gt;扩展类(ext) ----&gt; (启动类)根加载器(rt) —&gt;</p>
<ul>
<li>1.类加载器收到类加载的请求</li>
<li>2.将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器(根加载器rt)</li>
<li>3.启动类加载器检查是否能够加载当前这个类, 能够加载就结束了, 使用当前加载器,否则抛出异常,通知子类加载器进行加载.</li>
<li>4.重复步骤3.</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200926115616115.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
</li>
</ol>
<h2 id="5沙箱安全机制"><strong>5.沙箱安全机制</strong></h2>
<p>Java安全模型的核心就是Java沙箱(sandbox) ,<br>
 什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是<strong>将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。<br>
 沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。<br>
 所有的Java程序运行都可以指定沙箱，可以定制安全策略。<br>
 在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱Sandbox)机制。如下图所示JDK1.0安全模型<br>
<img src="https://img-blog.csdnimg.cn/20200714083918143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 JDK1.0安全模型</p>
<p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型<br>
<img src="https://img-blog.csdnimg.cn/20200714084054727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 JDK1.1安全模型</p>
<p>在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示<br>
<img src="https://img-blog.csdnimg.cn/20200714084127482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 JDK1.2安全模型</p>
<p>当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)<br>
<img src="https://img-blog.csdnimg.cn/20200714084152611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 JDK1.6安全模型</p>
<h3 id="组成沙箱的基本组件">组成沙箱的基本组件</h3>
<p>●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。<br>
●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用<br>
  它防止恶意代码去干涉善意的代码;<br>
  它守护了被信任的类库边界;<br>
  它将代码归入保护域,确定了代码可以进行哪些操作。<br>
 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。<br>
 类装载器采用的机制是双亲委派模式。<br>
 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;<br>
 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。<br>
●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。<br>
●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。<br>
●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:<br>
  安全提供者<br>
  消息摘要<br>
  数字签名<br>
  加密<br>
  鉴别</p>
<h2 id="6native"><strong>6.Native</strong>*</h2>
<p> native :凡是带了native关键字的，说明java的作用范围达不到了，<strong>回去调用底层c语言的库!</strong><br>
 会进入本地方法栈<br>
 调用本地方法本地接口 <strong>JNI</strong> (<strong>Java Native Interface</strong>)<br>
 JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: C、C++<br>
 Java诞生的时候C、C++横行，想要立足，必须要有调用C、C++的程序<br>
 它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法<br>
 在最终执行的时候，加载本地方法库中的方法通过JNI<br>
 例如：Java程序驱动打印机，管理系统，掌握即可，在企业级应用比较少<br>
 private native void start0();<br>
 //调用其他接口:Socket. . WebService~. .http~</p>
<h3 id="native-method-stack">Native Method Stack</h3>
<p>它的具体做法是Native Method Stack中登记native方法，在( Execution Engine )执行引擎执行的时候加载Native Libraies。[本地库]</p>
<h3 id="native-interface本地接口">Native Interface本地接口</h3>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序, Java在诞生的时候是C/C++横行的时候，想要立足，必须有调用C、C++的程序，于是就在内存中专门开辟了块区域处理标记为native的代码，它的具体做法是在Native Method Stack 中登记native方法,在( Execution Engine )执行引擎执行的时候加载Native Libraies。<br>
 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用Socket通信,也可以使用Web Service等等，不多做介绍!</p>
<h2 id="7pc寄存器"><strong>7.pc寄存器</strong></h2>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2020092611563737.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>
<h2 id="8方法区-method-area">8.方法区 Method Area</h2>
<p>方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;<br>
 <strong>静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</strong><br>
<img src="https://img-blog.csdnimg.cn/20200715083015673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 类实例化后</p>
<h2 id="9栈">9.栈</h2>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200715083122724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 为什么main()先执行，最后结束~</p>
<p>栈:先进后出<br>
桶:后进先出<br>
队列:先进先出( FIFO : First Input First Output )<br>
栈:<strong>栈内存,主管程序的运行,生命周期和线程同步</strong>;<br>
<strong>线程结束，栈内存也就是释放,对于栈来说,不存在垃圾回收问题</strong><br>
一旦线程结束，栈就Over!<br>
栈内存中:</p>
<p><strong>8大基本类型+对象引用+实例的方法</strong></p>
<p><strong>栈运行原理:栈帧</strong><br>
栈满了: StackOverflowError</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200715083341700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 栈的位置示意图</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200715083903686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 栈帧图解 栈底部子帧指向上一个栈的方法 上一个栈的父帧指向栈底部方法</p>
<h2 id="10三种jvm">10.三种JVM</h2>
<p>●Sun公司HotSpot Java Hotspot™ 64-Bit Server VM (build 25.181-b13,mixed mode)<br>
●BEA JRockit<br>
●IBM J9VM<br>
我们学习都是: Hotspot</p>
<h2 id="11堆">11.堆</h2>
<p>Heap, 一个JVM只有一个堆内存，堆内存的大小是可以调节的。<br>
类加载器读取了类文件后，一般会把什么东西放到堆中?<br>
类, 方法，常量,变量~，保存我们所有引用类型的真实对象;<br>
堆内存中还要细分为三个区域:<br>
●新生区(伊甸园区) Young/New<br>
●养老区old<br>
●永久区Perm<br>
<img src="https://img-blog.csdnimg.cn/20200715084134841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 堆内存详细划分</p>
<p>GC垃圾回收,主要是在伊甸园区和养老区~<br>
假设内存满了,OOM,堆内存不够! java.lang.OutOfMemoryError:Java heap space<br>
永久存储区里存放的都是Java自带的 例如lang包中的类 如果不存在这些，Java就跑不起来了<br>
在JDK8以后，永久存储区改了个名字(元空间)<br>
<img src="https://img-blog.csdnimg.cn/20200715084319804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 堆内存溢出</p>
<h2 id="12新生区-老年区">12.新生区、老年区</h2>
<h3 id="新生区">新生区</h3>
<p>●类:诞生和成长的地方，甚至死亡;<br>
●伊甸园，所有的对象都是在伊甸园区new出来的!<br>
●幸存者区(0,1)<br>
<img src="https://img-blog.csdnimg.cn/20200715084818824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 重GC和轻GC</p>
<p><strong>伊甸园满了就触发轻GC，经过轻GC存活下来的就到了幸存者区，幸存者区满之后意味着新生区也满了，则触发重GC，经过重GC之后存活下来的就到了养老区。</strong><br>
真理:经过研究，99%的对象都是临时对象!|</p>
<h2 id="13永久区">13.永久区</h2>
<p><strong>这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境~</strong> 这个区域不存在垃圾回收，关闭虚拟机就会释放内存<br>
●jdk1.6之前:永久代,常量池是在方法区;<br>
●jdk1.7:永久代,但是慢慢的退化了，去永久代，常量池在堆中<br>
●jdk1.8之后:无永久代,常量池在元空间</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/2020071515245167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 JVM探究</p>
<p>元空间：逻辑上存在，物理上不存在 (因为存储在本地磁盘内) 所以最后并不算在JVM虚拟机内存中</p>
<h2 id="14堆内存调优">14.堆内存调优</h2>
<p>测试代码</p>
<pre><code class="language-java">public static void main(String[] args) {
    String s = &quot;&quot;;
    while (true) {
        s += &quot;11111111111111111111111111111111111111111111111111111&quot;;
    }
}
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200715152713345.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 虚拟机放入参数</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/2020071515273798.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 控制台报错 到最后会报OOM（OutOfMemory）堆内存溢出报错</p>
<h3 id="在一个项目中突然出现了oom故障那么该如何排除-研究为什么出错~">在一个项目中，突然出现了OOM故障,那么该如何排除 研究为什么出错~</h3>
<p>●能够看到代码第几行出错:内存快照分析工具，MAT, Jprofiler<br>
●Dubug, 一行行分析代码!</p>
<h3 id="mat-jprofiler作用">MAT, Jprofiler作用</h3>
<p>●分析Dump内存文件,快速定位内存泄露;<br>
●获得堆中的数据<br>
●获得大的对象~</p>
<h3 id="mat是eclipse集成使用-在这里不学">MAT是eclipse集成使用 在这里不学</h3>
<h3 id="jprofile使用">Jprofile使用</h3>
<p>1.在idea中下载jprofile插件<br>
2.联网下载jprofile客户端<br>
3.在idea中VM参数中写参数 -Xms1m -Xmx8m -XX: +HeapDumpOnOutOfMemoryError<br>
4.运行程序后在jprofile客户端中打开找到错误 告诉哪个位置报错<br>
命令参数详解<br>
// -Xms设置初始化内存分配大小/164<br>
// -Xmx设置最大分配内存，默以1/4<br>
// -XX: +PrintGCDetails // 打印GC垃圾回收信息<br>
// -XX: +HeapDumpOnOutOfMemoryError //oom DUMP</p>
<h2 id="15-gc">15. GC</h2>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200715153054271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>图 GC的作用区</p>
<p>JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~<br>
●新生代<br>
<strong>●幸存区(form，to)</strong><br>
●老年区<br>
GC两种类:轻GC (普通的GC)， 重GC (全局GC)<br>
GC常见面试题目:<br>
●JVM的内存模型和分区~详细到每个区放什么?<br>
<img src="https://img-blog.csdnimg.cn/20200715153153103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 JVM内存模型和分区</p>
<p>●堆里面的分区有哪些?<br>
Eden, form, to, 老年区,说说他们的特点!<br>
●GC的算法有哪些?<br>
标记清除法，标记整理,复制算法，引用计数器<br>
●轻GC和重GC分别在什么时候发生?</p>
</li>
</ol>
<h2 id="16常用算法"><strong>16.常用算法</strong></h2>
<ol>
<li>
<h3 id="引用计数法"><strong>引用计数法</strong></h3>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200926120004515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol>
<li>
<h3 id="复制算法"><strong>复制算法</strong></h3>
</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200926120015325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/2020092612002912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>好处:没有内存的碎片</li>
<li>坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)</li>
<li><strong>复制算法最佳使用场景</strong>:对象存活度较低的时候:新生区;</li>
</ul>
<ol>
<li>
<h3 id="标记清除算法"><strong>标记清除算法</strong></h3>
</li>
</ol>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20200926120039882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>优点:不需要额外的空间</li>
<li>缺点:两次扫描,严重浪费时间,会产生内存碎片</li>
</ul>
<ol>
<li>
<h3 id="标记压缩优化标记清除"><strong>标记压缩(优化标记清除)</strong></h3>
</li>
</ol>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200926120051707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>三部曲:标记,清除.压缩</li>
</ul>
<h3 id="17-如何选择四种算法">17、如何选择四种算法:</h3>
<p><strong>内存效率</strong>:复制算法&gt;标记清除算法&gt;标记压缩算法(时间复杂度)</p>
<p><strong>内存整齐度</strong>:复制算法=标记压缩算法&gt;标记清除算法</p>
<p><strong>内存利用率</strong>:标记压缩算法=标记清除算法&gt;复制算法</p>
<p>难道没有一个最优的算法吗?</p>
<p>答案:<strong>没有</strong>,没有最好的算法,只有最合适的算法----&gt;GC:分带收集算法</p>
<p><strong>年轻代:</strong></p>
<ul>
<li>存活率低</li>
<li>复制算法</li>
</ul>
<p><strong>老年代：</strong></p>
<ul>
<li>区域大：存活率</li>
<li>标记清除（内存碎片不是太多）+标记压缩混合实现</li>
</ul>
<h2 id="18-jmm"><strong>18、JMM</strong></h2>
<p>1.什么是JMM？</p>
<p>JMM ：（java Memory Model 缩写）java内存模型</p>
<p>2.他是干什么的？</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/2020092612010865.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20200926120117490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>解决共享对象可见性的问题：volilate</p>
<p>3.他该如何学习</p>
<p>JMM ：抽象的概念，理论</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/20200926120127435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20200926120136562.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ganhan999.github.io/post/Java JUC并发编程/" class="post-title gt-a-link">
                    Java JUC并发编程
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/hot" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://ganhan999.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>

{"posts":[{"title":"455、分发饼干","content":"题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j]&gt;= g[i]， 我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 排序+贪心算法 1、对每个值进行倒序排序 2、保障让每一个饼干刚好满足当前的小朋友，就可以使得最后满足的人数最多。 大神做法1： class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: ##典型的贪心算法：先排序，倒序最好。让最大饼干的满足最贪心的小朋友，如果当前的饼干不能满足当前的小朋友，就找下一个小朋友看是否能满足 gi = 0 ## g:小朋友的胃口，也就是贪心值 si = 0 ## s:饼干值 g.sort(reverse=True) ##倒序输出 s.sort(reverse=True) res = 0 lens_g = len(g) lens_s = len(s) while gi&lt;lens_g and si&lt;lens_s: if s[si]&gt;=g[gi]: res+=1 si+=1 gi+=1 else: gi+=1 ##看一下小朋友的胃口是否能满足当前的饼干 return res ","link":"https://ganhan999.github.io/post/455、分发饼干/"},{"title":"453、最小操作次数使数组元素相等","content":"题目 给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。 示例： 输入： [1,2,3] 输出： 3 解释： 只需要3次操作（注意每次操作会增加两个元素的值）： [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 数学题 假设目前数组总和为sum，我们需要移动次数为m，那么整体数组总和将会增加m * (n - 1)，这里的n为数组长度，最后数组所有元素都相等为x，于是有： sum + m * (n - 1) = x * n (1) 我们再设数组最小的元素为min_val，m = x - min_val，即 x = m + min_val带入(1)得： m = sum - min_val * n 大神做法1： class Solution: def minMoves(self, nums: List[int]) -&gt; int: return sum(nums) - len(nums) * min(nums) ","link":"https://ganhan999.github.io/post/453、最小操作次数使数组元素相等/"},{"title":"434、字符串中的单词数","content":"题目 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: &quot;Hello, my name is John&quot; 输出: 5 解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 内置算法 大神做法1： class Solution: def countSegments(self, s): return len(s.split()) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件， 就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标）， 且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。 相当于数空格的数量 大神做法2： class Solution: def countSegments(self, s): segment_count = 0 for i in range(len(s)): if (i == 0 or s[i-1] == ' ') and s[i] != ' ': segment_count += 1 return segment_count ","link":"https://ganhan999.github.io/post/434、字符串中的单词数/"},{"title":"415、字符串相加","content":"题目 给定两个字符串形式的非负整数num1 和num2，计算它们的和。 提示： num1 和num2的长度都小于 5100 num1 和num2 都只包含数字0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 利用int函数 大神做法1： class Solution: def addStrings(self, num1: str, num2: str) -&gt; str: res = &quot;&quot; i, j, carry = len(num1) - 1, len(num2) - 1, 0 while i &gt;= 0 or j &gt;= 0: n1 = int(num1[i]) if i &gt;= 0 else 0 n2 = int(num2[j]) if j &gt;= 0 else 0 tmp = n1 + n2 + carry carry = tmp // 10 res = str(tmp % 10) + res i, j = i - 1, j - 1 return &quot;1&quot; + res if carry else res &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 标准加法进位，主要理解一下ASCII转换。 大神做法2： class Solution: def addStrings(self, num1: str, num2: str) -&gt; str: i = len(num1) - 1 j = len(num2) - 1 res = &quot;&quot; carry = 0 while i &gt;= 0 or j &gt;= 0: n1 = num1[i] if i &gt;= 0 else '0' n2 = num2[j] if j &gt;= 0 else '0' temp = ord(n1) + ord(n2) - 2 * ord('0') + carry cur = temp % 10 carry = temp // 10 res = chr(cur + 48) + res i -= 1 j -= 1 return '1' + res if carry != 0 else res ","link":"https://ganhan999.github.io/post/415、字符串相加/"},{"title":"414、第三大的数","content":"题目 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。 示例 1： 输入：[3, 2, 1] 输出：1 解释：第三大的数是 1 。 示例 2： 输入：[1, 2] 输出：2 解释：第三大的数不存在, 所以返回最大的数 2 。 示例 3： 输入：[2, 2, 3, 1] 输出：1 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 转成字典再转列表再排序 大神做法1： class Solution: def thirdMax(self, nums: List[int]) -&gt; int: nums = sorted(list(set(nums))) return nums[-1] if len(nums) &lt;= 2 else nums[-3] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 小顶堆 大神做法2： class Solution: def thirdMax(self, nums: List[int]) -&gt; int: # time O(nlog3) = O(n), space O(n) nums = set(nums) if len(nums) &lt; 3: return max(nums) nums = list(nums) pq = [] for n in nums: heapq.heappush(pq, n) if len(pq) &gt; 3: heapq.heappop(pq) return pq[0] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 快速排序 最差的可能性， time O(n^2), space O(n) 加入随机变量后, time O(n), space O(logn) 一种减而治之的思想。搜索区域中是否匹配到k-1（topk的索引） partition 可以灵活应变，前面大后面小，或者前面小后面大。 大神做法3： class Solution: def thirdMax(self, nums: List[int]) -&gt; int: # time O(nlog3) = O(n), space O(n) nums = set(nums) if len(nums) &lt; 3: return max(nums) nums = list(nums) pq = [] for n in nums: heapq.heappush(pq, n) if len(pq) &gt; 3: heapq.heappop(pq) return pq[0] ","link":"https://ganhan999.github.io/post/414、第三大的数/"},{"title":"412、Fizz Buzz","content":"题目 写一个程序，输出从 1 到 n 数字的字符串表示。 如果n是3的倍数，输出“Fizz”； 如果n是5的倍数，输出“Buzz”； 3.如果n同时是3和5的倍数，输出 “FizzBuzz”。 示例： n = 15, 返回: [ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot; ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 初始化一个空的答案列表。 遍历 1 ... N1...N。 对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。 如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。 如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。 如果以上都不行，把这个数加入答案列表。 大神做法1： class Solution: def fizzBuzz(self, n: int) -&gt; List[str]: ans=[] for i in range(1,n+1): if i%3==0 and i%5==0:ans.append('FizzBuzz') elif i%3==0:ans.append('Fizz') elif i%5==0:ans.append('Buzz') else:ans.append(str(i)) return ans ","link":"https://ganhan999.github.io/post/412、Fizz Buzz/"},{"title":"409、最长回文串","content":"题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如&quot;Aa&quot;不能当做一个回文字符串。 注意: 假设字符串的长度不会超过 1010。 示例 1: 输入: &quot;abccccdd&quot; 输出: 7 解释: 我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 1.统计各字符次数，eg:&quot;ddsad&quot;:[3, 1, 1] 2.统计两两配对的字符总个数，eg: {&quot;ddass&quot;:4,&quot;ddsss&quot;:4} 3.判断是否有没配对的单字符，有结果加一。 eg: {&quot;ddss&quot;:4, &quot;ddhjSS&quot;:4+1}--&gt;{&quot;ddss&quot;:4, &quot;ddhjSS&quot;:5} 大神做法1： class Solution: def longestPalindrome(self, s: str) -&gt; int: ans = 0 count = collections.Counter(s) for v in count.values(): ans += v // 2 * 2 if ans % 2 == 0 and v % 2 == 1: ans += 1 return ans ","link":"https://ganhan999.github.io/post/409、最长回文串/"},{"title":"405、数字转换为十六进制数","content":"题目 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用补码运算方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入: 26 输出: &quot;1a&quot; 示例 2： 输入: -1 输出: &quot;ffffffff&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 1、当正数时，直接循环右移4位（除以16也可以），直到商为0，再依次将余数字符串起来，逆序排列。 2、当0时，直接返回0。 3、当负数时，将其绝对值通过与（2的32次方减1）异或再加1，转化为对应的十进制正数，然后执第一步的操作。 大神做法1： class Solution: def toHex(self, num: int) -&gt; str: stra = '' if num &lt; 0: num = (abs(num) ^ ((2 ** 32) - 1)) + 1 elif num == 0: return '0' while (num &gt;&gt; 4) &gt; 0 or num &gt; 0: a = str(num &amp; 0xf) if a == '10': a = 'a' elif a == '11': a = 'b' elif a == '12': a = 'c' elif a == '13': a = 'd' elif a == '14': a = 'e' elif a == '15': a = 'f' stra += a num = num &gt;&gt; 4 return ''.join(reversed(stra)) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 核心思想，使用位运算，每4位，对应1位16进制数字。 使用0xf(00...01111b)获取num的低4位。 算数位移，其中正数右移左边补0，负数右移左边补1。 位移运算并不能保证num==0，需要使用32位int保证（对应16进制小于等于8位).大神做法1： class Solution: def toHex(self, num: int) -&gt; str: if num==0: return &quot;0&quot; hex, ans = &quot;0123456789abcdef&quot;, &quot;&quot; while num and len(ans) &lt; 8: ans = hex[num &amp; 0xf] + ans num &gt;&gt;= 4 return ans ","link":"https://ganhan999.github.io/post/405、数字转换为十六进制数/"},{"title":"404、左叶子之和","content":"题目 计算给定二叉树的所有左叶子之和。 示例： 3 / 9 20 / 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归 DFS 大神做法1： class Solution: def sumOfLeftLeaves(self, root: TreeNode) -&gt; int: def dfs(root, flag=False): # 初始化flag = False if not root: return 0 # 先判断root是否为None，否则下面的判断语句会报错 if not root.right and not root.left and flag: # 前两个条件保证是否是叶子节点，flag保证是否是左孩子 return root.val # 如果是左叶子结点就加上其值 return dfs(root.right, False) + dfs(root.left, True) # 递归root的左孩子并让flag = True, 右孩子flag = False return dfs(root) # 返回结果 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; BFS 广度优先遍历 也是放一个标志位表示左节点 大神做法1： class Solution: def sumOfLeftLeaves(self, root: TreeNode) -&gt; int: def dfs(root, flag=False): # 初始化flag = False if not root: return 0 # 先判断root是否为None，否则下面的判断语句会报错 if not root.right and not root.left and flag: # 前两个条件保证是否是叶子节点，flag保证是否是左孩子 return root.val # 如果是左叶子结点就加上其值 return dfs(root.right, False) + dfs(root.left, True) # 递归root的左孩子并让flag = True, 右孩子flag = False return dfs(root) # 返回结果 ","link":"https://ganhan999.github.io/post/404、左叶子之和/"},{"title":"401、二进制手表","content":"题目 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 为了方便计算，分别设置了小时数组和分钟数组 递归的四个参数分别代表：剩余需要点亮的灯数量，从索引index开始往后点亮灯，当前小时数，当前分钟数 每次进入递归后，先判断当前小时数和分钟数是否符合要求，不符合直接return for循环枚举点亮灯的情况，从index枚举到10，每次枚举 大神做法1： class Solution(object): def readBinaryWatch(self, num: int) -&gt; List[str]: hours = [1, 2, 4, 8, 0, 0, 0, 0, 0, 0] minutes = [0, 0, 0, 0, 1, 2, 4, 8, 16, 32] res = [] def backtrack(num, index, hour, minute): if hour &gt; 11 or minute &gt; 59: return if num == 0: res.append('%d:%02d' % (hour, minute)) return for i in range(index, 10): backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i]) backtrack(num, 0, 0, 0) return res ","link":"https://ganhan999.github.io/post/401、二进制手表/"},{"title":"392、判断子序列","content":"题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 示例 1： 输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot; 输出：true 示例 2： 输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot; 输出：false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 双指针 大神做法1： class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: n, m = len(s), len(t) i = j = 0 while i &lt; n and j &lt; m: if s[i] == t[j]: i += 1 j += 1 return i == n &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 动态规划 大神做法2： class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: n, m = len(s), len(t) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): f[i][j] = i if ord(t[i]) == j + ord('a') else f[i + 1][j] add = 0 for i in range(n): if f[add][ord(s[i]) - ord('a')] == m: return False add = f[add][ord(s[i]) - ord('a')] + 1 return True &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 对索引二分查找 大神做法3： class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: hashmap = {} for i, c in enumerate(t): if c not in hashmap: hashmap[c] = [i] else: hashmap[c].append(i) j = 0 for i in range(len(s)): c = s[i] if c not in hashmap: return False pos = self.find_left(hashmap[c], j) # 二分搜索与c匹配的下一个索引，避免线性扫描 if pos &gt;= len(hashmap[c]):#如果超过了 那么不可能匹配 return False j = hashmap[c][pos] + 1 return True def find_left(self, index, target): left, right = 0, len(index) - 1 while left &lt;= right: mid = (left + right) // 2 if index[mid] &lt; target: left = mid + 1 else: right = mid - 1 return left ","link":"https://ganhan999.github.io/post/392、判断子序列/"},{"title":"389、找不同","content":"题目 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 输入：s = &quot;abcd&quot;, t = &quot;abcde&quot; 输出：&quot;e&quot; 解释：'e' 是那个被添加的字母。 示例 2： 输入：s = &quot;&quot;, t = &quot;y&quot; 输出：&quot;y&quot; 示例 3： 输入：s = &quot;a&quot;, t = &quot;aa&quot; 输出：&quot;a&quot; 示例 4： 输入：s = &quot;ae&quot;, t = &quot;aea&quot; 输出：&quot;a&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 首先将两个字符串合并为a 在a中遍历，如果出现奇数次的字符即为不同的字符 大神做法1： class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: a = &quot;&quot;.join([s,t]) for ch in a: if a.count(ch) % 2 == 1: return ch &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 题目已说明，字符串 t 比字符串 s 多一个字母，那么我们可以先用数组统计 ss 的字符出现的次数。 然后开始遍历字符串 t，数组中对应字符的次数减 1。当数组中出现负数，那么代表对应的字符就是添加的字母。 大神做法2： class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: # 长度为 26 的数组，用以统计字符出现次数 str_count = [0] * 26 # 先遍历 s，统计 s 中字符出现的次数 for ch in s: str_count[ord(ch) - ord('a')] += 1 # 再遍历 t，将出现字符对应次数减 1， # 当出现负值，表示对应的字符就是添加的字母 for ch in t: str_count[ord(ch) - ord('a')] -= 1 if str_count[ord(ch) - ord('a')] &lt; 0: return ch return '' &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 异或，最后的结果就是多出来的数字 大神做法3： class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: # 初始化 ans 为 0 ans = 0 # 对字符串 s 的字符进行异或 for ch in s: ans ^= ord(ch) # 对字符串 t 的字符进行异或 for ch in t: ans ^= ord(ch) # 最终结果转换为 ASCII 字符 return chr(ans) ","link":"https://ganhan999.github.io/post/389、找不同/"},{"title":"387、字符串中的第一个唯一字符","content":"题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： s = &quot;leetcode&quot; 返回 0 s = &quot;loveleetcode&quot; 返回 2 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时， 我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回-1。 大神做法1： class Solution: def firstUniqChar(self, s: str) -&gt; int: frequency = collections.Counter(s) for i, ch in enumerate(s): if frequency[ch] == 1: return i return -1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c， 如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足 「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 -1）选择弹出队首的元素，直到队首元素「真的」只出现了 一次或者队列为空。 在遍历完成后，如果队列为空，说明没有不重复的字符，返回 -1，否则队首的元素即为第一个不重复的字符以及其索引的二元组。 大神做法2： class Solution: def firstUniqChar(self, s: str) -&gt; int: position = dict() q = collections.deque() n = len(s) for i, ch in enumerate(s): if ch not in position: position[ch] = i q.append((s[i], i)) else: position[ch] = -1 while q and position[q[0][0]] == -1: q.popleft() return -1 if not q else q[0][1] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 异或，最后的结果就是多出来的数字 大神做法3： class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: # 初始化 ans 为 0 ans = 0 # 对字符串 s 的字符进行异或 for ch in s: ans ^= ord(ch) # 对字符串 t 的字符进行异或 for ch in t: ans ^= ord(ch) # 最终结果转换为 ASCII 字符 return chr(ans) ","link":"https://ganhan999.github.io/post/387、字符串中的第一个唯一字符/"},{"title":"383、赎金信","content":"题目 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 示例 1： 输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot; 输出：false 示例 2： 输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot; 输出：false 示例 3： 输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot; 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 首先利用collections.Counter 得到元素的计数集合 再利用差集 大神做法1： class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: hash_table_m = collections.Counter(magazine) hash_table_r = collections.Counter(ransomNote) &quot;&quot;&quot;for i in hash_table_r: if hash_table_r[i] &gt; hash_table_m[i]: return False return True&quot;&quot;&quot; return not hash_table_r - hash_table_m &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 得到ransomnote的计数集合，然后分析magazine中的元素计数是不是比ransomnote的计数集合的更少 大神做法2： class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: a = dict(collections.Counter(ransomNote)) for k, v in a.items(): if magazine.count(k) &lt; v: return False return True ","link":"https://ganhan999.github.io/post/383、赎金信/"},{"title":"374、猜数字大小","content":"题目 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果， 返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 输入：n = 10, pick = 6 输出：6 示例 2： 输入：n = 1, pick = 1 输出：1 示例 3： 输入：n = 2, pick = 1 输出：1 示例 4： 输入：n = 2, pick = 2 输出：2 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 二分法 大神做法1： class Solution: def guessNumber(self, n: int) -&gt; int: l, r = 1, n # 二分查找 while l &lt; r: mid = (l + r) &gt;&gt; 1 check = guess(mid) if check &lt; 0: r = mid elif check &gt; 0: l = mid + 1 else: return mid return l ","link":"https://ganhan999.github.io/post/374、猜数字大小/"},{"title":"367、有效的完全平方数","content":"题目 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1： 输入：16 输出：True 示例 2： 输入：14 输出：False&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 二分法 大神做法1： class Solution: def isPerfectSquare(self, num: int) -&gt; bool: l, r = 1, num while l &lt; r: mid = (l + r) // 2 if mid * mid &lt; num: l = mid + 1 else: r = mid return l * l == num &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 牛顿迭代法 大神做法2： class Solution: def isPerfectSquare(self, num: int) -&gt; bool: if num &lt; 2: return True x = num // 2 while x * x &gt; num: x = (x + num // x) // 2 return x * x == num ","link":"https://ganhan999.github.io/post/367、有效的完全平方数/"},{"title":"350、两个数组的交集 II","content":"题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 哈希表 由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字， 其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。 首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组， 对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。 为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集 大神做法1： class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: if len(nums1) &gt; len(nums2): return self.intersect(nums2, nums1) m = collections.Counter() for num in nums1: m[num] += 1 intersection = list() for num in nums2: if (m.get(num, 0)) &gt; 0: intersection.append(num) m[num] -= 1 if m[num] == 0: m.pop(num) return intersection &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 排序加双指针 大神做法2： class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums1.sort() nums2.sort() length1, length2 = len(nums1), len(nums2) intersection = list() index1 = index2 = 0 while index1 &lt; length1 and index2 &lt; length2: num1 = nums1[index1] num2 = nums2[index2] if num1 == num2: # 保证加入元素的唯一性 intersection.append(num1) index1 += 1 index2 += 1 elif num1 &lt; num2: index1 += 1 else: index2 += 1 return intersection ","link":"https://ganhan999.github.io/post/350、两个数组的交集 II/"},{"title":"349、两个数组的交集","content":"题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 取两个集合 然后遍历短的集合元素 判断是否在另一个集合里面 大神做法1： class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: set1 = set(nums1) set2 = set(nums2) return self.set_intersection(set1, set2) def set_intersection(self, set1, set2): if len(set1) &gt; len(set2): return self.set_intersection(set2, set1) return [x for x in set1 if x in set2] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 排序加双指针 初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等， 则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于上一个被存入的数字，将该数字添加到答案， 同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。 大神做法2： class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: nums1.sort() nums2.sort() length1, length2 = len(nums1), len(nums2) intersection = list() index1 = index2 = 0 while index1 &lt; length1 and index2 &lt; length2: num1 = nums1[index1] num2 = nums2[index2] if num1 == num2: # 保证加入元素的唯一性 if not intersection or num1 != intersection[-1]: intersection.append(num1) index1 += 1 index2 += 1 elif num1 &lt; num2: index1 += 1 else: index2 += 1 return intersection ","link":"https://ganhan999.github.io/post/349、两个数组的交集/"},{"title":"345、反转字符串中的元音字串","content":"题目 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1： 输入：&quot;hello&quot; 输出：&quot;holle&quot; 示例 2： 输入：&quot;leetcode&quot; 输出：&quot;leotcede&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 双指针 一个指向前面 一个指向后面 想找到前面的 然后找到后面的 然后交换顺序 继续找 直到两个指针相遇 大神做法1： class Solution: def reverseVowels(self, s: str) -&gt; str: N = len(s) lst = list(s) vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'} i, j = 0, N-1 while i &lt; j: if lst[i] in vowels: while i &lt; j: if lst[j] in vowels: lst[i], lst[j] = lst[j], lst[i] i += 1 j -= 1 break else: j -= 1 else: i += 1 return ''.join(lst) ","link":"https://ganhan999.github.io/post/345、反转字符串中的元音字串/"},{"title":"342、4的幂","content":"题目 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x 示例 1： 输入：n = 16 输出：true 示例 2： 输入：n = 5 输出：false 示例 3： 输入：n = 1 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 暴力迭代 大神做法1： class Solution: def isPowerOfThree(self, n: int) -&gt; bool: if n == 0: return False while True: if n == 1: return True elif n%4 == 0: n = n/4 else: return False &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 预先计算所有可能的值 然后比对是不是在可能的集合里面 大神做法2： class Powers: def __init__(self): max_power = 15 self.nums = nums = [1] * (max_power + 1) for i in range(1, max_power + 1): nums[i] = 4 * nums[i - 1] class Solution: p = Powers() def isPowerOfFour(self, num: int) -&gt; bool: return num in self.p.nums &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 如果数字为 4 的幂 x = 4^a 那么a=1/2 log2 x，那么只要判断log2 x是偶数即可 大神做法3： class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and log2(num) % 2 == 0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 位运算 先利用num &gt; 0 and num &amp; (num - 1) == 0 判断是不是2的幂次 然后再即 4^a &amp;(101010...10) == 0判断是不是4次幂 大神做法4： class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and log2(num) % 2 == 0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 位运算2 先利用num &gt; 0 and num &amp; (num - 1) == 0 判断是不是2的幂次 然后再即 num % 3 == 1判断是不是4次幂 大神做法5： class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and num &amp; (num - 1) == 0 and num % 3 == 1 ","link":"https://ganhan999.github.io/post/342、4的幂/"},{"title":"326、3的幂","content":"题目 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x 示例 1： 输入：n = 27 输出：true 示例 2： 输入：n = 0 输出：false 示例 3： 输入：n = 9 输出：true 示例 4： 输入：n = 45 输出：false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 暴力迭代 大神做法1： class Solution: def isPowerOfThree(self, n: int) -&gt; bool: if n == 0: return False while True: if n == 1: return True elif n%3 == 0: n = n/3 else: return False &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 我们只需要将 3^{9 除以 n。若余数为 0 意味着 n 是 3^19的除数，因此是3的幂。 大神做法2： class Solution: def isPowerOfThree1(self, n: int) -&gt; bool: return n &gt; 0 and 1162261467 % n == 0 ","link":"https://ganhan999.github.io/post/326、3的幂/"},{"title":"290、单词规律","content":"题目 给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; 输出: true 示例 2: 输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; 输出: false 示例 3: 输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; 输出: false 示例 4: 输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 利用哈希表，用pattern中的元素为key，str中的单词为值，首先判断pattern中的元素有没有出现过， 如果出现过，那么判断对应的str的单词是不是不存在或着已经与别的单词配对 如果没出现过，那么就加到哈希表中 大神做法1： class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; s = str.split(' ') if len(s)!= len(pattern): return False dic = {} for i,x in enumerate(s): if pattern[i] not in dic: if x in dic.values(): return False dic[pattern[i]] = x else: if x != dic[pattern[i]]: return False return True ","link":"https://ganhan999.github.io/post/290、单词规律/"},{"title":"283、移动零","content":"题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。 大神做法1： class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: n = len(nums) left = right = 0 while right &lt; n:#当右指针指向第一个非零的数，那么就和左指针互换值，然后两个指针分别加一 if nums[right] != 0: nums[left], nums[right] = nums[right], nums[left] left += 1 right += 1 ","link":"https://ganhan999.github.io/post/283、移动零/"},{"title":"278、第一个错误的版本","content":"题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 用二分查找找到第一个True 大神做法1： class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; left, right = 1, n while left &lt; right: mid = left + (right - left) // 2 if isBadVersion(mid):#如果是True，那么右边界就停在这，而不是mid-1 right = mid else: left = mid + 1 return left ","link":"https://ganhan999.github.io/post/278、第一个错误的版本/"},{"title":"268、丢失的数字","content":"题目 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 输入：nums = [0] 输出：1 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 排序后，比较后一个数比前一个数大2就停止 大神做法1： class Solution: def missingNumber(self, nums): nums.sort() # Ensure that n is at the last index if nums[-1] != len(nums): return len(nums) # Ensure that 0 is at the first index elif nums[0] != 0: return 0 # If we get here, then the missing number is on the range (0, n) for i in range(1, len(nums)): expected_num = nums[i-1] + 1 if nums[i] != expected_num: return expected_num &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 先制作一个集合，然后对比0到n哪个数字不在集合中 大神做法2： class Solution: def missingNumber(self, nums): num_set = set(nums) n = len(nums) + 1 for number in range(n): if number not in num_set: return number &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 位运算，先用0到n做一次异或运算，然后再和数组中的数字做一次异或，最后的到的结果就是缺少的数字。因为2个重复的异或都变成0了 大神做法3： class Solution: def missingNumber(self, nums): missing = len(nums) for i, num in enumerate(nums): missing ^= i ^ num return missing ","link":"https://ganhan999.github.io/post/268、丢失的数字/"},{"title":"263、丑数","content":"题目 编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6 输出: true 解释: 6 = 2 × 3 示例 2: 输入: 8 输出: true 解释: 8 = 2 × 2 × 2 示例 3: 输入: 14 输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 如题意，丑数的质因数只包含[2,3,5],因此如果该数是丑数， 让这个数不断除以[2,3,5],最终结果肯定为1，否则就不是丑数。 对于负数及0自然就不是丑数。 大神做法1： class Solution: def isUgly(self, num: int) -&gt; bool: if num &lt;= 0: ## 如果num非正，就不是丑数 return False while True: last = num if not num % 2: ## 如果2整除num，就除以2 num &gt;&gt;= 1 if not num % 3: ## 如果3整除num，就除以3 num //= 3 if not num % 5: ## 如果5整除num，就除以5 num //= 5 if num == 1: ## 如果若干次操作后，num变成1，说明num的因数只有2、3、5，是丑数 return True if last == num: ## 如果1轮操作后，num没变，说明num不是丑数 return False &quot; ","link":"https://ganhan999.github.io/post/263、丑数/"},{"title":"258、各位相加","content":"题目 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 x100+y10+z=x99+y9+x+y+z 大神做法1： class Solution: def addDigits(self, num: int) -&gt; int: return (num-1)%9+1 if num!=0 else 0 ","link":"https://ganhan999.github.io/post/258、各位相加/"},{"title":"257、二叉树的所有路径","content":"题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / 2 3 5 输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。 如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。 如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径， 将该路径加入到答案即可。 大神做法1： class Solution: def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; def construct_paths(root, path): if root: path += str(root.val) if not root.left and not root.right: # 当前节点是叶子节点 paths.append(path) # 把路径加入到答案中 else: path += '-&gt;' # 当前节点不是叶子节点，继续递归遍历 construct_paths(root.left, path) construct_paths(root.right, path) paths = [] construct_paths(root, '') return paths &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 广度优先遍历 大神做法2： class Solution: def binaryTreePaths(self, root: TreeNode) -&gt; List[str]: paths = list() if not root: return paths node_queue = collections.deque([root]) path_queue = collections.deque([str(root.val)]) while node_queue: node = node_queue.popleft() path = path_queue.popleft() if not node.left and not node.right: paths.append(path) else: if node.left: node_queue.append(node.left) path_queue.append(path + '-&gt;' + str(node.left.val)) if node.right: node_queue.append(node.right) path_queue.append(path + '-&gt;' + str(node.right.val)) return paths ","link":"https://ganhan999.github.io/post/257、二叉树的所有路径/"},{"title":"242、有效的字母异位词","content":"题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true 示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 哈希表 用哈希表统计第一个字符串中的字符数量； 再统计第二个字符串时，若字符在哈希表中，计数减一，否则返回false 最后判断哈希表中值是否都为0。 大神做法1： class Solution(object): def isAnagram(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(s) != len(t): return False count = {} for char in s: if char in count: count[char] += 1 else: count[char] = 1 for char in t: if char in count: count[char] -= 1 else: return False for value in count.values(): if value != 0: return False return True &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 排序 然后逐位比较 大神做法2： class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: ###用传统循环方法进行排序比较 if len(s) != len(t): return False s = list(s) s.sort() t = list(t) t.sort() for i in range(len(s)): if s[i] == t[i]: continue else: return False return True ","link":"https://ganhan999.github.io/post/242、有效的字母异位词/"},{"title":"232、用栈实现队列","content":"题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ， 即使其中一个操作可能花费较长时间。 示例： 输入： [&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 双栈 元素全部在stack1里面 大神做法1： class MyQueue: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.stack1 = [] self.stack2 = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x to the back of queue. &quot;&quot;&quot; self.stack1.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; while self.stack1: self.stack2.append(self.stack1.pop()) res = self.stack2.pop() while self.stack2: self.stack1.append(self.stack2.pop()) return res def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; while self.stack1: self.stack2.append(self.stack1.pop()) res = self.stack2[-1] while self.stack2: self.stack1.append(self.stack2.pop()) return res def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the queue is empty. &quot;&quot;&quot; return not self.stack1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 双栈 每次都更新front 压入的元素在1栈，要被弹出的元素在2栈 大神做法2： class MyQueue: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.stack1 = [] self.stack2 = [] self.front = None def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x to the back of queue. &quot;&quot;&quot; if not self.stack1: self.front = x self.stack1.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) self.front = None return self.stack2.pop() def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; if self.stack2: return self.stack2[-1] return self.front def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the queue is empty. &quot;&quot;&quot; return not self.stack1 and not self.stack2 ","link":"https://ganhan999.github.io/post/232、用栈实现队列/"},{"title":"228、汇总区间","content":"题目 给定一个无重复元素的有序整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： &quot;a-&gt;b&quot; ，如果 a != b &quot;a&quot; ，如果 a == b 示例 1： 输入：nums = [0,1,2,4,5,7] 输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;] 解释：区间范围是： [0,2] --&gt; &quot;0-&gt;2&quot; [4,5] --&gt; &quot;4-&gt;5&quot; [7,7] --&gt; &quot;7&quot; 示例 2： 输入：nums = [0,2,3,4,6,8,9] 输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] 解释：区间范围是： [0,0] --&gt; &quot;0&quot; [2,4] --&gt; &quot;2-&gt;4&quot; [6,6] --&gt; &quot;6&quot; [8,9] --&gt; &quot;8-&gt;9&quot; 示例 3： 输入：nums = [] 输出：[] 示例 4： 输入：nums = [-1] 输出：[&quot;-1&quot;] 示例 5： 输入：nums = [0] 输出：[&quot;0&quot;] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 双指针 一个指向区间最后一个，一个指向区间第一个 一当发现不符合，把前面指针指向后面指针 大神做法1： class Solution: def summaryRanges(self, nums: List[int]) -&gt; List[str]: n = len(nums) # 初始化双指针均指向数组头部 left = 0 right = 0 ans = [] # 开始遍历 while right &lt; n: # 数组有序 # 先限定边界，查找间隔大于 1 的部分 while right &lt; n - 1 and nums[right] + 1 == nums[right + 1]: right += 1 # 找到间隔之后，将前面连续部分按照规定格式添加到结果列表中 tmp = [str(nums[left])] if nums[left] != nums[right]: tmp.append('-&gt;') tmp.append(str(nums[right])) ans.append(''.join(tmp)) # 维护更新 right 和 left right += 1 left = right return ans ","link":"https://ganhan999.github.io/post/228、汇总区间/"},{"title":"226、翻转二叉树","content":"题目 翻转一棵二叉树。 示例： 输入： ​ 4 / 2 7 / \\ / 1 3 6 9 输出： ​ 4 / 7 2 / \\ / 9 6 3 1 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 切片再翻转再合并 大神做法1： class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return root left = self.invertTree(root.left) right = self.invertTree(root.right) root.left, root.right = right, left return root ","link":"https://ganhan999.github.io/post/226、翻转二叉树/"},{"title":"225、用队列实现栈","content":"题目 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例： 输入： [&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 单列表 大神做法1： class MyStack: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.q = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x onto stack. &quot;&quot;&quot; self.q.append(x) q_length = len(self.q) while q_length &gt; 1: self.q.append(self.q.pop(0)) #反转前n-1个元素，栈顶元素始终保留在队首 q_length -= 1 def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element on top of the stack and returns that element. &quot;&quot;&quot; return self.q.pop(0) def top(self) -&gt; int: &quot;&quot;&quot; Get the top element. &quot;&quot;&quot; return self.q[0] def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the stack is empty. &quot;&quot;&quot; return not bool(self.q) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 双队列 大神做法2： from collections import deque class MyStack: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.data = deque() self.help = deque() def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x onto stack. &quot;&quot;&quot; self.data.append(x) def pop(self) -&gt; int:#两个队列互相交换 &quot;&quot;&quot; Removes the element on top of the stack and returns that element. &quot;&quot;&quot; while len(self.data) &gt; 1: self.help.append(self.data.popleft()) tmp = self.data.popleft() self.help,self.data = self.data,self.help return tmp def top(self) -&gt; int:#同上 但是这里把顶元素加上了 &quot;&quot;&quot; Get the top element. &quot;&quot;&quot; while len(self.data) != 1:#得到顶元素 self.help.append(self.data.popleft()) tmp = self.data.popleft() self.help.append(tmp)#加上顶元素 self.help,self.data = self.data,self.help return tmp def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the stack is empty. &quot;&quot;&quot; return not bool(self.data) ","link":"https://ganhan999.github.io/post/225、用队列实现栈/"},{"title":"205、同构字符串","content":"题目 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上， 相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1: 输入：s = &quot;egg&quot;, t = &quot;add&quot; 输出：true 示例 2： 输入：s = &quot;foo&quot;, t = &quot;bar&quot; 输出：false 示例 3： 输入：s = &quot;paper&quot;, t = &quot;title&quot; 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 双哈希表比较法 先把两个哈希表写出来 然后比较值是不是一样的 大神做法1： class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: if s == &quot;&quot; and t == &quot;&quot;: return True if s == &quot;&quot; or t == &quot;&quot;: return False hashmap_s = {} hashmap_t = {} # 对s中的字符进行录入，值为各个字符出现的下标 for i, n in zip(s, range(len(s))): if i not in hashmap_s: hashmap_s[i] = [n] else: hashmap_s[i].append(n) # 对t中的字符进行录入，值为各个字符出现的下标 for i, n in zip(t, range(len(t))): if i not in hashmap_t: hashmap_t[i] = [n] else: hashmap_t[i].append(n) # 对比两个哈希表值是否相同 for value in hashmap_s.values(): if value not in hashmap_t.values(): return False return True &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 双哈希表 互相映射 大神做法2： class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: a2b, b2a = {}, {} n = len(s) for i in range(n): a, b = s[i], t[i] if (a in a2b and a2b[a] != b) or (b in b2a and b2a[b] != a):#是否互相映射 return False a2b[a] = b b2a[b] = a return True ","link":"https://ganhan999.github.io/post/205、同构字符串/"},{"title":"219、存在重复元素 II","content":"题目 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上， 相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1: 输入：s = &quot;egg&quot;, t = &quot;add&quot; 输出：true 示例 2： 输入：s = &quot;foo&quot;, t = &quot;bar&quot; 输出：false 示例 3： 输入：s = &quot;paper&quot;, t = &quot;title&quot; 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 哈希表 键为数字，值为下标 大神做法1： class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: # 创建哈希表 hash_map = {} # 遍历一次数组 for idx, n in enumerate(nums): if n not in hash_map or (idx - hash_map[n]) &gt; k: # 情况1 &amp; 情况2 hash_map[n] = idx else: # 情况3 return True else: return False ","link":"https://ganhan999.github.io/post/219、存在重复元素 II/"},{"title":"204、计数质数","content":"题目 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 输入：n = 0 输出：0 示例 3： 输入：n = 1 输出：0 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 筛选法 质数的倍数一定不是质数 大神做法1： class Solution: def countPrimes(self, n: int) -&gt; int: #给每个位置立一个flag，初始化为1 isPrimes = [1] * n #result，输出的质数总个数的计数器，初始化为0 res = 0 #循环，从最小质数i开始到n循环 for i in range(2, n): #如果这个位置的flag为1，说明数字 i 没有被比 i 小的数整除过，说明它是质数，计数器+1 if isPrimes[i] == 1: res += 1 #下面这几步的思路是， i 的倍数一定不是质数，将这些数的flag设置为0 #设置倍数 j ，初始化与 i 相等。 因为i也是一点点加上来的，比如 i=5的时候，i 的4倍一定在 i=4 时已经设置为0过。 j = i#标记应该从i∗i 开始，而不是 2∗i 开始。因为对于每个数 i 来说，枚举是从小到大的，此时前面数字的倍数都已经进行了标记。对于 i而言，2∗i 也肯定会被在枚举数字 2 时进行标记，[2,i) 区间的数同理。 #当 i 的 j 倍大于n的时候跳出循环 while i * j &lt; n: #设置i 的 j 倍的flag为0 isPrimes[i * j] = 0 # 自增，下一个找 j+1 倍 j += 1 #返回结果 return res ","link":"https://ganhan999.github.io/post/204、计数质数/"},{"title":"203、移除链表元素","content":"题目 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6 输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 迭代 大神做法1： class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: while head and head.val == val: head = head.next if not head: return pre = head while pre.next: if pre.next.val == val: pre.next = pre.next.next else: pre = pre.next return head &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 双指针 1、设置两个指针分别指向头节点，pre （记录要删除节点的前一节点）和 cur (记录当前节点)； 2、遍历整个链表，查找节点值为 val 的节点，找到了就删除该节点，否则继续查找。 大神做法2： class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: while head and head.val == val: head = head.next pre, cur = head, head while cur: if cur.val == val: pre.next = cur.next else: pre = cur cur = cur.next return head &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; cycle_members = {4, 16, 37, 58, 89, 145, 42, 20} 循环链只有这一条 大神做法3： def isHappy(self, n: int) -&gt; bool: cycle_members = {4, 16, 37, 58, 89, 145, 42, 20} def get_next(number): total_sum = 0 while number &gt; 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum while n != 1 and n not in cycle_members: n = get_next(n) return n == 1 ","link":"https://ganhan999.github.io/post/203、移除链表元素/"},{"title":"202、快乐数","content":"题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 true ；不是，则返回 false 。 示例 1： 输入：19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 示例 2： 输入：n = 2 输出：false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 根据我们的探索，我们猜测会有以下三种可能。 1、最终会得到 11。 2、最终会进入循环。 3、值会越来越大，最后接近无穷大。 第三种情况不可能发生 所以只需要判断是否进入了循环 大神做法1： def isHappy(self, n: int) -&gt; bool: def get_next(n):#算下一个数 total_sum = 0 while n &gt; 0: n, digit = divmod(n, 10) total_sum += digit ** 2 return total_sum seen = set() while n != 1 and n not in seen:#如果是1就是快乐数，如果存在了那么就是遇到了循环就不是快乐数 seen.add(n) n = get_next(n) return n == 1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 快慢指针判断循环 大神做法2： def isHappy(self, n: int) -&gt; bool: def get_next(number): total_sum = 0 while number &gt; 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum slow_runner = n fast_runner = get_next(n) while fast_runner != 1 and slow_runner != fast_runner: slow_runner = get_next(slow_runner) fast_runner = get_next(get_next(fast_runner)) return fast_runner == 1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; cycle_members = {4, 16, 37, 58, 89, 145, 42, 20} 循环链只有这一条 大神做法3： def isHappy(self, n: int) -&gt; bool: cycle_members = {4, 16, 37, 58, 89, 145, 42, 20} def get_next(number): total_sum = 0 while number &gt; 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum while n != 1 and n not in cycle_members: n = get_next(n) return n == 1 ","link":"https://ganhan999.github.io/post/202、快乐数/"},{"title":"557、反转字符串中的单词 III","content":"题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例： 输入：&quot;Let's take LeetCode contest&quot; 输出：&quot;s'teL ekat edoCteeL tsetnoc&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 切片再翻转再合并 大神做法1： class Solution(object): def reverseWords(self, s): return &quot; &quot;.join(word[::-1] for word in s.split(&quot; &quot;)) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 先反转单词列表 再反转字符串 以字符串 “I love drag queen” 为例： s.split(&quot; &quot;) 将字符串分割成单词列表: ['I', 'love', 'drag', 'queen'] s.split(&quot; &quot;)[::-1] 将单词列表反转: ['queen', 'drag', 'love', 'I'] &quot; &quot;.join(s.split(&quot; &quot;)[::-1]) 将单词列表转换为字符串，以空格分隔: &quot;queen drag love I&quot; &quot; &quot;.join(s.split(&quot; &quot;)[::-1])[::-1] 将字符串反转： ”I evol gard neeuq“ 大神做法2： class Solution(object): def reverseWords(self, s): return &quot; &quot;.join(s.split(&quot; &quot;)[::-1])[::-1] ","link":"https://ganhan999.github.io/post/557、反转字符串中的单词 III/"},{"title":"344、反转字符串","content":"题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 库函数 大神做法1： class Solution: def reverseString(self, s: List[str]) -&gt; None: s[:]=s[::-1] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 双指针 大神做法2： class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; l,r=0,len(s)-1 while l&lt;r: s[l],s[r]=s[r],s[l] l+=1 r-=1 ","link":"https://ganhan999.github.io/post/344、反转字符串/"},{"title":"191、位1的个数","content":"题目 编写一个函数，输入是一个无符号整数（以二进制串的形式）， 返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型， 并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶： 如果多次调用这个函数，你将如何优化你的算法？ 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 库函数 大神做法1： class Solution: def hammingWeight(self, n: int) -&gt; int: return bin(n).count(&quot;1&quot;) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 每次都与1相与，然后将原字符串右移一位 大神做法2： class Solution: def hammingWeight(self, n: int) -&gt; int: res=0 while n: res+=n&amp;1 n&gt;&gt;=1 return res &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; n&amp;(n-1)会消掉最低位的1，看一共能消除多少次，就有多少个1 大神做法3： class Solution: def hammingWeight(self, n: int) -&gt; int: res=0 while n: res+=n&amp;1 n&gt;&gt;=1 return res ","link":"https://ganhan999.github.io/post/191、位1的个数/"},{"title":"中等238. 除自身以外数组的乘积","content":"题目 给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ， 其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4] 输出: [24,12,8,6] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 前缀*后缀 大神做法1： class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: length = len(nums) # L 和 R 分别表示左右两侧的乘积列表 L, R, answer = [0] * length, [0] * length, [0] * length # L[i] 为索引 i 左侧所有元素的乘积 # 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1 L[0] = 1 for i in range(1, length): L[i] = nums[i - 1] * L[i - 1] # R[i] 为索引 i 右侧所有元素的乘积 # 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1 R[length - 1] = 1 for i in reversed(range(length - 1)): R[i] = nums[i + 1] * R[i + 1] # 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 for i in range(length): answer[i] = L[i] * R[i] return answer &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 前缀*后缀 降低空间复杂度 class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: length = len(nums) answer = [0] * length # answer[i] 表示索引 i 左侧所有元素的乘积 # 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1 answer[0] = 1 for i in range(1, length): answer[i] = nums[i - 1] * answer[i - 1] # R 为右侧所有元素的乘积 # 刚开始右边没有元素，所以 R = 1 R = 1; for i in reversed(range(length)): # 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R answer[i] = answer[i] * R # R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上 R *= nums[i] return answer ","link":"https://ganhan999.github.io/post/238、除自身以外数组的乘积/"},{"title":"292、Nim 游戏","content":"题目 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。 如果可以赢，返回 true；否则，返回 false 。 示例 1： 输入：n = 4 输出：false 解释：如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 示例 2： 输入：n = 1 输出：true 示例 3： 输入：n = 2 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头， 那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样， 堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块， 使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。 大神做法1： class Solution: def canWinNim(self, n: int) -&gt; bool: return bool(n%4) ","link":"https://ganhan999.github.io/post/292、Nim 游戏/"},{"title":"237、 删除链表中的节点","content":"题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 -- head = [4,5,1,9]，它可以表示为: 示例 1： 输入：head = [4,5,1,9], node = 5 输出：[4,1,9] 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入：head = [4,5,1,9], node = 1 输出：[4,5,9] 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 用下一个节点的值替代被删除节点的值，然后节点其实并未被删除，被删除的是node的下一个节点 因为没有传头节点 大神做法1： class Solution: def deleteNode(self, node): node.val=node.next.val node.next=node.next.next ","link":"https://ganhan999.github.io/post/237、 删除链表中的节点/"},{"title":"中等236. 二叉树的最近公共祖先","content":"题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 输入：root = [1,2], p = 1, q = 2 输出：1 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归 把符合条件的搬到父节点 大神做法1： class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if not root:#如果是空那么就返回空 return None # 边界条件，如果匹配到left或right就直接返回停止递归 if root.val == p.val or root.val == q.val: return root # 这两行代码可以无脑先写好！ # 因为是DFS算法，这个模板可以无脑套用，写上之后可能你思路就清晰很多 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # 如果既在左子树找到，又在右子树找到，那么毫无疑问当前root就是公共节点 if left and right: return root # 只有左子树有，那么直接返回左子树匹配到的第一个节点 if left: return left if right: return right ","link":"https://ganhan999.github.io/post/236、二叉树的最近公共祖先/"},{"title":"235、二叉搜索树的最近公共祖先","content":"题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最 近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 两次遍历 找到两个节点 分别记录他们的路径 找到分岔点 大神做法1： class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -&gt; TreeNode: def getPath(root: TreeNode, target: TreeNode) -&gt; List[TreeNode]: path = list() node = root while node != target: path.append(node) if target.val &lt; node.val: node = node.left else: node = node.right path.append(node) return path path_p = getPath(root, p) path_q = getPath(root, q) ancestor = None for u, v in zip(path_p, path_q): if u == v: ancestor = u else: break return ancestor &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 一次遍历 我们从根节点开始遍历； 如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此将当前节点移动到它的左子节点； 如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此将当前节点移动到它的右子节点； 如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，p 和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。 大神做法2： class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -&gt; TreeNode: ancestor = root while True: if p.val &lt; ancestor.val and q.val &lt; ancestor.val: ancestor = ancestor.left elif p.val &gt; ancestor.val and q.val &gt; ancestor.val: ancestor = ancestor.right else: break return ancestor ","link":"https://ganhan999.github.io/post/235、二叉搜索树的最近公共祖先/"},{"title":"231、2的幂","content":"题目 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1 示例 2: 输入: 16 输出: true 解释: 24 = 16 示例 3: 输入: 218 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 一直除二，除到是奇数或者为1为止 大神做法1： class Solution(object): def isPowerOfTwo(self, n): if n == 0: return False while n % 2 == 0: n /= 2 return n == 1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 恒有 n &amp; (n - 1) == 0和n&gt;0的条件就是二的幂 这里n二进制最高位为1，其他为0 n-1则相反 大神做法2： class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: return n &gt; 0 and n &amp; (n - 1) == 0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 数1的个数 大神做法3： class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: return n&gt;=0 and bin(n).count('1') == 1 ","link":"https://ganhan999.github.io/post/231、2的幂/"},{"title":"中等230. 二叉搜索树中第K小的元素","content":"题目 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 输入：root = [3,1,4,null,2], k = 1 输出：1 示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3 输出：3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 中序遍历后查找 大神做法1： class Solution: def kthSmallest(self, root, k): &quot;&quot;&quot; :type root: TreeNode :type k: int :rtype: int &quot;&quot;&quot; def inorder(r): return inorder(r.left) + [r.val] + inorder(r.right) if r else [] return inorder(root)[k - 1] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 利用迭代就可以不用全部遍历二叉树 大神做法2： class Solution: def kthSmallest(self, root, k): &quot;&quot;&quot; :type root: TreeNode :type k: int :rtype: int &quot;&quot;&quot; stack = [] while True: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if not k: return root.val root = root.right ","link":"https://ganhan999.github.io/post/230、二叉搜索树中第K小的元素/"},{"title":"217、存在重复元素","content":"题目 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 本体思路 反证法，假设不存在有一个值是重复两次的，那么列表和集合的个数应该相同 #我的做法： class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: len1=len(nums) set1=set(nums) len2=len(set1) return True if len1!=len2 else False &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 排序后，然后判断前后元素是否相等 class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: # 先对数组排序 nums.sort() # 遍历数组，比较前后元素值 for i in range(len(nums)-1): if nums[i] == nums[i+1]: return True return False ","link":"https://ganhan999.github.io/post/217、存在重复元素/"},{"title":"中等215. 数组中的第K个最大元素","content":"题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 排序 大神做法1： class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: return sorted(nums, reverse = True)[k - 1] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 堆排序，库函数 大神做法2： class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: return heapq.nlargest(k, nums)[-1] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 堆排序，库函数 大神做法3： class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: ''' 寻找第k个大的元素第一想法是构建小顶堆 ''' def shift_up(new_idx): new_val = minheap[new_idx] # 临时存储需要上浮的元素 # 向上寻找父结点进行比较，决定是否上浮 while new_idx &gt; 0 and minheap[(new_idx - 1) // 2] &gt; new_val: minheap[new_idx] = minheap[(new_idx - 1) // 2] # 父结点下沉 new_idx = (new_idx - 1) // 2 # 子结点坐标上移 minheap[new_idx] = new_val # 完成结点上浮 def shift_down(start, end): start_val = minheap[start] # 临时存储头节点 # 向下寻找双子结点进行比较，决定是否下沉 while start * 2 + 1 &lt;= end: child = start * 2 + 1 # 设置左子节点 # 比较左右子节点的大小，对于小顶堆来说，需要找出最小子结点 if child + 1 &lt;= end and minheap[child] &gt; minheap[child + 1]: child += 1 if minheap[child] &lt; start_val: minheap[start] = minheap[child] # 子结点上浮 start = child else: break minheap[start] = start_val # 完成结点下沉 # 上浮式建堆 minheap = [] for i in range(min(len(nums), k)): minheap.append(nums[i]) shift_up(i) # 下沉式维护 for num in nums[k:]: if num &gt; minheap[0]: minheap[0] = num shift_down(0, k - 1) return minheap[0] &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 快速排序＋选择 大神做法4： class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def partition( left, right): tmp = nums[left] while left &lt; right: while left &lt; right and nums[right] &lt;= tmp:#注意是找大的，所以要从大到小排序 right = right - 1 nums[left] = nums[right] while left &lt; right and nums[left] &gt;= tmp: left = left + 1 nums[right] = nums[left] nums[left] = tmp mid = left return mid left = 0 right = len(nums) - 1 while 1: idx = partition(left, right) if idx == k - 1: return nums[idx] if idx &lt; k - 1: left = idx + 1 if idx &gt; k - 1: right = idx - 1 ","link":"https://ganhan999.github.io/post/215、数组中的第K个最大元素/"},{"title":"206、反转链表","content":"题目 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 本体思路 迭代 #我的做法： class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: pre = None cur = head while cur: temp = cur.next # 先把原来cur.next位置存起来 cur.next = pre pre = cur cur = temp return pre &quot;&quot;&quot;&quot;&quot;&quot; 递归 #大神做法1： class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or head.next == None: return head res = self.reverseList(head.next) head.next.next = head head.next = None return res ","link":"https://ganhan999.github.io/post/206、反转链表/"},{"title":"中等148. 排序链表","content":"题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3： 输入：head = [] 输出：[] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 合并排序，利用递归，自上而下 大神做法1： class Solution: def sortList(self, head: ListNode) -&gt; ListNode: def sortFunc(head: ListNode, tail: ListNode) -&gt; ListNode:#用快慢指针找到中点，分成两个链表 if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: slow = slow.next fast = fast.next if fast != tail: fast = fast.next mid = slow return merge(sortFunc(head, mid), sortFunc(mid, tail)) def merge(head1: ListNode, head2: ListNode) -&gt; ListNode: dummyHead = ListNode(0) temp, temp1, temp2 = dummyHead, head1, head2 while temp1 and temp2: if temp1.val &lt;= temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 elif temp2: temp.next = temp2 return dummyHead.next return sortFunc(head, None)#一开始是以None作为fast的最后一个节点的判断条件 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 合并排序，自底向上，先1后2再4以此类推 大神做法2： class Solution: def sortList(self, head: ListNode) -&gt; ListNode: def merge(head1: ListNode, head2: ListNode) -&gt; ListNode: dummyHead = ListNode(0) temp, temp1, temp2 = dummyHead, head1, head2 while temp1 and temp2: if temp1.val &lt;= temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 elif temp2: temp.next = temp2 return dummyHead.next if not head: return head length = 0 node = head while node: length += 1 node = node.next dummyHead = ListNode(0, head) subLength = 1 while subLength &lt; length: prev, curr = dummyHead, dummyHead.next while curr: head1 = curr for i in range(1, subLength): if curr.next: curr = curr.next else: break head2 = curr.next curr.next = None curr = head2 for i in range(1, subLength): if curr and curr.next: curr = curr.next else: break succ = None if curr: succ = curr.next curr.next = None merged = merge(head1, head2) prev.next = merged while prev.next: prev = prev.next curr = succ subLength &lt;&lt;= 1 return dummyHead.next ","link":"https://ganhan999.github.io/post/148、 排序链表/"},{"title":"中等146. LRU 缓存机制","content":"题目 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在， 则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例： 输入 [&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 首先建立key：value键值对，把键值对放入hashmap中，也就是python的字典。 然后再用双向链表的方式进行操作，链表中存储的是hashmap中的value 大神做法1： class ListNode: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.hashmap = {} # 新建两个节点 head 和 tail self.head = ListNode() self.tail = ListNode() # 初始化链表为 head &lt;-&gt; tail self.head.next = self.tail self.tail.prev = self.head # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法 def move_node_to_tail(self, key): # 先将哈希表key指向的节点拎出来，为了简洁起名node # hashmap[key] hashmap[key] # | | # V --&gt; V # prev &lt;-&gt; node &lt;-&gt; next pre &lt;-&gt; next ... node node = self.hashmap[key] node.prev.next = node.next node.next.prev = node.prev # 之后将node插入到尾节点前 # hashmap[key] hashmap[key] # | | # V --&gt; V # prev &lt;-&gt; tail ... node prev &lt;-&gt; node &lt;-&gt; tail node.prev = self.tail.prev node.next = self.tail self.tail.prev.next = node self.tail.prev = node def get(self, key: int) -&gt; int: if key in self.hashmap: # 如果已经在链表中了久把它移到末尾（变成最新访问的） self.move_node_to_tail(key) res = self.hashmap.get(key, -1) if res == -1: return res else: return res.value def put(self, key: int, value: int) -&gt; None: if key in self.hashmap: # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点 # 但是需要更新字典该值对应节点的value self.hashmap[key].value = value # 之后将该节点移到末尾 self.move_node_to_tail(key) else: if len(self.hashmap) == self.capacity: # 去掉哈希表对应项 self.hashmap.pop(self.head.next.key) # 去掉最久没有被访问过的节点，即头节点之后的节点 self.head.next = self.head.next.next self.head.next.prev = self.head # 如果不在的话就插入到尾节点前 new = ListNode(key, value) self.hashmap[key] = new new.prev = self.tail.prev new.next = self.tail self.tail.prev.next = new self.tail.prev = new ","link":"https://ganhan999.github.io/post/146、LRU 缓存机制/"},{"title":"中等142. 环形链表 II","content":"题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 本体思路 快慢指针法 因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部； 随后，它和slow每次向后移动一个位置。最终，它们会在入环点相遇。 #我的做法： class Solution(object): def detectCycle(self, head): fast, slow = head, head while True: if not (fast and fast.next): return fast, slow = fast.next.next, slow.next if fast == slow: break fast = head while fast != slow: fast, slow = fast.next, slow.next return fast &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 建立set集合 class Solution(object): def detectCycle(self, head): seen = set() while head: # 若存在，则表示存在环，返回True if head in seen: return head # 将节点加入seen seen.add(head) # 移向下一个节点 head = head.next return None ","link":"https://ganhan999.github.io/post/142、环形链表 II/"},{"title":"中等98. 验证二叉搜索树","content":"题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 输入: 2 / 1 3 输出: true 示例 2: 输入: 5 / 1 4 / 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 中序遍历后应该是递增序列 大神做法1： class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: stack, inorder = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if root.val &lt;= inorder: return False inorder = root.val root = root.right return True &quot;&quot;&quot;&quot;&quot;&quot; 从上往下递归 大神做法2： class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: return self.dg(root,-(2**32),2**32) #这里我直接粗暴地将最小值和最大值设置为一个足够小（大）的数，你可以设置你认为的最优解 def dg(self,root,min_v,max_v): # 参数：root：当前节点，min_v：允许最小值（下界），max_v：允许最大值（上界） if root == None: # 如果当前节点为空，证明已经递归到叶子节点，返回True return True if root.val &lt; max_v and root.val &gt; min_v : # 如果当前节点值符合规定，继续进行之后的递归 pass else: # 如果不符合规定，之间返回 False return False if self.dg(root.left,min_v,root.val) == False: # 对左子树进行递归，此时最大值应该为当前节点值 return False if self.dg(root.right,root.val,max_v) == False:# 对右子树进行递归，此时最小值应该为当前节点值 return False return True # 如果成功避开所有坑，恭喜，这个当前节点下的子树是一个二叉搜索树 ","link":"https://ganhan999.github.io/post/98、验证二叉搜索树/"},{"title":"234、回文链表","content":"题目 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 本体思路 链表转列表 #我的做法： class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: vals = [] current_node = head while current_node is not None: vals.append(current_node.val) current_node = current_node.next return vals == vals[::-1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 整个流程可以分为以下五个步骤： 找到前半部分链表的尾节点。 反转后半部分链表。 判断是否回文。 恢复链表。 返回结果。 class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if not head: return True fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next pre = None cur = slow.next slow.next = None while cur:#反转链表 tmp = cur.next cur.next = pre pre = cur #pre指向前一个指针 cur = tmp while pre: if head.val != pre.val: return False head = head.next pre = pre.next return True ","link":"https://ganhan999.github.io/post/234、回文链表/"},{"title":"中等96. 不同的二叉搜索树","content":"题目 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ 3 2 1 1 3 2 / / \\ 2 1 2 3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 动态规划 大神做法1： class Solution: def numTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; G = [0]*(n+1) G[0], G[1] = 1, 1 for i in range(2, n+1): for j in range(1, i+1): G[i] += G[j-1] * G[i-j] return G[n] ","link":"https://ganhan999.github.io/post/96、不同的二叉搜索树/"},{"title":"中等95. 不同的二叉搜索树 II","content":"题目 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。 示例： 输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ 3 2 1 1 3 2 / / \\ 2 1 2 3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归 大神做法1： class Solution: def generateTrees(self, n: int) -&gt; List[TreeNode]: def generateTrees(start, end): if start &gt; end: return [None] allTrees = [] for i in range(start, end + 1): # 枚举可行根节点 # 获得所有可行的左子树集合 leftTrees = generateTrees(start, i - 1) # 获得所有可行的右子树集合 rightTrees = generateTrees(i + 1, end) # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上 for l in leftTrees: for r in rightTrees: currTree = TreeNode(i) currTree.left = l currTree.right = r allTrees.append(currTree) return allTrees return generateTrees(1, n) if n else [] ","link":"https://ganhan999.github.io/post/95、不同的二叉搜索树 II/"},{"title":"中等94. 二叉树的中序遍历","content":"题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[2,1] 示例 5： 输入：root = [1,null,2] 输出：[1,2] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归 大神做法1： class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: def inorder(root): if not root: return inorder(root.left) # 递归完左子树后，处理节点值 ans.append(root.val) inorder(root.right) ans = [] inorder(root) return ans &quot;&quot;&quot;&quot;&quot;&quot; 利用栈 大神做法2： class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] stack = [] while stack or root: if root: # 这部分将左子树压入栈中 stack.append(root) root = root.left else: # 进入右子树前处理值 tmp = stack.pop() ans.append(tmp.val) # 进入右边第一个子树，继续循环 root = tmp.right return ans ","link":"https://ganhan999.github.io/post/94、二叉树的中序遍历/"},{"title":"中等92. 反转链表 II","content":"题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 用三个指针,进行插入操作 例如: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 将节点3插入节点1和节点2之间 变成: 1-&gt;3-&gt;2-&gt;4-&gt;5-&gt;NULL 再将节点4插入节点1和节点3之间 变成:1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 实现翻转的效果! 大神做法1： class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next = head pre = dummy # 找到翻转链表部分的前一个节点, 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 指的是 节点值为1 for _ in range(m - 1): pre = pre.next # 用 pre, start, tail三指针实现插入操作 # tail 是插入pre,与pre.next的节点 start = pre.next tail = start.next for _ in range(n - m): start.next = tail.next tail.next = pre.next pre.next = tail tail = start.next return dummy.next &quot;&quot;&quot;&quot;&quot;&quot; 找到要翻转部分的链表,将其翻转,再与原链表拼接; 大神做法2： class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next = head pre = dummy # 找到翻转链表部分的前一个节点, 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 指的是 节点值为1 for _ in range(m-1): pre = pre.next # 用双指针,进行链表翻转 node = None cur = pre.next for _ in range(n-m+1): tmp = cur.next cur.next = node node = cur#node是头节点 cur = tmp#cur是原链表的下一个节点 # 将翻转部分 和 原链表拼接 pre.next.next = cur pre.next = node return dummy.next ","link":"https://ganhan999.github.io/post/92、反转链表 II/"},{"title":"中等90. 子集 II","content":"题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 迭代 大神做法1： class Solution: def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: ans = [[]] for num in nums: ans += [ sorted([num] + i) for i in ans if sorted([num] + i) not in ans] return ans &quot;&quot;&quot;&quot;&quot;&quot; 回溯 大神做法2： class Solution: def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums = sorted(nums) n = len(nums) res = [] def back_func(start=0, temp=[]): res.append(temp[:]) for i in range(start, n): if i &gt; start and nums[i] == nums[i-1]: continue temp.append(nums[i]) back_func(i+1, temp) temp.pop() back_func() return res ","link":"https://ganhan999.github.io/post/90、子集 II/"},{"title":"中等89. 格雷编码","content":"题目 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 示例 1: 输入: 2 输出: [0,1,3,2] 解释: 00 - 0 01 - 1 11 - 3 10 - 2 对于给定的 n，其格雷编码序列并不唯一。 例如，[0,2,3,1] 也是一个有效的格雷编码序列。 00 - 0 10 - 2 11 - 3 01 - 1 示例 2: 输入: 0 输出: [0] 解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 看官方文档 https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/ class Solution: def grayCode(self, n: int) -&gt; List[int]: ''' 格雷编码结论： 设G(n)表示总位数为n的各类编码集合，根据以下策略可以求出G(n+1) 1. 将G(n)的每个元素前添加0得到G'(n) 2. 将G'(n)反转得到镜像R(n)，在R(n)中的每个元素前添加1得到R'(n) 3. 将G'(n)与R'(n)合并得到G(n+1) 编码思路： 1. 初始化G(0)和位数标识head 2. 外层循环次数为总位数n 3. 内层循环倒序遍历res(对应上述第2步反转),位数标识加上当前索引对应的值即为R'(n)中的元素 4. 在res后追加上述计算的元素，遍历结束，得到Gray编码集 ''' res, head = [0], 1 for i in range(n): for j in range(len(res)-1, -1, -1): res.append(head+res[j])#这里就相当于在最前面加了一个1，前面的不变，后面加一倍 head &lt;&lt;= 1 return res ","link":"https://ganhan999.github.io/post/89、格雷编码/"},{"title":"中等86. 分隔链表","content":"题目 给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例： 输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 本体本质就是将链表分为： 1.小于 x 部分的链表按照原始顺序 记为 p 2.大于等于 x 部分的链表按照原始顺序 记为 q 3.拼接两个链表，p --&gt; q class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: p=less=ListNode(0) q=more=ListNode(0) while head: if head.val&lt;x:#把所有小于x的排成一个链表 less.next=head less=less.next else:#把所有大于等于x的排成一个链表 more.next=head more=more.next head=head.next more.next=None less.next=q.next#两个链表合成一起 return p.next ","link":"https://ganhan999.github.io/post/86、分隔链表/"},{"title":"Java Mongodb","content":"MongoDB 1.Database 数据库分类 关系型数据库(RDBMS) MySQL, Oracle, DB2， SQL Server… 该数据库中全都是表 非关系型数据库(No SQL) MongoDB, Redis… 键值对数据库 文档数据库MongoDB MongoDB是为快速开发互联网web应用而设计的数据库系统 MongoDB的数据模型时面向文档的(BSON) 2.MongoDB 2.1.安装MongoDB 安装 配置环境 在c盘根目录创建data文件夹，在data中创建文件夹db 运行mongodb cmd：mongod //启动mongodb服务器，不要关闭 另一个cmd：mongo //连接mongodb，出现&gt; 如果想更改文件目录（不在c盘下，但仍需data+db) mongod --dbpath 文件路径\\data\\db [–port 123 //更改端口] database 服务器： 服务器用来保存数据 mongod 用来启动服务器 客户端： 客户端用来操作服务器，对数据进行增删查改的操作 mongo 用来启动客户端 将mongodb设置为系统服务，可以自动在后台启动，不需要每次都手动启动 在C盘根目录创建目录data mkdir c:\\data\\db mkdir c:\\data\\log 创建配置文件 在bin同目录下添加一个配置文件 mongod.cfg 以管理员身份运行cmd 执行如下命令 sc.exe create MongoDB binPath=&quot;\\&quot;D:\\MongoDB\\Server\\4.0\\bin\\mongod.exe\\&quot; --service --config=\\&quot;D:\\MongoDB\\Server\\4.0\\mongod.cfg\\&quot;&quot; DisplayName=&quot;MongoDB&quot; start=&quot;auto&quot; 1 启动mongodb服务 如果启动失败，证明操作有误 在控制台输入 sc delete MongoDB 删除之前的操作 重新再来一次 2.2.基本概念 数据库 是一个仓库，可以存放集合 集合 类似于数组，在集合中可以存放文档 文档 文档数据库中最小单位，我们存储和操作的内容都是文档 在mongodb中，数据库和集合都不需要手动创建，当创建文档时，如果文档所在的集合或数据库不存在则会自动创建 当一个文档的属性值是一个文档时，内部的文档称为 内嵌文档，mongoDB支持通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配，此时必须使用引号 eg: db.users.find({‘hobby.movies’:‘hero’}) 数据库的方法能少调用尽量少调用，因为会降低性能 2.3.基本指令 显示当前所有数据库：show dbs|databases 进入到指定的数据库中：use tes 当前所处数据库：db 显示数据库中所有集合：show collections 2.4.数据库的CRUD的操作 2.4.1数据库中插入文档 db.collection_name.insert(doc) 向集合中插入一个或多个文档 eg: 向test数据库中，stus集合中插入一个新的学生对象 {name: “www”, age: 18, gender: 男} db.stus.insert({name: “www”, age: 18, gender: “男”}) 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库自动为文档添加该属性，该属性用来作为文档唯一标识；如果自己 _id属性，需要注意该属性的唯一性 db.collection_name.insertOne() 插入一个文档 db.collection_name.insertMany() 插入多个文档 2.4.2数据库中查找文档 db.collection_name.find() 查询所有文档 可以接受一个对象作为条件参数 find()返回一个数组 db.conllection_name.find(“hello”); db.conllection_name.find(“hello”); eg: db.stus.find({idb.&quot;hello})’ db.collection_name.findOne({{}}); db.conllection_name.find(“hello”).count()|length(); //f返回数量 2.4.3数据中更改文档 db.collection_name.update(查询条件， 新对象) update()默认情况下会自动使用新对象替换就旧对象 如果需要指定属性，而不是替换则需要使用修改操作符 $set：可以用来修改文档中的指定属性 db.stuts.update(匹配条件, {$set: {修改属性键值对}}) $unset: 删除属性，用法同set $push: 用于向数组中添加一个新的元素 $addToSet: 向数组中添加一个新元素，如果数组中已经存在了该元素则添加失败 update()默认只会修改一个，可以更改multi属性 db.collection_name.updateMany() 同时修改多个符合条件的文档 db.collection_name.updateOne() 修改一个符合条件的文档 2.4.4数据库文档删除 db.collection_name.remove() remove可以根据条件删除文档，传递条件的方式同find一样 默认会删除符合条件的所有文档 如果传递第二个参数，值为true，则只会删除一个 如果传递一个空对象，则会删除所有文档，性能较差，此时可删除集合： db.collection_name.drop() db.collection_name.deleteOne() 删除一个文档 db.collection_name.deleteMany() 删除多个文档 db.collection_name.drop() 删除集合 db.dropDatabase() 删除数据库 一般数据库中的数据都不会删除，所以删除的方法很少调用 一般会在数据中添加一个字段，来表示数据是否被删除 2.5.文档之间的关系 2.5.1 一对一 MongoDB中，可以通过内嵌文档的形式来体现出一对一的关系 db.wifeAndHusband.insert([ { name: &quot;huangrong&quot;, husband: { name: &quot;guojing&quot; } }, { name: &quot;panjinlian&quot;, husband: { name: &quot;wudalang&quot; } }, ]); 1234567891011121314 2.5.2 一对多/多对一 用户 - 订单 映射 db.users.insert([ {username: 'swk'}, {username: 'zbj'} ]); db.order.insert({ list: ['apple','banana'], user_id: ObjectId(&quot;5fc49a3d759231f39f683f4d&quot;) }); 12345678910 2.5.3 多对多 分类 - 商品 同为映射，把上列user_id改为数组即可 2.6 补充内容 排序 查询文档时，默认情况按_id值进行排序（升序） sort() 可以用来指定文档排序的规则，需要传递一个对象指定排序规则（属性名：1|-1） limit skip sort 可以以任意的顺序进行调用 投影 在查询时，可以在第二个参数的位置来设置查询结果的投影 {属性名：0|1} 3.Mongoose Mongoose是一个让我们可以通过Node来操作mongoDB的模块 Mongoose是一个对象文档模型（ODM） 好处 可以为文档创建一个模式结构（Schema） - 约束 可以对模型中的对象/文档进行验证 数据可以通过类型转换为对象模型 可以使用中间件来应用业务逻辑挂钩 mongoose提供的新对象 Schema 模式对象 schema对象定义约束了数据库中的文档结构 Model Model对象作为集合中的所有文档的表示，相当于mongodb数据库中的集合collection Document Document表示集合中的具体文档，相当于集合中的一个具体的文档 使用 下载安装 npm i mongoose --save 在项目中引入mongoose var mongoose = require(“mongoose”) 连接mongodb数据库 mongoose.connect(‘mongodb://数据库的ip地址:端口号/数据库名’, {useMongoClient: true}) 如果端口号默认可以省略不写 断开数据库连接（一般不需要） mongdb数据库，一般情况下只需连接一次，之后除非项目停止服务器关闭，否则连接一般不会断开 mongoose.disconnect() 监听MongoDB数据库的连接状态 在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接 通过监视该对象的状态，可以来监听数据库的连接与断开 数据库连接成功的事件 mongoose.connection.once(“open”, function(){}); 数据库断开的事件 mongoose.connection.once(“close”, function(){}); 连接数据库 创建schema var mongoose = require('mongoose'); var Schema = mongoose.Schema; var blogSchema = new Schema({ title: String, author: String, body: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number } }); 123456789101112131415 通过schema创建model model代表的是数据库中的集合，通过model才能对数据库进行操作 mongoose.model(modelName, schema); modelName: 要映射的集合(mongoose会自动将集合变为复数) schema: 约束 stuModel.create(doc, function(err){}); 有了model，就可以对数据库进行增删改查的操作了 model 增加 Model.create(doc(s), [callback]) 用来创建一个或多个文档并添加到数据库中 参数： doc(s) 可以是一个文档对象，也可以是一个文档对象的数组 callback 当操作完成以后调用的回调函数 查找 Model.find() //直接获取 StuModel.find({name: &quot;唐僧&quot;}, function(err, docs){ if(!err){ console.log(docs); } }); //投影获取字段 StuModel.find({},{name:1, _id:0}, function(err, docs){ if(!err){ console.log(docs); } }); //skip：跳过的数量 limit：显示的数量 StuModel.find({},&quot;name age -_id&quot;,{skip: 3, limit: 1}, function(err, docs){ if(!err){ console.log(docs); } }); 1234567891011121314151617181920 通过find()查询的结果，返回的对象，就是document，文档对象 document对象就是model的实例 Model.findById() 通过id寻找 Model.findOne() 只返回第一个 修改 Model.update(conditions, doc[, options] [, callback]) Model.updateMany(conditions, doc[, options] [, callback]) Model.updateOne(conditions, doc[, options] [, callback]) 参数： conditions 查询条件 doc 修改后的对象 options 配置参数 callback 回调函数 StuModel.updateOne({name:&quot;唐僧&quot;},{$set:{age:20}}, function(err){}); 1 删除 Model.remove(conditions [, callback]) Model.deleteOne(conditions [, callback]) Model.deleteMany(conditions [, callback] 统计文档数量 Model.count(conditions [,callback]) Document save() Model#save([options], [fn]) stu.save(function(err){ if(!err){ console.log(&quot;保存成功&quot;); } }) 12345 update(update, [options], [callback]) 修改对象 StuModel.findOne({}, function(err, doc){ if(!err){ doc.update({$set:{age:28}}, function(err){ console.log(&quot;修改成功&quot;); }); // console.log(doc); } }); 12345678 remove([callback]) 删除对象 StuModel.findOne({}, function(err, doc){ if(!err){ doc.remove(function(err){ if(!err){ console.log(&quot;大师兄再见&quot;); } }); } }); 123456789 get(name) 获取文档中的指定属性值 set(name, value) 设置文档的指定的属性值s id 获取文档的_id 属性值 toObject() 将document对象转换为普通的js对象 转换以后所有的document对象的方法都不能使用了 ","link":"https://ganhan999.github.io/post/Java Mongodb/"},{"title":"中等82. 删除排序链表中的重复元素 II","content":"题目 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出: 1-&gt;2-&gt;5 示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3 输出: 2-&gt;3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 直接按照规律循环解题。 但避免开头就出现重复数字，因此还是先加空头 class Solution:#感谢各位的更好思路或改进办法 def deleteDuplicates(self, head: ListNode) -&gt; ListNode: thead = ListNode('a') thead.next = head pre,cur = None,thead while cur: pre=cur cur=cur.next while cur and cur.next and cur.next.val == cur.val: t=cur.val while cur and cur.val==t: cur=cur.next pre.next=cur return thead.next ","link":"https://ganhan999.github.io/post/82、 删除排序链表中的重复元素 II - 副本/"},{"title":"Java 23种设计模式","content":"设计原则：设计模式（总纲） 创建型：单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 结构型：代理模式 适配器模式 装饰器模式 桥接模式 组合模式 享元模式 外观模式 行为型： 观察者模式 模板方法模式 命令模式 状态模式 职责链模式 解释器模式 中介者模式 访问者模式 策略模式 备忘录模式 迭代器模式 以上便是设计模式的分类以及各个模式的传送门，可以看到其中行为型模式的个数为最多，结构型次之，创建型设计模式最少。 在写这篇文章的时候，LZ考虑的最多的一个问题就是，从哪几个维度去对比设计模式能让大家更加清楚的看出各个设计模式的区别与联系，思来想去，LZ决定从以下几个维度去对比设计模式。 设计原则：描述每个设计模式都遵循了哪些设计原则，破坏了哪些设计原则。 常用场景：描述各个设计模式大部分情况下，都会在哪些场景下出现。 使用概率：主要指在普遍的工作当中，该设计模式出现的频率，若是类库或是开源框架提供的功能中包含该模式，则也会计算其频率。 复杂度：特指一个设计模式在实现的时候的复杂度，主要的衡量标准是类的数量、类之间的耦合关系。 变化点：设计模式很大的一个意义在于容纳变化，掌握一个设计模式的变化点是非常重要的一件事。 选择关键点：当选择使用一个设计模式的时候，指出最关键的选择点在哪里。 逆鳞：龙有逆鳞，不可触摸，同样的，设计模式也有逆鳞，有些地方是不能碰的。 相关设计模式：与其它设计模式的关系。 创建型设计模式 单例模式 设计原则：无 常用场景：应用中有对象需要是全局的且唯一 使用概率：99.99999% 复杂度：低 变化点：无 选择关键点：一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误 逆鳞：在以为是单例的情况下，却产生了多个实例 相关设计模式 原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。 简单工厂模式 设计原则：遵循单一职责、违背开闭原则 常用场景：需要在一堆产品中选择其中一个产品 使用概率：99.99999% 复杂度：低 变化点：产品的种类 选择关键点：一种产品是否可根据某个参数决定它的种类 逆鳞：工厂类不能正常工作 相关设计模式 工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象化，在这两者之间做选择，主要看将工厂进一步抽象化是否有必要，通常情况下，如果工厂的作用仅仅是用来制造产品，则没必要使用工厂方法模式。 工厂方法模式 设计原则：遵循单一职责、依赖倒置、开闭原则 常用场景：一种场景是希望工厂与产品的种类对客户端保持透明，给客户端提供一致的操作，另外一种是不同的工厂和产品可以提供客户端不同的服务或功能 使用概率：60% 复杂度：中低 变化点：工厂与产品的种类 选择关键点：工厂类和产品类是否是同生同灭的关系 逆鳞：无 相关设计模式 抽象工厂模式：工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。 抽象工厂模式 设计原则：遵循单一职责、依赖倒置、开闭原则 常用场景：需要一个接口可以提供一个产品族，且不必知道产品的具体种类 使用概率：30% 复杂度：中 变化点：工厂与产品的种类 选择关键点：产品族是否需要一起提供，且是否有一致的接口 逆鳞：无 相关设计模式 建造者模式：两者都是建造一批对象或者说产品，不同的是两者的目的和实现手段，在建造者模式中，是为了复用对象的构建过程而定义了一个指挥者，而在抽象工厂模式中，是为了提供一个这批对象的创建接口而定义了抽象工厂接口。 建造者模式 设计原则：遵循单一职责、开闭原则 常用场景：需要构建一批构建过程相同但表示不同的产品，而构建过程非常复杂 使用概率：10% 复杂度：中 变化点：产品的表示 选择关键点：各个产品的构建过程是否相同 逆鳞：指挥者不能正常工作 原型模式 设计原则：无 常用场景：需要在运行时动态的创建指定实例种类的对象，或是需要复用其状态 使用概率：10% 复杂度：中低 变化点：无 选择关键点：创建出来的对象是否可以立即投入使用 逆鳞：在以为是深度拷贝的情况下，却未实现深度拷贝 结构型设计模式 代理模式 设计原则：体现功能复用 常用场景：需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理，若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理，否则可使用cglib 使用概率：99.99999% 复杂度：中高 变化点：静态代理没有变化点，动态代理的变化点为具有相同切入点的类 选择关键点：静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点 逆鳞：切入点的不稳定 相关设计模式 适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口 适配器模式 设计原则：遵循开闭原则、体现功能复用 常用场景：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法 使用概率：40% 复杂度：中 变化点：无 选择关键点：定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案 逆鳞：无 相关设计模式 装饰器模式：对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。 装饰器模式 设计原则：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用 常用场景：一个类需要动态的添加功能，且这些功能可以相互叠加 使用概率：99.99999% 复杂度：中 变化点：动态添加的功能或者说装饰器 选择关键点：添加的功能是否需要动态组装 逆鳞：无 桥接模式 设计原则：遵循单一职责、迪米特、开闭原则，体现功能复用 常用场景：一个对象有多个维度的变化，需要将这些维度抽离出来，让其独立变化 使用概率：20% 复杂度：中高 变化点：维度的扩展与增加 选择关键点：是否可以将对象拆分成多个不相关的维度 逆鳞：无 组合模式 设计原则：遵循依赖倒置、开闭原则，破坏接口隔离 常用场景：当有一个结构可以组合成树形结构，且需要向客户端提供一致的操作接口，使得客户端操作忽略简单元素与复杂元素 使用概率：30% 复杂度：中 变化点：节点的数量 选择关键点：对外提供一致操作接口的结构是否可转化为树形结构 逆鳞：结构不稳定或结构中的节点有递归关系 享元模式 设计原则：无 常用场景：一些状态相同的对象被大量的重复使用 使用概率：90% 复杂度：中 变化点：无 选择关键点：被共享的对象是否可以将外部状态提取出来 逆鳞：没有将外部状态提取完全 外观模式 设计原则：遵循迪米特 常用场景：一个子系统需要对外提供服务 使用概率：60% 复杂度：中 变化点：无 选择关键点：子系统对外提供服务是否需要依赖很多的类 逆鳞：子系统对外提供的服务的变化或子系统本身的不稳定 相关设计模式 中介者模式：二者都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系 行为型设计模式 观察者模式 设计原则：遵循迪米特、开闭原则 常用场景：需要将观察者与被观察者解耦或者是观察者的种类不确定 使用概率：40% 复杂度：中 变化点：观察者的种类与个数 选择关键点：观察者与被观察者是否是多对一的关系 逆鳞：观察者之间有过多的细节依赖 模板方法模式 设计原则：破坏里氏替换，体现功能复用 常用场景：一批子类的功能有可提取的公共算法骨架 使用概率：80% 复杂度：中低 变化点：算法骨架内各个步骤的具体实现 选择关键点：算法骨架是否牢固 逆鳞：无 命令模式 设计原则：遵循迪米特、开闭原则 常用场景：行为的请求者与行为的处理者耦合度过高 使用概率：20% 复杂度：中高 变化点：命令的种类 选择关键点：请求者是否不需要关心命令的执行只知道接受者 逆鳞：命令的种类无限制增长 相关设计模式 职责链模式：容易将二者关联在一起的原因是，二者都是为了处理请求或者命令而存在的，而且二者都是为了将请求者与响应者解耦，不同的是命令模式中，客户端需要知道一个命令的接受者，在创建命令的时候就把接受者与命令绑定在一起发送给调用者，而职责链模式中，客户端并不关心最终处理请求的对象是谁，客户端只是封装一个请求对象，随后交给职责链的头部而已，也正因为这样，二者的实现方式，有着很大的区别 状态模式 设计原则：遵循单一职责、依赖倒置、开闭原则 常用场景：一个对象在多个状态下行为不同，且这些状态可互相转换 使用概率：20% 复杂度：中 变化点：状态的种类 选择关键点：这些状态是否经常在运行时需要在不同的动态之间相互转换 逆鳞：无 相关设计模式 策略模式：二者的实现方式非常相似，策略接口与状态接口，具体的策略与具体的状态以及二者都拥有的上下文，如果看它们的类图，会发现几乎一模一样，而二者不同的地方就在于，状态模式经常会在处理请求的过程中更改上下文的状态，而策略模式只是按照不同的算法处理算法逻辑，而且从实际场景来讲，顾名思义，状态模式改变的是状态，策略模式改变的是策略 职责链模式 设计原则：遵循迪米特 常用场景：一个请求的处理需要多个对象当中的一个或几个协作处理 使用概率：15% 复杂度：中 变化点：处理链的长度与次序 选择关键点：对于每一次请求是否每个处理的对象都需要一次处理机会 逆鳞：无 解释器模式 设计原则：遵循单一职责 常用场景：有一种语言被频繁的使用 使用概率：0.00009% 复杂度：中高 变化点：语言的规则 选择关键点：被频繁使用的语言是否可用文法表示 逆鳞：语言的规则无限制增长或规则十分不稳定 中介者模式 设计原则：遵循迪米特，破坏单一职责 常用场景：一个系列的对象交互关系十分复杂 使用概率：10% 复杂度：中 变化点：对象之间的交互 选择关键点：复杂的交互关系是否有共性可被中介者承担 逆鳞：中介者无法工作 访问者模式 设计原则：遵循倾斜的开闭原则 常用场景：作用于一个数据结构之上的操作经常变化 使用概率：5% 复杂度：高 变化点：数据结构之上的操作 选择关键点：数据结构是否稳定以及操作是否经常变化 逆鳞：数据结构的不稳定 策略模式 设计原则：遵循单一职责、依赖倒置、迪米特、开闭原则 常用场景：算法或者策略需要经常替换 使用概率：60% 复杂度：中 变化点：策略的种类 选择关键点：客户端是否依赖于某一个或若干个具体的策略 逆鳞：无 备忘录模式 设计原则：遵循迪米特、开闭原则 常用场景：需要在对象的外部保存该对象的内部状态 使用概率：5% 复杂度：中 变化点：无 选择关键点：是否可以在必要的时候捕捉到对象的内部状态 逆鳞：大对象的备份 迭代器模式 设计原则：遵循迪米特 常用场景：需要迭代访问一个聚合对象中的各个元素，且不暴露该聚合对象内部的表示 使用概率：99.99999% 复杂度：中 变化点：聚合对象的种类 选择关键点：客户端是否关心遍历的次序 逆鳞：无 相关设计模式 访问者模式：二者都是迭代的访问一个聚合对象中的各个元素，不同的是，访问者模式中，扩展开放的部分在作用于对象的操作上，而迭代器模式中，扩展开放的部分在聚合对象的种类上，而且二者的实现方式也有着很大的区别。 作者：马士兵的小迷弟 https://www.bilibili.com/read/cv4826481 出处： bilibili ","link":"https://ganhan999.github.io/post/Java 23种设计模式/"},{"title":"中等81. 搜索旋转排序数组 II","content":"题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 这道题和33题一样，但是包含了重复元素。其实影响到的是，当左端点和右端点相等时，无法判断mid在左半边有序数组还是右半边有序数组，所以只需要一直pop直到左端点和右端点不相等就可以了。就加上两句话即可： class Solution: def search(self, nums: List[int], target: int) -&gt; bool: ######## 就是这两句 ####### while len(nums) &gt; 1 and nums[0] == nums[-1]: nums.pop() ########################## length = len(nums) left, right = 0, length - 1 while left &lt;= right: mid = left + (right - left) // 2 if nums[mid] == target: return True if nums[0] &lt;= nums[mid]: # mid在左半边有序数组 if nums[0] &lt;= target &lt; nums[mid]: # 并且目标在左半边有序数组中 right = mid - 1 else: left = mid + 1 else: # mid在右半边有序数组 if nums[mid] &lt; target &lt;= nums[-1]: # 并且目标在右半边有序数组中 left = mid + 1 else: right = mid - 1 return False ","link":"https://ganhan999.github.io/post/81、搜索旋转排序数组 II/"},{"title":"中等80. 删除排序数组中的重复项 II","content":"题目 给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 我们使用两个变量，i 是遍历数组的指针，count 是记录当前数字出现的次数。count 的最小计数始终为 1。大神做法1： class Solution(object): def removeDuplicates(self, nums): i, count = 1, 1 while i &lt; len(nums): if nums[i] == nums[i - 1]: count += 1 if count &gt; 2: nums.pop(i) i -= 1 else: count = 1 i += 1 return len(nums) &quot;&quot;&quot;&quot;&quot;&quot; 双指针法，一个指向要被替换的位置，一个遍历元素 1、我们使用了两个指针，i 是遍历指针，指向当前遍历的元素；j 指向下一个要覆盖元素的位置。 2、同样，我们用 count 记录当前数字出现的次数。count 的最小计数始终为 1。 3、我们从索引 1 开始一次处理一个数组元素。 4、若当前元素与前一个元素相同，即 nums[i]==nums[i-1]，则 count++。若 count &gt; 2，则说明遇到了多余的重复项。 在这种情况下，我们只向前移动 i，而 j 不动。 5、若 count &lt;=2，则我们将 i 所指向的元素移动到 j 位置，并同时增加 i 和 j。 6、若当前元素与前一个元素不相同，即 nums[i] != nums[i - 1]，说明遇到了新元素，则我们更新 count = 1， 并且将该元素移动到 j 位置，并同时增加 i 和 j。 7、当数组遍历完成，则返回 j。大神做法2： class Solution(object): def removeDuplicates(self, nums): j, count = 1, 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: count += 1 else: count = 1 if count &lt;= 2: nums[j] = nums[i] j += 1 return j ","link":"https://ganhan999.github.io/post/80、删除排序数组中的重复项 II/"},{"title":"狂神说秋招","content":"1、何为秋招？ 1.1、应届生 暑假：大学生（实习、工作） 8月、春招！ 应届毕业生！ 2015年级 2019界 2016年级 2020界 应届毕业生： 大三升大四！ 大三暑假找工作找实习！ 大四：毕业再找！切记、不好！ 2020校招！不收2019届！ 1.2、秋招/春招/校招 校招： 校园招聘 流程：网申-笔试-面试（23轮）-录取通知-体检-签三方-毕业！-上班！ 秋招： 7来年一月 7~10，校招核心！ 秋招名额远大于春招！ 招聘信息 宣讲会 招聘会 春招： 春节到6月 3~4、秋招补录！ 网申（不打无准备的仗） 网络在线申请，大型企业！ 注意：填表格！ 开放性问题：优缺点？失败经历？公司的看法？ 一定要仔细？大三时候就一定要准备好！ 复制到记事本！ 宣讲会 公司 HR、技术！ 讲解公司的内容、岗位、待遇、Q&amp;A？ 1、开完就走！ 2、现场接受简历 3、现场接受简历、面试！一分钟（记住你！ 准备60s的自我介绍） 4、现场接受简历、面试、笔试！ 多跑! 招聘会（多对一）体验一次！ 政府: 人力资源组织 ! 现场招聘/网络招聘 现场招聘 综合/理工科/经管文科 准备： HR、直接递交简历。现场面试， hR！ 1、简历！ 2、带上U盘！资料文件！防备不时之需 3、目标确定性： 1000家公司（2~3 公司的信息、岗位需要的职业技能！） 简历是可以改变的！（掌握技能、实习工作经历） 3个公司、3份不一样的（根据公司的需要来定 制！） 1.3、社招/海投 社招： 社会招聘！ 目标人群： 毕业的人、经验人士！ 社招持续存在！ 社招: 校招是有新人培训！社招直接进去就工作！ 一定都是招收有经验的人士！ 参加校招：大四！不要在毕业之后！ 大三~大四！重视校招！ 社招: 猎头、打造知名度（开源项目、博客、媒体影响力！） 海投: 广撒网！ 不建议：没有针对！ 百度、阿里：做了准备、历届面试题、实训！ 投的数量多不一定有用！ 不打无准备的仗： 秋招、社招（选定心仪的公司！ 2~3） 1、集中精力研究这些公司的面试！ 2、努力提升自己的技能！拿到再多的oﬀer ，最终你只能选择一家！ 面试！一开始就选择了！ 100家公司！ 没有人鸟你，自我否定！ 2、秋招信息如何获取？ 秋招：获取秋招信息 1、公司官网+官方招聘公众号！正规 2、内推（熟人内部推荐！群里/公众号）学长、学姐 3、牛客网！专业的网站去找咨询！ 牛客求职区：https://www.nowcoder.com/recommend 牛客讨论区：https://www.nowcoder.com/discuss 校招日程汇总：https://www.nowcoder.com/school/schedule 大数据：筛选出有用的消息！ 不要超过5家公司！ 百度、阿里、腾讯、美团、京东 到社会上第一步: 选择 1、钱多事少离家近 （钱多） 2、背书，大公司！ 证明！ 3、锻炼自己！ 工资 、能力对等！ 3、如何备战秋招？ 3.1、简历（ps做简历） 1、模板！ word 黑白字！ 一定要找一个稳健的模板（工作相关的模板） 尽量不要太多（最多2~3张/ 1张能解决是最好的） 突出主题（线上发邮件：PDF！不要发word、文 字乱码！） 颜值高、照片！（大学都去拍摄一组正装的艺术照！） 不同的公司岗位你要写不同的简历！ 内容： 个人信息： 姓名、求职岗位、手机号、邮箱地址（突出显示、一下子就能看到自己的联系方 式） 学校的学历： 毕业院校、本科：直接写本科院校：研究生：本科毕业院校、研究生毕业院 校。有的公司敲门砖就是 985/211 问题：我的学校不够好？ 学校不是最致命的条件、毕业院校不是很好（重点就是 实习经 历+项目经历 博客/影响力的东西：一定要突出！（价值） 学习一定要产出！ 实习经历：（重中之重） 大厂实习经历！最好的！ 假设没有实习经历。 突出项目经历！ 项目经历： 自己在学校做过哪些项目 真实，自己做过哪些项目经历 切记不要流水账！ 我做了什么项目 我在项目中负责那一部分 在项目开发中遇到了哪些难题 我是怎么处理和解决的！ 不要伪造（培训机构出来的人，大部分都会伪造项目经历和工作年龄！） 校园经历： 学生会、社团。自己在学校举办的活动。 获奖经历。 奖学金 掌握的技能 如实的写 熟悉、精通（少用精通，最多1~2个精通！） 面试会通过这个来问你！ 不要在这里给自己挖坑！ 2、真实！ 3、措辞！ 3.2、笔试准备 技术岗（编程和问答！） 解决方法：看书+练题！多锻炼自己的说话能力！ 练题不要瞎练习：针对性练习题目 目标： 找到历届的笔试面试题！ 提前3个月做准备！ 刷题+属性以前的套路！ 名企笔试真题练习：https://www.nowcoder.com/contestRoom 校招笔试真题汇总：https://www.nowcoder.com/contestRoom?mutiTagIds=1657 校招备战学习计划：https://www.nowcoder.com/studypath/1 在线编程：https://www.nowcoder.com/activity/oj 剑指oﬀer在线编程：https://www.nowcoder.com/ta/coding-interviews 不打无准备的仗！ 算法很重要，没有套路，就是多刷题！一定要多花时间研究！ 大学生：4年！ 大一大二就扎实学习基础技能！ 大三了解公司，了解面试，刷题！ 大三暑假：找实习找工作 大四就是毕业、交朋友、熟悉公司、到社会！ 3.3、面试准备 多看面经！ 每个公司的面试风格都不同！ 牛客讨论区：https://www.nowcoder.com/discuss 各岗位汇总目录：https://www.nowcoder.com/discuss/167046 各公司面经汇总目录：https://www.nowcoder.com/discuss/161635 1、多看他人的面经？ 2、善于总结自己的面试经验？多分享（交流） 练手： 中意大公司，面试很紧张！ 去小公司面试锻炼：慢慢找到自己的不足，锻炼经验，保证自己面试不经常！ 练到自己不紧张不惧怕面试了就可以去自己中意的公司面试！ 要把最好的状态留个最重要的面试！ 面试：不断地打击自信心的过程！ 千万不要对自己失去信心！ 最黑暗时刻、就是黎明前！ 坚持：多找自己的问题，弥补不足，在尝试！ 总结 1、秋招时机，提前批、内推、公众平台、社会招聘、…… 信息很重要！ 2、早些做好自己的职业规划（大三之前） 3、写一个优秀的简历。不是自我介绍，而是让公司看到简历之后知道为什么需要你！简历是可以有多 份！ 4、笔试和面试尽量提前3个月准备充分！提前了解公司！ ","link":"https://ganhan999.github.io/post/狂神说秋招/"},{"title":"中等79.单词搜索","content":"题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = &quot;ABCCED&quot;, 返回 true 给定 word = &quot;SEE&quot;, 返回 true 给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 通过次数134,541提交次数305,651 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 回溯 大神做法1： class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: m = len(board) n = len(board[0]) visited = [[False] * n for _ in range(m)] rows = [-1, 0, 1, 0] cols = [0, 1, 0, -1] def dfs(x, y, idx): &quot;&quot;&quot;搜索单词 Args: x: 行索引 y: 列索引 idx: 单词对应的字母索引 &quot;&quot;&quot; if board[x][y] != word[idx]: return False if idx == len(word) - 1: return True # 先标记 visited[x][y] = True # 找到符合的字母时开始向四个方向扩散搜索 for i in range(4): nx = x + rows[i] ny = y + cols[i] if 0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n and not visited[nx][ny] and dfs(nx, ny, idx + 1):#判断下一个字母是否匹配后面的字符串 return True # 扩散未搜索对应的字母，释放标记 # 继续往其他方位搜索 visited[x][y] = False#后面四个方向完全匹配不到就返回False，且把该元素置为False，相当于回溯 return False for x in range(m): for y in range(n): if dfs(x, y, 0): return True return False ","link":"https://ganhan999.github.io/post/79、单词搜索/"},{"title":"Java POI和EasyExcel","content":"跟着狂神聊聊POI和EasyExcel POI和easyExcel讲解 常用信息 将用户信息导出为excel表格 讲Excel表中的信息录入到网站数据库，大大减小网站数据的录入量！ 开发中经常会涉及到excel的处理，如导出Excel到数据库中！ 操作Excel目前比较流行的就是Apache POI和阿里巴巴的easyExcel Apache POI Apache POI官网: https://poi.apache.org/ easyExcel easyExcel官网地址: https://github.com/alibaba/easyexcel EasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单，节约内存著称。 EasyExcel能大量减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从一个磁盘上一行行读取数据，逐个解析。 下图是EasyExcel和POI在解析Excel时的对比图(时间与空间的相互取舍)。 官方文档: https://www.yuque.com/easyexcel/doc/easyexcel POI-Excel操作 POI-Excel写 创建项目 创建一个普通空项目,然后新建一个model的maven项目 引入pom依赖 &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--xLs(03)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version &gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--xLsx(07)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期格式化工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 03|07版本的写，就是对象不同，方法是一样的 区别：03版最多65536行，07行数没有限制 工作薄 工作表 行 单元格 03版本 package com.kuang; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.joda.time.DateTime; import org.junit.Test; import java.io.FileOutputStream; import java.io.IOException; import java.util.Date; public class ExcelWriteTest { String PATH=&quot;ExcelCreate\\\\&quot;; @Test public void testWrite03() throws IOException { //1,创建一个工作簿 Workbook workbook = new HSSFWorkbook(); //2,创建一个工作表 Sheet sheet = workbook.createSheet(&quot;03统计表&quot;); //3，创建一行（1，1） Row row1 = sheet.createRow(0); //4，创建一个单元格 Cell cell11 = row1.createCell(0); cell11.setCellValue(&quot;新增观众&quot;); //（1，2） Cell cell12 = row1.createCell(1); cell12.setCellValue(666); //第二行（2，1） Row row2 = sheet.createRow(1); Cell cell21 = row2.createCell(0); cell21.setCellValue(&quot;时间记录&quot;); //（2，2） Cell cell22 = row2.createCell(1); cell22.setCellValue(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;)); //生成一张表（IO流）03版本使用xls结尾！ FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;03版本测试.xls&quot;); //输出 workbook.write(fileOutputStream); //关闭流 fileOutputStream.close(); System.out.println(&quot;03生成成功&quot;); } } 运行结果 07版(和03不同的就这两处) Workbook workbook = new XSSFWorkbook(); //生成一张表（IO流）07版本使用xlsx结尾！ FileOutputStream fos = new FileOutputStream(PATH+&quot;07版本Excel测试.xlsx&quot;) 注意对象的一个区别,文件后缀! 大文件写HSSF 缺点：最多只能处理65536行，否则会报异常 java.lang.IllegalArgumentException:Invalid row number (65536) outside allowable range (0.. 65535) 优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快 @Test public void testwrite03BigData() throws IOException { //时间 long begin = System.currentTimeMillis(); //创建一个薄 Workbook workbook = new HSSFWorkbook(); //创建表 Sheet sheet = workbook.createSheet(); //写入数据 for (int rowNum = 0; rowNum &lt; 65536; rowNum++) { Row row = sheet.createRow(rowNum); for (int cellNum = 0; cellNum &lt; 10; cellNum++) { Cell cell = row.createCell(cellNum); cell.setCellValue(cellNum); } } FileOutputStream fos = new FileOutputStream(PATH + &quot;03版本Excel大量数据测试.xls&quot;); workbook.write(fos); fos.close(); System.out.println(&quot;over&quot;); long end = System.currentTimeMillis(); System.out.println((double) (end - begin) / 1000); } 运行结果 over 3.057 大文件写XSSF 缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条数据 优点：可以写较大的数据量，如20万条数据 Workbook workbook = new XSSFWorkbook(); Fileoutputstream ops = new Fileoutputstream(PATH +&quot;07版本Excel大量数据测试.xlsx&quot;); 大文件写SXSSF 优点：可以写非常大量的数据库，如100万条甚至更多条，写数据速度快，占用更少的内存 注意： 过程中会产生临时文件，需要清理临时文件 默认由100条记录被保存在内存中，如果超出这数量，则最前面的数据被写入临时文件 如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook（数量） Workbook workbook = new SXSSFWorkbook(); Fileoutputstream ops = new Fileoutputstream(PATH +&quot;07版本Excel大量数据测试.xlsx&quot;); @Test public void testwrite07_S_BigData() throws IOException { //时间 long begin = System.currentTimeMillis(); //创建一个薄 Workbook workbook = new SXSSFWorkbook(100); //创建表 Sheet sheet = workbook.createSheet(); //写入数据 for (int rowNum = 0; rowNum &lt; 65536; rowNum++) { Row row = sheet.createRow(rowNum); for (int cellNum = 0; cellNum &lt; 10; cellNum++) { Cell cell = row.createCell(cellNum); cell.setCellValue(cellNum); } } FileOutputStream fos = new FileOutputStream(PATH + &quot;07_S_版本Excel大量数据测试.xlsx&quot;); workbook.write(fos); fos.close(); //清除临时缓存 ((SXSSFWorkbook)workbook).dispose(); System.out.println(&quot;over&quot;); long end = System.currentTimeMillis(); System.out.println((double) (end - begin) / 1000); } SXSSWorkbook 来自官方解释：实现：BigGridDemo策略的流式XSSFWorkbook版本。这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。 SXSSWorkbook 来自官方解释：实现：BigGridDemo策略的流式XSSFWorkbook版本。这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。 POI-Excel读 03类型 package com.kuang; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.junit.Test; import java.io.FileInputStream; public class ExcelReadTest { String PATH = &quot;ExcelCreate\\\\&quot;; @Test public void testRead03() throws Exception { //获取文件流 FileInputStream fis = new FileInputStream(PATH + &quot;03版本测试.xls&quot;); //1、创建一个工作簿。使用 exceL能操作的这边他都可以操作！ Workbook workbook = new HSSFWorkbook(fis); //2、得到表 Sheet sheet = workbook.getSheetAt(0); //3、得到行 Row row = sheet.getRow(0); //4、得到列 Cell cell = row.getCell(1); //读取值的时候，一定要注意类型！ //getStringCellValue 字符串类型 System.out.println(cell.getNumericCellValue()); fis.close(); } } 07类型 @Test public void testRead07() throws Exception { //获取文件流 FileInputStream fis = new FileInputStream(PATH + &quot;07版本测试.xlsx&quot;); //1、创建一个工作簿。使用 exceL能操作的这边他都可以操作！ Workbook workbook = new XSSFWorkbook(fis); //2、得到表 Sheet sheet = workbook.getSheetAt(0); //3、得到行 Row row = sheet.getRow(0); //4、得到列 Cell cell = row.getCell(0); //读取值的时候，一定要注意类型！ //getStringCellValue 字符串类型 System.out.println(cell.getStringCellValue()); fis.close(); } 注意获取值的类型即可 读取不同的数据类型 @Test public void testCellType() throws Exception { //获取文件流 FileInputStream fis = new FileInputStream(PATH +&quot;课题信息表20190701.xlsx&quot;); //创建一个工作簿。使用 excel能操作的这边他都可以操作 Workbook workbook = new XSSFWorkbook(fis); Sheet sheet = workbook.getSheetAt(0); //获取标题内容 Row rowTitle = sheet.getRow(0); if (rowTitle != null) { //得到一行有多少列有数据 int cellCount = rowTitle.getPhysicalNumberOfCells(); for (int cellNum = 0; cellNum &lt; cellCount; cellNum++) { Cell cell = rowTitle.getCell(cellNum); if (cell != null) { int cellType = cell.getCellType(); String cellValue = cell.getStringCellValue(); System.out.print(cellValue + &quot;|&quot;); } } System.out.println(); } //获取表中的内容 //获取表中有多少行有数据 int rowCount = sheet.getPhysicalNumberOfRows(); for (int rowNum = 1; rowNum &lt; rowCount; rowNum++) { Row rowData = sheet.getRow(rowNum); if (rowData != null) { //读取列 int cellCount = rowTitle.getPhysicalNumberOfCells(); for (int cellNum = 0; cellNum &lt; cellCount; cellNum++) { System.out.println(&quot;[&quot; + (rowNum + 1) + &quot;-&quot; + (cellNum + 1) + &quot;]&quot;); Cell cell = rowData.getCell(cellNum); //匹配列的数据类型 if (cell != null) { int cellType = cell.getCellType(); String cellValue = &quot;&quot;; switch (cellType) { case HSSFCell.CELL_TYPE_STRING://字符 System.out.print(&quot;【 String】&quot;); cellValue = cell.getStringCellValue(); break; case HSSFCell.CELL_TYPE_BOOLEAN://布尔 System.out.print(&quot;【 BOOLEAN】&quot;); cellValue = String.valueOf(cell.getBooleanCellValue()); break; case HSSFCell.CELL_TYPE_BLANK://空 System.out.print(&quot;【 BLANK】&quot;); break; case HSSFCell.CELL_TYPE_NUMERIC://数字(日期、普通数字) System.out.print(&quot;【 NUMERIC】&quot;); if (HSSFDateUtil.isCellDateFormatted(cell)) {// 日期 System.out.print(&quot;--【日期】&quot;); Date date = cell.getDateCellValue(); cellValue = new DateTime(date).toString(&quot;yyyy-MM-dd&quot;); } else { //不是日期格式，防止数字过长！ System.out.print(&quot;--【转换为字符串输出】&quot;); cell.setCellType(HSSFCell.CELL_TYPE_STRING); cellValue = cell.toString(); } break; case HSSFCell.CELL_TYPE_ERROR://错误 System.out.print(&quot;【 数据类型错误】&quot;); break; } System.out.println(cellValue); } } } } //关闭流 fis.close(); } 计算公式 @Test public void testFormula() throws Exception { FileInputStream fis = new FileInputStream(PATH+&quot;公式.xls&quot;); //创建一个工作簿。使用 excel能操作的这边他都可以操作 Workbook workbook = new HSSFWorkbook(fis); Sheet sheet = workbook.getSheetAt(0); Row row = sheet.getRow(4); Cell cell = row.getCell(0); //拿到计算公司 evaL FormulaEvaluator FormulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook) workbook); //输出单元格的内容 int cellType = cell.getCellType(); switch (cellType) { case Cell.CELL_TYPE_FORMULA://公式 String formula = cell.getCellFormula(); System.out.println(formula); //计算 CellValue evaluate = FormulaEvaluator.evaluate(cell); String cellValue = evaluate.formatAsString(); System.out.println(cellValue); break; } } 运行结果 SUM(A2:A4) 600.0 EasyExcel操作 EasyExcel写入操作： 官方API https://www.yuque.com/easyexcel/doc/read 导入依赖 &lt;!--easyexcel--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version &gt;2.2.0-beta2&lt;/version&gt; &lt;/dependency&gt; 由于easyexcel依赖中包含POI相关依赖,有可能发生冲突,所以注释掉 &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version &gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;!--easyexcel--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version &gt;2.2.0-beta2&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version &gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &amp;lt;!&amp;ndash;xLs(03)&amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &amp;lt;!&amp;ndash;xLsx(07)&amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!--日期格式化工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 实体类 package com.kuang.easy; import com.alibaba.excel.annotation.ExcelIgnore; import com.alibaba.excel.annotation.ExcelProperty; import lombok.Data; import java.util.Date; @Data public class DemoData { @ExcelProperty(&quot;字符串标题&quot;) private String string; @ExcelProperty(&quot;日期标题&quot;) private Date date; @ExcelProperty(&quot;数字标题&quot;) private Double doubleData; //忽略这个字段 @ExcelIgnore private String ignore; } 测试 package com.kuang.easy; import com.alibaba.excel.EasyExcel; import org.junit.Test; import java.util.ArrayList; import java.util.Date; import java.util.List; public class EasyTest { String PATH = &quot;ExcelCreate\\\\&quot;; //模拟写入数据 private List&lt;DemoData&gt; data() { java.util.List&lt;DemoData&gt; list = new ArrayList&lt;DemoData&gt;(); for (int i = 0; i &lt; 10; i++) { DemoData data = new DemoData(); data.setString(&quot;字符串&quot; + i); data.setDate(new Date()); data.setDoubleData(0.56); list.add(data); } return list; } //根据ist写 excel @Test public void simplewrite() { String fileName = PATH + &quot;EasyTest.xlsx&quot;; //这里需要指定写用哪个 class去写，然后写到第一个 sheet，名字为模板然后文件流会自动关闭 //write(fileName,格式类) //sheet（表名） //doWrite（数据） EasyExcel.write(fileName, DemoData.class).sheet(&quot;模板&quot;).doWrite(data()); } } EasyExcel读取操作： 对象 @Data public class DemoData { private String string; private Date date; private Double doubleData; } 监听器 // 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去 public class DemoDataListener extends AnalysisEventListener&lt;DemoData&gt; { private static final Logger LOGGER = LoggerFactory.getLogger(DemoDataListener.class); /** * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收 */ private static final int BATCH_COUNT = 5; List&lt;DemoData&gt; list = new ArrayList&lt;DemoData&gt;(); /** * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。 */ private DemoDAO demoDAO; public DemoDataListener() { // 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数 demoDAO = new DemoDAO(); } /** * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来 * * @param demoDAO */ public DemoDataListener(DemoDAO demoDAO) { this.demoDAO = demoDAO; } /** * 这个每一条数据解析都会来调用 * * @param data * one row value. Is is same as {@link AnalysisContext#readRowHolder()} * @param context */ @Override public void invoke(DemoData data, AnalysisContext context) { LOGGER.info(&quot;解析到一条数据:{}&quot;, JSON.toJSONString(data)); list.add(data); // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM if (list.size() &gt;= BATCH_COUNT) { saveData(); // 存储完成清理 list list.clear(); } } /** * 所有数据解析完成了 都会来调用 * * @param context */ @Override public void doAfterAllAnalysed(AnalysisContext context) { // 这里也要保存数据，确保最后遗留的数据也存储到数据库 saveData(); LOGGER.info(&quot;所有数据解析完成！&quot;); } /** * 加上存储数据库 */ private void saveData() { LOGGER.info(&quot;{}条数据，开始存储数据库！&quot;, list.size()); demoDAO.save(list); LOGGER.info(&quot;存储数据库成功！&quot;); } } 持久层 /** * 假设这个是你的DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。 **/ public class DemoDAO { public void save(List&lt;DemoData&gt; list) { // 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入 } } 代码 /** * 最简单的读 * &lt;p&gt;1. 创建excel对应的实体对象 参照{@link DemoData} * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener} * &lt;p&gt;3. 直接读即可 */ @Test public void simpleRead() { // 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去 // 写法1： String fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;; // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭 EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead(); // 写法2： fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;; ExcelReader excelReader = null; try { excelReader = EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).build(); ReadSheet readSheet = EasyExcel.readSheet(0).build(); excelReader.read(readSheet); } finally { if (excelReader != null) { // 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的 excelReader.finish(); } } } 固定套路： 写入，固定类格式进行写入 读取，根据监听器设置的规则进行读取！ ","link":"https://ganhan999.github.io/post/Java POI和EasyExcel/"},{"title":"Java 阿里云验证码","content":"1. 了解阿里云用户权限操作 需要通过个人账户获得 授权码（id、密码），再通过这些信息获得服务 阿里云网址 ： https://www.aliyun.com/ 登录 / 注册 阿里云 点击 AccessKey 管理 创建一个用户 为新建的用户添加权限 2. 开通阿里云短信服务 进入短信服务后台 了解计费规则 3. 添加短信模板 看到每条短信是需要短信费用的，所以如果需要使用该功能，需要充点钱备用。 4. 添加签名 5. 编写测试代码 可以查看 API Demo ，修改即可 新建一个 Spring-boot 项目 sms-verification 引入依赖 &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.73&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 编写一个测试类，就把刚刚的 API Demo 复制过来进行修改 // 注意这里所有的包都是 aliyuncs 包下的 @Test void contextLoads() { // 这里的 AccessKey ID 、 Secret就是 阿里云用户对于的值，复制过来即可 DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;&lt;accessKeyId&gt;&quot;, &quot;&lt;accessSecret&gt;&quot;); IAcsClient client = new DefaultAcsClient(profile); // 构建请求 CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.setSysAction(&quot;SendSms&quot;); // 上面不需要改 // 自定义参数 ： // 手机号，这里 Value 就填用户的手机号，实际应用须要从表单获取 request.putQueryParameter(&quot;PhoneNumbers&quot;, &quot;138XXXXXXXX&quot;); // 签名，这里的 Value 就是在阿里云上申请的 签名 request.putQueryParameter(&quot;SignName&quot;, &quot;XXXX&quot;); // 模板，这里的 Value 就是在阿里云上申请的模板的 模版CODE 值 request.putQueryParameter(&quot;TemplateCode&quot;, &quot;XXXX&quot;); // 验证码，真实应用需要自动构建验证码 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, 112233); request.putQueryParameter(&quot;TemplateParam&quot;, JSONObject.toJSONString(map)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } } 最后就可以得到短信了 注意： 如果上面自定义的参数名写错，不会成功 如果 模板、签名 没有通过审核会报错 6. 模板 新建几个文件夹 编写接口 SendSmsService public interface SendSmsService { /** * 用于发送短信 * @param phoneNumber ：手机号 * @param templateCode ：模板编号 * @param code ：验证码 * @return 是否发送成功 */ public boolean send(String phoneNumber, String templateCode, Map&lt;String, Object&gt; code); } 编写实现类 SendSmsServiceImpl public class SendSmsServiceImpl implements SendSmsService { @Override public boolean send(String phoneNumber, String templateCode, Map&lt;String, Object&gt; code) { DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;&lt;accessKeyId&gt;&quot;, &quot;&lt;accessSecret&gt;&quot;); IAcsClient client = new DefaultAcsClient(profile); // 构建请求 CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.setSysAction(&quot;SendSms&quot;); // 上面不需要改 // 自定义参数 ： // 手机号，这里 Value 就填用户的手机号，实际应用须要从表单获取 request.putQueryParameter(&quot;PhoneNumbers&quot;, phoneNumber); // 签名，这里的 Value 就是在阿里云上申请的 签名 request.putQueryParameter(&quot;SignName&quot;, &quot;XXXX&quot;); // 模板，这里的 Value 就是在阿里云上申请的模板的 模版CODE 值 request.putQueryParameter(&quot;TemplateCode&quot;, templateCode); // 验证码，真实应用需要自动构建验证码 request.putQueryParameter(&quot;TemplateParam&quot;, JSONObject.toJSONString(code)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); // 自带的判断是否成功的方法 return response.getHttpResponse().isSuccess(); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } return false; } } 编写配置文件，连接 Redis ：application.yml server: port: 8088 # 配置 Redis spring: redis: host: 192.168.142.120 port: 6379 password: 123456 编写调用接口 ==== @RestController @CrossOrigin // 跨域的支持 public class SmsApiController { @Autowired private SendSmsService sendSmsService; @Autowired private RedisTemplate redisTemplate; @GetMapping(&quot;send/{phone}&quot;) public String sendSms(@PathVariable(&quot;phone&quot;) String phoneNumber){ // 调用发送发放（模拟真实业务，整合 Redis） // 判断当前手机号是否存储在 Redis 中 // 如果没有则发送短信 // 如果有表示上一个验证码还未过期，不用发送 String code = (String) redisTemplate.opsForValue().get(phoneNumber); if (!StringUtils.isEmpty(code)){ return &quot;[手机号: &quot;+phoneNumber + &quot;],[验证码: &quot; + code +&quot;],还未过期&quot;; } // 生成验证码 code = UUID.randomUUID().toString().substring(0,6); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,code); sendSmsService.send(phoneNumber,&quot;XXXX&quot;,map); // 如果发送成功，就放入 Redis if (isSend){ redisTemplate.opsForValue().set(phoneNumber,code,5, TimeUnit.MINUTES); return &quot;[手机号: &quot;+phoneNumber + &quot;],[验证码: &quot; + code +&quot;],发送成功&quot;; }else { return &quot;[手机号: &quot;+phoneNumber + &quot;],[验证码: &quot; + code +&quot;],发送失败&quot;; } } } ","link":"https://ganhan999.github.io/post/Java 阿里云验证码/"},{"title":"中等78. 子集","content":"题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 库函数 大神做法1： class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] for i in range(len(nums)+1): for tmp in itertools.combinations(nums, i): res.append(tmp) return res &quot;&quot;&quot;&quot;&quot;&quot; 迭代 大神做法2： class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res=[[]] for num in nums: res=res+[[num]+i for i in res] return res &quot;&quot;&quot;&quot;&quot;&quot; 回溯 大神做法3： class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: ans = [] # 存储符合要求的子集 tmp = [] n = len(nums) def helper(idx): # 先添加子集 ans.append(tmp[:]) for i in range(idx, n): tmp.append(nums[i]) # 避免重复，每次递归，从下一个索引开始 helper(i + 1) # 回溯 tmp.pop() helper(0) return ans &quot;&quot;&quot;&quot;&quot;&quot; 位运算，那一位是1就把那一位对应的值加进去 大神做法4： class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: size = len(nums) n = 1 &lt;&lt; size res = [] for i in range(n): cur = [] for j in range(size): if i &gt;&gt; j &amp; 1: cur.append(nums[j]) res.append(cur) return res ","link":"https://ganhan999.github.io/post/78、子集/"},{"title":"Java Docker","content":"笔记整理来源 B站UP主狂神说Javahttps://space.bilibili.com/95256449/ &lt;&lt;三体&gt;&gt;： 弱小和无知不是生存的障碍，傲慢才是。 即使再小的帆，就往死里学 Docker 学习 Docker 概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 。。。 Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker（单机Docker) Docker Compose Docker Swarm CI\\CD Jenkins Docker概述 Docker为什么出现？ 一款产品： 开发–上线 两套环境！应用环境，应用配置！ 开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？ 环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。 发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！ 之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。 开发环境Windows，最后发布到Linux！ 传统：开发jar，运维来做！ 现在：开发打包部署上线，一套流程做完！ 安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！ docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）----- Docker给以上的问题，提出了解决方案！ Docker的思想就来自于集装箱！ JRE – 多个应用(端口冲突) – 原来都是交叉的！ 隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。 Docker通过隔离机制，可以将服务器利用到极致！ 本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！ Docker历史 2010年，几个的年轻人，就在美国成立了一家公司 dotcloud 做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！ Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。 他们将自己的技术（容器化技术）命名就是 Docker Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！ 开源 2013年，Docker开源！ 越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！ 2014年4月9日，Docker1.0发布！ docker为什么这么火？十分的轻巧！ 在容器技术出来之前，我们都是使用虚拟机技术！ 虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！ 虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！ vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟 docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！ 12 聊聊Docker Docker基于Go语言开发的！开源项目！ docker官网：https://www.docker.com/ 文档：https://docs.docker.com/ Docker的文档是超级详细的！ 仓库：https://hub.docker.com/ Docker能干嘛 之前的虚拟机技术！ 虚拟机技术缺点： 1、 资源占用十分多 2、 冗余步骤多 3、 启动很慢！ 容器化技术 容器化技术不是模拟一个完整的操作系统 比较Docker和虚拟机技术的不同： 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响 DevOps（开发、运维） 应用更快速的交付和部署 传统：一对帮助文档，安装程序。 Docker：打包镜像发布测试一键运行。 更便捷的升级和扩缩容 使用了 Docker之后，我们部署应用就和搭积木一样 项目打包为一个镜像，扩展服务器A！服务器B 更简单的系统运维 在容器化之后，我们的开发，测试环境都是高度一致的 更高效的计算资源利用 Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。 Docker安装 Docker的基本组成 镜像（image)： docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==&gt;run==&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。 容器(container)： Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的. 启动，停止，删除，基本命令 目前就可以把这个容器理解为就是一个简易的 Linux系统。 仓库(repository)： 仓库就是存放镜像的地方！ 仓库分为公有仓库和私有仓库。(很类似git) Docker Hub是国外的。 阿里云…都有容器服务器(配置镜像加速!) 安装Docker 环境准备 Linux要求内核3.0以上 ➜ ~ uname -r 4.15.0-96-generic # 要求3.0以上 ➜ ~ cat /etc/os-release NAME=&quot;Ubuntu&quot; VERSION=&quot;18.04.4 LTS (Bionic Beaver)&quot; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&quot;Ubuntu 18.04.4 LTS&quot; VERSION_ID=&quot;18.04&quot; HOME_URL=&quot;https://www.ubuntu.com/&quot; SUPPORT_URL=&quot;https://help.ubuntu.com/&quot; BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot; PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic 安装 帮助文档：https://docs.docker.com/engine/install/ #1.卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine #2.需要的安装包 yum install -y yum-utils #3.设置镜像的仓库 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的，不推荐 #推荐使用国内的 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #更新yum软件包索引 yum makecache fast #4.安装docker相关的 docker-ce 社区版 而ee是企业版 yum install docker-ce docker-ce-cli containerd.io #5、启动docker docker systemctl start docker #6. 使用docker version查看是否按照成功 docker version #7. 测试 docker run hello-world #7. 测试 ➜ ~ docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ #8.查看一下下载的镜像 ➜ ~ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 4 months ago 13.3kB 了解：卸载docker #1. 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io #2. 删除资源 rm -rf /var/lib/docker # /var/lib/docker 是docker的默认工作路径！ 阿里云镜像加速 1、登录阿里云找到容器服务 2、找到镜像加速器 3、配置使用 回顾HelloWorld流程 docker run 流程图 底层原理 Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！ Docker-Server接收到Docker-Client的指令，就会执行这个命令！ 为什么Docker比Vm快 1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 2、docker利用的是宿主机的内核,而不需要Guest OS。 GuestOS： VM（虚拟机）里的的系统（OS）; HostOS：物理机里的系统（OS）； 因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。 Docker的常用命令 帮助命令 docker version #显示docker的版本信息。 docker info #显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help #帮助命令 帮助文档的地址：https://docs.docker.com/engine/reference/commandline/build/ 镜像命令 docker images #查看所有本地主机上的镜像 可以使用docker image ls代替 docker search 搜索镜像 docker pull 下载镜像 docker image pull docker rmi 删除镜像 docker image rm docker images 查看所有本地的主机上的镜像 ➜ ~ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 e73346bdf465 24 hours ago 448MB # 解释 #REPOSITORY # 镜像的仓库源 #TAG # 镜像的标签 #IMAGE ID # 镜像的id #CREATED # 镜像的创建时间 #SIZE # 镜像的大小 # 可选项 Options: -a, --all Show all images (default hides intermediate images) #列出所有镜像 -q, --quiet Only show numeric IDs # 只显示镜像的id ➜ ~ docker images -aq ＃显示所有镜像的id e73346bdf465 d03312117bb0 d03312117bb0 602e111c06b6 2869fc110bf7 470671670cac bf756fb1ae65 5acf0e8da90b docker search 搜索镜像 ➜ ~ docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9500 [OK] mariadb MariaDB is a community-developed fork of MyS… 3444 [OK] # --filter=STARS=3000 #搜索出来的镜像就是STARS大于3000的 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output ➜ ~ docker search mysql --filter=STARS=3000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9500 [OK] mariadb MariaDB is a community-developed fork of MyS… 3444 [OK] docker pull 下载镜像 # 下载镜像 docker pull 镜像名[:tag] ➜ ~ docker pull tomcat:8 8: Pulling from library/tomcat #如果不写tag，默认就是latest 90fe46dd8199: Already exists #分层下载： docker image 的核心 联合文件系统 35a4f1977689: Already exists bbc37f14aded: Already exists 74e27dc593d4: Already exists 93a01fbfad7f: Already exists 1478df405869: Pull complete 64f0dd11682b: Pull complete 68ff4e050d11: Pull complete f576086003cf: Pull complete 3b72593ce10e: Pull complete Digest: sha256:0c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df640a027 # 签名 防伪 Status: Downloaded newer image for tomcat:8 docker.io/library/tomcat:8 #真实地址 #等价于 docker pull tomcat:8 docker pull docker.io/library/tomcat:8 docker rmi 删除镜像 ➜ ~ docker rmi -f 镜像id #删除指定的镜像 ➜ ~ docker rmi -f 镜像id 镜像id 镜像id 镜像id#删除指定的镜像 ➜ ~ docker rmi -f $(docker images -aq) #删除全部的镜像 容器命令 docker run 镜像id 新建容器并启动 docker ps 列出所有运行的容器 docker container list docker rm 容器id 删除指定容器 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前正在运行的容器 docker kill 容器id #强制停止当前容器 说明：我们有了镜像才可以创建容器，Linux，下载centos镜像来学习 ➜ ~ docker container Usage: docker container COMMAND Manage containers Commands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem exec Run a command in a running container export Export a container's filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers logs Fetch the logs of a container ls List containers pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container restart Restart one or more containers rm Remove one or more containers run Run a command in a new container start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codes Run 'docker container COMMAND --help' for more information on a command. 新建容器并启动 docker run [可选参数] image | docker container run [可选参数] image #参书说明 --name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 -p 8080(宿主机):8080(容器) -p ip:主机端口:容器端口 -p 主机端口:容器端口(常用) -p 容器端口 容器端口 -P(大写) 随机指定端口 # 测试、启动并进入容器 ➜ ~ docker run -it centos /bin/bash Unable to find image 'centos:latest' locally latest: Pulling from library/centos 8a29a15cefae: Already exists Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700 Status: Downloaded newer image for centos:latest [root@95039813da8d /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@95039813da8d /]# exit #从容器退回主机 exit ➜ ~ ls shell user.txt 列出所有运行的容器 #docker ps命令 #列出当前正在运行的容器 -a, --all Show all containers (default shows just running) -n, --last int Show n last created containers (includes all states) (default -1) -q, --quiet Only display numeric IDs ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 68729e9654d4 portainer/portainer &quot;/portainer&quot; 14 hours ago Up About a minute 0.0.0.0:8088-&gt;9000/tcp funny_curie d506a017e951 nginx &quot;nginx -g 'daemon of…&quot; 15 hours ago Up 15 hours 0.0.0.0:3344-&gt;80/tcp nginx01 ➜ ~ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 95039813da8d centos &quot;/bin/bash&quot; 3 minutes ago Exited (0) 2 minutes ago condescending_pike 1e46a426a5ba tomcat &quot;catalina.sh run&quot; 11 minutes ago Exited (130) 9 minutes ago sweet_gould 14bc9334d1b2 bf756fb1ae65 &quot;/hello&quot; 3 hours ago Exited (0) 3 hours ago amazing_stonebraker f10d60f473f5 bf756fb1ae65 &quot;/hello&quot; 3 hours ago Exited (0) 3 hours ago dreamy_germain 68729e9654d4 portainer/portainer &quot;/portainer&quot; 14 hours ago Up About a minute 0.0.0.0:8088-&gt;9000/tcp funny_curie 677cde5e4f1d elasticsearch &quot;/docker-entrypoint.…&quot; 15 hours ago Exited (143) 8 minutes ago elasticsearch 33eb3f70b4db tomcat &quot;catalina.sh run&quot; 15 hours ago Exited (143) 8 minutes ago tomcat01 d506a017e951 nginx &quot;nginx -g 'daemon of…&quot; 15 hours ago Up 15 hours 0.0.0.0:3344-&gt;80/tcp nginx01 24ce2db02e45 centos &quot;/bin/bash&quot; 16 hours ago Exited (0) 15 hours ago hopeful_faraday 42267d1ad80b bf756fb1ae65 &quot;/hello&quot; 16 hours ago Exited (0) 16 hours ago ecstatic_sutherland ➜ ~ docker ps -aq 95039813da8d 1e46a426a5ba 14bc9334d1b2 f10d60f473f5 68729e9654d4 677cde5e4f1d 33eb3f70b4db d506a017e951 24ce2db02e45 42267d1ad80b 退出容器 exit #容器直接退出 ctrl +P +Q #容器不停止退出 删除容器 docker rm 容器id #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf docker rm -f $(docker ps -aq) #删除指定的容器 docker ps -a -q|xargs docker rm #删除所有的容器 启动和停止容器的操作 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前正在运行的容器 docker kill 容器id #强制停止当前容器 常用其他命令 后台启动命令 # 命令 docker run -d 镜像名 ➜ ~ docker run -d centos a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 问题docker ps. 发现centos 停止了 # 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止 # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 查看日志 docker logs --help Options: --details Show extra details provided to logs * -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) * --tail string Number of lines to show from the end of the logs (default &quot;all&quot;) * -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) ➜ ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志 #显示日志 -tf #显示日志信息（一直更新） --tail number #需要显示日志条数 docker logs -t --tail n 容器id #查看n行日志 docker logs -ft 容器id #跟着日志 查看容器中进程信息 ps # 命令 docker top 容器id 查看镜像的元数据 # 命令 docker inspect 容器id #测试 ➜ ~ docker inspect 55321bcae33d [ { &quot;Id&quot;: &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;, &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo 6666;sleep 1;done&quot; ], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 22973, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-05-15T05:22:06.165904633Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; }, &quot;Image&quot;: &quot;sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066-json.log&quot;, &quot;Name&quot;: &quot;/bold_bell&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;docker-default&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: { &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: { &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: {} }, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: {}, &quot;RestartPolicy&quot;: { &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 }, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] }, &quot;GraphDriver&quot;: { &quot;Data&quot;: { &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/1f347949ba49c4dbee70cea9ff3af39a14e602bc8fac8331c46347bf6708757a-init/diff:/var/lib/docker/overlay2/5afcd8220c51854a847a36f52775b4ed0acb16fe6cfaec3bd2e5df59863835ba/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/1f347949ba49c4dbee70cea9ff3af39a14e602bc8fac8331c46347bf6708757a/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/1f347949ba49c4dbee70cea9ff3af39a14e602bc8fac8331c46347bf6708757a/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/1f347949ba49c4dbee70cea9ff3af39a14e602bc8fac8331c46347bf6708757a/work&quot; }, &quot;Name&quot;: &quot;overlay2&quot; }, &quot;Mounts&quot;: [], &quot;Config&quot;: { &quot;Hostname&quot;: &quot;55321bcae33d&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true;do echo 6666;sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: { &quot;org.label-schema.build-date&quot;: &quot;20200114&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;, &quot;org.opencontainers.image.created&quot;: &quot;2020-01-14 00:00:00-08:00&quot;, &quot;org.opencontainers.image.licenses&quot;: &quot;GPL-2.0-only&quot;, &quot;org.opencontainers.image.title&quot;: &quot;CentOS Base Image&quot;, &quot;org.opencontainers.image.vendor&quot;: &quot;CentOS&quot; } }, &quot;NetworkSettings&quot;: { &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;63ed0c837f35c12453bae9661859f37a08541a0749afb86e881869bf6fd9031b&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: {}, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/63ed0c837f35&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;b129d9a5a2cbb92722a2101244bd81a9e3d8af034e83f338c13790a1a94552a1&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.4&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;ad5ada6a106f5ba3dda9ce4bc1475a4bb593bf5f7fbead72196e66515e8ac36a&quot;, &quot;EndpointID&quot;: &quot;b129d9a5a2cbb92722a2101244bd81a9e3d8af034e83f338c13790a1a94552a1&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.4&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;, &quot;DriverOpts&quot;: null } } } } ] ➜ ~ 进入当前正在运行的容器 # 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 # 命令 docker exec -it 容器id bashshell #测试 ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 55321bcae33d centos &quot;/bin/sh -c 'while t…&quot; 10 minutes ago Up 10 minutes bold_bell a7215824a4db centos &quot;/bin/sh -c 'while t…&quot; 13 minutes ago Up 13 minutes zen_kepler 55a31b3f8613 centos &quot;/bin/bash&quot; 15 minutes ago Up 15 minutes lucid_clarke ➜ ~ docker exec -it 55321bcae33d /bin/bash [root@55321bcae33d /]# 1234567891011121314 # 方式二 docker attach 容器id #测试 docker attach 55321bcae33d 正在执行当前的代码... 区别 #docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用） #docker attach # 进入容器正在执行的终端 从容器内拷贝到主机上 docker cp 容器id:容器内路径 主机目的路径 #进入docker容器内部 ➜ ~ docker exec -it 55321bcae33d /bin/bash [root@55321bcae33d /]# ls bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr #新建一个文件 [root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java [root@55321bcae33d /]# cat java.java hello [root@55321bcae33d /]# exit exit ➜ ~ docker cp 55321bcae33d:/java.java / #拷贝 ➜ ~ cd / ➜ / ls #可以看见java.java存在 bin home lib mnt run sys vmlinuz boot initrd.img lib64 opt sbin tmp vmlinuz.old dev initrd.img.old lost+found proc srv usr wget-log etc java.java media root swapfile var 学习方式：将我的所有笔记敲一遍，自己记录笔记！ 小结： attach Attach local standard input, output, and error streams to a running container #当前shell下 attach连接指定运行的镜像 build Build an image from a Dockerfile # 通过Dockerfile定制镜像 commit Create a new image from a container's changes #提交当前容器为新的镜像 cp Copy files/folders between a container and the local filesystem #拷贝文件 create Create a new container #创建一个新的容器 diff Inspect changes to files or directories on a container's filesystem #查看docker容器的变化 events Get real time events from the server # 从服务获取容器实时时间 exec Run a command in a running container # 在运行中的容器上运行命令 export Export a container's filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import] history Show the history of an image # 展示一个镜像形成历史 images List images #列出系统当前的镜像 import Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像 info Display system-wide information # 显示全系统信息 inspect Return low-level information on Docker objects #查看容器详细信息 kill Kill one or more running containers # kill指定docker容器 load Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save] login Log in to a Docker registry # logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes 作业练习 Docker 安装Nginx #1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档 #2. 拉取镜像 pull #3、运行测试 # -d 后台运行 # --name 给容器命名 # -p 宿主机端口：容器内部端口 ➜ ~ docker run -d --name nginx00 -p 82:80 nginx 75943663c116f5ed006a0042c42f78e9a1a6a52eba66311666eee12e1c8a4502 ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 75943663c116 nginx &quot;nginx -g 'daemon of…&quot; 41 seconds ago Up 40 seconds 0.0.0.0:82-&gt;80/tcp nginx00 ➜ ~ curl localhost:82 #测试 &lt;!DOCTYPE html&gt;,,,, 思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分的麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？√数据卷！ 作用：docker 来装一个tomcat # 官方的使用 docker run -it --rm tomcat:9.0 # 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm image 一般是用来测试，用完就删除 --rm Automatically remove the container when it exits #下载 docker pull tomcat #启动运行 docker run -d -p 8080:8080 --name tomcat01 tomcat #测试访问有没有问题 curl localhost:8080 #进入容器 ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES db09851cf82e tomcat &quot;catalina.sh run&quot; 28 seconds ago Up 27 seconds 0.0.0.0:8080-&gt;8080/tcp tomcat01 ➜ ~ docker exec -it db09851cf82e /bin/bash root@db09851cf82e:/usr/local/tomcat# # 发现问题：1、linux命令少了。 2.没有webapps 思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，webapps，我们在外部放置项目，就自动同步内部就好了！ 作业：部署es+kibana # es 暴露的端口很多！ # es 的数据一般需要放置到安全目录！挂载 # --net somenetwork ? 网络配置 # 启动elasticsearch docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2 # 测试一下es是否成功启动 ➜ ~ curl localhost:9200 { &quot;name&quot; : &quot;d73ad2f22dd3&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;atFKgANxS8CzgIyCB8PGxA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } ➜ ~ docker stats # 查看docker容器使用内存情况 #关闭，添加内存的限制，修改配置文件 -e 环境配置修改 ➜ ~ docker rm -f d73ad2f22dd3 ➜ ~ docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 ➜ ~ curl localhost:9200 { &quot;name&quot; : &quot;b72c9847ec48&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;yNAK0EORSvq3Wtaqe2QqAg&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } 作业：使用kibana连接es？思考网络如何才能连接 可视化 portainer(先用这个) docker run -d -p 8080:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD再用) 什么是portainer？ Docker图形化界面管理工具！提供一个后台面板供我们操作！ docker run -d -p 8080:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问： 外网：8080 进入之后的面板 Docker镜像讲解 镜像是什么 镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件 Docker镜像加载原理 UnionFs （联合文件系统） UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？ 对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs. 虚拟机是分钟级别，容器是秒级！ 分层理解 分层的镜像 我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载 思考：为什么Docker镜像要采用这种分层的结构呢？ 最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 查看镜像分层的方式可以通过docker image inspect 命令 ➜ / docker image inspect redis [ { &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;, &quot;RepoTags&quot;: [ &quot;redis:latest&quot; ], &quot;RepoDigests&quot;: [ &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot; ], &quot;Parent&quot;: &quot;&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;, &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;, &quot;ContainerConfig&quot;: { &quot;Hostname&quot;: &quot;d30c0bcea885&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: { &quot;6379/tcp&quot;: {} }, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;GOSU_VERSION=1.12&quot;, &quot;REDIS_VERSION=6.0.1&quot;, &quot;REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz&quot;, &quot;REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) &quot;, &quot;CMD [\\&quot;redis-server\\&quot;]&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0&quot;, &quot;Volumes&quot;: { &quot;/data&quot;: {} }, &quot;WorkingDir&quot;: &quot;/data&quot;, &quot;Entrypoint&quot;: [ &quot;docker-entrypoint.sh&quot; ], &quot;OnBuild&quot;: null, &quot;Labels&quot;: {} }, &quot;DockerVersion&quot;: &quot;18.09.7&quot;, &quot;Author&quot;: &quot;&quot;, &quot;Config&quot;: { &quot;Hostname&quot;: &quot;&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: { &quot;6379/tcp&quot;: {} }, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;GOSU_VERSION=1.12&quot;, &quot;REDIS_VERSION=6.0.1&quot;, &quot;REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz&quot;, &quot;REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273&quot; ], &quot;Cmd&quot;: [ &quot;redis-server&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0&quot;, &quot;Volumes&quot;: { &quot;/data&quot;: {} }, &quot;WorkingDir&quot;: &quot;/data&quot;, &quot;Entrypoint&quot;: [ &quot;docker-entrypoint.sh&quot; ], &quot;OnBuild&quot;: null, &quot;Labels&quot;: null }, &quot;Architecture&quot;: &quot;amd64&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Size&quot;: 104101893, &quot;VirtualSize&quot;: 104101893, &quot;GraphDriver&quot;: { &quot;Data&quot;: { &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work&quot; }, &quot;Name&quot;: &quot;overlay2&quot; }, &quot;RootFS&quot;: { &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13&quot;, &quot;sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990&quot;, &quot;sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8&quot;, &quot;sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8&quot;, &quot;sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123&quot;, &quot;sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894&quot; ] }, &quot;Metadata&quot;: { &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; } } ] 理解： 所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。 举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包， 就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。 上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版 文种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中 Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统 Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的 件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。 Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。 下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图 特点 Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！ 这一层就是我们通常说的容器层，容器之下的都叫镜像层！ commit镜像 docker commit 提交容器成为一个新的副本 # 命令和git原理类似 docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] 实战测试 # 1、启动一个默认的tomcat docker run -d -p 8080:8080 tomcat # 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！ docker exec -it 容器id # 3、拷贝文件进去 # 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。 docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG] docker commit -a=&quot;kuangshen&quot; -m=&quot;add webapps app&quot; 容器id tomcat02:1.0 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。 入门成功！！！！ docker 进阶 之容器数据卷 DockerFile Docker网络 — 狂神说 容器数据卷 DockerFile Docker网络讲解 IDEA整合Docker Docker Compose Docker Swarm CI、CD之Jenkins ","link":"https://ganhan999.github.io/post/Java Docker/"},{"title":"Java ElasticSearch","content":"ElasticSearch 1. 介绍 本笔记参考狂神说，版本为7.6.X https://www.bilibili.com/video/BV17a4y1x7zq?p=2 Lucene是一套信息检索工具包（jar包），不含搜索引擎系统 ElasticSearch是基于Lucene做了一些封装和增强 2. 入门操作 JDK1.8以上，客户端，界面工具 版本对应。 2.1 下载 官网下载 windows下解压就可以使用 目录： bin：启动文件 config：配置文件 log4j2 日志文件 jvm.options 虚拟机文件 elasticsearch.yml 配置文件 比如默认9200端口 lib：相关jar包 modules：功能模块 plugins：插件：比如ik插件 启动，然后localhost:9200访问 2.2 安装可视化界面head es head插件，github上面下载 https://github.com/mobz/elasticsearch-head npm install npm run start #启动插件：localhost:9100 解决跨域问题：修改elasticsearch.yml文件 #解决跨域问题 http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 2.3 安装kibana ELK：日志分析架构栈 注意：下载版本与es一致；可以在配置文件中汉化 默认端口 localhost:5601 3. ES核心概念 es是面向文档的，一切都是JSON 对比 关系型数据库 Elasticsearch 数据库database 索引 indices（数据库） 表tables types （以后会被启用） 行rows documents （文档） 字段columns fields 物理设计 在后台把每个索引划分为多个分片，每片可以再集群中的不同服务器间迁移； 逻辑设计 文档：索引和搜索数据的最小单位是文档； 自我包含：key：value 层次型：一个文档中包含文档（json对象） 类型：文档的逻辑容器 索引：数据库 倒排索引 es使用倒排索引的结构，采用Lucene倒排索引作为底层。用于快速全文检索。 4. IK分词器插件 什么是IK分词器： 把一句话分词 如果使用中文：推荐IK分词器 两个分词算法：ik_smart（最少切分），ik_max_word（最细粒度划分） 4.1 下载安装 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases 然后解压，放到elasticsearch的plugins中，建立“ik”文件夹，然后放入； 重启观察es：发现加载ik插件了 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ewUmG3or-1590485221083)(http://njpsz.xyz/images/ik.png)] 4.2 使用Kibana测试： 【ik_smart】测试： 输入： GET _analyze { &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;我是社会主义接班人&quot; } 输出： { &quot;tokens&quot; : [ { &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 }, { &quot;token&quot; : &quot;是&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 }, { &quot;token&quot; : &quot;社会主义&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 }, { &quot;token&quot; : &quot;接班人&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 9, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 3 } ] } 【ik_max_word】测试： 输入： GET _analyze { &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是社会主义接班人&quot; } 输入： { &quot;tokens&quot; : [ { &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 }, { &quot;token&quot; : &quot;是&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 }, { &quot;token&quot; : &quot;社会主义&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 }, { &quot;token&quot; : &quot;社会&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 3 }, { &quot;token&quot; : &quot;主义&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 6, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 }, { &quot;token&quot; : &quot;接班人&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 9, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 5 }, { &quot;token&quot; : &quot;接班&quot;, &quot;start_offset&quot; : 6, &quot;end_offset&quot; : 8, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 6 }, { &quot;token&quot; : &quot;人&quot;, &quot;start_offset&quot; : 8, &quot;end_offset&quot; : 9, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 7 } ] } 4.3 用户配置字典 当一些特殊词（比如姓名）不能被识别切分时候，用户可以自定义字典： 重启es和kibana测试 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dNxpUIif-1590485221097)(http://njpsz.xyz/images/20200417150218.png)] 5. Rest风格 5.1 简介 RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。 操作 method url地址 描述 PUT localhost:9100/索引名称/类型名称/文档id 创建文档（指定id） POST localhost:9100/索引名称/类型名称 创建文档（随机id） POST localhost:9100/索引名称/文档类型/文档id/_update 修改文档 DELETE localhost:9100/索引名称/文档类型/文档id 删除文档 GET localhost:9100/索引名称/文档类型/文档id 查询文档通过文档id POST localhost:9100/索引名称/文档类型/_search 查询所有文档 5.2 测试 1、创建一个索引PUT /索引名/类型名/id 默认是_doc [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DeUg5fjf-1590485221110)(http://njpsz.xyz/images/20200417153651.png)] 5.3 数据类型 基本数据类型 字符串 text, keyword 数据类型 long, integer,short,byte,double,float,half_float,scaled_float 日期 date 布尔 boolean 二进制 binary 制定数据类型 输入：创建规则 PUT /test2 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;text&quot; }, &quot;age&quot;: { &quot;type&quot;: &quot;long&quot; }, &quot;birthday&quot;: { &quot;type&quot;: &quot;date&quot; } } } } 输出： { &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;test2&quot; } 如果不指定具体类型，es会默认配置类型 5.4 关于索引的基本操作 查看索引信息： GET test2 查看es信息 get _cat/ 修改 之前的办法：直接put 现在的办法： POST /test3/_doc/1/_update { “doc”: { “name”: “庞世宗” } } 删除索引 DELETE test1 5.5 关于文档的基本操作（重点） 5.5.1 基本操作 1、添加数据 PUT /psz/user/1 { &quot;name&quot;: &quot;psz&quot;, &quot;age&quot;: 22, &quot;desc&quot;: &quot;偶像派程序员&quot;, &quot;tags&quot;: [&quot;暖&quot;,&quot;帅&quot;] } 2、获取数据 GEt psz/user/1 ===============输出=========== { &quot;_index&quot; : &quot;psz&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : { &quot;name&quot; : &quot;psz&quot;, &quot;age&quot; : 22, &quot;desc&quot; : &quot;偶像派程序员&quot;, &quot;tags&quot; : [ &quot;暖&quot;, &quot;帅&quot; ] } } 3、 更新数据PUT 4、更新数据，推荐POST _update 不推荐 POST psz/user/1 { &quot;doc&quot;:{ &quot;name&quot;: &quot;庞庞胖&quot; #后面信息会没有 } } 推荐！ POST psz/user/1/_update { &quot;doc&quot;:{ &quot;name&quot;: &quot;庞庞胖&quot; #后面信息存在 } } 5、简单搜索 GET GET psz/user/1 简答的条件查询：根据默认映射规则产生基本的查询 GET psz/user/_search?q=name:庞世宗 5.5.2 复杂查询 1、查询，参数使用JSON体 GET psz/user/_search { &quot;query&quot;: { &quot;match&quot;: { &quot;name&quot;: &quot;庞世宗&quot; //根据name匹配 } }, &quot;_source&quot;: [&quot;name&quot;,&quot;age&quot;], //结果的过滤，只显示name和age &quot;sort&quot;: [ { &quot;age&quot;: { &quot;order&quot;: &quot;desc&quot; //根据年龄降序 } } ], &quot;from&quot;: 0, //分页：起始值，从0还是 &quot;size&quot;: 1 //返回多少条数据 } 之后只用java操作es时候，所有的对象和方法就是这里面的key 分页前端 /search/{current}/{pagesize} 2 、布尔值查询 must(对应mysql中的and) ,所有条件都要符合 GET psz/user/_search { &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ //相当于and { &quot;match&quot;: { &quot;name&quot;: &quot;庞世宗&quot; } }, { &quot;match&quot;: { &quot;age&quot;: 22 } } ] } } } shoule(对应mysql中的or) GET psz/user/_search { &quot;query&quot;: { &quot;bool&quot;: { &quot;should&quot;: [ //should相当于or { &quot;match&quot;: { &quot;name&quot;: &quot;庞世宗&quot; } }, { &quot;match&quot;: { &quot;age&quot;: 22 } } ] } } } must_not (对应mysql中的not) 过滤器 GET psz/user/_search { &quot;query&quot;: { &quot;bool&quot;: { &quot;should&quot;: [ { &quot;match&quot;: { &quot;name&quot;: &quot;庞世宗&quot; } } ], &quot;filter&quot;: [ { &quot;range&quot;: { &quot;age&quot;: { &quot;gt&quot;: 20 //过滤年龄大于20的 } } } ] } } } 3、精确查询 trem查询是直接通过倒排索引指定的词条进行精确的查找的。 关于分词： trem，直接查询精确地 match，会使用分词器解析 关于类型： text: 分词器会解析 keywords: 不会被拆分 4、高亮查询 GET psz/user/_search { &quot;query&quot;: { &quot;match&quot;: { &quot;name&quot;: &quot;庞世宗&quot; } }, &quot;_source&quot;: [&quot;name&quot;,&quot;age&quot;], &quot;sort&quot;: [ { &quot;age&quot;: { &quot;order&quot;: &quot;desc&quot; } } ], &quot;highlight&quot;: //高亮 { &quot;pre_tags&quot;: &quot;&lt;P&gt;&quot;, //自定义高亮 &quot;post_tags&quot;: &quot;&lt;/P&gt;&quot;, &quot;fields&quot;: { &quot;name&quot;:{} //自定义高亮区域 } } } 6. 集成Springboot 6.1 集成Springboot 官方文档：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html 1、找到原生的依赖 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.6.1&lt;/elasticsearch.version&gt; &lt;/properties&gt; 12345678910 2、找对象 Initialization A RestHighLevelClient instance needs a REST low-level client builder to be built as follows: RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;), new HttpHost(&quot;localhost&quot;, 9201, &quot;http&quot;))); The high-level client will internally create the low-level client used to perform requests based on the provided builder. That low-level client maintains a pool of connections and starts some threads so you should close the high-level client when you are well and truly done with it and it will in turn close the internal low-level client to free those resources. This can be done through the close: client.close(); In the rest of this documentation about the Java High Level Client, the RestHighLevelClient instance will be referenced as client. 3、分析类中的方法 一定要版本一致！默认es是6.8.1，要改成与本地一致的。 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.6.1&lt;/elasticsearch.version&gt; &lt;/properties&gt; 1234 Java配置类 @Configuration //xml public class EsConfig { @Bean public RestHighLevelClient restHighLevelClient(){ RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;))); //妈的被这个端口搞了 return client; } } 6.2 索引API操作 1、创建索引 @SpringBootTest class EsApplicationTests { @Autowired @Qualifier(&quot;restHighLevelClient&quot;) private RestHighLevelClient restHighLevelClient; //创建索引的创建 Request @Test void testCreateIndex() throws IOException { //1.创建索引请求 CreateIndexRequest request = new CreateIndexRequest(&quot;索引名&quot;); //2.执行创建请求 indices 请求后获得响应 CreateIndexResponse createIndexResponse = restHighLevelClient.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); } } 2、获取索引 @Test void testExistIndex() throws IOException { GetIndexRequest request = new GetIndexRequest(&quot;索引名&quot;); boolean exist =restHighLevelClient.indices().exists(request,RequestOptions.DEFAULT); System.out.println(exist); } 3、删除索引 @Test void deleteIndex() throws IOException{ DeleteIndexRequest requset = new DeleteIndexRequest(&quot;索引名&quot;); AcknowledgedResponse delete = restHighLevelClient.indices().delete(requset, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); } 6.3 文档API操作 1、测试添加文档 //测试添加文档 @Test void testAddDocument() throws IOException { //创建对象 User user = new User(&quot;psz&quot;, 22); IndexRequest request = new IndexRequest(&quot;ppp&quot;); //规则 PUT /ppp/_doc/1 request.id(&quot;1&quot;); request.timeout(timeValueSeconds(1)); //数据放入请求 IndexRequest source = request.source(JSON.toJSONString(user), XContentType.JSON); //客户端发送请求,获取响应结果 IndexResponse indexResponse = restHighLevelClient.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); } 2、获取文档 //获取文档，判断是否存在 GET /index/doc/1 @Test void testIsExists() throws IOException { GetRequest getRequest = new GetRequest(&quot;ppp&quot;, &quot;1&quot;); //过滤，不放回_source上下文 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(&quot;_none_&quot;); boolean exists = restHighLevelClient.exists(getRequest, RequestOptions.DEFAULT); System.out.println(exists); } 3、获取文档信息 //获取文档信息 @Test void getDocument() throws IOException { GetRequest getRequest = new GetRequest(&quot;ppp&quot;, &quot;1&quot;); GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT); System.out.println(getResponse.getSourceAsString()); System.out.println(getResponse); } ==============输出========================== {&quot;age&quot;:22,&quot;name&quot;:&quot;psz&quot;} {&quot;_index&quot;:&quot;ppp&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:2,&quot;_seq_no&quot;:1,&quot;_primary_term&quot;:1,&quot;found&quot;:true,&quot;_source&quot;:{&quot;age&quot;:22,&quot;name&quot;:&quot;psz&quot;}} 4、更新文档信息 //更新文档信息 @Test void updateDocument() throws IOException { UpdateRequest updateRequest = new UpdateRequest(&quot;ppp&quot;,&quot;1&quot;); updateRequest.timeout(&quot;1s&quot;); //json格式传入对象 User user=new User(&quot;新名字&quot;,21); updateRequest.doc(JSON.toJSONString(user),XContentType.JSON); //请求，得到响应 UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse); } 5、删除文档信息 //删除文档信息 @Test void deleteDocument() throws IOException { DeleteRequest deleteRequest = new DeleteRequest(&quot;ppp&quot;,&quot;1&quot;); deleteRequest.timeout(&quot;1s&quot;); DeleteResponse deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(deleteResponse); } 6.4 批量操作Bulk 真实项目中，肯定用到大批量查询 @Test void testBulkRequest() throws IOException{ BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(&quot;10s&quot;);//数据量大的时候，秒数可以增加 ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;psz&quot;,11)); userList.add(new User(&quot;psz2&quot;,12)); userList.add(new User(&quot;psz3&quot;,13)); userList.add(new User(&quot;psz4&quot;,14)); userList.add(new User(&quot;psz5&quot;,15)); for (int i = 0; i &lt; userList.size(); i++) { bulkRequest.add( new IndexRequest(&quot;ppp&quot;) .id(&quot;&quot;+(i+1)) .source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); } //请求+获得响应 BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures());//返回false：成功 } 6.5 搜索 /* 查询: 搜索请求：SearchRequest 条件构造：SearchSourceBuilder */ @Test void testSearch() throws IOException { SearchRequest searchRequest = new SearchRequest(&quot;ppp&quot;); //构建搜索条件 SearchSourceBuilder searchSourceBuilderBuilder = new SearchSourceBuilder(); // 查询条件QueryBuilders工具 // ：比如：精确查询 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, &quot;psz&quot;); searchSourceBuilderBuilder.query(termQueryBuilder); //设置查询时间 searchSourceBuilderBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); //设置高亮 //searchSourceBuilderBuilder.highlighter() searchRequest.source(searchSourceBuilderBuilder); SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); } ","link":"https://ganhan999.github.io/post/Java ElasticSearch/"},{"title":"Java Redis","content":"nosql 为什么要用nosql 2020年，大数据时代； 单机MySQL 大数据，一般的数据库无法进行处理了！2006，Hadoop发布 数据量太大，一个机器放不下 数据的索引（B+ Tree）,一个机器内存也放不下 访问量，一个服务器承受不了 2.Memcached（缓存）+MySQL+垂直拆分（读写分离） 发展过程： 优化数据结构和索引–》文件缓存（IO）–》Memcached（当时最热门的技术） 分库分表+水平差分+Mysql集群 本质：数据库（读，写） MySQL，早些年MyISAM：表锁（100w，张三–密码），十分影响效率，高并发下就会出现严重的问题 Innodb：行锁，每次查询只锁一行 每个不同的业务使用不同的数据库进行单独管理 慢慢的就开始使用分库分表解决写的压力！MySQL在那个年代推出了表分区！这个并没有多少公司使用 MYSQL的集群，很好满足了那个年代的所有需求 最近的年代 技术爆炸 MySQL等关系型数据库就不够用了，数据量大，变化快！ 如果有一种数据库专门处理大文件数据，mysql压力就会变小 研究如何处理这些问题，大数据IO压力下，表基本上无法更改 1亿 目前一个基本的互联网项目 用户的个人信息，社交网络，地理位置，用户自己产生的数据，用户日志等等爆发性增长 这时候我们就需要用到nosql。nosql可以很好的处理以上的情况 什么是NOSQL NoSQL： not only sql 泛指非关系型数据库，随着web2.0互联网的诞生；传统的关系型数据库很难对付web2.0时代！尤其是大规模高并发的社区！暴露出来难以克服的问题，NoSQL在当今大数据环境下发展十分迅速，Redis是发展最快的，当下要掌握的东西 关系型数据库：表格，行，列（POI技术）， 很多的数据类型用户的个人信息，社交网络，地理位置，这些数据类型的存储不需要一个固定格式！不需要多余的操作就可以横向扩展！Map&lt;String,Object&gt;,使用键值对来控制 NoSQL特点： 解耦 方便扩展（数据之间没有关系，很好扩展） 大数据量高性能（Redis一秒可以写八万次，读取11w次，NoSQL的缓存记录级，是一种细粒度的缓存，性能比较高） 数据类型是多样型的（不需要事先设计数据库，随取随用！如果是数据库量十分大的表，无法设计） 传统的RDBMS和NoSQL 传统的RDBMS - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 数据操作，数据定义语言 - 严格的一致性 - 。。。。 1234567 NoSQL - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE（异地多活） 初级架构师 - 高性能，高可用，高可扩展 - 。。。。 12345678 了解：3V+3高 大数据的3V：主要是描述问题的 海量Volume 多样Variety 实时Velocity 三高：对程序的要求 高并发 高可扩（随时水平拆分，机器不够了，可以扩展机器来解决） 高性能（保证用户体验和性能） 真正在公司中的实践，一定是nosql + RDBMS，一起使用才是最强的 技术没有高低之分，就看你如何使用。（内功，思维的提高） alibaba架构演进 思考问题：这么多的问题都是在一个数据库中的吗？ 技术不能急，慢慢学才能扎实。 敏捷开发，极限编程 开源才是技术的王道 如果未来想当一个架构师，没有什么是加一层解决不了的 1.商品的基本信息 名称，价格，商家信息 关系型数据库就可以解决了，MySQL/Oracle 淘宝内部的mysql不是我们用的mysql 2.商品的描述。评论（文字比较多） 文档型数据库中，MongoDB 3，图片 分布式文件系统，FastDFS - 淘宝自己的 TFS - Google的 GFS - Hadoop的HDFS - 阿里云的 oss 4.商品关键字 - 搜索引擎 solr elasticsearch - ISearch：多隆 5. 商品热门的波段信息 - 内存数据库 - Redis，Tair，Memacache 6。商品的交易，外部的支付接口 - 三方应用 1234567891011121314151617181920 大型互联网应用问题： 数据类型太多了 数据源太多了，经常重构 数据要改造需要大面积改动 解决问题： nosql数据类型 nosql四大分类 KV键值对： 新浪：Redis 美团：Redis + Tair 阿里，百度：Redis + Memacache 文档型数据库（bson格式，和json一样）： MongoDB（一般必须要掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的 ConthDB 列存储数据库 HBase 分布式文件系统 图关系数据库 不是存图形的，放的是关系 Neo4j，InfoGrid CAP BASE Redis入门 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 免费和开源！是当下最热门的nosql技术 区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能干嘛： 内存存储，持久化，内存中是断电即失，所以说持久化很重要，（rdb，aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器，计数器（浏览量） 特性： 多样的数据类型 持久化 集群 事务 学习中需要用到的东西： 狂神的公众号 官网：https://redis.io/ 中文网 ：http://www.redis.cn/ 下载地址，通过官网下载即可 注意：windows版本的在github上下载（停更很久了） Redis推荐都是在linux上搭建的 Redis安装 Windows下安装 下载安装包https://github.com/dmajkic/redis/releases 下载完毕得到压缩包 解压到自己电脑下的环境目录即可，Redis十分的小 开启Redis，双击运行服务即可，默认端口号：6379 使用redis客户端来连接redis ping 测试连接 set name yangjian key-value键值对 123 记住一句话，Windows下使用确实简单，但是Redis推荐我们使用linux去开发使用 Linux下安装 下载安装包，官网下载 http://www.redis.cn/redis-6.0.6.tar.gz 解压redis安装包，程序/opt tar -zxvf redis-6.0.6.tar.gz 1 进入解压后的文件，可以看到redis的配置文件 https://blog.csdn.net/qq_39135287/article/details/83474865?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160427974219724813256379%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160427974219724813256379&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v28-1-83474865.pc_search_result_cache&amp;utm_term=linux%E4%B8%8B%E5%AE%89%E8%A3%85redis&amp;spm=1018.2118.3001.4449 注意：新版本需要升级gcc 通过指定的配置文件启动服务 使用redis-cli客户端连接 查看redis进程是否开启 如何关闭redis服务呢？shutdown 后面我们会使用单机多redis集群进行测试 测试性能 redis-benchmark是一个压力测试工具 官方自带的性能测试工具 命令参数 自己来测试一下 # 测试100个并发连接，100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 如何查看分析 基础知识 redis默认有16个数据库 默认使用的是第0个 可以使用select 进行切换数据库 127.0.0.1:6379&gt; select 3 # 切换数据库 OK 127.0.0.1:6379[3]&gt; dbsize # 查看db大小 (integer) 0 keys * # 查看当前数据库所有的key flushdb # 清空当前库 flushall # 清空所有数据库 12345678910 为什么redis的端口号为6379（了解即可，一个女人的姓名（手机 redis是单线程的 明白redis是很快的，官方表示，redis是基于内存操作的，cpu不是redis的性能瓶颈，redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，那就使用了单线程了！所以就使用了单线程， Redis是由c语言写的，官方提供的数据为 100000+的QPS，说明这个完全不比memecache差！ Redis 为什么单线程还更快？ 误区：高性能的服务器一定是多线程的？ 误区：多线程一定比单线程效率高（上下文切换） CPU&gt;内存&gt;硬盘的速度要有所了解 核心：redis是将所有的数据全部放在内存里面的，所以说使用单线程操作效率就是最高的（CPU上下文切换是一个耗时的操作） 对于内存系统来说，如果没有上下文切换，效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案 五大基本数据类型 官方文档 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability） 现在的命令一定要全部记住，后面使用springboot，jredis，所有的都是基于此 Redis-Key 基本命令 set key value # set值 keys * #查看当前db的所有key get key # 得到key的value exists key # 是否存在key（键） move key db # 移动键到另外一个数据库，共有16个数据库，默认为0 expire key 秒数 # 设置过期时间，单位是秒 ttl key # 查看还有多少时间过期 type key # 查看key的具体类型 123456789101112131415 不会的命令去官网查http://www.redis.cn/commands.html String 九成的java程序员使用redis只会一个String类型！ append key &quot;字符串&quot; # 向key后追加一个字符串，如果当前key不存在，就相当于set strlen key # 获取字符串长度 incr key # 加一 decr key # 自减1 incrby value #增加value，可以设置步长，指定增量 decrby value # 减少value ############################################################ 字符串范围 range getrange key start end # 下标从0开始，start-end getrange key 0 -1 # 查看整个字符串,获取全部字符串，和get key是一样的 # 替换 # 替换指定位置开始的字符串 setrange key offset string # offset：偏移量，string：要替换的字符串 ########################################################### # setex(set with expire) # 设置过期时间 # setnx(set if not exist) # 不存在设置，在分布式锁中会经常使用，保证当前这个值存在 127.0.0.1:6379&gt; setex key3 30 hello # 设置key3的值30s后过期 OK 127.0.0.1:6379&gt; ttl key3 (integer) 27 127.0.0.1:6379&gt; get key3 &quot;hello&quot; 127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey不存在，创建mykey (integer) 1 127.0.0.1:6379&gt; keys * 1) &quot;mykey&quot; 2) &quot;key2&quot; 3) &quot;key1&quot; 127.0.0.1:6379&gt; ttl key3 (integer) -2 127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，则创建失败 (integer) 0 127.0.0.1:6379&gt; get mykey &quot;redis&quot; ######################################################## # 批量set，get mset k1 v1 k2 v2 ... # 同时设置多个值 mget k1 k2 ... # 同时获取多个值 msetnx k1 v1 k2 v2 ... # msetnx是一个原子性的操作，要么一起成功，要么一起失败 # 对象 set user:1 {name:zhangsan,age:3} # 设置一个user:1对象，值为json字符串来保存一个对象 mset user:1:name zhangsan user:1:age 20 # 这里的key是一个巧妙的设计，user:{id}:{field}，如此设计在redis中是完全可以的 getset # 先get后se getset key value # 如果不存在值则返回nil，如果存在值则获取原来的值，然后set 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 数据结构是相通的 String类似的使用场景：value除了是我们的字符串还可以是数字 计数器 统计多单位的数量 uid 粉丝数 对象缓存存储 List 基本的数据类型，列表 在redis里面，我们可以把list玩成栈，队列 所有的list命令都是用l来开头的，不区分大小写命令 127.0.0.1:6379&gt; lpush list one # 将一个值或多个值插入到列表的头部 (integer) 1 127.0.0.1:6379&gt; lpush list two (integer) 2 127.0.0.1:6379&gt; lpush list three (integer) 3 127.0.0.1:6379&gt; lrange list 0 -1 # 获取所有元素 1) &quot;three&quot; 2) &quot;two&quot; 3) &quot;one&quot; 127.0.0.1:6379&gt; lrange list 0 1 # 获取0-1，通过区间获取具体的值 1) &quot;three&quot; 2) &quot;two&quot; 127.0.0.1:6379&gt; rpush list right # 将一个值放在链表的尾部 (integer) 4 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;three&quot; 2) &quot;two&quot; 3) &quot;one&quot; 4) &quot;right&quot; ############################################################## lpop key # 移除列表的第一个元素 rpop key # 移除列表的最后一个元素 lindex key index # 获取key的index下标处的值，index从0开始 llen key # 获取list的长度 # 移除指定的值 lrme key count value # 删除count个value，从前往后删除，精确匹配 ############################################################# trim 修剪操作：list截断 ltrim key start stop # 截取list的start到stop之间的所有元素，左右都闭合，这个list就已经被改变了，只剩下截取的元素 rpoplpush source destination # 移除列表的最后一个元素并添加到目的列表的第一个 exists key # 判断里面有没有值 lset key index element # 设置key的index下标位置的值为element ，只有存在这个index下标才可以使用 linsert key before|after pivot element # 在pivot之前或之后插入值 1234567891011121314151617181920212223242526272829303132333435363738394041424344 小结： list实际上一个链表，before Node after，左右都可以插入 如果key不存在，创建新的链表 如果存在，新增内容 如果移除了所有值，空链表，不存在 在两边改动效率最高，中间元素效率会低一点 消息排队！消息队列， Set set中的值是不能重复的 sadd key value # 向set集合中添加 smembers key # 查看key里面的所有值 scard key # 获取set的元素个数 sismember key value # 判断value值是否在key中 srem key value # 移除value元素 set # 无序不重复集合，抽随机 srandmember myset count # 随机抽出指定个数元素 spop key count # 随机删除一些set集合中的元素 smove source destination # 将一个集合中的元素移动到另一个集合中 数字集合类： - 差集 sdiff key1 key2 - 交集 sinter key1 key2 # 共同好友就可以这样实现 - 并集 sunion key1 key2 12345678910111213141516171819202122 共同关注，共同爱好，二度好友 Hash（哈希） Map集合，key-,key-map,这时候这个值是一个map集合，本质和string没有太大区别 hset key filed value [field value] # 存放hash As of Redis 4.0.0, HSET is variadic and allows for multiple field/value pairs. # As per Redis 4.0.0, HMSET is considered deprecated. Please use HSET in new code. hget key field # 获取key中filed键的值 hgetall key # 获取所有的键值对 hdel key filed # 删除hash指定的字段，对应的value也就没有了 hlen key # 获取hash的内容长度 hexists key field # 判断hash中的某个filed是否存在 hkeys key # 获取hash的所有键（key） hvals key # 获取hash的所有值 hincrby key filed count # 自增count hdecrby key field count # 自减 1234567891011121314151617181920 Zset(有序集合) 在set的基础上，增加了一个值, zset k1 score1 v1 zadd key score value # 添加值，score代表优先级，可以一次添加多个 zrange key start end # 获取start-end的值，0 -1代表获取所有值 # 排序如何实现 zrangebyscore key startscore endscore # 对集合通过score排序， 默认升序 zrangebyscore key -inf inf withscores # 显示score zrevrange salary 0 -1 [withscores] # 降序排列所有值 zrem key member [member] # 移除元素 zcard key # 获取有序集合中的个数 zcount key start end # 获取start-end之间的个数 12345678910111213141516 多查官方文档 案例思路：set 排序 存储班级成绩表，工资表排序 普通消息：1.重要消息 2.带权重进行判断 排行榜应用实现，取top n测试 三种特殊数据类型 geospatial 地理位置 朋友的定位，附近的人，打车距离计算。 两地之间的距离，方圆几里的人 可以查询一些测试数据 只有六个命令 geoadd，添加地理位置的经度纬度 # 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入 # geoadd key 纬度 经度 名称 # 添加地理位置信息 127.0.0.1:6379&gt; geoadd China:city 116.23128 40.22077 beijing (integer) 1 127.0.0.1:6379&gt; geoadd China:city 121.48941 31.40527 shanghai (integer) 1 127.0.0.1:6379&gt; geoadd China:city 106.54041 29.40268 chongqing 12345678 geopos，获取指定的经度纬度 geopos key position # 获取position的经度纬度 1 geodist：返回两个位置的绝对距离 返回两个给定位置之间的距离。 如果两个位置之间的其中一个不存在， 那么命令返回空值。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 geodist key member1 member2 [m|km|ft|mi] # 查看member1到member2的直线距离 1 georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。 范围可以使用以下其中一个单位： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 我附近的人？（获得附近所有人的地址，定位！）通过半径来查询 georadius key longitude latitude radius [m|km|ft|mi] [withcoord] [withdist] # 查询坐标半径的所有元素,后面可以跟很多参数，具体参数查看官方文档 1 georadiusbymember 这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点 指定成员的位置被用作查询的中心。 # 找出指定元素周围的其他元素 georadiusbymember key member radius [m|km|ft|mi] 12 geohash 该命令将返回11个字符的Geohash字符串，所以没有精度Geohash，损失相比，使用内部52位表示。返回的geohashes具有以下特性： 他们可以缩短从右边的字符。它将失去精度，但仍将指向同一地区。 它可以在 geohash.org 网站使用，网址 http://geohash.org/&lt;geohash-string&gt;。查询例子：http://geohash.org/sqdtr74hyu0. 与类似的前缀字符串是附近，但相反的是不正确的，这是可能的，用不同的前缀字符串附近。 geohash key member [member] # 获取指定元素坐标的hash表示,如果两个字符串越接近，离的越近 1 geo底层的实现原理其实就是Zset！我们可以使用Zset命令操作geo zrange key 0 -1 #查看所有元素 zrem key member # 删除指定元素 123 hyperloglog 什么是基数 不重复的元素 Redis2.8.9版本就更新了Hyperloglog数据结构 Redis Hyperloglog 基数统计的算法 网页的 UA（一个访问一个网站多次，但是还是算做一个人） 传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断，存在误差 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是计数，而不是保存用户id 优点：占用的内存是固定的，2^64不同元素，只需要废12kb的内存，如果要从内存角度来比较的话，Hyperloglog是首选 0.81%的错误率！统计UA的任务，是可以忽略不计的 pfadd key member [member] # 添加元素 pfcount key # 查看个数 pfmerge destkey sourcekey [sourcekey] # 合并多个sourcekey # 注意：不会有重复数据 1234567 bitmap 位存储 统计疫情感染人数：0 1 0 1，统计用户信息，活跃，不活跃，打开，365打卡，两个状态的，都可以使用bitmaps来存储 bitmap 位图，也是一种数据结构！都是操作二进制位来进行记录，都只有 0 1两种状态 365天 = 365 bit， 1字节 = 8bit， 46个字节左右！ 测试 使用bitmaps记录周一到周日的打卡，查看某一天 setbit key offset value # 设置 getbit key offset # 得到结果 # 统计操作，打卡的天数 bitcount key [start end] # 统计打卡天数 123456 事务 MYSQL：ACID！ 要么同时成功，要么同时失败：原子性，redis没有原子性 Redis单条命令保证原子性，但是事务不保证原子性 Redis事务本质：一组命令的集合,一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行 一次性，顺序性，排他性！执行一系列的命令 Redis事务没有隔离级别的概念 所有的命令在事务中，并没有被直接被执行，只有发起执行命令的时候才会被执行！Exec redis的事务 开启事务(multi) 命令入队(……) 执行事务(exec) 锁：redis可以实现乐观锁，watch 正常执行事务 127.0.0.1:6379&gt; multi # 开启事务 OK 127.0.0.1:6379&gt; set k1 v1 QUEUED 127.0.0.1:6379&gt; set k2 v2 QUEUED 127.0.0.1:6379&gt; get k2 QUEUED 127.0.0.1:6379&gt; set k3 v3 QUEUED 127.0.0.1:6379&gt; exec # 执行事务 1) OK 2) OK 3) &quot;v2&quot; 4) OK 123456789101112131415 放弃事务 127.0.0.1:6379&gt; multi # 开启事务 OK 127.0.0.1:6379&gt; set k1 v1 QUEUED 127.0.0.1:6379&gt; set k2 v2 QUEUED 127.0.0.1:6379&gt; set k4 v4 QUEUED 127.0.0.1:6379&gt; discard # 放弃事务 OK 127.0.0.1:6379&gt; get k4 # 事务中的命令都不会被执行 (nil) 12345678910111213 编译型异常（代码有问题，命令有错 ），事务中所有的命令都不会执行 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set k1 v2 QUEUED 127.0.0.1:6379&gt; set k2 v2 QUEUED 127.0.0.1:6379&gt; set k3 v3 QUEUED 127.0.0.1:6379&gt; getset k3 # 错误的命令 (error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379&gt; set k4 v4 QUEUED 127.0.0.1:6379&gt; set k5 v5 QUEUED 127.0.0.1:6379&gt; exec # 执行事务报错 (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行 (nil) 123456789101112131415161718 运行时异常（1/0），如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set k1 &quot;v1&quot; QUEUED 127.0.0.1:6379&gt; incr k1 QUEUED 127.0.0.1:6379&gt; set k2 v2 QUEUED 127.0.0.1:6379&gt; set k3 v3 QUEUED 127.0.0.1:6379&gt; get k3 QUEUED 127.0.0.1:6379&gt; exec 1) OK 2) (error) ERR value is not an integer or out of range # 虽然这条命令报错，但是依旧执行成功 3) OK 4) OK 5) &quot;v3&quot; 12345678910111213141516171819 监控！Watch ：（ ，面试常问 悲观锁： 很悲观，认为什么时候都会出问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会加锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version Redis测试监视测试 正常执行成功 watch key # 监视值 unwatch # 放弃监视 exec # 执行事务 multi # 开启事务 127.0.0.1:6379&gt; set money 100 OK 127.0.0.1:6379&gt; set out 0 OK 127.0.0.1:6379&gt; watch money # 监视money对象 OK 127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功 OK 127.0.0.1:6379&gt; decrby money 20 QUEUED 127.0.0.1:6379&gt; incrby out 20 QUEUED 127.0.0.1:6379&gt; exec 1) (integer) 80 2) (integer) 20 123456789101112131415161718192021222324 执行失败，使用watch可以当redis的乐观锁操作 # 主线程 127.0.0.1:6379&gt; watch money OK 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; decrby money 10 QUEUED 127.0.0.1:6379&gt; incrby out 10 QUEUED 127.0.0.1:6379&gt; exec # 执行之前，另外一个线程修改了值，就会导致执行失败 (nil) # 线程2 127.0.0.1:6379&gt; get money &quot;80&quot; 127.0.0.1:6379&gt; set money 1000 OK 1234567891011121314151617 如果修改失败，获取最新的值就好 Jedis 我们要用java来操作Redis 什么是Jedis 是 Redis官方推荐的java连接开发工具！使用java操作redis中间件！如果要使用java操作redis，那么一定要对jedis十分的熟悉 知其然并知其所以然 代入Jedis的包 &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.74&lt;/version&gt; &lt;/dependency&gt; 12345678910111213 编码测试 连接数据库 public class TestPing { public static void main(String[] args) { // 1.new Jedis对象 Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379); // jedis所有的命令就是之前学习的所有指令,所以之间的指令很重要 System.out.println(jedis.ping()); } } // 输出，pong 12345678910 操作命令 断开连接 常用API String List Set Hash Zset 所有的API命令就是上面对应的指令，一个都没有变化 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;hello&quot;, &quot;world&quot;); jsonObject.put(&quot;name&quot;, &quot;杨剑&quot;); jedis.flushDB(); //开启事务 Transaction multi = jedis.multi(); String s = jsonObject.toJSONString(); try { multi.set(&quot;user1&quot;, s); multi.set(&quot;user2&quot;, s); int i = 1/0; //代码抛出异常，事务执行失败 multi.exec();//执行事务 } catch (Exception e) { multi.discard(); //放弃事务 e.printStackTrace(); } finally { System.out.println(jedis.get(&quot;user1&quot;)); System.out.println(jedis.get(&quot;user2&quot;)); jedis.close(); } } } 12345678910111213141516171819202122232425262728 SpringBoot整合 Springboot操作数据：spring-data jpa jdbc mongodb redis SpringData也是和SpringBoot齐名的项目 说明：在springboot2.x之后，原来使用的jedis被替换成了lettuce？ jedis：采用的是直连，多个线程操作是不安全的，如果想要避免，使用jedis pool连接池！BIO lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 整合测试一下 /* * Copyright 2012-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.boot.autoconfigure.data.redis; import java.net.UnknownHostException; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisOperations; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; /** * {@link EnableAutoConfiguration Auto-configuration} for Spring Data's Redis support. * * @author Dave Syer * @author Andy Wilkinson * @author Christian Dupuis * @author Christoph Strobl * @author Phillip Webb * @author Eddú Meléndez * @author Stephane Nicoll * @author Marco Aust * @author Mark Paluch * @since 1.0.0 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RedisOperations.class) @EnableConfigurationProperties(RedisProperties.class) @Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class }) public class RedisAutoConfiguration { @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) //我们可以自己定义一个RedisTemplate来替换默认的 // 默认的template没有过多的设置，redis对象都是需要序列化的 //两个泛型都是object类型，我们后面使用需要强制转换&lt;String,Object&gt; public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean //由于String类型是Redis中最常使用的类型，所以单独提出来了一个bean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 导入连接 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;65 &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 1234 配置连接 # springboot所有的配置类，都有一个自动配置类 RedisAutoConfiguration # 自动配置类都会绑定一个properties配置文件 RedisProperties # 配置redis spring.redis.host=localhost spring.redis.port=6379 123456 测试！ @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { //redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // 操作字符串，类似String类型 // redisTemplate.opsForValue(); // // 操作List // redisTemplate.opsForList(); // //opsforset // redisTemplate.opsForSet(); // //opsforhash // redisTemplate.opsForHash(); // //地图 // redisTemplate.opsForGeo(); // //Zset // redisTemplate.opsForZSet(); // //基数：hyperloglog // redisTemplate.opsForHyperLogLog(); //除了基本的操作，常用的方法都可以直接使用,事务和基本的crud //获取redis连接对象 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); redisTemplate.opsForValue().set(&quot;name&quot;,&quot;yangjian&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); } } 1234567891011121314151617181920212223242526272829303132 序列化配置 自定义RedisTemplate(拿过来可以直接用) package com.yang.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.net.UnknownHostException; @Configuration public class RedisConfig { //编写自己的RedisTemplate //自己定义了一个RedisTemplate //这是一个固定模板，拿去可以直接使用 @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { //为了我们自己开发方便，一般直接使用&lt;String,Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); //json序列化配置 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectJackson2JsonRedisSerializer.setObjectMapper(om); //String的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); //key采用String序列化方式 template.setKeySerializer(stringRedisSerializer); //hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value的序列化方式采用jackson template.setValueSerializer(objectJackson2JsonRedisSerializer); //hash的value序列化方式采用jackson template.setHashValueSerializer(objectJackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 RedisUtil工具类 package com.yang.utils; import org.springframework.data.redis.connection.DataType; import org.springframework.data.redis.core.Cursor; import org.springframework.data.redis.core.ScanOptions; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.core.ZSetOperations.TypedTuple; import org.springframework.stereotype.Component; import java.util.Collection; import java.util.Date; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; import java.util.concurrent.TimeUnit; /** * Redis工具类 * * @author WangFan * @date 2018-02-24 下午03:09:50 * @version 1.1 (GitHub文档: https://github.com/whvcse/RedisUtil ) */ @Component public class RedisUtil { private StringRedisTemplate redisTemplate; public void setRedisTemplate(StringRedisTemplate redisTemplate) { this.redisTemplate = redisTemplate; } public StringRedisTemplate getRedisTemplate() { return this.redisTemplate; } /** -------------------key相关操作--------------------- */ /** * 删除key * * @param key */ public void delete(String key) { redisTemplate.delete(key); } /** * 批量删除key * * @param keys */ public void delete(Collection&lt;String&gt; keys) { redisTemplate.delete(keys); } /** * 序列化key * * @param key * @return */ public byte[] dump(String key) { return redisTemplate.dump(key); } /** * 是否存在key * * @param key * @return */ public Boolean hasKey(String key) { return redisTemplate.hasKey(key); } /** * 设置过期时间 * * @param key * @param timeout * @param unit * @return */ public Boolean expire(String key, long timeout, TimeUnit unit) { return redisTemplate.expire(key, timeout, unit); } /** * 设置过期时间 * * @param key * @param date * @return */ public Boolean expireAt(String key, Date date) { return redisTemplate.expireAt(key, date); } /** * 查找匹配的key * * @param pattern * @return */ public Set&lt;String&gt; keys(String pattern) { return redisTemplate.keys(pattern); } /** * 将当前数据库的 key 移动到给定的数据库 db 当中 * * @param key * @param dbIndex * @return */ public Boolean move(String key, int dbIndex) { return redisTemplate.move(key, dbIndex); } /** * 移除 key 的过期时间，key 将持久保持 * * @param key * @return */ public Boolean persist(String key) { return redisTemplate.persist(key); } /** * 返回 key 的剩余的过期时间 * * @param key * @param unit * @return */ public Long getExpire(String key, TimeUnit unit) { return redisTemplate.getExpire(key, unit); } /** * 返回 key 的剩余的过期时间 * * @param key * @return */ public Long getExpire(String key) { return redisTemplate.getExpire(key); } /** * 从当前数据库中随机返回一个 key * * @return */ public String randomKey() { return redisTemplate.randomKey(); } /** * 修改 key 的名称 * * @param oldKey * @param newKey */ public void rename(String oldKey, String newKey) { redisTemplate.rename(oldKey, newKey); } /** * 仅当 newkey 不存在时，将 oldKey 改名为 newkey * * @param oldKey * @param newKey * @return */ public Boolean renameIfAbsent(String oldKey, String newKey) { return redisTemplate.renameIfAbsent(oldKey, newKey); } /** * 返回 key 所储存的值的类型 * * @param key * @return */ public DataType type(String key) { return redisTemplate.type(key); } /** -------------------string相关操作--------------------- */ /** * 设置指定 key 的值 * @param key * @param value */ public void set(String key, String value) { redisTemplate.opsForValue().set(key, value); } /** * 获取指定 key 的值 * @param key * @return */ public String get(String key) { return redisTemplate.opsForValue().get(key); } /** * 返回 key 中字符串值的子字符 * @param key * @param start * @param end * @return */ public String getRange(String key, long start, long end) { return redisTemplate.opsForValue().get(key, start, end); } /** * 将给定 key 的值设为 value ，并返回 key 的旧值(old value) * * @param key * @param value * @return */ public String getAndSet(String key, String value) { return redisTemplate.opsForValue().getAndSet(key, value); } /** * 对 key 所储存的字符串值，获取指定偏移量上的位(bit) * * @param key * @param offset * @return */ public Boolean getBit(String key, long offset) { return redisTemplate.opsForValue().getBit(key, offset); } /** * 批量获取 * * @param keys * @return */ public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) { return redisTemplate.opsForValue().multiGet(keys); } /** * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value * * @param key * @param postion * 位置 * @param value * 值,true为1, false为0 * @return */ public boolean setBit(String key, long offset, boolean value) { return redisTemplate.opsForValue().setBit(key, offset, value); } /** * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout * * @param key * @param value * @param timeout * 过期时间 * @param unit * 时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES * 秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS */ public void setEx(String key, String value, long timeout, TimeUnit unit) { redisTemplate.opsForValue().set(key, value, timeout, unit); } /** * 只有在 key 不存在时设置 key 的值 * * @param key * @param value * @return 之前已经存在返回false,不存在返回true */ public boolean setIfAbsent(String key, String value) { return redisTemplate.opsForValue().setIfAbsent(key, value); } /** * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 * * @param key * @param value * @param offset * 从指定位置开始覆写 */ public void setRange(String key, String value, long offset) { redisTemplate.opsForValue().set(key, value, offset); } /** * 获取字符串的长度 * * @param key * @return */ public Long size(String key) { return redisTemplate.opsForValue().size(key); } /** * 批量添加 * * @param maps */ public void multiSet(Map&lt;String, String&gt; maps) { redisTemplate.opsForValue().multiSet(maps); } /** * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 * * @param maps * @return 之前已经存在返回false,不存在返回true */ public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) { return redisTemplate.opsForValue().multiSetIfAbsent(maps); } /** * 增加(自增长), 负数则为自减 * * @param key * @param value * @return */ public Long incrBy(String key, long increment) { return redisTemplate.opsForValue().increment(key, increment); } /** * * @param key * @param value * @return */ public Double incrByFloat(String key, double increment) { return redisTemplate.opsForValue().increment(key, increment); } /** * 追加到末尾 * * @param key * @param value * @return */ public Integer append(String key, String value) { return redisTemplate.opsForValue().append(key, value); } /** -------------------hash相关操作------------------------- */ /** * 获取存储在哈希表中指定字段的值 * * @param key * @param field * @return */ public Object hGet(String key, String field) { return redisTemplate.opsForHash().get(key, field); } /** * 获取所有给定字段的值 * * @param key * @return */ public Map&lt;Object, Object&gt; hGetAll(String key) { return redisTemplate.opsForHash().entries(key); } /** * 获取所有给定字段的值 * * @param key * @param fields * @return */ public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) { return redisTemplate.opsForHash().multiGet(key, fields); } public void hPut(String key, String hashKey, String value) { redisTemplate.opsForHash().put(key, hashKey, value); } public void hPutAll(String key, Map&lt;String, String&gt; maps) { redisTemplate.opsForHash().putAll(key, maps); } /** * 仅当hashKey不存在时才设置 * * @param key * @param hashKey * @param value * @return */ public Boolean hPutIfAbsent(String key, String hashKey, String value) { return redisTemplate.opsForHash().putIfAbsent(key, hashKey, value); } /** * 删除一个或多个哈希表字段 * * @param key * @param fields * @return */ public Long hDelete(String key, Object... fields) { return redisTemplate.opsForHash().delete(key, fields); } /** * 查看哈希表 key 中，指定的字段是否存在 * * @param key * @param field * @return */ public boolean hExists(String key, String field) { return redisTemplate.opsForHash().hasKey(key, field); } /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param increment * @return */ public Long hIncrBy(String key, Object field, long increment) { return redisTemplate.opsForHash().increment(key, field, increment); } /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param delta * @return */ public Double hIncrByFloat(String key, Object field, double delta) { return redisTemplate.opsForHash().increment(key, field, delta); } /** * 获取所有哈希表中的字段 * * @param key * @return */ public Set&lt;Object&gt; hKeys(String key) { return redisTemplate.opsForHash().keys(key); } /** * 获取哈希表中字段的数量 * * @param key * @return */ public Long hSize(String key) { return redisTemplate.opsForHash().size(key); } /** * 获取哈希表中所有值 * * @param key * @return */ public List&lt;Object&gt; hValues(String key) { return redisTemplate.opsForHash().values(key); } /** * 迭代哈希表中的键值对 * * @param key * @param options * @return */ public Cursor&lt;Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) { return redisTemplate.opsForHash().scan(key, options); } /** ------------------------list相关操作---------------------------- */ /** * 通过索引获取列表中的元素 * * @param key * @param index * @return */ public String lIndex(String key, long index) { return redisTemplate.opsForList().index(key, index); } /** * 获取列表指定范围内的元素 * * @param key * @param start * 开始位置, 0是开始位置 * @param end * 结束位置, -1返回所有 * @return */ public List&lt;String&gt; lRange(String key, long start, long end) { return redisTemplate.opsForList().range(key, start, end); } /** * 存储在list头部 * * @param key * @param value * @return */ public Long lLeftPush(String key, String value) { return redisTemplate.opsForList().leftPush(key, value); } /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, String... value) { return redisTemplate.opsForList().leftPushAll(key, value); } /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, Collection&lt;String&gt; value) { return redisTemplate.opsForList().leftPushAll(key, value); } /** * 当list存在的时候才加入 * * @param key * @param value * @return */ public Long lLeftPushIfPresent(String key, String value) { return redisTemplate.opsForList().leftPushIfPresent(key, value); } /** * 如果pivot存在,再pivot前面添加 * * @param key * @param pivot * @param value * @return */ public Long lLeftPush(String key, String pivot, String value) { return redisTemplate.opsForList().leftPush(key, pivot, value); } /** * * @param key * @param value * @return */ public Long lRightPush(String key, String value) { return redisTemplate.opsForList().rightPush(key, value); } /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, String... value) { return redisTemplate.opsForList().rightPushAll(key, value); } /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, Collection&lt;String&gt; value) { return redisTemplate.opsForList().rightPushAll(key, value); } /** * 为已存在的列表添加值 * * @param key * @param value * @return */ public Long lRightPushIfPresent(String key, String value) { return redisTemplate.opsForList().rightPushIfPresent(key, value); } /** * 在pivot元素的右边添加值 * * @param key * @param pivot * @param value * @return */ public Long lRightPush(String key, String pivot, String value) { return redisTemplate.opsForList().rightPush(key, pivot, value); } /** * 通过索引设置列表元素的值 * * @param key * @param index * 位置 * @param value */ public void lSet(String key, long index, String value) { redisTemplate.opsForList().set(key, index, value); } /** * 移出并获取列表的第一个元素 * * @param key * @return 删除的元素 */ public String lLeftPop(String key) { return redisTemplate.opsForList().leftPop(key); } /** * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public String lBLeftPop(String key, long timeout, TimeUnit unit) { return redisTemplate.opsForList().leftPop(key, timeout, unit); } /** * 移除并获取列表最后一个元素 * * @param key * @return 删除的元素 */ public String lRightPop(String key) { return redisTemplate.opsForList().rightPop(key); } /** * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public String lBRightPop(String key, long timeout, TimeUnit unit) { return redisTemplate.opsForList().rightPop(key, timeout, unit); } /** * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 * * @param sourceKey * @param destinationKey * @return */ public String lRightPopAndLeftPush(String sourceKey, String destinationKey) { return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey); } /** * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param sourceKey * @param destinationKey * @param timeout * @param unit * @return */ public String lBRightPopAndLeftPush(String sourceKey, String destinationKey, long timeout, TimeUnit unit) { return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey, timeout, unit); } /** * 删除集合中值等于value得元素 * * @param key * @param index * index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素; * index&lt;0, 从尾部开始删除第一个值等于value的元素; * @param value * @return */ public Long lRemove(String key, long index, String value) { return redisTemplate.opsForList().remove(key, index, value); } /** * 裁剪list * * @param key * @param start * @param end */ public void lTrim(String key, long start, long end) { redisTemplate.opsForList().trim(key, start, end); } /** * 获取列表长度 * * @param key * @return */ public Long lLen(String key) { return redisTemplate.opsForList().size(key); } /** --------------------set相关操作-------------------------- */ /** * set添加元素 * * @param key * @param values * @return */ public Long sAdd(String key, String... values) { return redisTemplate.opsForSet().add(key, values); } /** * set移除元素 * * @param key * @param values * @return */ public Long sRemove(String key, Object... values) { return redisTemplate.opsForSet().remove(key, values); } /** * 移除并返回集合的一个随机元素 * * @param key * @return */ public String sPop(String key) { return redisTemplate.opsForSet().pop(key); } /** * 将元素value从一个集合移到另一个集合 * * @param key * @param value * @param destKey * @return */ public Boolean sMove(String key, String value, String destKey) { return redisTemplate.opsForSet().move(key, value, destKey); } /** * 获取集合的大小 * * @param key * @return */ public Long sSize(String key) { return redisTemplate.opsForSet().size(key); } /** * 判断集合是否包含value * * @param key * @param value * @return */ public Boolean sIsMember(String key, Object value) { return redisTemplate.opsForSet().isMember(key, value); } /** * 获取两个集合的交集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sIntersect(String key, String otherKey) { return redisTemplate.opsForSet().intersect(key, otherKey); } /** * 获取key集合与多个集合的交集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) { return redisTemplate.opsForSet().intersect(key, otherKeys); } /** * key集合与otherKey集合的交集存储到destKey集合中 * * @param key * @param otherKey * @param destKey * @return */ public Long sIntersectAndStore(String key, String otherKey, String destKey) { return redisTemplate.opsForSet().intersectAndStore(key, otherKey, destKey); } /** * key集合与多个集合的交集存储到destKey集合中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) { return redisTemplate.opsForSet().intersectAndStore(key, otherKeys, destKey); } /** * 获取两个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, String otherKeys) { return redisTemplate.opsForSet().union(key, otherKeys); } /** * 获取key集合与多个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) { return redisTemplate.opsForSet().union(key, otherKeys); } /** * key集合与otherKey集合的并集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sUnionAndStore(String key, String otherKey, String destKey) { return redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey); } /** * key集合与多个集合的并集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) { return redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey); } /** * 获取两个集合的差集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sDifference(String key, String otherKey) { return redisTemplate.opsForSet().difference(key, otherKey); } /** * 获取key集合与多个集合的差集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) { return redisTemplate.opsForSet().difference(key, otherKeys); } /** * key集合与otherKey集合的差集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sDifference(String key, String otherKey, String destKey) { return redisTemplate.opsForSet().differenceAndStore(key, otherKey, destKey); } /** * key集合与多个集合的差集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sDifference(String key, Collection&lt;String&gt; otherKeys, String destKey) { return redisTemplate.opsForSet().differenceAndStore(key, otherKeys, destKey); } /** * 获取集合所有元素 * * @param key * @param otherKeys * @param destKey * @return */ public Set&lt;String&gt; setMembers(String key) { return redisTemplate.opsForSet().members(key); } /** * 随机获取集合中的一个元素 * * @param key * @return */ public String sRandomMember(String key) { return redisTemplate.opsForSet().randomMember(key); } /** * 随机获取集合中count个元素 * * @param key * @param count * @return */ public List&lt;String&gt; sRandomMembers(String key, long count) { return redisTemplate.opsForSet().randomMembers(key, count); } /** * 随机获取集合中count个元素并且去除重复的 * * @param key * @param count * @return */ public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) { return redisTemplate.opsForSet().distinctRandomMembers(key, count); } /** * * @param key * @param options * @return */ public Cursor&lt;String&gt; sScan(String key, ScanOptions options) { return redisTemplate.opsForSet().scan(key, options); } /**------------------zSet相关操作--------------------------------*/ /** * 添加元素,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @param score * @return */ public Boolean zAdd(String key, String value, double score) { return redisTemplate.opsForZSet().add(key, value, score); } /** * * @param key * @param values * @return */ public Long zAdd(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values) { return redisTemplate.opsForZSet().add(key, values); } /** * * @param key * @param values * @return */ public Long zRemove(String key, Object... values) { return redisTemplate.opsForZSet().remove(key, values); } /** * 增加元素的score值，并返回增加后的值 * * @param key * @param value * @param delta * @return */ public Double zIncrementScore(String key, String value, double delta) { return redisTemplate.opsForZSet().incrementScore(key, value, delta); } /** * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @return 0表示第一位 */ public Long zRank(String key, Object value) { return redisTemplate.opsForZSet().rank(key, value); } /** * 返回元素在集合的排名,按元素的score值由大到小排列 * * @param key * @param value * @return */ public Long zReverseRank(String key, Object value) { return redisTemplate.opsForZSet().reverseRank(key, value); } /** * 获取集合的元素, 从小到大排序 * * @param key * @param start * 开始位置 * @param end * 结束位置, -1查询所有 * @return */ public Set&lt;String&gt; zRange(String key, long start, long end) { return redisTemplate.opsForZSet().range(key, start, end); } /** * 获取集合元素, 并且把score值也获取 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start, long end) { return redisTemplate.opsForZSet().rangeWithScores(key, start, end); } /** * 根据Score值查询集合元素 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;String&gt; zRangeByScore(String key, double min, double max) { return redisTemplate.opsForZSet().rangeByScore(key, min, max); } /** * 根据Score值查询集合元素, 从小到大排序 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max) { return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max); } /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max, long start, long end) { return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max, start, end); } /** * 获取集合的元素, 从大到小排序 * * @param key * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRange(String key, long start, long end) { return redisTemplate.opsForZSet().reverseRange(key, start, end); } /** * 获取集合的元素, 从大到小排序, 并返回score值 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key, long start, long end) { return redisTemplate.opsForZSet().reverseRangeWithScores(key, start, end); } /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max) { return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max); } /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores( String key, double min, double max) { return redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max); } /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max, long start, long end) { return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end); } /** * 根据score值获取集合元素数量 * * @param key * @param min * @param max * @return */ public Long zCount(String key, double min, double max) { return redisTemplate.opsForZSet().count(key, min, max); } /** * 获取集合大小 * * @param key * @return */ public Long zSize(String key) { return redisTemplate.opsForZSet().size(key); } /** * 获取集合大小 * * @param key * @return */ public Long zZCard(String key) { return redisTemplate.opsForZSet().zCard(key); } /** * 获取集合中value元素的score值 * * @param key * @param value * @return */ public Double zScore(String key, Object value) { return redisTemplate.opsForZSet().score(key, value); } /** * 移除指定索引位置的成员 * * @param key * @param start * @param end * @return */ public Long zRemoveRange(String key, long start, long end) { return redisTemplate.opsForZSet().removeRange(key, start, end); } /** * 根据指定的score值的范围来移除成员 * * @param key * @param min * @param max * @return */ public Long zRemoveRangeByScore(String key, double min, double max) { return redisTemplate.opsForZSet().removeRangeByScore(key, min, max); } /** * 获取key和otherKey的并集并存储在destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long zUnionAndStore(String key, String otherKey, String destKey) { return redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey); } /** * * @param key * @param otherKeys * @param destKey * @return */ public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) { return redisTemplate.opsForZSet() .unionAndStore(key, otherKeys, destKey); } /** * 交集 * * @param key * @param otherKey * @param destKey * @return */ public Long zIntersectAndStore(String key, String otherKey, String destKey) { return redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey); } /** * 交集 * * @param key * @param otherKeys * @param destKey * @return */ public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) { return redisTemplate.opsForZSet().intersectAndStore(key, otherKeys, destKey); } /** * * @param key * @param options * @return */ public Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) { return redisTemplate.opsForZSet().scan(key, options); } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367 所有的Redis操作，其实对于java开发人员来说十分的简单，更重要的是理解思想和应用场景 Redis.conf详解 启动的时候就是通过配置文件启动的 对大小写不敏感 包含 好比学习spring的时候，import，include 网络：重要 bind 127.0.0.1 # 绑定的ip protected-mode yes # 保护模式 port 6379 # 端口设置 123 通用 daemonize yes # 以守护进程的方式运行，默认是no，需要自己开启为yes pidfile /var/run/redis_6379.pid # 如果以后台方式运行，我们需要指定一个pid文件 # 日志 loglevel notice logfile &quot;&quot; # 日志的文件位置名 databases 16 #数据库的数量，默认为16个 always-show-logo yes # 是否显示logo 123456789 快照 持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof redis是内存数据库，如果没有持久化，那么数据断电即失去 # 如果900秒内至少有一个key进行了修改，我们就进行持久化操作 save 900 1 # 如果300秒内至少有10key进行了修改，我们就进行持久化操作 save 300 10 # 如果60秒内至少有10000key进行了修改，我们就进行持久化操作 save 60 10000 # 我们之后学习持久化，会自己定义这个配置 stop-writes-on-bgsave-error yes # 持久化出错后是否继续工作 rdbcompression yes # 是否压缩rdb文件，需要消耗一些cpu的资源 rdbchecksum yes # 报错rdb文件时候进行错误的检查校验 dir ./ # rdb文件保存的目录，默认为当前目录 123456789101112131415 REPLICATION 复制，主从复制 SECURITY 可以在这里设置redis的密码，默认是没有密码的 127.0.0.1:6379&gt; config get requirepass # 获取redis的密码 1) &quot;requirepass&quot; 2) &quot;&quot; 127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis密码 OK auth 123456 # 输入密码后才可以登录 123456 限制CLIENTS maxclients 10000 # 设置能连接上的最大客户端的数量 maxmemory &lt;bytes&gt; # redis最大的内存容量 maxmemory-policy noeviction # 内存达到上限的处理策略 # 移除一些过期的key # 报错 # 。。。 noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。（默认值） allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。 volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。 allkeys-random: 所有key通用; 随机删除一部分 key。 volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。 volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。 redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取maxmeory-samples个键，删除这三个键中最近最少使用的键。 12345678910111213141516 APPEND ONLY 模式 aof配置 appendonly no # 默认不开启aof模式，默认使用rdb方式持久化，几乎在所有情况下rdb够用 appendfilename &quot;appendonly.aof&quot; # 持久化文件的名字 # appendfsync always # 每次修改都会同步，消耗性能 appendfsync everysec # 每秒都同步一次 sync，可能会丢失这1s数据 # appendfsync no # 不执行同步，这时候操作系统自己同步数据，速度最快 1234567 Redis持久化 RDB（Redis Database） 在主从复制中，rdb就是备用的！在从机上面 面试和工作，持久化必须是重点 Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能 在指定时间间隔内将内存中的数据集写入磁盘，也就是Snapshot快照，它恢复时是将文件直接读到内存里 Redis会单独创建（fork）一个子进程来进行持久化，会先将书局写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效，RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。 RDB保存的文件是dump.rdb都是在我们配置文件中的快照中进行配置的 自己测试一次，60s内修改5次，就会触发rdb操作 flushall默认产生一个dump.rdb文件 触发机制 save规则满足的情况下，会自动触发rdb规则 执行flushall命令也会触发rdb规则 退出redis，也会产生rdb 备份就自动生成dump.rdb 如何恢复rdb文件 只需要将rdb文件放在redis的启动目录下就可以了，redis启动的时候会自动检查dump.rdb文件恢复 查看需要存在的位置 127.0.0.1:6379&gt; config get dir 1) &quot;dir&quot; 2) &quot;/usr/local/redis-6.0.6/bin&quot; #如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据 123 几乎他自己的默认配置就够用了，但是我们还是学习 有时候在生产环境，我们会将这个文件进行备份 优点： 适合大规模的数据恢复！dump.rdb 如果对数据完整性不高！ 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，那么最后一次修改的数据就没有了 fork进程的时候会占用一定的内存空间 AOF（Append Only File） 将我们的所有命令都记录下来，history，恢复的时候把这个文件全部再执行一遍 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从签到后执行一次以完成数据的恢复工作 AOF保存的是appendonly.aof文件 默认是不开启的，我们需要手动进行配置，我们只需要将appendonly改为yes即可 重启redis就可以生效了 如果这个aof文件有错位，这时候redis是启动不起来的，我们需要修复这个aof文件 redis给我们提供了redis-check-aof --fix appendonly.aof来进行appendonly.aof的修复 如果文件正常，重启就可以直接恢复了 优点和缺点 优点： 每一次修改都同步，文件完整性更加好 每同步一次，可能会丢失一秒的数据 从不同步 缺点： 相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢 AOF运行效率也要比rdb慢，redis默认的配置就是rdb持久化 重写规则说明 如果aof文件大于64MB，太大了，！fork一个新的进程来将我们文件进行重写 aof默认就是文件的无限追加，文件会越来越大 扩展： Redis 持久化 Redis 提供了不同级别的持久化方式: RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储. AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大. 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. 最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始: RDB的优点 RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集. RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复. RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能. 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些. RDB的缺点 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据. RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度. AOF 优点 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据. AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题. Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 AOF 缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 Redis发布订阅 消息队列 通信，队列 发送者 订阅者 Redis 发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。微信，微博 Redis客户端可以订阅任意数量的频道 订阅/发布消息图： 第一个：消息发送者，第二个：频道 第三个：消息订阅者！ 命令： psubcribe pattern [pattern] 订阅一个或多个符合给定模式的频道 pubsub subcommand [argument [argument]] 查看订阅与发布系统状态 publish channel message 将信息发送到指定的频道 punsubscribe [pattern [pattern]] 退订所有给定模式的频道 subscribe channel [channel 订阅一个或多个频道的信息 unsubscribe [channel [channel]] 退订给定的频道 测试 订阅端 127.0.0.1:6379&gt; SUBSCRIBE yangjianChannel # 订阅一个频道 Reading messages... (press Ctrl-C to quit) 1) &quot;subscribe&quot; 2) &quot;yangjianChannel&quot; 3) (integer) 1 # 等待读取推送的信息 1) &quot;message&quot; #消息 2) &quot;yangjianChannel&quot; # 哪个频道的消息 3) &quot;hello,yangjianChannel&quot; # 具体内容 1) &quot;message&quot; 2) &quot;yangjianChannel&quot; 3) &quot;hello,Redis&quot; 123456789101112 发送端 127.0.0.1:6379&gt; PUBLISH yangjianChannel &quot;hello,yangjianChannel&quot; # 发布者发布消息到指定的频道 (integer) 1 127.0.0.1:6379&gt; PUBLISH yangjianChannel &quot;hello,Redis&quot; (integer) 1 1234 原理 Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis 的理解。Redis通过PUBLISH 、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。 微信: 通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。 通过PUBLSH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 Pub/Sub从字面上理解就是发布(Publish)与订阅( Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。 使用场景： 实时消息系统 实时聊天（频道当做聊天室） 订阅关注系统 稍微复杂的场景，消息中间件MQ（） Redis主从复制 概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(masterleader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。 主从复制的作用主要包括: 1、数据冗余∶主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 2、故障恢复∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。 3、负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载﹔尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 4、高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的(宕机，最少3个），原因如下: 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大; 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是&quot;多读少写&quot;。对于这种场景，我们可以使如下这种架构︰ 主从复制，读写分离！80%情况下都是在进行读操作！减缓服务器压力，架构经常使用！一主二从！ 只要在公司中，主从复制就是必须要使用的，因为在真实的项目中，不可能单机使用redis！ 环境配置 只配置从库，不用配置主库 主从复制信息 info replication # 查看当前库的信息 127.0.0.1:6379&gt; info replication # Replication role:master # 角色：master connected_slaves:0 # 没有从机 master_replid:85e0dc3072e2b2d876b7ff4a0cb53f961d7fd5e6 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 1234567891011121314 复制三个配置文件，修改对应的信息 端口号 pid 日志名字 备份文件名字 dump.rdb 修改完毕之后启动三个redis服务 一主二从 默认情况下，每台Redis服务器都是主节点，我们一般情况下只用配置从机就好了 认老大，一主（79）二从（80,81） slaveof host port # 设置这个主机的主人 127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 # 认定这个主机下的6379端口为主 OK 127.0.0.1:6380&gt; info replication # Replication role:slave master_host:127.0.0.1 # 可以看到主机的信息 master_port:6379 master_link_status:up master_last_io_seconds_ago:8 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14 # 在主机中查看 [root@iZbp17e1mp4a0cgbw1358xZ bin]# redis-cli -p 6379 127.0.0.1:6379&gt; info replication # Replication role:master connected_slaves:1 slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=1 master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd master_replid2:0000000000000000000000000000000000000000 master_repl_offset:126 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:126 1234567891011121314151617181920212223242526272829303132333435363738394041 如果两个都配置完了，就会有两个从机的 真实的主从配置应该在配置文件中配置，这样的话是永久的，使用命令是暂时的 细节 主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存 测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，如果主机回来，从机依旧可以直接获取到主机写的信息 如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机!只要变为从机，立马就会从主机中获取值 复制原理 Slave启动成功连接到master后会发送一个sync命令 Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制︰而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制:Master继续将新的所有收集到的修改命令依次传给slave，完成同步。 但是只要是重新连接master，一次完全同步(全量复制）将被自动执行。我们的数据一定可以在从机中看到 层层链路 上一个M连接下一个S，这时候也可以完成我们的主从复制 如果没有老大，能不能选择一个老大出来呢，手动 谋朝篡位 salveof no one,如果主机断开了连接，可以使用这个命令来让自己成为主节点，其他的结点就可以手动连接到最新的这个主节点 如果这个时候老大修复了，那就只能重新连接 Redis哨兵模式（自动选取老大的模式） 概述： 主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务器不可用。这不是一种推荐方式，更多时候，我们优先考虑哨兵模式，Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。 谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例 哨兵有两个作用 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 测试 我们目前的状态是一主二从 配置哨兵配置文件sentinel.conf # sentinel monitor 被监控的名称 host port 1 sentinel monitor myredis 127.0.0.1 6379 1 # 1是有多少哨兵认为挂了，master才是真的挂了 123 后面的这个数字1代表主机挂了，slave投票看让谁来接替成为主机，票数最多的就会成为主机 启动哨兵 redis-sentinel ../etc/sentinal.conf [root@iZbp17e1mp4a0cgbw1358xZ bin]# redis-sentinel ../etc/sentinal.conf 20615:X 05 Nov 2020 13:05:15.181 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 20615:X 05 Nov 2020 13:05:15.181 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=20615, just started 20615:X 05 Nov 2020 13:05:15.181 # Configuration loaded _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 6.0.6 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 26379 | `-._ `._ / _.-' | PID: 20615 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 20615:X 05 Nov 2020 13:05:15.182 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 20615:X 05 Nov 2020 13:05:15.185 # Sentinel ID is ee900e749cf585634b3bc2860471d28dcd1ec109 20615:X 05 Nov 2020 13:05:15.185 # +monitor master myredis 127.0.0.1 6379 quorum 1 20615:X 05 Nov 2020 13:05:15.186 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379 20615:X 05 Nov 2020 13:05:15.188 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379 123456789101112131415161718192021222324252627282930 如果master结点断开了，这个时候就会从从机中随机选择一个服务器,这里面有一个投票算法 哨兵日志 哨兵模式 如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！ 优点： 哨兵模式，基于主从复制模式，所有主从配置的优点它都有 主从可以切换，故障可以转移，系统的可用性就会更好 哨兵模式就是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置是非常麻烦的，里面有很多选择 哨兵模式全部配置 # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass &lt;master-name&gt; &lt;password&gt; sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 Redis缓存穿透与雪崩（面试高频，工作常用） 服务的高可用问题 不会详细分析解决方案的底层（专题） 缓存穿透（查不到） 概念 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 解决方案 布隆过滤器 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力﹔ 缓存空对象 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源; 但是这种方法会存在两个问题: 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键; 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 缓存击穿（查的太多，量大，缓存过期） 微博服务器宕机（60 60.1 0.1） 概述： 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 解决方案 设置热点数据永不过期 从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题 加互斥锁 分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁考验很大 缓存雪崩 概念 缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 解决方案 Redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。(异地多活） 限流降级（在SpringCloud中有） 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","link":"https://ganhan999.github.io/post/Java Redis/"},{"title":"中等77. 组合","content":"题目 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 回溯算法 大神做法1： class Solution: def combine(self, n: int, k: int) -&gt; list: ans = list() def backtrack(tmp: list, index: int) -&gt; None: if len(tmp) == k: ans.append(tmp[:]) return for i in range(index, n + 1): tmp.append(i) backtrack(tmp, i + 1) tmp.pop() backtrack([], 1) return ans &quot;&quot;&quot;&quot;&quot;&quot; 用Python的itertools来写组合组合 大神做法2： class Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: return list(itertools.combinations(range(1,n+1),k)) ","link":"https://ganhan999.github.io/post/77、 组合/"},{"title":"中等75. 颜色分类","content":"题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 单指针 我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。 在第二次遍历中，我们将数组中所有的 11 交换到头部的 0 之后。此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。 大神做法1： class Solution: def sortColors(self, nums: List[int]) -&gt; None: n = len(nums) ptr = 0 for i in range(n): if nums[i] == 0: nums[i], nums[ptr] = nums[ptr], nums[i] ptr += 1 for i in range(ptr, n): if nums[i] == 1: nums[i], nums[ptr] = nums[ptr], nums[i] ptr += 1 &quot;&quot;&quot;&quot;&quot;&quot; 双指针，一个指向换0的位置，一个指向换1的位置。 大神做法2： class Solution: def sortColors(self, nums: List[int]) -&gt; None: n = len(nums) p0 = p1 = 0 for i in range(n): if nums[i] == 1: nums[i], nums[p1] = nums[p1], nums[i] p1 += 1 elif nums[i] == 0: nums[i], nums[p0] = nums[p0], nums[i] if p0 &lt; p1:#如果p0 &lt; p1，要把nums[i], nums[p1]互换，当 p_0 &lt; p_1时，我们已经将一些1连续地放在头部，此 # 时一定会把一个 11 交换出去，导致答案错误 nums[i], nums[p1] = nums[p1], nums[i] p0 += 1 p1 += 1 ","link":"https://ganhan999.github.io/post/75、颜色分类/"},{"title":"Java MyBatisPlus","content":"MyBatisPlusB站狂神说 学习MyBatis-Plus之前要先学MyBatis–&gt;Spring—&gt;SpringMVC 为什么要学它?MyBatisPlus可以节省我们大量的时间,所有CRUD代码都可以自动完成 JPA, tk-mapper ,MyBatisPlus 偷懒用的! 1.简介 是什么? 官网:https://baomidou.com/ 2.特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 1.快速入门 地址:https://baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B 使用第三方插件: 导入对应的依赖 研究依赖如何配置 代码如何编写 提高扩展技术能力 步骤 1.创建数据库 mybatis_plus 2.创建数据库 创建表 DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); --真实开发环境中,version(乐观锁),deleted(逻辑删除),gmt_create,gmt_modified 插入数据 DELETE FROM user; INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); 3.编写项目,初始化项目! 使用SpringBoot初始化! 4.导入依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 说明:我们使用mybatis-plus 可以节省我们大量的代码,尽量不要同时导入mybatis和mybatis-plus因为版本有差异! 5.连接数据库!这一步和mybatis相同! # mysql 5 驱动不同 com.mysql.jdbc.Driver # mysql 8 驱动不同 com.mysql.cj.jdbc.Driver . 需要增加时区的配置 serverTimezone=GMT%2B8 spring.datasource.username=codeyuaiiao spring.datasource.password=3615yuhaijiao spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 1234567 6.传统的方式pojo-dao(连接mybatis,配置mapper.xml文件)-service-controller 6.使用了mybatis-plus之后 pojo @Data @AllArgsConstructor @NoArgsConstructor public class User { private Long id; private String name; private Integer age; private String email; mapper接口 import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.codeyuaiiao.pojo.User; import org.springframework.stereotype.Repository; //在对应的mapper上面继承基本的类 BaseMapper @Repository//代表持久层 public interface UserMapper extends BaseMapper&lt;User&gt; { //所有CRUD操作都已经编写完成了 //你不需要向以前一样配置一大堆文件了! } 注意点:需要在主启动类MybatisPlusApplication上扫描我们Mapper包下的所有接口 @MapperScan(&quot;com.codeyuaiiao.mapper&quot;) 测试类中测试 @SpringBootTest class MybatisPlusApplicationTests { //继承了BaseMapper, 所有的方法都来自己父类 //我们也可以编写自己的扩展方法 @Autowired private UserMapper userMapper; @Test void contextLoads() { //参数是一个Wrapper , 条件构造器,这里我们先不用 --null //查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } } 查询结果: 思考问题 sql谁帮我们写的?—mybatis-plus 方法谁帮我们写的?—mybatis-pluss 2.配置日志 我们所有的sql是不可见的,我们希望知道他是怎么执行的,所以我们必须看日志! # 配置日志 (默认控制台输出) mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 配置完日志之后你会喜欢上mybatis-plus! 3.CRUD扩展 1.插入数据 @Test public void testInsert(){ User user = new User(); user.setName(&quot;codeyuaiiao&quot;); user.setAge(3); user.setEmail(&quot;747557612@qq.com&quot;); int result = userMapper.insert(user); System.out.println(result); System.out.println(user); } 注意点:数据库插入的id默认值为:全局的唯一id 2.主键生成策略 默认 ID_WORKER 全局唯一id 对应数据库中的主键(uuid.自增id.雪花算法.redis.zookeeper) 分布式系统唯一id生成:https://www.cnblogs.com/haoxinyue/p/5208136.html 雪花算法😦Twitter的snowflake算法) snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0.可以保证几乎全球唯一 主键自增 我们需要配置主键自增: 实体类字段上@TableId(type = IdType.AUTO) 数据库字段一定要是自增! 其余源码解释 public enum IdType { AUTO(0),//数据库ID自增 NONE(1),//该类型为未设置主键类型 INPUT(2),//用户输入ID //该类型可以通过自己注册自动填充插件进行填充 //以下3种类型、只有当插入对象ID 为空，才自动填充。 ID_WORKER(3),//全局唯一ID (idWorker) UUID(4),//全局唯一ID (UUID) ID_WORKER_STR(5);//字符串全局唯一ID (idWorker 的字符串表示) 3.更新数据 动态sql 注意:updateById()参数是 一个对象! //测试更新 @Test public void testUpdate(){ User user = new User(); user.setId(2L); user.setName(&quot;阿峧不是山交&quot;); // 注意:updateById()参数是 一个对象! int i = userMapper.updateById(user); System.out.println(i); } 所有的sql都是动态帮你配置的 4.自动填充 创建时间 . 修改时间! 这些个操作都是自动化完成的,我们不希望手动更新! 阿里巴巴开发手册:所有的数据库表:gmt_create .gmt_modified几乎所有的表都要配置上!而且需要自动化! 方式一:数据库级别 1.在表中新增字段 create_time , update_time 2.再次测试插入方法,我们需要先把实体类同步 private Data creatTime; private Data updateTime; 再次更新查看结果即可 方式二:代码级别 1.删除数据库默认值 2.实体类字段属性上添加注解 //记住用util包下的Date!! //字段添加填充内容 @TableField(fill = FieldFill.INSERT) private Data creatTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Data updateTime; 3.编写处理器来处理这个注解 package com.codeyuaiiao.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j @Component //把处理器加到IOC容器中 public class MyMetaObjectHandler implements MetaObjectHandler { //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(&quot;Start insert fill.... &quot;); this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); } //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(&quot;Start update fill.... &quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); } } 3.编写处理器来处理这个注解即可! package com.codeyuaiiao.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j @Component //把处理器加到IOC容器中 public class MyMetaObjectHandler implements MetaObjectHandler { //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(&quot;Start insert fill.... &quot;); this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); } //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(&quot;Start update fill.... &quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); } } 4.测试插入 5测试更新,观察时间即可! 5.乐观锁&amp;悲观锁 乐观锁: 顾名思义十分乐观,他总是认为不会出现问题,无论干什么都不去上锁!如果出现了问题,再次更新值测试 悲观锁;顾名思义十分悲观,他总是认为出现问题,无论干什么都会上锁!再去操作! 我们这里主要讲解 乐观锁机制! 乐观锁实现方式: 取出记录时,获取当前version 更新时,带上这个version 执行更新时,set version = newVersion where version = oldVersion 如果version不对,就更新失败 6.查询操作 //测试查询 @Test public void testSelectById(){ User user = userMapper.selectById(1L); System.out.println(user); } //测试批量查询 public void testSelectBatchId(){ List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); } //按条件查询之--使用Map操作 @Test public void testSelectBatchIds(){ HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;阿峧说java&quot;); map.put(&quot;age&quot;,&quot;18&quot;); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println); } 我们在工作中会遇见逻辑删除 7.逻辑删除 物理删除:从数据库中直接移除 逻辑删除: 在数据库中没有被移除,而是通过一个变量来让他失效! deleted=0=&gt;deleted=1 管理员可以查看被删除的记录!防止数据的丢失,类似于回收站! 测试: 1.在数据表中增加一个deleted字段 2.实体类中增加属性 //逻辑删除 @TableLogic private Integer deleted; 3.配置 //注册逻辑删除 @Bean public ISqlInjector sqlInjector(){ return new LogicSqlInjector(); } 配置 # 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 走的是更新操作,不是删除操作 查询的时候会自动过滤删除的数据 以上的所有CRUD操作及其扩展,我们都必须精通掌握!会大大提好你的工作和写项目的效率 4.性能分析插件 我们在平时的开发中,会遇到一些慢sql. MP也提供了性能分析插件,如果超过这个时间就停止运行! 1.导入插件 @Bean @Profile({&quot;dev&quot;,&quot;test&quot;}) //设置dev 和 test环境开启 public PerformanceInterceptor performanceInterceptor(){ PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(1); performanceInterceptor.setFormat(true); return performanceInterceptor; } [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7kbdevy0-1601449207282)(MyBatisPlusB站狂神说.assets/image-20200930133715010.png)] 记住在SpringBoot中配置环境为 dev或者test环境 application.properties中添加设置开发环境 #设置开发环境 spring.profiles.active=dev 2.测试查询 @Test public void testSelectBatchId(){ List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); } 5.条件构造器 package com.kuang; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.kuang.mapper.UserMapper; import com.kuang.pojo.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; import java.util.Map; @SpringBootTest public class WrapperTest { @Autowired private UserMapper userMapper; @Test void contextLoads() { // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(&quot;name&quot;) .isNotNull(&quot;email&quot;) .ge(&quot;age&quot;,12); userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习的map对比一下 } @Test void test2(){ // 查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;name&quot;,&quot;狂神说&quot;); User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List 或者 Map System.out.println(user); } @Test void test3(){ // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(&quot;age&quot;,20,30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); } // 模糊查询 @Test void test4(){ // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左和右 t% wrapper .notLike(&quot;name&quot;,&quot;e&quot;) .likeRight(&quot;email&quot;,&quot;t&quot;); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println); } // 模糊查询 @Test void test5(){ QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // id 在子查询中查出来 wrapper.inSql(&quot;id&quot;,&quot;select id from user where id&lt;3&quot;); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); } //测试六 @Test void test6(){ QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 通过id进行排序 wrapper.orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); } } 6.代码自动生成**非常NB dao、pojo、service、controller都给我自己去编写完成！ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、 Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 只需要改实体类名字 和包名 还有 数据库配置即可 测试: import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.po.TableFill; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import java.util.ArrayList; // 代码自动生成器 public class KuangCode { public static void main(String[] args) { // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath+&quot;/src/main/java&quot;); gc.setAuthor(&quot;狂神说&quot;); gc.setOpen(false); gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/kuang_community? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); //只需要改实体类名字 和包名 还有 数据库配置即可 pc.setModuleName(&quot;blog&quot;); pc.setParent(&quot;com.kuang&quot;); pc.setEntity(&quot;entity&quot;); pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;blog_tags&quot;,&quot;course&quot;,&quot;links&quot;,&quot;sys_settings&quot;,&quot;user_record&quot;,&quot; user_say&quot;); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 自动填充配置 TableFill gmtCreate = new TableFill(&quot;gmt_create&quot;, FieldFill.INSERT); TableFill gmtModified = new TableFill(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); // localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 } } 大家可以给B站狂神说点一波关注! ","link":"https://ganhan999.github.io/post/Java MyBatisPlus/"},{"title":"中等56. 合并区间","content":"题目 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 依次合并区间，直到它完全在某两个区间之内，添加到区间内 大神做法1： class Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: left, right = newInterval placed = False ans = list() for li, ri in intervals: if li &gt; right: # 在插入区间的右侧且无交集 if not placed:#第一次在区间内就加入，之后就不进行语句内操作 ans.append([left, right]) placed = True ans.append([li, ri]) elif ri &lt; left: # 在插入区间的左侧且无交集 ans.append([li, ri]) else: # 与插入区间有交集，计算它们的并集 left = min(left, li) right = max(right, ri) if not placed:# 没找到就填到最后 ans.append([left, right]) return ans ","link":"https://ganhan999.github.io/post/57、插入区间/"},{"title":"Git","content":"狂神聊Git 学习git之前，我们需要先明白一个概念 版本控制！ 版本控制 什么是版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术。 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。 无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！ 多人开发就必须要使用版本控制！ 常见的版本控制工具 我们学习的东西，一定是当下最流行的！ 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN 版本控制分类 1、本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。 2、集中版本控制 SVN 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3、分布式版本控制 Git 每个人都拥有全部的代码！安全隐患！ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN的主要区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git是目前世界上最先进的分布式版本控制系统。 聊聊Git的历史 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 Linux社区中存在很多的大佬！破解研究 BitKeeper ！ 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！ Git是目前世界上最先进的分布式版本控制系统。 Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！ Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰 Git环境配置 软件下载 打开 [git官网] https://git-scm.com/，下载git对应操作系统的版本。 所有东西下载慢的话就可以去找镜像！ 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/ 下载对应的版本即可安装！ 安装：无脑下一步即可！安装完毕就可以使用了！ 启动Git 安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！ **Git Bash：**Unix与Linux风格的命令行，使用最多，推荐最多 **Git CMD：**Windows风格的命令行 Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 常用的Linux命令 平时一定要多使用这些基础的命令！ 1）、cd : 改变目录。 2）、cd . . 回退到上一个目录，直接cd进入默认目录 3）、pwd : 显示当前所在的目录路径。 4）、ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 6）、rm: 删除一个文件, rm index.js 就会把index.js文件删除。 7）、mkdir: 新建一个目录,就是新建一个文件夹。 8）、rm -r : 删除一个文件夹, rm -r src 删除src目录 rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！ 9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。 10）、reset 重新初始化终端/清屏。 11）、clear 清屏。 12）、history 查看命令历史。 13）、help 帮助。 14）、exit 退出。 15）、#表示注释 Git配置 所有的配置文件，其实都保存在本地！ 查看配置 git config -l 查看不同级别的配置文件： #查看系统config git config --system --list #查看当前用户（global）配置 git config --global --list Git相关的配置文件： 1）、Git\\etc\\gitconfig ：Git 安装目录下的 gitconfig --system 系统级 2）、C:\\Users\\Administrator\\ .gitconfig 只适用于当前登录用户的配置 --global 全局 这里可以直接编辑配置文件，通过命令设置后会响应到这里。 设置用户名与邮箱（用户标识，必要） 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： git config --global user.name &quot;kuangshen&quot; #名称 git config --global user.email 24736743@qq.com #邮箱 只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。总之--global为全局配置，不加为某个项目的特定配置。 Git基本理论（重要） 三个区域 Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本： Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建 创建工作目录与常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用GIT管理的项目的根目录执行： # 在当前目录新建一个Git代码库 $ git init 2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ # 克隆一个项目和它的整个代码历史(版本信息) $ git clone [url] # https://gitee.com/kuangstudy/openclass.git 2、去 gitee 或者 github 上克隆一个测试！ Git文件操作 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 上面说文件有4种状态，通过如下命令可以查看到文件的状态： #查看指定文件状态 git status [filename] #查看所有文件状态 git status # git add . 添加所有文件到暂存区 # git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 #为注释 *.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！ !lib.txt #但lib.txt除外 /temp #仅忽略项目根目录下的TODO文件,不包括其它目录temp build/ #忽略build/目录下的所有文件 doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 使用码云 github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器 这个其实可以作为大家未来找工作的一个重要信息！ 1、注册登录码云，完善个人信息 2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！) # 进入 C:\\Users\\Administrator\\.ssh 目录 # 生成公钥 ssh-keygen 3、将公钥信息public key 添加到码云账户中即可！ 4、使用码云创建一个自己的仓库！ 许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，... 限制！ 克隆到本地！ IDEA中集成Git 1、新建项目，绑定git。 注意观察idea中的变化 2、修改文件，使用IDEA操作git。 添加到暂存区 commit 提交 push到远程仓库 3、提交测试 这些都是单个人的操作！ 学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式） 有道无术、术尚可求。有术无道、止于术！ 真正的教学，授人以渔！ 说明：GIT分支 分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！ git分支中常用指令： # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 $ git merge [branch] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] IDEA中操作 如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！ 1、不要把Git想的很难，工作中多练习使用就自然而然的会了！ 2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！ ","link":"https://ganhan999.github.io/post/Git/"},{"title":"中等74. 搜索二维矩阵","content":"题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true 示例 2： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 二分法 大神做法1： class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: m = len(matrix) if m == 0: return False n = len(matrix[0]) # 二分查找 left, right = 0, m * n - 1 while left &lt;= right: pivot_idx = (left + right) // 2 pivot_element = matrix[pivot_idx // n][pivot_idx % n] if target == pivot_element: return True else: if target &lt; pivot_element: right = pivot_idx - 1 else: left = pivot_idx + 1 return False ","link":"https://ganhan999.github.io/post/74、搜索二维矩阵/"},{"title":"Java Linux","content":"为什么要学Linux 在服务器端，在开发领域Linux是越来越受欢迎，很多程序员都觉得不懂点Linux都觉得不好意思，Linux在开源社区的地位依然岿然不动。 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！ Linux简介 Linux内核最初只是由芬兰人林纳斯.托瓦兹( Linus Torvalds )在赫尔辛基大学上学时出于个人爱好而编写的。 Linux是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX (可移植操作系统接口)和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。 Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux 继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux发行版 发行版就是将Linux内核与应用软件做一个打包 图 版本图解 Linux应用领域 今天各种场合都有使用各种Linux发行版,从嵌入式设备到超级计算机,并且在服务器领域确定了地位,通常服务器使用LAMP(Linux + Apache + MySQL + PHP)或LNMP(Linux + Nginx + MySQL + PHP)组合。 目前Linux不仅在家庭与企业中使用,并且在政府中也很受欢迎。 许多国家都在使用Linux系统 环境搭建 跳过 环境：虚拟机VMware Workstation Pro 15.2+CentOS 7 走近Linux系统 开机 会启动许多程序。它们在Windows叫做’服务&quot; ( service ) , 在Linux就叫做&quot;守护进程&quot; ( daemon)。 一般来说，用户的登录方式有三种: ●命令行登录 ●SSH登录(远程) ●图形界面登录 最高权限账户为root,可以操作一切! 关机 在linux领域内大多用在服务器上,很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的,除非特殊情况下,不得已才会关机。 关机指令为shutdown sync #将数据由内存同步到硬盘中。 shutdown #关机指令，你可以man shutdown 来看一下 帮助文档。例如你可以运行如下命令关机: shutdown -h 10 #这个命令告诉大家，计算机将在10分钟后关机 shutdown -h now#立马关机 shutdown -h 20:25 #系统会在今天20:25关机 shutdown -h +10 #十分钟后关机 shutdown -r now #系统立马重启 shutdown -r +10 #系统十分钟后重启 reboot #就是重启，等同于shutdown -r now halt #关闭系统，等同于shutdown -h now和poweroff 最后总结：不管是重启还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中，执行命令之后没有返回消息则表明运行成功 系统目录 1、一切皆文件 2、根目录/ ,所有的文件都挂载在这个节点下 ls / #查看当前下的目录 图 树状目录结构 目录解释 /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 用完即丢的文件可以放在这个目录下 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。 /www：存放服务器网站相关的资源，环境，网站的项目 2020/6/29 常用的基本命令 cd:切换目录 cd:#切换目录命令! ./:#当前目录 /:#绝对路径 cd..:#返回上一级目录 cd ~:#回到当前的用户目录 pwd :#显示当前用户所在的目录 图 pwd展示 ls(列出目录！) 在Linux中Is可能是最常常被使用的! -a:#参数: all ,查看全部的文件,包括隐藏文件 -l:#参数列出所有的文件,包含文件的属性和权限,没有隐藏文件 所有Linux可以组合使用! ls -al 查看全部的文件包括隐藏文件的属性和权限 mkdir 创建一个目录 mkdir -p test2/test3/test4 # 用-p递归创建层级目录 rmdir 删除目录 rmdir -p test2/test3/test4 #递归删除文件 rmdir仅能删除空的目录,如果下面存在文件,需要先删除文件,递归删除多个目录-p参数即可 cp(复制文件或者目录) cp install.sh cqhstudy #将当前目录下的install.sh 复制到cqhstudy文件夹中 rm 移除文件或者目录 -f #忽略不存在的文件,不会出现警告,强制删除! -r #递归删除目录! -i #互动,删除询问是否删除 rm -rf install.sh/#删除系统中的install.sh mv 移动文件或者目录|重命名文件 -f #强制 -u #只替换已经更新过的文件 12 mv install.sh cqhstudy #移动文件 mv cqhstudy cqhstudy2 #重命名文件夹名 基本属性 Linux系统是一种典型的多用户系统,不同的用户处于不同的地位,拥有不同的权限。为了保护系统的安全性, Linux系统对不同的用户访问同一文件(包括目录文件)的权限做了不同的规定。 在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组,如: 实例中, boot文件的第一个属性用&quot;d&quot;表示。 &quot;d&quot;在Linux中代表该文件是一 个目录文件。 在Linux中第一个字符代表这个文件是目录、 文件或链接文件等等: ●当为[d]则是目录 ●当为[-]则是文件; ●若是[l]则表示为链接文档( link file); ●若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ; ●若是[c]则表示为装置文件里面的串行端口设备,例如键盘、鼠标( 一次性读取装置)。 接下来的字符中,以三个为一组,且均为[rwx] 的三个参数的组合。 其中，[r]代表可读(read)、[w]代表可写(write)、[x]代表可执行(execute)。 要注意的是,这三个权限的位置不会改变,如果没有权限,就会出现减号[-]而已。 每个文件的属性由左边第一部分的10个字符来确定 (如下图) : 图 属性图解 从左至右用0-9这些数字来表示。 第0位确定文件类型,第1-3位确定属主(该文件的所有者)拥有该文件的权限。第4-6位确定属组 (所有者的同组用户)拥有该文件的权限,第7-9位确定其他用户拥有该文件的权限。 其中: 第1、4、7位表示读权限,如果用&quot;r&quot;字符表示,则有读权限,如果用&quot;-“字符表示,则没有读权限; 第2、5、8位表示写权限,如果用&quot;W&quot;字符表示,则有写权限,如果用”-“字符表示没有写权限; 第3、6、9位表示可执行权限,如果用&quot;x&quot;字符表示,则有执行权限,如果用”-&quot;字符表示,则没有执行权限。 对于文件来说,它都有一个特定的所有者,也就是对该文件具有所有权的用户。 同时,在Linux系统中,用户是按组分类的, - -个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此, Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中, boot文件是一个目录文件,属主和属组都为root。 图 图解 修改文件属性 1、chgrp :更改文件属组 chgrp [-R] 属组名文件名 1 -R :递归更改文件属组,就是在更改某个目录文件的属组时,如果加上R的参数,那么该目录下的所有文件的属组都会更改。 2、chown :更改文件属主,也可以同时更改文件属组 chown [-R] 属主名文件名 chown [-R] 属主名:属组名文件名 3、chmod :更改文件9个属性 chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法,一种是数字（常用的是数字）, 一种是符号。 Linux文件的基本权限就有九个,分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据:文件的权限字符为: [-rwxrwxrwx]，这九个权限是三个三个一组的!其中,我们可以使用字来代表各个权限,各权限的分数对照表如下: r:4 w:2 x:1 可读可写不可执行 rw- 6 可读可写可执行 rwx 7 chomd 777 文件赋予所有用户可读可执行! 图 示例 文件内容查看 Linux系统中使用以下命令来查看文件的内容: ●cat由第一行开始显示文件内容 ●tac从最后一行开始显示，可以看出tac是cat的倒着写! 图 cat和tac图解 ●nl显示的时候,顺道输出行号! 图 nl命令图解 ●more一页一页的显示文件内容（空格表示翻页，enter代表向下看下一行） 图 more命令图解 ●less与more类似,但是比more更好的是,他可以往前翻页!（空格翻页，上下键代表上下翻动页面，退出q命令，查找字符串/要查询的字符向下查询，向上查询使用?要查询的字符串,用n继续搜寻下一个,用N向上寻找） ●head 只看头几行 通过-n参数来控制显示几行 ●tail只看尾巴几行 通过-n参数来控制显示几行 你可以使用man 命令来查看各个命令的使用文档,如: man [命令]。 网络配置目录: cd /etc/ sysconfig/network-scripts 图 网络基础配置 ping #用来查看网络是否连通 ifconfig #查看网络 和Windows的ipconfig是一样的 2020/6/30 硬链接和软链接 Linux链接分为两种：硬链接、软链接 硬链接：A—B,假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种机制硬链接到一个重要文件上，防止误删 软链接：类似Windows下的快捷方式，删除源文件，快捷方式也就访问不了 操作步骤： 创建链接 ln命令！ touch命令创建文件！ echo输入字符串 图 图解 删除f1之后，查看f2和f3的区别 图 删除f1之后 f2和f3的区别 Vim编辑器 什么是Vim编辑器 Vim通过一些插件可以实现和IDE的功能! Vim是从Vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富,在程序员中被广泛使用。尤其是Linux中,必须要会使用Vim (查看内容, 编辑内容,保存内容! ) 简单的来说，Vi是老式的字处理器,不过功能已经很齐全了,但是还是有可以进步的地方。 Vim则可以说是程序开发者的一项很好用的工具。 三种使用方式: 基本上Vi/Vim共分为三种模式,分别是 命令模式( Command mode) , 输入模式( Insert mode )和 底线命令模式( Lastline mode )。 这三种模式的作用分别是: 命令模式 用户刚刚启动Vi/Vim ,便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令,而非输入字符。比如我们此时按下i ,并不会输入一个字符, i被当作了一个命令。 以下是常用的几个命令: ●i切换到输入模式,以输入字符。 ●x删除当前光标所在处的字符。 ●:切换到底线命令模式,以在最底一行输入命令。 若想要编辑文本:启动Vim,进入了命令模式,按下i,切换到输入模式。 命令模式只有一些最基本的命令,因此仍要依靠底线命令模式输入更多命令。 输入模式 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键：  字符按键以及Shift组合，输入字符  ENTER，回车键，换行  BACK SPACE，退格键，删除光标前一个字符  DEL，删除键，删除光标后一个字符  方向键，在文本中移动光标  HOME/END，移动光标到行首/行尾  Page Up/Page Down，上/下翻页  Insert，切换光标为输入/替换模式，光标将变成竖线/下划线  ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 2020/7/1 账号管理 Linux系统是一个多用户多任务的分时操作系统,任何一个要使用系统资源的用户,都必须首先向系统管理员申请一个账号,然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪,并控制他们对系统资源的访问;另一方面也可以帮助用户组织文件,并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后,就能够进入系统和自己的主目录。 实现用户账号的管理,要完成的工作主要有如下几个方面: ●用户账号的添加、删除与修改。 ●用户口令的管理。 ●用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号,然后为新账号分配用户号、用户组、主目录和登录ShelI等资源。 useradd 命令 添加用户 useradd -选项 用户名 -m:自动创建这个用户的主目录/home/cqh -G:给用户分配组 [root@cqh home]useradd -m cqh #创建一个用户 [root@cqh home]ls install.sh cqhstudy cqh www 123 理解一下本质: Linux中一切皆文件,这里的添加用户说白了就是往某-个文件中写入用户的信息了! /etc/passwd [root@cqh home]cat /etc/passwd #创建一个用户 cqh:x:1002:1002::/home/cqh:/bin/bash 12 删除用户 userdel userdel -r cqh #删除用户的时候把它的目录也删除掉 修改用户 usermod 对应修改的内容 修改那个用户 [root@cqh home]usermode -d /home/233 cqh 修改完毕后查看配置文件 将cqh用户下的目录修改为233 切换用户 图 细节说明 1.切换用户的命令为: su username [username是你的用户名] 图 切换后的细节 2.从普通用户切换到root用户,还可以使用命令: sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d ,可以退回到原来用户,其实ctrl+d也是执行的exit命令 4.在切换用户时,如果想在切换用户之后使用新用户的工作环境,可以在su和username之间加,例如: [su- root] $表示普通用户，#表示超级用户,也就是root用户 用户的密码设置问题 我们一般通过root创建用户的时候!要配置密码! 如果是超级用户 passwd username new password #新密码 re password #修改密码 普通用户 passwd (current)UNIX password: new password: #密码不能过于简单 re password: 锁定账户 root ,比如张三辞职了!冻结这个账号, 一旦冻结,这个人就登录不上系统了! passwd -l cqh #锁定之后这个用户就不能再登录了 passwd -d cqh #把密码清空 这样也能防止用户登录 效果图 2020/7/2 用户组管理 属主、属组 每个用户都有一个用户组,系统可以对一个用户组中的所有用户进行集中管理(开发、测试、运维)。不同Linux 系统对用户组的规定有所不同,如Linux下的用户属于与它同名的用户组,这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 创建一个用户组 groupadd [root@cqh ~]group add cqh [root@cqh ~]cat /etc/group 创建完用户组后可以得到一一个组的id ,这个id是可以指定的! -g 520， 若果不指定就是自增1 删除用户组 groupdel [root@cqh ~]groupdel cqh [root@cqh ~]cat /etc/group 修改用户组的权限和名字 groupmod -g-n cqh:x:1003 [root@cqh ~]group -g 666 -n newcqh cqh #修改cqh用户组id为666 重命名为newcqh 用户切换用户组 #当前登录用户 cqh $ newgrp root #切换为root 拓展 用户账户文件的查看(了解即可) /etc/passwd 用户名:口令(登录密码，我们不可见) :用户标识号:组标识号:注释性描述:主目录:登录She11 这个文件中的每一行都代表这一用户,我们可以从这里看出这个用户的主目录在那里,可以看到属于哪一个组! 登录口令:把真正的加密后的用户口令字存放到/etc/shadow文件中,保证我们密码的安全性! 用户组的所有信息都存放在/etc/group文件中。 磁盘管理 df(列出文件系统整体的磁盘使用量) du(检查磁盘空间使用量) 图 df命令 图 du命令 du -sm /* 图 查看系统目录 Mac或者想使用Linux挂载我们的一些本地磁盘或者文件! 挂载：mount 图 挂载图 卸载：umount-f [挂载位置] 强制卸载 除了这个之外，以后安装了JDK，可以使用Java命令查看信息 进程管理 什么是进程 1、在Linux中 ,每一个程序都是有自己的一个进程,每一个进程都有一个id号! 2、每一个进程呢,都会有一个父进程! 3、进程可以有两种存在方式:前台!后台运行! 4、一般的话服务都是后台运行的，基本的程序都是前台运行的 命令 ps 查看当前系统中正在执行的各种进程的信息！ ps- xx： -a 显示当前终端所有的进程信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数 #ps -aux 查看所有进程 ps-aux|grep mysql 查看mysql相关进程 # | 在Linux中这个叫管道符 A|B # grep 查找文件中符合条件的字符串 对于我们来说,这里目前只需要记住一个命令即可ps -xx|grep进程名字!过滤进程信息! ps-ef ：可以查看到父进程的信息 ps-ef|grep mysql 看父进程我们一般可以通过目录树结构来查看 #进程树 #pstree -pu #-p 显示父id #-u 显示用户组 进程树效果图 结束进程：杀掉进程 等价于Windows结束任务 kill -9 pid 表示强制结束该进程 环境安装 安装软件一般有三种方式  rpm（在线发布一个SpringBoot项目）  解压缩  yum在线安装 JDK安装 1、下载IDK rpm。 去oralce官网下载即可! 2、安装java环境 java -version 检测当前系统是否存在Java环境 和windows命令一样 #如果有的话就需要卸载 rpm -qa|grep jdk 查看JDK版本信息 rpm -e --nodeps jdk_ 卸载 #卸载完毕后可安装JDK rpm -ivk rpm包 图 java-version命令 图 安装中 配置环境变量: /etc/profile 在文件的最后面增加java的配置和window安装环境变量一样! vim /etc/profile 这个环境变量有问题 狂神老师敲的是有问题的 JAVA_HOME=/usr/java/jdk-14.0.1 JRE_HOME=$JAVA_HOME/jre PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export JAVA_HOME JRE_HOME PATH CLASSPATH 让这个配置文件生效! source /etc/profile 狂神老师用的是阿里云，自带网络了，此处给用虚拟机的同学使用。虚拟机联网教程：虚拟机和主机联网教程 配置完后在Linux防火墙中开启相应端口 使用java -jar发布 如果你的项目在云服务器上，就可以在公网上进行发布查看了 #开启防火墙端口 firewall-cmd --zone=public --add-port=9000/tcp --permanent #重启防火墙 systemctl restart firewalld.service #查看所有开启的端口，如果是阿里云 需要配置安全组规则 firewall-cmd --list-ports 命令运行效果 查出centos7中的ip 外机进行访问 Tomcat安装 ssm war 就需要放在tomcat中运行 1.下载tomcat 官网下载即可 2.解压tar -zxvf apache-tomcat-9.0.36.tar.gz 3.启动tomcat #执行 ./startup.sh #停止 ./shutdown.sh 启动效果 #开启端口 firewall-cmd --zone=public --add-port=8080/tcp –permanent 命令含义: --zone 作用域 --add-port-80/tcp 添加端口， 格式为:端口/通讯协议 --permanent 永久生效，没有此参数重启后失效 如果是阿里云 上传完毕的项目直接购买自己的域名,备案解析过去即可! 域名解析后,如果端口是80 - http或者443-https 可以直接访问,如果是9000 8080 ,就需要通过Apcahe或者Nginx做一下反向代理即可（配置文件） Docker（yum安装） 1.检测CentOS 7 [root@localhost ~] cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) 2.安装我们的准备环境 yum -y install 包名 #yum install 安装命令 -y 所有的提示都为y yum -y install gcc yum -y install gcc-c++ 3.卸载以前的docker yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 4.下载环境 yum install -y yum-utils \\device-mapper-persistent-data \\lvm2 5.使用国内阿里云镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.更新yum软件包安装 yum makecache fast 7.安装docker ce yum -y install docker-ce docker-ce-Cli containerd.io 8.启动docker systemctl start docker 9.测试 docker version docker run hello-world docker images 图 运行效果 ","link":"https://ganhan999.github.io/post/Java Linux/"},{"title":"中等73. 矩阵置零","content":"题目 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 输入: [ [1,1,1], [1,0,1], [1,1,1] ] 输出: [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2: 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 我们扫描一遍原始矩阵，找到所有为零的元素。 如果我们找到 [i, j] 的元素值为零，我们需要记录下行号 i 和列号 j。 用两个 sets ，一个记录行信息一个记录列信息。 最后，我们迭代原始矩阵，对于每个格子检查行 r 和列 c 是否被标记过，如果是就将矩阵格子的值设为 0。 时间复杂度：O(M×N)，其中 M 和 N 分别对应行数和列数。 空间复杂度：O(M+N)。 大神做法1： class Solution(object): def setZeroes(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; R = len(matrix) C = len(matrix[0]) rows, cols = set(), set() # Essentially, we mark the rows and columns that are to be made zero for i in range(R): for j in range(C): if matrix[i][j] == 0: rows.add(i) cols.add(j) # Iterate over the array once again and using the rows and cols sets, update the elements for i in range(R): for j in range(C): if i in rows or j in cols: matrix[i][j] = 0 &quot;&quot;&quot;&quot;&quot;&quot; 遍历原始矩阵，如果发现如果某个元素 cell[i][j] 为 0，我们将第 i 行和第 j 列的所有非零元素设成很大的负虚拟值（比如说 -1000000）。注意，正确的虚拟值取值依赖于问题的约束，任何允许值范围外的数字都可以作为虚拟之。 最后，我们便利整个矩阵将所有等于虚拟值（常量在代码中初始化为 MODIFIED）的元素设为 0。 大神做法2： class Solution(object): def setZeroes(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; MODIFIED = -1000000 R = len(matrix) C = len(matrix[0]) for r in range(R): for c in range(C): if matrix[r][c] == 0: # We modify the elements in place. Note, we only change the non zeros to MODIFIED for k in range(C): matrix[r][k] = MODIFIED if matrix[r][k] != 0 else 0 for k in range(R): matrix[k][c] = MODIFIED if matrix[k][c] != 0 else 0 for r in range(R): for c in range(C): # Make a second pass and change all MODIFIED elements to 0 &quot;&quot;&quot; if matrix[r][c] == MODIFIED: matrix[r][c] = 0 &quot;&quot;&quot;&quot;&quot;&quot; 遍历整个矩阵，如果 cell[i][j] == 0 就将第 i 行和第 j 列的第一个元素标记。 第一行和第一列的标记是相同的，都是 cell[0][0]，所以需要一个额外的变量告知第一列是否被标记， 同时用 cell[0][0] 继续表示第一行的标记。 然后，从第二行第二列的元素开始遍历，如果第 r 行或者第 c 列被标记了，那么就将 cell[r][c] 设为 0。 这里第一行和第一列的作用就相当于方法一中的 row_set 和 column_set 。 然后我们检查是否 cell[0][0] == 0 ，如果是则赋值第一行的元素为零。 然后检查第一列是否被标记，如果是则赋值第一列的元素为零。 大神做法3： class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: row = len(matrix) col = len(matrix[0]) row0_flag = False col0_flag = False # 找第一行是否有0 for j in range(col): if matrix[0][j] == 0: row0_flag = True break # 第一列是否有0 for i in range(row): if matrix[i][0] == 0: col0_flag = True break # 把第一行或者第一列作为 标志位 for i in range(1, row): for j in range(1, col): if matrix[i][j] == 0: matrix[i][0] = matrix[0][j] = 0 #print(matrix) # 置0 for i in range(1, row): for j in range(1, col): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if row0_flag: for j in range(col): matrix[0][j] = 0 if col0_flag: for i in range(row): matrix[i][0] = 0 ","link":"https://ganhan999.github.io/post/73、矩阵置零/"},{"title":"中等64. 最小路径和","content":"题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 动态规划，先把最上边和最左边的最短路径算出来，因为最上和最左只有唯一的路径可以走。 大神做法1： class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: if not grid or not grid[0]: return 0 rows, columns = len(grid), len(grid[0]) dp = [[0] * columns for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, columns): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, rows): for j in range(1, columns): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][columns - 1] ","link":"https://ganhan999.github.io/post/64、最小路径和/"},{"title":"Java SpringCloud","content":"学习前言 1.1 学习前提 熟练使用SpringBoot 微服务快速开发框架 了解过Dubbo + Zookeeper 分布式基础 电脑配置内存不低于8G(我自己的是16G) 给大家看下多个服务跑起来后的内存开销图： 1.2 文章大纲 Spring Cloud 五大组件 服务注册与发现——Netflix Eureka 负载均衡： 客户端负载均衡——Netflix Ribbon 服务端负载均衡：——Feign(其也是依赖于Ribbon，只是将调用方式RestTemplete 更改成Service 接口) 断路器——Netflix Hystrix 服务网关——Netflix Zuul 分布式配置——Spring Cloud Config 1.3 常见面试题 1.1 什么是微服务？ 1.2 微服务之间是如何独立通讯的？ 1.3 SpringCloud 和 Dubbo有那些区别？ 1.4 SpringBoot 和 SpringCloud，请谈谈你对他们的理解 1.5 什么是服务熔断？什么是服务降级？ 1.6 微服务的优缺点分别是什么？说下你在项目开发中遇到的坑 1.7 你所知道的微服务技术栈有哪些？列举一二 1.8 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别 … 2. 微服务概述 2.1 什么是微服务？ 什么是微服务？ 微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 2.2 微服务与微服务架构 微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 2.3 微服务优缺点 优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 2.4 微服务技术栈有那些？ 微服务技术条目 落地技术 服务开发 SpringBoot、Spring、SpringMVC等 服务配置与管理 Netfix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、PRC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用(客户端调用服务的简化工具) Fegin等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix、Nagios、Metrics、Specatator等 全链路追踪 Zipkin、Brave、Dapper等 数据流操作开发包 SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息) 时间消息总栈 SpringCloud Bus 服务部署 Docker、OpenStack、Kubernetes等 2.5 为什么选择SpringCloud作为微服务架构 选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX … 各微服务框架对比 功能点/服务框架 Netflix/SpringCloud Motan gRPC Thri t Dubbo/DubboX 功能定位 完整的微服务框架 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现 RPC框架 RPC框架 服务框架 支持Rest 是，Ribbon支持多种可拔插的序列号选择 否 否 否 否 支持RPC 否 是(Hession2) 是 是 是 支持多语言 是(Rest形式) 否 是 是 否 负载均衡 是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是(客户端) 否 否 是(客户端) 配置服务 Netfix Archaius，Spring Cloud Config Server 集中配置 是(Zookeeper提供) 否 否 否 服务调用链监控 是(zuul)，zuul提供边缘服务，API网关 否 否 否 否 高可用/容错 是(服务端Hystrix+客户端Ribbon) 是(客户端) 否 否 是(客户端) 典型应用案例 Netflix Sina Google Facebook 社区活跃程度 高 一般 高 一般 2017年后重新开始维护，之前中断了5年 学习难度 中等 低 高 高 低 文档丰富程度 高 一般 一般 一般 高 其他 Spring Cloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部在开发集成gRPC IDL定义 实践的公司比较多 3. SpringCloud入门概述 3.1 SpringCloud是什么？ Spring官网：https://spring.io/ 3.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 3.3 Dubbo 和 SpringCloud技术选型 1. 分布式+服务治理Dubbo 目前成熟的互联网架构，应用服务化拆分 + 消息中间件 2. Dubbo 和 SpringCloud对比 可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： Dubbo SpringCloud 服务注册中心 Zookeeper Spring Cloud Netfilx Eureka 服务调用方式 RPC REST API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netfilx Hystrix 服务网关 无 Spring Cloud Netfilx Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总栈 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task 最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。 品牌机和组装机的区别 社区支持与更新力度的区别 **总结：**二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 3.4 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … 3.5 SpringCloud下载 官网：http://projects.spring.io/spring-cloud/ 版本号有点特别： SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc 4. SpringCloud Rest学习环境搭建：服务提供者 4.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ...... 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 4.2 SpringCloud版本选择 大版本说明 SpringBoot SpringCloud 关系 1.2.x Angel版本(天使) 兼容SpringBoot1.2x 1.3.x Brixton版本(布里克斯顿) 兼容SpringBoot1.3x，也兼容SpringBoot1.4x 1.4.x Camden版本(卡姆登) 兼容SpringBoot1.4x，也兼容SpringBoot1.5x 1.5.x Dalston版本(多尔斯顿) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 1.5.x Edgware版本(埃奇韦尔) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 2.0.x Finchley版本(芬奇利) 兼容SpringBoot2.0x，不兼容SpringBoot1.5x 2.1.x Greenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parent spring-cloud-dependencles 版本号 发布日期 版本号 发布日期 1.5.2.RELEASE 2017-03 Dalston.RC1 2017-x 1.5.9.RELEASE 2017-11 Edgware.RELEASE 2017-11 1.5.16.RELEASE 2018-04 Edgware.SR5 2018-10 1.5.20.RELEASE 2018-09 Edgware.SR5 2018-10 2.0.2.RELEASE 2018-05 Fomchiey.BULD-SNAPSHOT 2018-x 2.0.6.RELEASE 2018-10 Fomchiey-SR2 2018-10 2.1.4.RELEASE 2019-04 Greenwich.SR1 2019-03 使用后两个 4.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;springcloud-api&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;springcloud-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-eureka-7002&lt;/module&gt; &lt;module&gt;springcloud-eureka-7003&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;springcloud-zuul-9527&lt;/module&gt; &lt;module&gt;springcloud-config-server-3344&lt;/module&gt; &lt;module&gt;springcloud-config-client-3355&lt;/module&gt; &lt;module&gt;springcloud-config-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-config-dept-8001&lt;/module&gt; &lt;/modules&gt; &lt;!--打包方式 pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springCloud的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot 启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志测试~--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 父工程为springcloud，其下有多个子mudule，详情参考完整代码了解 springcloud-consumer-dept-80访问springcloud-provider-dept-8001下的controller使用REST方式 如DeptConsumerController.java /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { /** * 理解：消费者，不应该有service层~ * RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 * (地址：url, 实体：Map ,Class&lt;T&gt; responseType) * &lt;p&gt; * 提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ */ @Autowired private RestTemplate restTemplate; /** * 服务提供方地址前缀 * &lt;p&gt; * Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 */ private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; //private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) { // postForObject(服务提供方地址(接口),参数实体,返回类型.class) return restTemplate.postForObject(REST_URL_PREFIX + &quot;/dept/add&quot;, dept, Boolean.class); } /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/{id}&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) { // getForObject(服务提供方地址(接口),返回类型.class) return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/get/&quot; + id, Dept.class); } /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() { return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/list&quot;, List.class); } } 使用RestTemplete先需要放入Spring容器中 ConfigBean.java @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate // IRule // RoundRobinRule 轮询 // RandomRule 随机 // AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ // RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } } springcloud-provider-dept-8001的dao接口调用springcloud-api模块下的pojo，可使用在springcloud-provider-dept-8001的pom文件导入springcloud-api模块依赖的方式： &lt;!--我们需要拿到实体类，所以要配置api module--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; springcloud-consumer-dept-80和springcloud-provider-dept-8001的pom.xml和父工程下的依赖基本一样，直接看完整代码即可，不再添加重复笔记。 5. Eureka服务注册中心 5.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 5.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 5.3 构建步骤 1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 7001 # Eureka配置 eureka: instance: # Eureka服务端的实例名字 hostname: 127.0.0.1 client: # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) register-with-eureka: false # fetch-registry如果为false,则表示自己为注册中心,客户端的化为 ture fetch-registry: false # Eureka监控页面~ service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 源码中Eureka的默认端口以及访问路径: 主启动类 /** * @Auther: csp1999 * @Date: 2020/05/18/10:26 * @Description: 启动之后，访问 http://127.0.0.1:7001/ */ @SpringBootApplication // @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ @EnableEurekaServer public class EurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7001.class,args); } } 启动成功后访问 http://localhost:7001/ 得到以下页面 2. eureka-client 调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 &lt;!--Eureka依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; application中新增Eureca配置 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ 为主启动类添加@EnableEurekaClient注解 /** * @Auther: csp1999 * @Date: 2020/05/17/22:09 * @Description: 启动类 */ @SpringBootApplication // @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务 @EnableEurekaClient public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } } 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001/ 产看结果如图，成功 修改Eureka上的默认描述信息 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 结果如图： 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制： 配置关于服务加载的监控信息 pom.xml中添加依赖 &lt;!--actuator完善监控信息--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; application.yml中添加配置 # info配置 info: # 项目的名称 app.name: haust-springcloud # 公司的名称 company.name: 河南科技大学西苑校区软件学院 此时刷新监控页，点击进入跳转新页面显示如下内容： 3. EureKa自我保护机制：好死不如赖活着 一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。 该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。 但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：eureka.server.enable-self-preservation=false【不推荐关闭自我保护机制】 详细内容可以参考下这篇博客内容：https://blog.csdn.net/wudiyong22/article/details/80827594 4. 注册进来的微服务，获取一些消息（团队开发会用到） DeptController.java新增方法 /** * DiscoveryClient 可以用来获取一些配置的信息，得到具体的微服务！ */ @Autowired private DiscoveryClient client; /** * 获取一些注册进来的微服务的信息~， * * @return */ @GetMapping(&quot;/dept/discovery&quot;) public Object discovery() { // 获取微服务列表的清单 List&lt;String&gt; services = client.getServices(); System.out.println(&quot;discovery=&gt;services:&quot; + services); // 得到一个具体的微服务信息,通过具体的微服务id，applicaioinName； List&lt;ServiceInstance&gt; instances = client.getInstances(&quot;SPRINGCLOUD-PROVIDER-DEPT&quot;); for (ServiceInstance instance : instances) { System.out.println( instance.getHost() + &quot;\\t&quot; + // 主机名称 instance.getPort() + &quot;\\t&quot; + // 端口号 instance.getUri() + &quot;\\t&quot; + // uri instance.getServiceId() // 服务id ); } return this.client; } 主启动类中加入@EnableDiscoveryClient 注解 @SpringBootApplication // @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务 @EnableEurekaClient // @EnableEurekaClient 开启服务发现客户端的注解，可以用来获取一些配置的信息，得到具体的微服务 @EnableDiscoveryClient public class DeptProvider_8001 { ... } 结果如图： 5.4 Eureka：集群环境配置 1.初始化 新建springcloud-eureka-7002、springcloud-eureka-7003 模块 1.为pom.xml添加依赖 (与springcloud-eureka-7001相同) &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.application.yml配置(与springcloud-eureka-7001相同) server: port: 7003 # Eureka配置 eureka: instance: hostname: localhost # Eureka服务端的实例名字 client: register-with-eureka: false # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false # fetch-registry如果为false,则表示自己为注册中心 service-url: # 监控页面~ # 重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3.主启动类(与springcloud-eureka-7001相同) /** * @Auther: csp1999 * @Date: 2020/05/18/10:26 * @Description: 启动之后，访问 http://127.0.0.1:7003/ */ @SpringBootApplication // @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7003 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7003.class,args); } } 2.集群成员相互关联 配置一些自定义本机名字，找到本机hosts文件并打开 在hosts文件最后加上，要访问的本机名称，默认是localhost 修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002/springcloud-eureka-7003同样分别修改为其对应的名称即可 在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003 完整的springcloud-eureka-7001下的application.yml如下 server: port: 7001 #Eureka配置 eureka: instance: hostname: eureka7001.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7001关联7002、7003 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003 完整的springcloud-eureka-7002下的application.yml如下 server: port: 7002 #Eureka配置 eureka: instance: hostname: eureka7002.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7002关联7001、7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/ springcloud-eureka-7003配置方式同理可得. 通过springcloud-provider-dept-8001下的yml配置文件，修改Eureka配置：配置服务注册中心地址 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 这样模拟集群就搭建号了，就可以把一个项目挂载到三个服务器上了 5.5 对比和Zookeeper区别 1. 回顾CAP原则 RDBMS (MySQL\\Oracle\\sqlServer) ===&gt; ACID NoSQL (Redis\\MongoDB) ===&gt; CAP 2. ACID是什么？ A (Atomicity) 原子性 C (Consistency) 一致性 I (Isolation) 隔离性 D (Durability) 持久性 3. CAP是什么? C (Consistency) 强一致性 A (Availability) 可用性 P (Partition tolerance) 分区容错性 CAP的三进二：CA、AP、CP 4. CAP理论的核心 一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求 根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类 CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP：满足一致性，分区容错的系统，通常性能不是特别高 AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些 5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？ 著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。 Zookeeper 保证的是 CP —&gt; 满足一致性，分区容错的系统，通常性能不是特别高 Eureka 保证的是 AP —&gt; 满足可用性，分区容错的系统，通常可能对一致性要求低一些 Zookeeper保证的是CP 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。 Eureka保证的是AP Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其他节点中 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪 6. Ribbon：负载均衡(基于客户端) 6.1 负载均衡以及Ribbon Ribbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx(反向代理服务器)，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式 LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 6.2 集成Ribbon springcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在application.yml文件中配置Eureka # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 主启动类加上@EnableEurekaClient注解，开启Eureka //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } } 修改conroller：DeptConsumerController.java //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; 123 6.3 使用Ribbon实现负载均衡 流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka7001.com:7002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 再次访问http://localhost/consumer/dept/list这时候随机的是服务提供者8001 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询策略 * RandomRule 随机策略 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @Bean public IRule myRule() { return new RandomRule();//使用随机策略 //return new RoundRobinRule();//使用轮询策略 //return new AvailabilityFilteringRule();//使用轮询策略 //return new RetryRule();//使用轮询策略 } } 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级，要跟启动类所在包同级： MyRule.java /** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */ @Configuration public class MyRule { @Bean public IRule myRule(){ return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 } } 主启动类开启负载均衡并指定自定义的MyRule配置类 //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则) @RibbonClient(name = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,configuration = MyRule.class)//开启负载均衡,并指定自定义的规则 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java public class MyRandomRule extends AbstractLoadBalancerRule { /** * 每个服务访问5次则换下一个服务(总共3个服务) * &lt;p&gt; * total=0,默认=0,如果=5,指向下一个服务节点 * index=0,默认=0,如果total=5,index+1 */ private int total = 0;//被调用的次数 private int currentIndex = 0;//当前是谁在提供服务 //@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;) public Server choose(ILoadBalancer lb, Object key) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread.interrupted()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers();//获得当前活着的服务 List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务 int serverCount = allList.size(); if (serverCount == 0) { /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; } //int index = chooseRandomInt(serverCount);//生成区间随机数 //server = upList.get(index);//从或活着的服务中,随机获取一个 //=====================自定义代码========================= if (total &lt; 5) { server = upList.get(currentIndex); total++; } else { total = 0; currentIndex++; if (currentIndex &gt; upList.size()) { currentIndex = 0; } server = upList.get(currentIndex);//从活着的服务中,获取指定的服务来进行操作 } //====================================================== if (server == null) { /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; } if (server.isAlive()) { return (server); } // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); } return server; } protected int chooseRandomInt(int serverCount) { return ThreadLocalRandom.current().nextInt(serverCount); } @Override public Server choose(Object key) { return choose(getLoadBalancer(), key); } @Override public void initWithNiwsConfig(IClientConfig clientConfig) { // TODO Auto-generated method stub } } 7.Feign：负载均衡(基于服务端) 7.1 Feign简介 Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 7.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 通过Ribbon实现：—原来的controller：DeptConsumerController.java /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { /** * 理解：消费者，不应该有service层~ * RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 * (地址：url, 实体：Map ,Class&lt;T&gt; responseType) * &lt;p&gt; * 提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ */ @Autowired private RestTemplate restTemplate; /** * 服务提供方地址前缀 * &lt;p&gt; * Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 */ // private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) { // postForObject(服务提供方地址(接口),参数实体,返回类型.class) return restTemplate.postForObject(REST_URL_PREFIX + &quot;/dept/add&quot;, dept, Boolean.class); } /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/{id}&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) { // getForObject(服务提供方地址(接口),返回类型.class) return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/get/&quot; + id, Dept.class); } /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() { return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/list&quot;, List.class); } } 通过Feign实现：—改造后controller：DeptConsumerController.java /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) { return deptClientService.addDept(dept); } /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/{id}&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) { return deptClientService.queryById(id); } /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() { return deptClientService.queryAll(); } } Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽，而且Feign调用方式更符合我们之前在做SSM或者SprngBoot项目时，Controller层调用Service层的编程习惯！ 主配置类： /** * @Auther: csp1999 * @Date: 2020/05/17/22:47 * @Description: */ @SpringBootApplication @EnableEurekaClient // feign客户端注解,并指定要扫描的包以及配置接口DeptClientService @EnableFeignClients(basePackages = {&quot;com.haust.springcloud&quot;}) // 切记不要加这个注解，不然会出现404访问不到 //@ComponentScan(&quot;com.haust.springcloud&quot;) public class FeignDeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(FeignDeptConsumer_80.class, args); } } 改造springcloud-api模块 pom.xml添加feign依赖 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 新建service包，并新建DeptClientService.java接口， // @FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;) public interface DeptClientService { @GetMapping(&quot;/dept/get/{id}&quot;) public Dept queryById(@PathVariable(&quot;id&quot;) Long id); @GetMapping(&quot;/dept/list&quot;) public Dept queryAll(); @GetMapping(&quot;/dept/add&quot;) public Dept addDept(Dept dept); } 7.3 Feign和Ribbon如何选择？ 根据个人习惯而定，如果喜欢REST风格使用Ribbon；如果喜欢社区版的面向接口风格使用Feign. Feign 本质上也是实现了 Ribbon，只不过后者是在调用方式上，为了满足一些开发者习惯的接口调用习惯！ 下面我们关闭springcloud-consumer-dept-80 这个服务消费方，换用springcloud-consumer-dept-feign(端口还是80) 来代替：(依然可以正常访问，就是调用方式相比于Ribbon变化了) 8. Hystrix：服务熔断 分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败！ 8.1 服务雪崩 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以达到单个依赖关系的失败而不影响整个应用程序或系统运行。 我们需要，弃车保帅！ 8.2 什么是Hystrix？ Hystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，向调用方返回一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 8.3 Hystrix能干嘛？ 服务降级 服务熔断 服务限流 接近实时的监控 … 当一切正常时，请求流可以如下所示： 当许多后端系统中有一个潜在阻塞服务时，它可以阻止整个用户请求： 随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。 应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。 当使用Hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应： 官网资料：https://github.com/Netflix/Hystrix/wiki 8.4 服务熔断 什么是服务熔断? 熔断机制是赌赢雪崩效应的一种微服务链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：@HystrixCommand。 服务熔断解决如下问题： 当所依赖的对象不稳定时，能够起到快速失败的目的； 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。 入门案例 新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept–8001内的pom.xml、resource和Java代码进行初始化并调整。 导入hystrix依赖 &lt;!--导入Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 调整yml配置文件 server: port: 8001 # mybatis配置 mybatis: # springcloud-api 模块下的pojo包 type-aliases-package: com.haust.springcloud.pojo # 本模块下的mybatis-config.xml核心配置文件类路径 config-location: classpath:mybatis/mybatis-config.xml # 本模块下的mapper配置文件类路径 mapper-locations: classpath:mybatis/mapper/*.xml # spring配置 spring: application: #项目名 name: springcloud-provider-dept datasource: # 德鲁伊数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-hystrix-8001 #修改Eureka上的默认描述信息 prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost #info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 prefer-ip-address: false: prefer-ip-address: true： 修改controller /** * @Auther: csp1999 * @Date: 2020/05/17/22:06 * @Description: 提供Restful服务 */ @RestController public class DeptController { @Autowired private DeptService deptService; /** * 根据id查询部门信息 * 如果根据id查询出现异常,则走hystrixGet这段备选代码 * @param id * @return */ @HystrixCommand(fallbackMethod = &quot;hystrixGet&quot;) @RequestMapping(&quot;/dept/get/{id}&quot;)//根据id查询 public Dept get(@PathVariable(&quot;id&quot;) Long id){ Dept dept = deptService.queryById(id); if (dept==null){ throw new RuntimeException(&quot;这个id=&gt;&quot;+id+&quot;,不存在该用户，或信息无法找到~&quot;); } return dept; } /** * 根据id查询备选方案(熔断) * @param id * @return */ public Dept hystrixGet(@PathVariable(&quot;id&quot;) Long id){ return new Dept().setDeptno(id) .setDname(&quot;这个id=&gt;&quot;+id+&quot;,没有对应的信息,null---@Hystrix~&quot;) .setDb_source(&quot;在MySQL中没有这个数据库&quot;); } } 为主启动类添加对熔断的支持注解@EnableCircuitBreaker /** * @Auther: csp1999 * @Date: 2020/05/17/22:09 * @Description: 启动类 */ @SpringBootApplication @EnableEurekaClient // EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 @EnableDiscoveryClient // 服务发现~ @EnableCircuitBreaker // 添加对熔断的支持注解 public class HystrixDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(HystrixDeptProvider_8001.class,args); } } 测试： 使用熔断后，当访问一个不存在的id时，前台页展示数据如下: 而不适用熔断的springcloud-provider-dept–8001模块访问相同地址会出现下面状况: 因此，为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的 8.5 服务降级 什么是服务降级? 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理，或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。 资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。 由上图可得，当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级。 服务降级需要考虑的问题 1）那些服务是核心服务，哪些服务是非核心服务 2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么 3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？ 自动降级分类 1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况 2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况 3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据） 4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。 入门案例 在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java /** * @Auther: csp1999 * @Date: 2020/05/20/9:18 * @Description: Hystrix服务降级 ~ */ @Component public class DeptClientServiceFallBackFactory implements FallbackFactory { @Override public DeptClientService create(Throwable cause) { return new DeptClientService() { @Override public Dept queryById(Long id) { return new Dept() .setDeptno(id) .setDname(&quot;id=&gt;&quot; + id + &quot;没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭&quot;) .setDb_source(&quot;没有数据~&quot;); } @Override public List&lt;Dept&gt; queryAll() { return null; } @Override public Boolean addDept(Dept dept) { return false; } }; } } 在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory @Component //注册到spring容器中 //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,fallbackFactory = DeptClientServiceFallBackFactory.class)//fallbackFactory指定降级配置类 public interface DeptClientService { @GetMapping(&quot;/dept/get/{id}&quot;) public Dept queryById(@PathVariable(&quot;id&quot;) Long id); @GetMapping(&quot;/dept/list&quot;) public List&lt;Dept&gt; queryAll(); @GetMapping(&quot;/dept/add&quot;) public Boolean addDept(Dept dept); } 在springcloud-consumer-dept-feign模块中开启降级： server: port: 80 # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ # 开启降级feign.hystrix feign: hystrix: enabled: true 8.6 服务熔断和降级的区别 服务熔断—&gt;服务端：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断) 服务降级—&gt;客户端：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始） 实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。 熔断，降级，限流： 限流：限制并发的请求访问量，超过阈值则拒绝； 降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑； 熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复 8.7 Dashboard 流监控 新建springcloud-consumer-hystrix-dashboard模块 添加依赖 &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 主启动类 @SpringBootApplication // 开启Dashboard @EnableHystrixDashboard public class DeptConsumerDashboard_9001 { public static void main(String[] args) { SpringApplication.run(DeptConsumerDashboard_9001.class,args); } } 给springcloud-provider-dept-hystrix-8001模块下的主启动类添加如下代码,添加监控 @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); //访问该页面就是监控页面 registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); return registrationBean; } } 访问：http://localhost:9001/hystrix 进入监控页面： 效果如下图： 9. Zull路由网关 概述 什么是zuul? Zull包含了对请求的路由(用来跳转的)和过滤两个最主要功能： 其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。 注意：Zuul 服务最终还是会注册进 Eureka 提供：代理 + 路由 + 过滤 三大功能！ Zuul 能干嘛？ 路由 过滤 官方文档：https://github.com/Netflix/zuul/ 入门案例 新建springcloud-zuul模块，并导入依赖 &lt;dependencies&gt; &lt;!--导入zuul依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 9527 spring: application: name: springcloud-zuul #微服务名称 # eureka 注册中心配置 eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: #实例的id instance-id: zuul9527.com prefer-ip-address: true # 显示ip info: app.name: haust.springcloud # 项目名称 company.name: 河南科技大学西苑校区 # 公司名称 # zull 路由网关配置 zuul: # 路由相关配置 # 原来访问路由 eg:http://www.cspStudy.com:9527/springcloud-provider-dept/dept/get/1 # zull路由配置后访问路由 eg:http://www.cspstudy.com:9527/haust/mydept/dept/get/1 routes: mydept.serviceId: springcloud-provider-dept # eureka注册中心的服务提供方路由名称 mydept.path: /mydept/** # 将eureka注册中心的服务提供方路由名称 改为自定义路由名称 # 不能再使用这个路径访问了，*： 忽略,隐藏全部的服务名称~ ignored-services: &quot;*&quot; # 设置公共的前缀 prefix: /haust 主启动类 /** * @Auther: csp1999 * @Date: 2020/05/20/20:53 * @Description: Zull路由网关主启动类 */ @SpringBootApplication @EnableZuulProxy // 开启Zuul public class ZuulApplication_9527 { public static void main(String[] args) { SpringApplication.run(ZuulApplication_9527.class,args); } } 测试： 可以看出Zull路由网关被注册到Eureka注册中心中了！ 上图是没有经过Zull路由网关配置时，服务接口访问的路由，可以看出直接用微服务(服务提供方)名称去访问，这样不安全，不能将微服务名称暴露！ 所以经过Zull路由网关配置后，访问的路由为： 我们看到，微服务名称被替换并隐藏，换成了我们自定义的微服务名称mydept，同时加上了前缀haust，这样就做到了对路由fan访问的加密处理！ 详情参考springcloud中文社区zuul组件 :https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul 10. Spring Cloud Config 分布式配置 Dalston.RELEASE Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。 概述 分布式系统面临的–配置文件问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！ 什么是SpringCloud config分布式配置中心？ spring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。 spring cloud config 分为服务端和客户端两部分。 服务端也称为 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。 spring cloud config 分布式配置中心能干嘛？ 集中式管理配置文件 不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置 将配置信息以REST接口的形式暴露 spring cloud config 分布式配置中心与GitHub整合 由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http / https 访问的形式。 入门案例 服务端 新建springcloud-config-server-3344模块导入pom.xml依赖 &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--config--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置： server: port: 3344 spring: application: name: springcloud-config-server # 连接码云远程仓库 cloud: config: server: git: # 注意是https的而不是ssh uri: https://gitee.com/cao_shi_peng/springcloud-config.git # 通过 config-server可以连接到git，访问其中的资源以及配置~ # 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对 # 或者直接注释掉eureka依赖 这里暂时用不到eureka eureka: client: register-with-eureka: false fetch-registry: false 主启动类 @EnableConfigServer // 开启spring cloud config server服务 @SpringBootApplication public class Config_server_3344 { public static void main(String[] args) { SpringApplication.run(Config_server_3344.class,args); } } 将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库： 定位资源的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri），并使用它来初始化一个迷你SpringApplication。小应用程序的Environment用于枚举属性源并通过JSON端点发布。 HTTP服务具有以下格式的资源： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 其中“应用程序”作为SpringApplication中的spring.config.name注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。 测试访问http://localhost:3344/application-dev.yml 测试访问 http://localhost:3344/application/test/master 测试访问 http://localhost:3344/master/application-dev.yml 如果测试访问不存在的配置则不显示 如：http://localhost:3344/master/application-aaa.yml 客户端 将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库： 新建一个springcloud-config-client-3355模块，并导入依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; resources下创建application.yml和bootstrap.yml配置文件 bootstrap.yml 是系统级别的配置 # 系统级别的配置 spring: cloud: config: name: config-client # 需要从git上读取的资源名称，不要后缀 profile: dev label: master uri: http://localhost:3344 application.yml 是用户级别的配置 # 用户级别的配置 spring: application: name: springcloud-config-client 创建controller包下的ConfigClientController.java 用于测试 @RestController public class ConfigClientController { @Value(&quot;${spring.application.name}&quot;) private String applicationName; //获取微服务名称 @Value(&quot;${eureka.client.service-url.defaultZone}&quot;) private String eurekaServer; //获取Eureka服务 @Value(&quot;${server.port}&quot;) private String port; //获取服务端的端口号 @RequestMapping(&quot;/config&quot;) public String getConfig(){ return &quot;applicationName:&quot;+applicationName + &quot;eurekaServer:&quot;+eurekaServer + &quot;port:&quot;+port; } } 主启动类 @SpringBootApplication public class ConfigClient { public static void main(String[] args) { SpringApplication.run(ConfigClient.class,args); } } 测试： 启动服务端Config_server_3344 再启动客户端ConfigClient 访问：http://localhost:8201/config/ 小案例 本地新建config-dept.yml和config-eureka.yml并提交到码云仓库 这里配置文件内容不再列举直接到代码中看把。 新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。 1.清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置 spring: cloud: config: name: config-eureka # 仓库中的配置文件名称 label: master profile: dev uri: http://localhost:3344 2.在pom.xml中添加spring cloud config依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.主启动类 @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class ConfigEurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(ConfigEurekaServer_7001.class,args); } } 4.测试 第一步：启动 Config_Server_3344，并访问 http://localhost:3344/master/config-eureka-dev.yml 测试 第二部：启动ConfigEurekaServer_7001，访问 http://localhost:7001/ 测试 显示上图则成功 新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容 同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置 spring: cloud: config: name: config-dept label: master profile: dev uri: http://localhost:3344 主启动类 @SpringBootApplication @EnableEurekaClient //在服务启动后自动注册到Eureka中！ @EnableDiscoveryClient //服务发现~ @EnableCircuitBreaker // public class ConfigDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(ConfigDeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); return registrationBean; } } ","link":"https://ganhan999.github.io/post/Java SpringCloud/"},{"title":"中等63. 不同路径 II","content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例1： 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释： 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例2： 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 动态规划，每一个格子都是左边或者上面格子的总和，如果遇到障碍物，那么就默认设置为0，只有另外一个方向可以走了。 大神做法1： class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: #新建矩阵版 height, width = len(obstacleGrid),len(obstacleGrid[0]) store = [[0]*width for i in range(height)] #从上到下，从左到右 for m in range(height):#每一行 for n in range(width):#每一列 if not obstacleGrid[m][n]: #如果这一格没有障碍物,如果有那么就把它默认为0 if m == n == 0: #或if not(m or n) store[m][n] = 1 else: a = store[m-1][n] if m!=0 else 0 #上方格子 b = store[m][n-1] if n!=0 else 0 #左方格子 store[m][n] = a+b return store[-1][-1] ","link":"https://ganhan999.github.io/post/63、不同路径 II/"},{"title":"中等62. 不同路径","content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 动态规划，每一个格子都是左边或者上面格子的总和，边界条件都是1，一维和二维数组的空间利用率不同 大神做法1： class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)] print(f) for i in range(1, m): for j in range(1, n): f[i][j] = f[i - 1][j] + f[i][j - 1] return f[m - 1][n - 1] class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: # 一维dp dp = [1] * n for i in range(1, m): for j in range(1, n): dp[j] += dp[j - 1]#dp[j - 1]左边的数值，dp[j]上一层的数值 return dp[-1] &quot;&quot;&quot;&quot;&quot;&quot; 排列组合，数学公式 大神做法2： class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: return comb(m + n - 2, n - 1) ","link":"https://ganhan999.github.io/post/62、不同路径/"},{"title":"中等61. 旋转链表","content":"题目 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 解释: 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4 输出: 2-&gt;0-&gt;1-&gt;NULL 解释: 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 遍历有多少节点的同时，形成一个环，之后(n - k % n - 1)个节点就是新的尾节点，(n - k % n)是新的头节点，再遍历断环。 大神做法1： class Solution: def rotateRight(self, head: 'ListNode', k: 'int') -&gt; 'ListNode': # base cases if not head: return None if not head.next: return head # close the linked list into the ring old_tail = head n = 1 while old_tail.next: old_tail = old_tail.next n += 1 old_tail.next = head#这里就形成一个环 # find new tail : (n - k % n - 1)th node # and new head : (n - k % n)th node new_tail = head for i in range(n - k % n - 1): new_tail = new_tail.next new_head = new_tail.next # break the ring new_tail.next = None#断环 return new_head &quot;&quot;&quot;&quot;&quot;&quot; 快慢指针，这样就只需要遍历一次 大神做法2： class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if not head or not head.next or not k: return head tmp, count= head, 0 while tmp: tmp = tmp.next count += 1 k = k % count if k == 0: return head fast = slow = head for i in range(k): fast = fast.next while fast.next: fast = fast.next slow = slow.next newHead = slow.next slow.next = None fast.next = head return newHead ","link":"https://ganhan999.github.io/post/61、旋转链表/"},{"title":"Idea 小技巧","content":"无处不在的跳转 项目的跳转 ctrl+Alt+[ 或 ] 文件的跳转 ctrl+e 最近的文件 ctrl+shift+e 最近编辑的文件 浏览修改位置的跳转 ctrl+shift+backspace 最新浏览位置的修改 ctrl+shift+左箭头（win10会改变屏幕方向） 使用书签进行跳转 标记书签 ctrl+shift+数字或字母 跳转书签 ctrl+数字或者字母 总览书签 shift+F11 插件emacs 在同一屏幕内支持跳转到任何字母 需要自己设置快捷键 使用方法是点下快捷键后 在点下相应的字母 快速寻找功能快捷键——ctrl+shift+A 精准搜索 定位类 ctrl+n 定位文件 ctrl + shift +n 定位函数或者属性 ctrl + shift + alt +n 字符串 ctrl + shift + f 按两次可以实现在全部文件搜索（非本项目） 列操作 选中文件中相同的所有 ctrl + shift + alt + A 移动光标到下一个词的词头或返回上一个词头 ctrl + —&gt; ctrl + &lt;— 从光标处选中到下一个词头 ctrl + shift + —&gt; ctrl + shift + &lt;— 大小写转换 ctrl + shift + U 移动到行头或行尾（选中的话就是加shift） home、end 移动到文件头或尾（选中的话就是加shift） ctrl + home ctrl + end Live Template live template就是一个代码模板，可以自定义模板实现快速编写代码。 操作步骤： \\1. ctrl+shift+A 搜索 Live Template 选择Settings 打开如下窗口： \\2. 点击+号可以新建group 和新建template \\3. 具体使用的时候，输入psfi 回车就会自动生成这个模板。 Postfix Postfix有点类似Live Template，也可以理解成是一个快速编写代码的模板。 但是Postfix不可以自定义，修改。 for循环 == 100.fori 创建field属性 == name.filed if(user!=null){} == user.nn 其他的可以在ctrl+shift+A 搜索 postfix 选择Settings 中具体查看。 alt + enter 智能提示，修补，重构代码，类似Eclipse里面的ctrl + / 重构和抽取 重构参数名称：shfit + F6，实现批量修改 重构方法参数：ctrl + F6 或 alt + enter 抽取这部分都是 ctrl + alt + XXX 抽取方法内变量：ctrl + alt + v 抽取静态变量：ctrl + alt + c 抽取为成员变量：ctrl + alt + f 抽取为方法参数：ctrl + alt + p 抽取为方法：ctrl + alt + m Git 集成 在看不懂的代码前右击，选中annotate，可以找到代码的所有者，更进一步点击，还可以找到该作者的修改记录。 遍历修改记录：Ctrl+Alt+Shift+上下箭头（牛逼的快捷键） Revert：Ctrl+Alt+Z 没装版本控制软件时，IDEA也有一个本地的local history Ctrl + shfit + A 搜索 local history —— show History 即可 还可以把多次修改 设置成一个label 便于集中管理 关联Spring 和 数据库 关联Spring 我们用IDEA开发WEB项目时，会用到Spring，但是依赖注入的时候，都是用接口接收。 如果实现类很多，自动注入的是哪一个实现类不清楚。 xml配置文件中，通过包扫描bean注解实现管理bean，我们扫描到了多少也不清楚。 IDEA提供了一个关联的功能，把Spring类与类，包与类之间进行了关联。 ctrl+shift+A 搜索 Project Structure 添加Spring关联后，下面会自动搜索出Spring的配置文件，关联即可。 关联数据库 关联数据库的好处： 1、写mybatis的sqlmap时，IDEA会自动提示表中的字段名和表名，防止写错 2、可以重构表明 字段名 ，批量修改 shfit + F6即可 调试程序 添加删除断点：ctrl + F8 Debug运行：shfit + F9 Step into ： F7 Step over：F8 Resume(运行到下个断点) ：F9 运行到光标处：Alt + F9 查看所有断点： ctrl + shfit + F8 禁止所有断点（直接运行到结束）：mute breakpoints 在下面的窗口处 条件断点：Ctrl + shift + F8 （满足某个条件时，断点生效，用的java语言表达式） 查看某个表达式的值：Alt + F8 表达式求值：在上一个基础上，可以list.get(0) 查看结果中的一个值 还可以修改表达式的值，让他继续运行（SetValue）：在debug的结果窗口，某个变量上按F2，就可以修改值。 运行（单元测试 main函数等） 在光标所在位置，按ctrl+shift+F9，会自动寻找一个最小的可运行的上下文。 比如： 光标在test单元测试中，那么就会运行这个单元测试 如果光标在一个类中，不在main函数中，那么就会运行main函数 如果光标在单元测试类中，那么就运行这个类中的所有单元测试 其他操作 文件操作 在当前目录下新建文件 ctrl + shfit + N 复制文件到当前目录：F5 移动文件到新文件夹：F6 文本操作 ctrl + c 复制文件名 ctrl + shift + c 复制完整路径 ctrl + shift + v ：查看剪贴板上历史复制的记录 结构图(看源码时很好用) ctrl + F12 ：查看类中有什么方法，属性 ctrl + alt + shift + u ：查看当前文件的类实现了什么接口，继承了什么类 ；还可以生成maven pom文件的结构图 ctrl + alt + u ：生成光标所在的文字的类实现了什么接口，继承了什么类，小窗口显示 ctrl + h ：查看类的继承关系 ctrl + alt + h ：查看方法的调用关系图 Ctrl+Shift+Alt+L : 格式化代码 ","link":"https://ganhan999.github.io/post/Idea 小技巧/"},{"title":"Java SpringBoot","content":"1、SpringBoot 回顾什么是Spring Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 Spring是如何简化Java开发的 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot 学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 真的很爽，我们快速去体验开发个接口的感觉吧！ 2、第一个SpringBoot程序 环境准备 jdk1.8 Maven 3.6.3 Springboot:最新版 IDEA 官方提供了一个快速生成的网站，IDEA集成了这个网站 项目创建方式一 使用Spring Initializr 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二 使用 IDEA 直接创建项目 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml pom.xml 分析 打开pom.xml，看看Spring Boot项目的依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.codekitty&lt;/groupId&gt; &lt;artifactId&gt;springboot-study&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-study&lt;/name&gt; &lt;description&gt;study project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 打包插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 启动Banner修改 在resource下建立banner.txt,放入想要的Banner图即可，Banner可以直接百度搜索springboot banner 3、原理初探 自动配置： pom.xml Spring-boot-dependencies:核心依赖在父工程中 我们在写或者引入springboot依赖的时候，不需要指定版本，因为有这些版本仓库 启动器 &lt;!--启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 启动器：说白了就是Springboot的启动场景 比如spring-boot-starter-web，他就会帮我们自动导入web环境所有的依赖 springboot会将所有的功能场景，都变成一个个的启动器 我们要使用什么功能，就值需要找到对应的启动器starter 主程序 //标注这个类是一个springboot的应用 @SpringBootApplication public class SpringbootStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringbootStudyApplication.class, args); } } 注解 //springboot的配置 @SpringBootConfiguration //spring配置类 @Configuration //说明这也是一个spring的组件 @Component //自动配置 @EnableAutoConfiguration //自动配置包 @AutoConfigurationPackage //自动配置 @Import(AutoConfigurationPackages.Registrar.class) //自动配置导入选择 @Import(AutoConfigurationImportSelector.class) //获取所有的配置 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); 获取候选的配置 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } META-INF/spring.factories. Springboot所有自动配置都是在启动的时候扫描并加载：spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的strater，就有了对应的启动器，有了启动器，我们自动装配就会生效，然后配置成功 springboot在启动的时候，从类路径下 /META-INF/spring.factories.获取指定的值； 将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置 以前我们需要手动配置的东西，现在Springboot帮我们做了 整合javaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure包下 它会把所有需要导入的组件，以类名的方式返回，这些组件就会添加到容器 容器中也会存在XXXXautoConfiguration的文件(@Bean)，就是这些类给容器中导入了这个场景所需要的所有组件,并自动配置，@Configuration,JavaConfig 有了自动配置类，免去了我们自己编写配置文件的步骤 启动原理： 最初以为就是运行了一个main方法，没想到却开启了一个服务； @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { SpringApplication.run(SpringbootApplication.class, args); } } 这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 run方法流程分析 4、Springboot配置文件 SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value server.port=8081 application.yml 语法结构 ：key：空格 value server: port: 8081 application.yml 语法结构 ：key：空格 value server: port: 8081 # 普通的key-value name: 李明 #对象 student: name: jj age: 3 #行内写法 student1: {name: jj,age: 3} #数组 pets: - cat - dog - pig pets1: [cat,dog,pig] yaml可以直接给实体类赋值 在yaml写好配置 person: name: 小红 age: 3 happy: true birth: 2020/7/27 maps: {k1: v1,k2: v2} lists: - code - music dog: name: 旺旺 age: 3 在实体类上加上注解 @ConfigurationProperties(prefix = &quot;person&quot;) 在Springboot提供的单元测试类中测试 @Autowired private Person person; @Test void contextLoads() { System.out.println(person); } 注意：注解的prefix值要和配置文件中的属性名相同 yaml的松散绑定 比如我的yaml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。 结论： 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ JSR303数据校验 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 使用 在实体类上增加@Validated注解 在实体属性上增加以下注解即可实现相应的校验,在注解内加入message属性可以指定校验未通过时的提示信息 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) Validates that the annotated string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 @Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。 数值检查 建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为”“,Integer为null @Min 验证 Number 和 String 对象是否大等于指定的值 @Max 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min=, max=) 被指定的元素必须在合适的范围内 @Range(min=10000,max=50000,message=”range.bean.wage”) @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang= ,script=, alias=) @URL(protocol=,host=, port=,regexp=, flags=) 数据校验的注解存储在Maven: jakarta.validation:jakarta.validation-api:2.0.2包内[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iC4c9seR-1599793610943)(/Users/mac/Desktop/截屏2020-07-27 上午9.23.59.png)] 可以在多个位置使用配置文件 配置文件的优先级由高到低分别为项目路径下的config/application.yaml&gt;application.yaml&gt;resources/config/application.yaml&gt;resources/application.yaml 默认创建的是优先级最低的resources/application.yaml 多环境切换 yaml多环境切换 用---来分隔多个文件，使用profiles的active来选择调用哪个环境 server: port: 8081 spring: profiles: active: dev --- server: port: 8082 spring: profiles: dev --- server: port: 8083 spring: profiles: test 自动配置的原理！ 1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； **xxxxAutoConfigurartion：自动配置类；**给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 开启debug可以在启动的时候在控制台输出配置 debug: true 5、SpringBoot Web开发 Jar: webapp 自动装配 springboot到底帮我们配置了什么？能不能修改，能修改哪些东西？能不能拓展 xxxxAutoConfigurartion…向容器中自动配置组件 xxxxProperties:自动配置类，装配配置文件中自定义的一些内容 要解决的问题: 导入静态资源… 首页 jsp,模版引擎Thymeleaf 装配扩展SpringMVC 增删改查 拦截器 国际化 静态资源总结： 在springboot，我们 可以使用以下方式处理静态资源 webjarslocalhost:8080/wbjars/ Public, static,/**,resources, localhost:8080 优先级：resources&gt;static&gt;(默认)&gt;public 6、Thymeleaf模版引擎 结论：只要导入对应的maven依赖即可使用 &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示,我们可以去官方文档。 xmlns:th=&quot;http://www.thymeleaf.org&quot; 3、在controller设置接收请求 @GetMapping(&quot;/test&quot;) public String test(Model model){ model.addAttribute(&quot;msg&quot;,&quot;helloSpringboot&quot;); return &quot;test&quot;; } 4、在主入口启动，访问localhost:8080/test即可 注意：在项目新建module是无法访问到，最终找到原因是创建module时没有导入thymeleaf 遍历数组 用th:each遍历，有两种取值方法 &lt;h3 th:each=&quot;user:${users}&quot; th:text=&quot;${user}&quot;&gt;&lt;/h3&gt; &lt;h3 th:each=&quot;user:${users}&quot;&gt;[[${user}}]]&lt;/h3&gt; Thymeleaf语法 Thymeleaf表达式 Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象：#18 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的一些工具对象： #execInfo : information about the template being processed. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. ================================================================================== Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； Fragment Expressions: ~{...}：片段引用表达式 Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 7、装配MVC 官方建议：直接创建一个MVCconfig类，在类上加上@Configuration注解，并且实现WebMvcConfigurer接口，并且不能使用@EnableWebMvc注解 为什么不能使用@EnableWebMvc注解 这个注解导入了一个类：DelegatingWebMvcConfiguration,这个类从容器中获取所有的webmvcconfig 并且在WebMvcAutoConfiguration类中有这样一个注解： @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效 如果加了@EnableWebMVC容器中就有了组件，这个配置就不生效了 如果需要全面接管SpringMVC可以使用该注解，当然在开发中，不推荐使用全面接管SpringMVC 8、进行项目前的准备 准备好数据，在这里用Map模拟数据库中的数据，后期再进行数据库整合 @Repository public class DeptDao { private static Map&lt;Integer, Dept&gt; depts = null; static{ //模拟数据库中的数据 depts = new HashMap&lt;Integer,Dept&gt;();//创建一个部门表 depts.put(101,new Dept(101,&quot;教学部&quot;)); depts.put(102,new Dept(102,&quot;市场部&quot;)); depts.put(103,new Dept(103,&quot;后勤部&quot;)); depts.put(104,new Dept(104,&quot;教研部&quot;)); } //获得所有部门信息 public Collection&lt;Dept&gt; getDept(){ return depts.values(); } public Dept getDept(Integer id){ return depts.get(id); } } 准备好模版（在网上找bootstrap或其他的模版，或者自己写） 页面直接放在templates下，css、img、js等放在static下 修改html页面，使其符合Thymeleaf模版规范 在url路径属性前增加th:并修改url路径为@{}格式（js、css、img等） 9、项目：国际化* 在resources下创建i18n文件夹，并创建login.proterties文件login_zh_CN.proterties文件login_en_US.proterties文件 在内部写入配置 login.password=password login.tip=Please sign in login.username=username #------------------------ login.password=密码 login.tip=请登录 login.username=用户名 #------------------------ login.password=password login.tip=Please sign in login.username=username #------------------------ 在核心配置文件中配置一下属性 spring.messages.basename=i18n.login 在config包内创建类，实现localereslover接口,重写方法,解析请求 //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault();//得到一个默认的，如果没有传入的就使用默认的 System.out.println(&quot;==========&gt;&quot; + language); if(!StringUtils.isEmpty(language)){ String[] s = language.split(&quot;_&quot;); System.out.println(&quot;----------------&quot;); locale = new Locale(s[0], s[1]); } return locale; } 在mvcconfig配置Bean @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } 在页面设置按钮发送请求，并修改页面文字元素为thymeleaf格式 &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(l='zh_CN')}&quot;&gt;中文&lt;/a&gt;| &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(l='en_US')}&quot;&gt;English&lt;/a&gt; 测试运行 10、项目：登陆 + 拦截器 修改页面form的action请求action为th:action 新建controller @Controller public class LoginController { @RequestMapping(&quot;/login&quot;) public String Login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;passWord&quot;) String passWord, Model model, HttpSession session){ if(!StringUtils.isEmpty(userName) &amp;&amp; &quot;12345&quot;.equals(passWord)){ session.setAttribute(&quot;loginUser&quot;,userName); System.out.println(session.getAttribute(&quot;loginUser&quot;)); return &quot;redirect:/main.html&quot;; }else{ model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误&quot;); System.out.println(&quot;444&quot;); return &quot;login&quot;; } } } 注意：在这里将userName存入了session中，取的时候需要通过session.userName来取 11、展示员工页面 首先做页面代码复用工作，取页面公共组件放在一个页面中，每个组件设置一个th:fragment=&quot;&quot;属性，在需要用的页面使用th:insert或者th:replace属性进行复用 &lt;div th:replace=&quot;~{empl/list::top}&quot;&gt;&lt;/div&gt; 定义一个controller类来实现处理请求数据的功能 @Controller public class EmployeeController { @Autowired EmplDao empl; @RequestMapping(&quot;/empl&quot;) public String list(Model model){ Collection&lt;Empl&gt; all = empl.getAll(); model.addAttribute(&quot;emplList&quot;,all); for (Empl empl : all) { System.out.println(empl.toString()); } return &quot;empl/list&quot;; } } 在页面中定义表格，将获取到的数据通过thymeleaf显示出来 &lt;table class=&quot;table table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;deptName&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;emp:${emplList}&quot;&gt; &lt;td th:text=&quot;${emp.getId()}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.getLastName()}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.getEmail()}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.getGender()==0?'女':'男'}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.getDeptName().getDeptName()}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${#dates.format(emp.getBirth())}&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;btn btn-sm btn-primary&quot; &gt;编辑&lt;/button&gt; &lt;button class=&quot;btn btn-sm btn-danger&quot; &gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 本节遇到的问题 点击请求数据时出现500错误，原因是controller没有加@Autowired注解 数据显示时只显示一行，并且是最后一条数据，开始以为是显示的原因，后来向上查找原因发现是使用Map代替数据库时，map的键重复，导致map的put时后面会覆盖前面定义好的，最终只剩一条最后插入的数据（我贼智障） 回顾 SpringBoot是什么 微服务 HelloWorld 探究源码～自动装配原理 配置yaml 多文档环境切换 静态资源映射 Thymeleaf th:xxx SpringBoot 如何扩展MVC javaConfig～ 如何修改SpringBoot的默认配置 CRUD 国际化 拦截器 定制首页，错误页 接下来 JDBC Mybatis Druid Shiro:安全 Spring Security:安全 异步任务～，邮件发送，定时任务 Swagger Dubbo + Zookeeper 12、整合JDBC 新建项目，引入JDBC API、mysql Driver和Spring Web Springboot会自动帮我们导入以下启动器 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 编写yaml配置文件 spring: datasource: username: codekitty password: lihaiyang url: jdbc:mysql://codekitty.cn:3306/study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 可以使用了，进行测试 //DI注入数据源 @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException { //查看一下数据源 System.out.println(dataSource.getClass()); //获得数据库连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); } 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件： @Import( {Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class})protected static class PooledDataSourceConfiguration { protected PooledDataSourceConfiguration() { }} 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀； 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate JDBCTemplate 1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库； 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 JdbcTemplate主要提供以下几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 测试 编写一个controller，注入jdbcTemplate，编写测试方法进行访问测试 @RestController public class JDBCcontroller { @Autowired JdbcTemplate jdbcTemplate; //查询数据库的所有信息 //List中的1个Map对应数据库中的一行数据 //Map中的key对应数据库中的字段名，value对应数据库的字段值 @GetMapping(&quot;/userList&quot;) public List&lt;Map&lt;String,Object&gt;&gt; userList(){ String sql = &quot;select * from User&quot;; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; } //新增一个用户 @GetMapping(&quot;/addUser&quot;) public String addUser(){ String sql = &quot;insert into study.User(id,username,userPassword) values(10,'李华','09876543456')&quot;; jdbcTemplate.update(sql); return &quot;update-ok&quot;; } //修改一个用户 @GetMapping(&quot;/updateUser/{id}&quot;) public String updateUser(@PathVariable(&quot;id&quot;) int id){ //插入语句 String sql = &quot;update study.User set username=?,userPassword=? where id=&quot; + id; //数据 Object[] objects = new Object[2]; objects[0] = &quot;李华2&quot;; objects[1] = &quot;3333333&quot;; jdbcTemplate.update(sql,objects); return &quot;update-ok&quot;; } //删除用户 @GetMapping(&quot;/deleteUser/{id}&quot;) public String deleteUser(@PathVariable(&quot;id&quot;) int id){ String sql = &quot;delete from study.User where id=&quot; + id; jdbcTemplate.update(sql); return &quot;update-ok&quot;; } } 13、整合Druid Druid简介 Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。 Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。 Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 Github地址：https://github.com/alibaba/druid/ 基本配置 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 1、添加上 Druid 数据源依赖。 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; 2、切换数据源；springBoot2.0以上默认使用，但可以通过spring.datasource.type指定数据源 spring: datasource: username: codekitty password: lihaiyang url: jdbc:mysql://codekitty.cn:3306/study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 进行测试 @Configuration public class DruidConfig { @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource(){ return new DruidDataSource(); } @Bean //后台监控功能 //因为SpringBoot内置了Servlet容器，所以没有Web.xml，替代方法：ServletRegistrationBean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); //后台需要有人登陆，账号密码配置 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); //增加配置 map.put(&quot;loginUsername&quot;,&quot;admin&quot;);//登陆的key，是固定的，不能自己定义成其他的 map.put(&quot;loginPassword&quot;,&quot;123456&quot;); //允许谁可以访问 map.put(&quot;allow&quot;,&quot;localhost&quot;); bean.setInitParameters(map);//初始化参数 return bean; } @Bean //filter public FilterRegistrationBean WebStartFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean&lt;&gt;(); //设置过滤器 bean.setFilter(new WebStatFilter()); //可以过滤哪些请求 Map&lt;String,String&gt; filters = new HashMap&lt;&gt;(); //这些东西不进行统计 filters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(filters); return bean; } } 14、整合Mybatis 整合包 mybatis-spring-boot-starter 导入包 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 配置文件 #整合mybatis mybatis: type-aliases-package: com.springbootdatamybatis.pojo mapper-locations: classpath:mybatis/mapper/*.xml mybatis配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.springbootdatamybatis.mapper.UserMapper&quot;&gt; &lt;/mapper&gt; 编写Sql &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt; select * from study.User; &lt;/select&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot;&gt; select * from User where #{id} &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt; insert into User(id,username,userPassword) values(#{id},#{username},#{userPassword}) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update User set username=#{username},userPassword=#{userPassword} where id=#{id} &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from User where id=#{id} &lt;/delete&gt; 业务层调用dao层 controller调用service层(这里直接用controller调用的dao层) @RestController public class UserController { @Autowired private UserMapper userMapper; @GetMapping(&quot;/queryUserList&quot;) public List&lt;User&gt; queryUserList(){ List&lt;User&gt; userList = userMapper.queryUserList(); for (User user : userList) { System.out.println(user); } return userList; } } 15、SpringSecurity（安全） 安全简介 在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 市面上存在比较有名的：Shiro，Spring Security ！ 认证，授权 认识SpringSecurity Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 引入 Spring Security 模块 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 编写基础配置类 package com.kuang.config; @EnableWebSecurity // 开启WebSecurity模式 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { } } 定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { // 定制请求的授权规则 // 首页所有人可以访问 http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); } 测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 在configure()方法中加入以下配置，开启自动配置的登录功能！ // 开启自动配置的登录功能 // &quot;/login&quot; 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin(); 此时如果没有权限就会跳转至登陆页 定义认定规则，重写configure(AuthenticationManagerBuilder auth)方法 //认证 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //数据正常应该从数据库中取，现在从内存中取 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;admin&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;); 这里设置密码加密auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())否则会报There is no PasswordEncoder mapped for the id &quot;null&quot;错误,创建的每个用户也必须添加密码加密**.password(new BCryptPasswordEncoder().encode(&quot;123&quot;))** 测试,发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定 权限控制和注销 注销 开启自动配置的注销的功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //.... //开启自动配置的注销的功能 // /logout 注销请求 http.logout(); } 我们在前端，增加一个注销的按钮，index.html 导航栏中 &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@{/logout}&quot;&gt;注销&lt;/a&gt; 测试发现，点击注销按钮后会跳转到登陆页面，此时想要在注销成功后跳转到指定页面需要在请求后添加.logoutSuccessUrl(&quot;/&quot;); // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页 http.logout().logoutSuccessUrl(&quot;/&quot;); 权限控制 **需求：**用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如admin这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！ 导入maven依赖 &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 导入命名空间 xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot; 修改index页面,增加判断 &lt;div&gt; &lt;!--如果未登录则显示以下内容--&gt; &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@{/toLogin}&quot;&gt;登陆&lt;/a&gt; &lt;/div&gt; &lt;!--如果已登录则显示以下内容--&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; 用户名&lt;p sec:authentication=&quot;name&quot;&gt;&lt;/p&gt; 角色&lt;p sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/p&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@{/logout}&quot;&gt;注销&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--如果用户拥有这个角色，则显示该div内的内容，如果没有则不显示--&gt; &lt;div class=&quot;div&quot; sec:authorize=&quot;hasRole('vip1')&quot;&gt; &lt;a th:href=&quot;@{/level1/1}&quot;&gt;level1-1&lt;/a&gt;&lt;br/&gt; &lt;a th:href=&quot;@{/level1/2}&quot;&gt;level1-2&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;div&quot; sec:authorize=&quot;hasRole('vip2')&quot;&gt; &lt;a th:href=&quot;@{/level2/1}&quot;&gt;level2-1&lt;/a&gt;&lt;br/&gt; &lt;a th:href=&quot;@{/level2/2}&quot;&gt;level2-2&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;div&quot; sec:authorize=&quot;hasRole('vip3')&quot;&gt; &lt;a th:href=&quot;@{/level3/1}&quot;&gt;level3-1&lt;/a&gt;&lt;br/&gt; &lt;a th:href=&quot;@{/level3/2}&quot;&gt;level3-2&lt;/a&gt; &lt;/div&gt; 如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 http.csrf().disable(); 记住我 开启记住我功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //。。。。。。。。。。。 //记住我,保存2周 http.rememberMe(); } 测试，关闭浏览器再次打开用户依旧存在 本质上是保存到cookie，通过浏览器审查元素的application中可以看到 如果使用自己的页面中的按钮，可以给按钮设置name，再在配置后面加上如下方法 http.rememberMe().rememberMeParameter(&quot;remember&quot;); 定制登录页 在配置中设置，用.loginProcessingUrl(&quot;/login&quot;)并将前端form表单的action设置为括号内相同即可，但如果前端用户名和密码前后端不一样，则需要进行设置，括号内的属性为前端页面的name属性 http.formLogin().loginPage(&quot;/toLogin&quot;).usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;).loginProcessingUrl(&quot;/login&quot;); 16、Shiro shiro简介 基本功能点 Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。其基本功能点如下图所示： Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。 Shiro的架构 外部 我们从外部来看 Shiro ，即从应用程序角度的来观察如何使用 Shiro 完成工作。如下图： 可以看到：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject；其每个 API 的含义： Subject：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器； Realm：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 也就是说对于我们而言，最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。 内部 接下来我们来从 Shiro 内部来看下 Shiro 的架构，如下图所示： Subject：主体，可以看到主体可以是任何可以与应用交互的 “用户”； SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm； SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。 shiro组件 身份验证 身份验证，即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来表明他就是他本人，如提供身份证，用户名 / 密码来证明。 在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份： principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名 / 密码 / 手机号。 credentials：证明 / 凭证，即只有主体知道的安全值，如密码 / 数字证书等。 最常见的 principals 和 credentials 组合就是用户名 / 密码了。接下来先进行一个基本的身份认证。 另外两个相关的概念是之前提到的 Subject 及 Realm，分别是主体及验证主体的数据源。 快速开始（helloworld） 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 配置文件（shiro.ini） [users] # user 'root' with password 'secret' and the 'admin' role root = secret, admin # user 'guest' with the password 'guest' and the 'guest' role guest = guest, guest # user 'presidentskroob' with password '12345' (&quot;That's the same combination on # my luggage!!!&quot; ;)), and role 'president' presidentskroob = 12345, president # user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz' darkhelmet = ludicrousspeed, darklord, schwartz # user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz' lonestarr = vespa, goodguy, schwartz [roles] # 'admin' role has all permissions, indicated by the wildcard '*' admin = * # The 'schwartz' role can do anything (*) with any lightsaber: schwartz = lightsaber:* # The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with # license plate 'eagle5' (instance specific id) goodguy = winnebago:drive:eagle5 log4j log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n # General Apache libraries log4j.logger.org.apache=WARN # Spring log4j.logger.org.springframework=WARN # Default Shiro logging log4j.logger.org.apache.shiro=INFO # Disable verbose logging log4j.logger.org.apache.shiro.util.ThreadContext=WARN log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN Quickstart.java import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.session.Session; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * @author lee * @date 2020/8/11 - 6:24 下午 */ public class Quickstart { private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) { Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //获取当前的用户对象 Subject Subject currentUser = SecurityUtils.getSubject(); // 通过当前用户拿到Session Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if (value.equals(&quot;aValue&quot;)) { log.info(&quot;Subject=&gt;session[&quot; + value + &quot;]&quot;); } //判断当前用户是否被认证 if (!currentUser.isAuthenticated()) { //Token： 令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;); token.setRememberMe(true);//设置记住我 try { currentUser.login(token);//执行登陆操作 } catch (UnknownAccountException uae) { log.info(&quot;There is no user with username of &quot; + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;); } catch (LockedAccountException lae) { log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; + &quot;Please contact your administrator to unlock it.&quot;); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { //unexpected condition? error? } } //say who they are: //print their identifying principal (in this case, a username): log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;); //test a role: if (currentUser.hasRole(&quot;schwartz&quot;)) { log.info(&quot;May the Schwartz be with you!&quot;); } else { log.info(&quot;Hello, mere mortal.&quot;); } //test a typed permission (not instance-level) if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) { log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;); } else { log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;); } //a (very powerful) Instance Level permission: if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) { log.info(&quot;You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. &quot; + &quot;Here are the keys - have fun!&quot;); } else { log.info(&quot;Sorry, you aren't allowed to drive the 'eagle5' winnebago!&quot;); } //all done - log out! currentUser.logout(); System.exit(0); } } 以下方法Spring Security都有 Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); currentUser.isAuthenticated() currentUser.getPrincipal() currentUser.hasRole(&quot;schwartz&quot;) currentUser.isPermitted(&quot;lightsaber:wield&quot;) currentUser.logout(); 在SpringBoot中集成Shiro 创建springboot项目，创建时选择导入springboot web和thmyeleaf 编写UserRealm类 //自定义的UserRealm public class UserRealm extends AuthorizingRealm { //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(&quot;执行了=》授权&quot;); return null; } //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(&quot;执行了=》认证&quot;); return null; } } 编写Shiroconfig类(三个方法，从下往上写) @Configuration public class ShiroConfig { //shiroFilterFactoryBean：3 public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager){ ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); return bean; } //DefaultWebSecurityManager：2 @Bean(name=&quot;securityManager&quot;) public DefaultWebSecurityManager getdefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm){ DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; } //创建realm对象：1 @Bean public UserRealm userRealm(){ return new UserRealm(); } } 实现登陆拦截 配置ShiroConfig配置类 //添加shiro的内置过滤器 /* anon:无需认证 authc:必须认证了才能访问 user:必须拥有记住我功能才能用 perms:拥有对某个资源的权限才能访问 role:拥有某个角色权限才能访问 */ Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/add&quot;,&quot;authc&quot;); filterMap.put(&quot;/update&quot;,&quot;authc&quot;); bean.setFilterChainDefinitionMap(filterMap); //如果没有权限就调到登陆页面 bean.setLoginUrl(&quot;/toLogin&quot;); 在controller类实现/toLogin请求 @RequestMapping(&quot;/toLogin&quot;) public String toLogin(){ return &quot;login&quot;; } 实现用户认证 在controller配置请求 @RequestMapping(&quot;/login&quot;) public String login(String username ,String password,Model model){ //获取当前的用户 Subject subject = SecurityUtils.getSubject(); //封装用户的登陆数据 UsernamePasswordToken token = new UsernamePasswordToken(username,password); try { subject.login(token);//执行登陆方法，如果没有异常就说明登陆成功 return &quot;index&quot;; }catch (UnknownAccountException e){//用户名不存在 model.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;); return &quot;login&quot;; }catch (IncorrectCredentialsException e){ model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; } } 在UserRealm类中配置认证 //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { System.out.println(&quot;执行了=》认证&quot;); //用户名密码 数据库取 String name = &quot;root&quot;; String password = &quot;123&quot;; UsernamePasswordToken userToken = (UsernamePasswordToken) token; System.out.println(userToken.toString()); if(!userToken.getUsername().equals(name)){ return null; //抛出异常 UnknownAccountException } return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;); } 用户名验证自己来做，密码验证shiro来做 整合Mybatis 配置properties(yaml),和日志配置 mybatis.type-aliases-package=com.shirospringboot.pojo mybatis.mapper-locations=classpath:mapper/*.xml spring: datasource: username: codekitty password: lihaiyang url: jdbc:mysql://codekitty.cn:3306/study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 编写mapper接口和mapper.xml @Repository @Mapper public interface UserMapper { public User queryUserByName(String name); } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt; &lt;mapper namespace=&quot;com.shirospringboot.mapper.UserMapper&quot;&gt; &lt;!-- 查询语句 id相当与要重写的方法名--&gt; &lt;select id=&quot;queryUserByName&quot; resultType=&quot;User&quot; parameterType=&quot;String&quot;&gt; select * from study.User where username = #{username} &lt;/select&gt; &lt;/mapper&gt; 写service层 public interface UserService { public User queryUserByName(String name); } @Service public class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override public User queryUserByName(String username) { return userMapper.queryUserByName(username); } } 测试项目可以直接调用dao，不写service层，但公司项目一般要求写service层 实现授权 对资源设置权限 //拦截 Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/add&quot;,&quot;perms[user:add]&quot;); filterMap.put(&quot;/update&quot;,&quot;perms[user:update]&quot;); bean.setFilterChainDefinitionMap(filterMap); //未授权就跳转到此请求 bean.setUnauthorizedUrl(&quot;/noauth&quot;); 对登陆用户进行授权,该用户拥有的权限从数据库取得 //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(&quot;执行了=》授权&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //拿到当前登陆的对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User)subject.getPrincipal();//拿到User info.addStringPermission(currentUser.getPerms());//授权 return info; } 整合thymeleaf 导入shiro整合thymeleaf的maven资源 &lt;!-- shiro-thymeleaf整合--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 导入命名空间（不导没有提示，但不影响使用） xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 配置bean @Bean //整合shiroDialect ：用来整合shiro和thymeleaf public ShiroDialect getShiroDialect(){ return new ShiroDialect(); } 实现登陆后只显示有用户权限的页面的链接 &lt;div shiro:hasPermission=&quot;user:add&quot;&gt; &lt;a th:href=&quot;@{/add}&quot;&gt;add&lt;/a&gt; &lt;/div&gt; &lt;div shiro:hasPermission=&quot;user:update&quot;&gt; &lt;a th:href=&quot;@{/update}&quot;&gt;update&lt;/a&gt; &lt;/div&gt; 17、Swagger 接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项 目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接 口文档和实际情况不一致。 很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当 自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢 记于心。 如果接口文档可以实时动态生成就不会出现上面问题。 Swagger 可以完美的解决上面的问题。 Swagger 简介： Swagger 是一套围绕 Open API 规范构建的开源工具，可以帮助设 计，构建，记录和使用 REST API。 Swagger 工具包括的组件： Swagger Editor ：基于浏览器编辑器，可以在里面编写 Open API规范。类似 Markdown 具有实时预览描述文件的功能。 Swagger UI：将 Open API 规范呈现为交互式 API 文档。用可视化UI 展示描述文件。 Swagger Codegen：将 OpenAPI 规范生成为服务器存根和客户端 库。通过 Swagger Codegen 可以将描述文件生成 html 格式和 cwiki 形 式的接口文档，同时也可以生成多种言语的客户端和服务端代码。 Swagger Inspector：和 Swagger UI 有点类似，但是可以返回更多 信息，也会保存请求的实际参数数据。 Swagger Hub：集成了上面所有项目的各个功能，你可以以项目 和版本为单位，将你的描述文件上传到 Swagger Hub 中。在 Swagger Hub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。 使用 Swagger，就是把相关的信息存储在它定义的描述文件里面（yml 或 json 格式），再通过维护这个描述文件可以去更新接口文档， 以及生成各端代码。 Swagger集成 导入maven依赖 &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 创建SwaggerConfig.java @Configuration @EnableSwagger2 //开启Swagger2 public class SwaggerConfig{ } 运行访问http://localhost:8080/swagger-ui.html进行测试 Swagger配置 在SwaggerConfig进行如下配置即可自定义Swagger配置 @Configuration @EnableSwagger2 //开启Swagger2 public class SwaggerConfig{ @Bean public Docket docket(){ return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); } private ApiInfo apiInfo(){ //作者信息 Contact contact = new Contact(&quot;李海洋&quot;, &quot;codekitty.cn:8000&quot;, &quot;L18249290950@126.com&quot;); return new ApiInfo(&quot;codekitty's Swagger API Documentation&quot;, &quot;千里之行，始于足下&quot;, &quot;1.0&quot;, &quot;codekitty.cn:8000&quot;,contact , &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); } } Swagger扫描接口 Docket(DocumentationType.SWAGGER_2).select() new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b)//是否启用Swagger，false则不启用 .select() //RequestHandlerSelectors,配置要扫描接口的方式 //basePackage，指定扫描包 // .apis(RequestHandlerSelectors.any()),扫描全部 // .apis(RequestHandlerSelectors.none()),不扫描 // withMethodAnnotation(GetMapping.class)) //扫描类上的注解 // withClassAnnotation(GetMapping.class)) //扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.controller&quot;)) //Path过滤路径 // .paths(PathSelectors.ant(&quot;/com/**&quot;)) .build(); 实现开发环境中使用Swagger，运行上线环境中不使用Swagger public Docket docket(Environment environment){ //设置要显示的Swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;); //获取项目的环境：判断是否处在自己设定的环境中 boolean flag = environment.acceptsProfiles(profiles); } 在properties中选择使用的环境,将flag传入Enable() 通过groupName(&quot;&quot;)配置多个Docket，(在多人开发中，每个开发者配置一个自己的Swagger，方便管理) @Bean public Docket docket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;); } @Bean public Docket docket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;); } @Bean public Docket docket3(){ return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;); } 实体类配置 @ApiModel(&quot;用户实体类&quot;) public class User { @ApiModelProperty(&quot;用户名&quot;) private String username; @ApiModelProperty(&quot;密码&quot;) private String password; 在Controller进行配置请求 @ApiOperation(&quot;user请求&quot;) //只要接口中返回值存在实体类，它就会被扫描到Swagger中 @PostMapping(value = &quot;/user&quot;) public String user(@ApiParam(&quot;用户名&quot;)String username){ return &quot;hello&quot; + username; } 就可以在Swagger显示实体类的信息，如果属性是private需要加get,set方法 总结： 我们可以通过Swagger给一些比较难理解的属性或接口增加注释信息 接口文档实时更新 可以在线测试 【注意】在正式发布时要关闭Swagger！！！可以保证安全和避免浪费性能 18、任务 异步任务 定义一个Service @Service public class AsyncService { @Async public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;数据正在处理&quot;); } } 定义一个请求,在请求中调用service中的方法 @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello(){ asyncService.hello(); return &quot;OK&quot;; } 在Service的方法中使用@Async,并在主入口上使用@EnableAsync开启异步任务 邮件发送 在properties中配置自己的邮件信息 spring.mail.username=1012074120@qq.com spring.mail.password=jtnhlvabxxqsbbga spring.mail.host=smtp.qq.com #开启加密验证(qq邮箱) spring.mail.properties.mail.smtp.ssl.enable=true 简单邮件发送 直接调用SpringBoot的JavaMailSenderImpl类,使用SimpleMailMessage发送简单邮件 @Autowired JavaMailSenderImpl mailSender; @Test void contextLoads() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(&quot;你好&quot;); simpleMailMessage.setText(&quot;Hello world&quot;); simpleMailMessage.setTo(&quot;L18249290950@126.com&quot;); simpleMailMessage.setFrom(&quot;1012074120@qq.com&quot;); mailSender.send(simpleMailMessage); } 复杂邮件发送 调用mailSender.createMimeMessage()并使用MimeMessageHelper配置邮件内容，发送即可，邮件内容后设置为true可以解析html格式的内容 public void SendMail(Boolean html,String title, String text, File file, String sendTo, String sendFrom) throws MessagingException { //复杂邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); //组装 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage,true); mimeMessageHelper.setSubject(title); mimeMessageHelper.setText(text,true);//true,开启html解析 mimeMessageHelper.addAttachment(&quot;1.jpg&quot;,file); mimeMessageHelper.setTo(sendTo); mimeMessageHelper.setFrom(sendFrom); mailSender.send(mimeMessage); } 定时任务 TaskScheduler //任务调度程序 TaskExecutor //任务执行者 @EnableScheduling //开启定时功能的注解，放在主入口 @Scheduled //什么时候执行 cron表达式 在方法上面加上@Scheduled(cron = &quot;0 43 14 * * ?&quot;)并加上相应的表达式即可 常用表达式例子： （1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? * 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 19、集成Redis Springboot操作数据：spring-data jpa jdbc mongodb redis SpringData 也是和SpringBoot齐名的项目 说明：在SpringBoot2.x之后，原来使用的jedis被替换为乐lettuce jedis：底层采用直连，多线程操作不安全，如果想要避免不安全，使用jedis pool连接池 更像Bio模式 lettuce：底层采用netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数量，更像Nio模式 集成 源码分析 @Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;}//我们可以自己定义一个RedisTamplate来替换这个默认的 ) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { //默认的RedisTemplate没有过多的设置，redis对象都是需要序列化的！ //两个泛型都是&lt;Object,Object&gt;的类型，我们使用需要强制转换成&lt;String,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean //由于String类型时redis中最长使用的类型，所以单独提取出来一个bean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } 导入依赖 &lt;!-- 操作redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置连接 #配置redis spring.redis.host=127.0.0.1 spring.redis.port=6379 测试 @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate; @Test void contextLoads() { //opsForValue 操作字符串 类似String //opsForList 操作List 类似List //opsForSet 操作 //opsForHash //opsForZSet //opsForGeo //opsForHyperLogLog //除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;李明&quot;); System.out.println((String)redisTemplate.opsForValue().get(&quot;mykey&quot;)); } 输出“李明”既为测试成功 后续等学过redis后再记 分布式Dubbo+Zokeeper+SpringBoot 什么是分布式系统？ 在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 什么是RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； Dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 l 服务容器负责启动，加载，运行服务提供者。 l 服务提供者在启动时，向注册中心注册自己提供的服务。 l 服务消费者在启动时，向注册中心订阅自己所需的服务。 l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 安装Dubbo-admin 下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 进行打包（可以是Idea打包，也可以是命令行打包） 使用命令java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 访问localhost:7001即可访问Dubbo-admin页面 实现跨项目访问类 提供者配置文件 #服务应用名字 dubbo.application.name=provider-server #注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 #哪些服务要被注册(扫描包) dubbo.scan.base-packages=com.servic 编写提供者的接口和实现类 消费者配置文件 #消费者去哪里拿服务需要暴露自己的名字 dubbo.application.name=customer-server #注册中心的地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 在消费者和提供者相同的包下建立提供者的接口 消费者服务类 @Service //注入到容器中 public class UserService { @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名 TicketService ticketService; public void bugTicket(){ String ticket = ticketService.getTicket(); System.out.println(&quot;在注册中心买到&quot;+ticket); } 编写测试类 @Autowired UserService userService; @Test public void contextLoads() { userService.bugTicket(); } 启动测试 1. 开启zookeeper 2. 打开dubbo-admin实现监控【可以不用做】 3. 开启服务者 4. 消费者消费测试 回顾,架构! 层架构+MVC 架构 --&gt;解耦 开发框架 Spring IOC AOP IOC : 控制反转 泡温泉,泡茶泡友 附近的人,打招呼。加微信,聊天,天天聊&gt;约泡 浴场(容器):温泉,茶庄泡友 直接进温泉,就有人和你一起了! 原来我们都是自己一步步操作,现在交给容器了!我们需要什么就去拿就可以了 ​ AOP:切面(本质,动态代理） ​ 为了解什么?不影响业本来的情况下,实现动态增加功能,大量应用在日志,事务等等 Spring是一个轻量级的Java开源框架，容器 目的：解决企业开发的复杂性问题 Spring是春天，但配置文件繁琐 SpringBoot SpringBoot ,新代javaEE的开发标准,开箱即用!&gt;拿过来就可以用,它自 动帮我们配置了非常多的东西,我们拿来即用,特性:约定大于配置! 随着公司体系越来越大,用户越来越多 微服务架构—&gt;新架构 模块化,功能化! 用户,支付,签到,娱乐…; 人多余多一台服务器解决不了就再增加一台服务器! --横向扩展 假设A服务器占用98%资源B服务器只占用了10%.–负载均衡; 将原来的整体项,分成模块化,用户就是一个单独的项目,签到也是一个单独的项目,项目和项目之前需要通信,如何通信 用户非常多而到十分少给用户多一点服务器,给签到少一点服务器 微服务架构问题? 分布式架构会遇到的四个核心题? 这么多服务,客户端该如何去访? 这么多服务,服务之间如何进行通信? 这么多服务,如何治理呢? 解决方案:SpringCloud Springcloud是一套生态，就是来解决以上分布式架构的4个问题 想使用Spring Clould ,必须要掌握 springBoot , 因为Springcloud是基于springBoot ; spring Cloud NetFlix ,出来了一套解决方案！一站式解决方案。可以直接使用 Api网关 , zuul组件 Feign --&gt; Httpclient —&gt; http通信方式,同步并阻塞 服务注册与发现 , Eureka 熔断机制 , Hystrix 2018年年底,NetFlix 宣布无限期停止维护。生态不再维护,就会脱节。 Apache Dubbo zookeeper , API:没有!要么找第三方组件,要么自己实现 Dubbo 是一个高性能的基于ava实现的RPC通信框架!2.6.x 服务注册与发现 , zookeeper :动物管理者 ( Hadoop , Hive ) 没有:借助了Hystrix 不完善，Dubbo SpringCloud Alibaba 一站式解决方案 目前又提出了新的思路 服务网格：也许是下一代维服务标准，Service mesh 代表解决方案：istio（未来可能需要掌握） 总而言之，要解决的问题就是4个 API网关 ， 服务路由 HTTP，RPC框架，异步调用 服务注册与发现，高可用 熔断机制，服务降级 为什么要解决这个问题？因为网络是不可靠的 ","link":"https://ganhan999.github.io/post/Java SpringBoot/"},{"title":"中等59. 螺旋矩阵 II","content":"题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 利用余数作为改方向的手段，并且遍历的顺序是右下左上， dx = [0, 1, 0, -1] # 方向：右，下，左，上 dy = [1, 0, -1, 0] # 注：与通常平面坐标系 记号 不同 到了尽头了就变一次 大神做法1： class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: list0 = [j for j in range(1,n**2 + 1)] # 生成长列表 x = y = 0 dx = [0,1,0,-1] # 方向坐标 dy = [1,0,-1,0] di = 0 visited = set() # 初始化集合，用于记录已走过坐标 list1 = [[None for k in range(n)] for k in range(n)] # 生成空矩阵 for i in range(n**2): list1[x][y] = list0[i] visited.add((x,y)) nx,ny = x + dx[di],y+dy[di] # 记录下一步操作 if 0&lt;=nx&lt;n and 0&lt;=ny&lt;n and (nx,ny) not in visited: # 判断是否越界，未曾走过的路 x,y = nx,ny else: di = (di+1)%4 x,y= x+dx[di],y+dy[di] return list1 &quot;&quot;&quot;&quot;&quot;&quot; 从外到内 大神做法2： class Solution: def generateMatrix(self, n: int) -&gt; [[int]]: l, r, t, b = 0, n - 1, 0, n - 1 mat = [[0 for _ in range(n)] for _ in range(n)] num, tar = 1, n * n while num &lt;= tar: for i in range(l, r + 1): # left to right mat[t][i] = num num += 1 t += 1 for i in range(t, b + 1): # top to bottom mat[i][r] = num num += 1 r -= 1 for i in range(r, l - 1, -1): # right to left mat[b][i] = num num += 1 b -= 1 for i in range(b, t - 1, -1): # bottom to top mat[i][l] = num num += 1 l += 1 return mat ","link":"https://ganhan999.github.io/post/59、螺旋矩阵 II/"},{"title":"中等56. 合并区间","content":"题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间： 如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾； 否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。 如果右端点比左端点还小，那么就要合并 大神做法1： class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]:#如果右端点比左端点还小，那么就要合并 merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged ","link":"https://ganhan999.github.io/post/56、合并区间/"},{"title":"中等55. 跳跃游戏","content":"题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 如果某一个作为 起跳点 的格子可以跳跃的距离是 3,那么表示后面 3 个格子都可以作为 起跳点。 可以对每一个能作为 起跳点 的格子都尝试跳一次，把能跳到最远的距离 不断更新。 如果可以一直跳到最后，就成功了。 大神做法1： class Solution: def canJump(self, nums: List[int]) -&gt; bool: max_distance = 1#至少为1 length = len(nums) index = 0 while index+1 &lt;= max_distance:#因为索引肯定要少1的 max_distance = max(max_distance, nums[index] + index+1) if max_distance &gt;= length: return True else: index += 1 return True if index &gt;= length else False &quot;&quot;&quot;&quot;&quot;&quot; 可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。 定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。 例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。 大神做法2： class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix or not matrix[0]: return list() rows, columns = len(matrix), len(matrix[0]) order = list() left, right, top, bottom = 0, columns - 1, 0, rows - 1 while left &lt;= right and top &lt;= bottom: for column in range(left, right + 1): order.append(matrix[top][column]) for row in range(top + 1, bottom + 1): order.append(matrix[row][right]) if left &lt; right and top &lt; bottom: for column in range(right - 1, left, -1): order.append(matrix[bottom][column]) for row in range(bottom, top, -1): order.append(matrix[row][left]) left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return order &quot;&quot;&quot;&quot;&quot;&quot; 同上 贪心算法 刷新每次最长距离 class Solution: def canJump(self, nums: List[int]) -&gt; bool: n, rightmost = len(nums), 1 for i in range(n): if i+1 &lt;= rightmost: rightmost = max(rightmost, i +1 + nums[i]) if rightmost &gt;= n : return True return False ","link":"https://ganhan999.github.io/post/55、跳跃游戏/"},{"title":"Java Vue","content":"一、前端核心分析 1.1、概述 Soc原则：关注点分离原则 Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。 HTML + CSS + JS : 视图 ： 给用户看，刷新后台给的数据 网络通信 ： axios 页面跳转 ： vue-router 状态管理：vuex Vue-UI : ICE , Element UI 1.2、前端三要素 HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容 CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式。 JavaScript（行为）：是一种弱类型脚本语言，其源码不需经过编译，而是由浏览器解释运行，用于控制网页的行为 1.3、结构层（HTML） 太简单，略 1.4、表现层（CSS） CSS层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下： 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护； 这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为【CSS预处理器】的工具,提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大的提高了前端在样式上的开发效率。 什么是CSS预处理器 CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只需要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”。 常用的CSS预处理器有哪些 SASS：基于Ruby ，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。 LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以如果我们后台人员如果需要的话，建议使用LESS。 1.5、行为层（JavaScript） JavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需要经过编译，而是将文本格式的字符代码发送给浏览器，由浏览器解释运行。 Native 原生JS开发 原生JS开发，也就是让我们按照【ECMAScript】标准的开发方式，简称ES，特点是所有浏览器都支持。截至到当前，ES标准以发布如下版本： ES3 ES4（内部，未正式发布） ES5（全浏览器支持） ES6（常用，当前主流版本：webpack打包成为ES5支持） ES7 ES8 ES9（草案阶段） 区别就是逐步增加新特性。 TypeScript 微软的标准 TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集， 而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格(C#、Delphi、TypeScript之父； .NET创立者) 主导。该语言的特点就是除了具备ES的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持TypeScript语法， 需要编译后(编译成JS) 才能被浏览器正确执行。 JavaScript框架 JQuery：大家熟知的JavaScript库，优点就是简化了DOM操作，缺点就是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6，7，8； Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用了TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代–&gt;2 代，除了名字，基本就是两个东西；截止发表博客时已推出了Angular6） React：Facebook 出品，一款高性能的JS前端框架；特点是提出了新概念 【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言； Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和React(虚拟 DOM) 的优点； Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery 提供的AJAX 通信功能； 二、前端发展史 2.1、UI框架 Ant-Design：阿里巴巴出品，基于React的UI框架 ElementUI、iview、ice：饿了么出品，基于Vue的UI框架 BootStrap：Teitter推出的一个用于前端开发的开源工具包 AmazeUI：又叫“妹子UI”，一款HTML5跨屏前端框架 2.2、JavaScript构建工具 Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript WebPack：模块打包器，主要作用就是打包、压缩、合并及按序加载 注：以上知识点已将WebApp开发所需技能全部梳理完毕 2.3、三端同一 混合开发（Hybrid App） 主要目的是实现一套代码三端统一（PC、Android：.apk、iOS：.ipa）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种： 云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud 本地打包： Cordova（前身是 PhoneGap） 微信小程序 详见微信官网，这里就是介绍一个方便微信小程序UI开发的框架：WeUI 2.4、后端技术 前端人员为了方便开发也需要掌握一定的后端技术但我们Java后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了Node JS这样的技术。Node JS的作者已经声称放弃Node JS(说是架构做的不好再加上笨重的node modules，可能让作者不爽了吧)开始开发全新架构的De no 既然是后台技术，那肯定也需要框架和项目管理工具， Node JS框架及项目管理工具如下： Express：Node JS框架 Koa：Express简化版 NPM：项目综合管理工具，类似于Maven YARN：NPM的替代方案，类似于Maven和Gradle的关系 2.5、主流前端框架 Vue.js iView iview是一个强大的基于Vue的UI库， 有很多实用的基础组件比element ui的组件更丰富， 主要服务于PC界面的中后台产品。使用单文件的Vue组件化开发模式基于npm+webpack+babel开发， 支持ES 2015高质量、功能丰富友好的API， 自由灵活地使用空间。 官网地址 Github iview-admin 备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多 Element UI Element是饿了么前端开源维护的Vue UI组件库， 组件齐全， 基本涵盖后台所需的所有组件，文档讲解详细， 例子也很丰富。主要用于开发PC端的页面， 是一个质量比较高的Vue UI组件库。 ·官网地址 ·Git hub ·vue-element-admin 备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多 ICE 飞冰是阿里巴巴团队基于React/Angular/Vue的中后台应用解决方案， 在阿里巴巴内部， 已经有270多个来自几乎所有BU的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。 官网地址。 Git hub 备注：主要组件还是以React为主， 截止2019年02月17日更新博客前对Vue的支持还不太完善，目前尚处于观望阶段 VantUI Vant UI是有赞前端团队基于有赞统一的规范实现的Vue组件库， 提供了-整套UI基础组件和业务组件。通过Vant， 可以快速搭建出风格统一的页面，提升开发效率。 官网地址 Github AtUI at-ui是一款基于Vue 2.x的前端UI组件库， 主要用于快速开发PC网站产品。它提供了一套n pm+web pack+babel前端开发工作流程， CSS样式独立， 即使采用不同的框架实现都能保持统一的UI风格。 ·官网地址 ·Git hub Cube Ul cube-ui是滴滴团队开发的基于Vue js实现的精致移动端组件库。支持按需引入和后编译， 轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 官网地址 Github 混合开发 Flutter Flutter是谷歌的移动端UI框架， 可在极短的时间内构建Android和iOS上高质量的原生级应用。Flutter可与现有代码一起工作， 它被世界各地的开发者和组织使用， 并且Flutter是免费和开源的。 官网地址 Github 备注：Google出品， 主要特点是快速构建原生APP应用程序， 如做混合应用该框架为必选框架 lonic lonic既是一个CSS框架也是一个Javascript UI库， lonic是目前最有潜力的一款HTML 5手机应用开发框架。通过SASS构建应用程序， 它提供了很多UI组件来帮助开发者开发强大的应用。它使用JavaScript MV VM框架和Angular JS/Vue来增强应用。提供数据的双向绑定， 使用它成为Web和移动开发者的共同选择。 官网地址 ·官网文档 ·Git hub 微信小程序 mpvue mpvue是美团开发的一个使用Vue.js开发小程序的前端框架， 目前支持微信小程序、百度智能小程序，头条小程序和支付宝小程序。框架基于Vue.js， 修改了的运行时框架runtime和代码编译器compiler实现， 使其可运行在小程序环境中， 从而为小程序开发引入了Vue.js开发体验。 ·官网地址 ·Git hub 备注：完备的Vue开发体验， 井且支持多平台的小程序开发， 推荐使用 WeUI WeUI是一套同微信原生视觉体验一致的基础样式库， 由微信官方设计团队为微信内网页和微信小程序量身设计， 令用户的使用感知更加统一。包含button、cell、dialog、toast、article、icon等各式元素。 官网地址 Github 三、了解前后分离的演变史 为什么需要前后分离 3.1、后端为主的MVC时代 为了降低开发的复杂度， 以后端为出发点， 比如：Struts、Spring MVC等框架的使用， 就是后端的MVC时代； 以SpringMVC流程为例： 发起请求到前端控制器(Dispatcher Servlet) 前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找 处理器映射器HandlerMapping向前端控制器返回Handler 前端控制器调用处理器适配器去执行Handler 处理器适配器去执行Handler Handler执行完成给适配器返回ModelAndView 处理器适配器向前端控制器返回ModelAndView，ModelAndView是SpringMvc框架的一个底层对象，包括Model和View 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(JSP) 视图解析器向前端控制器返回View 前端控制器进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域 前端控制器向用户响应结果 优点 MVC是一个非常好的协作模式， 能够有效降低代码的耦合度从架构上能够让开发者明白代码应该写在哪里。为了让View更纯粹， 还可以使用Thyme leaf、Frree marker等模板引擎， 使模板里无法写入Java代码， 让前后端分工更加清晰。 缺点 前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式： 第一种是前端写DEMO， 写好后， 让后端去套模板。好处是DEMO可以本地开发， 很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大； 另一种协作模式是前端负责浏览器端的所有开发和服务器端的View层模板开发。好处是UI相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码，还有一个很大的灰色地带是Controller， 页面路由等功能本应该是前端最关注的， 但却是由后端来实现。Controller本身与Model往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在Controller层。这些问题不能全归结于程序员的素养， 否则JSP就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用[Comet】、【Big Pipe】等技术方案来优化性能。 注：在这期间(2005年以前) ， 包括早期的JSP、PHP可以称之为Web 1.0时代。在这里想说一句， 如果你是一名Java初学者， 请你不要再把一些陈旧的技术当回事了， 比如JSP， 因为时代在变、技术在变、什么都在变(引用扎克伯格的一句话：唯一不变的是变化本身)；当我们去给大学做实训时，有些同学会认为我们没有讲什么干货，其实不然，只能说是你认知里的干货对于市场来说早就过时了而已 3.2、基于AJAX带来的SPA时代 时间回到2005年A OAX(Asynchronous JavaScript And XML， 异步JavaScript和XML，老技术新用法)被正式提出并开始使用CDN作为静态资源存储， 于是出现了JavaScript王者归来(在这之前JS都是用来在网页上贴狗皮膏药广告的) 的SPA(Single Page Application) 单页面应用时代。 优点 这种模式下， **前后端的分工非常清晰， 前后端的关键协作点是AJAX接口。**看起来是如此美妙， 但回过头来看看的话， 这与JSP时代区别不大。复杂度从服务端的JSP里移到了浏览器的JavaScript，浏览器端变得很复杂。类似Spring MVC， 这个时代开始出现浏览器端的分层架构： 缺点 前后端接口的约定：如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。 前端开发的复杂度控制：SPA应用大多以功能交互型为主，JavaScript代码过十万行很正常。大量JS代码的组织，与View层的绑定等，都不是容易的事情。 3.3、前端为主的MV*时代 此处的MV*模式如下： MVC(同步通信为主) ：Model、View、Controller MVP(异步通信为主) ：Model、View、Presenter MVVM(异步通信为主)：Model、View、View Model为了降低前端开发复杂度，涌现了大量的前端框架，比如：Angular JS、React、Vue.js、Ember JS等， 这些框架总的原则是先按类型分层， 比如Templates、Controllers、Models， 然后再在层内做切分，如下图： 优点 前后端职责很清晰：前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难， 前端可以本地开发。后端则可以专注于业务逻辑的处理， 输出RESTful等接口。 前端开发的复杂度可控：前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。 部署相对独立：可以快速改进产品体验缺点 代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。 全异步， 对SEO不利。往往还需要服务端做同步渲染的降级方案。 性能并非最佳，特别是移动互联网环境下。 SPA不能满足所有需求， 依旧存在大量多页面应用。URL Design需要后端配合， 前端无法完全掌控。 3.4、Node JS带来的全栈时代 前端为主的MV*模式解决了很多很多问题， 但如上所述， 依旧存在不少不足之处。随着Node JS的兴起， JavaScript开始有能力运行在服务端。这意味着可以有一种新的研发模式： 在这种研发模式下，前后端的职责很清晰。对前端来说，两个UI层各司其职： Front-end Ul layer处理浏览器层的展现逻辑。通过CSS渲染样式， 通过JavaScript添加交互功能， HTML的生成也可以放在这层， 具体看应用场景。 Back-end Ul layer处理路由、模板、数据获取、Cookie等。通过路由， 前端终于可以自主把控URL Design， 这样无论是单页面应用还是多页面应用， 前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。 通过Node， WebServer层也是JavaScript代码， 这意味着部分代码可前后复用， 需要SEO的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。 与JSP模式相比， 全栈模式看起来是一种回归， 也的确是一种向原始开发模式的回归， 不过是一种螺旋上升式的回归。 基于Node JS的全栈模式， 依旧面临很多挑战： 需要前端对服务端编程有更进一步的认识。比如TCP/IP等网络知识的掌握。 Node JS层与Java层的高效通信。Node JS模式下， 都在服务器端， RESTful HTTP通信未必高效， 通过SOAP等方式通信更高效。一切需要在验证中前行。 对部著、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 注：看到这里，相信很多同学就可以理解，为什么我总在课堂上说：“前端想学后台很难，而我们后端程序员学任何东西都很简单”；就是因为我们后端程序员具备相对完善的知识体系。 全栈!So Easy! 3.5、总结 综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于Soc(关注度分离原则)，上面种种模式，都是让前后端的职责更清晰，分工更合理高效。 四、第一个Vue程序 4.1、什么是MVVM MVVM（Model-View-ViewModel）是一种软件设计模式，由微软WPF（用于替代WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行WPF）的架构师Ken Cooper和Ted Peters开发，是一种简化用户界面的事件驱动编程方式。由John Gossman（同样也是WPF和Sliverlight的架构师）与2005年在他的博客上发表。 MVVM源自于经典的MVC（Model-View-Controller）模式。MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用。其作用如下： 该层向上与视图层进行双向数据绑定 向下与Model层通过接口请求进行数据交互 MVVM已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的MVVM框架有Vue.js，Anfular JS 4.2、为什么要使用MVVM MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大好处 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可复用：你可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewMode），设计人员可以专注于页面设计。 可测试：界面素来是比较难以测试的，而现在测试可以针对ViewModel来写。 （1）View View是视图层， 也就是用户界面。前端主要由HTH L和csS来构建， 为了更方便地展现vi eu to del或者Hodel层的数据， 已经产生了各种各样的前后端模板语言， 比如FreeMarker，Thyme leaf等等， 各大MV VM框架如Vue.js.Angular JS， EJS等也都有自己用来构建用户界面的内置模板语言。 （2）Model Model是指数据模型， 泛指后端进行的各种业务逻辑处理和数据操控， 主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则 （3）ViewModel ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层， 前端开发者对从后端获取的Model数据进行转换处理， 做二次封装， 以生成符合View层使用预期的视图数据模型。 需要注意的是View Model所封装出来的数据模型包括视图的状态和行为两部分， 而Model层的数据模型是只包含状态的 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态(展示) 页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为(交互) 视图状态和行为都封装在了View Model里。这样的封装使得View Model可以完整地去描述View层。由于实现了双向绑定， View Model的内容会实时展现在View层， 这是激动人心的， 因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图。 MVVM框架已经把最脏最累的一块做好了， 我们开发者只需要处理和维护View Model， 更新数据视图就会自动得到相应更新，真正实现事件驱动编程。 View层展现的不是Model层的数据， 而是ViewModel的数据， 由ViewModel负责与Model层交互， 这就完全解耦了View层和Model层， 这个解耦是至关重要的， 它是前后端分离方案实施的重要一环。 4.3、Vue Vue(读音/vju/， 类似于view) 是一套用于构建用户界面的渐进式框架， 发布于2014年2月。与其它大型框架不同的是， Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层， 不仅易于上手， 还便于与第三方库(如：vue-router，vue-resource，vue x) 或既有项目整合。 （1）MVVM模式的实现者 Model：模型层， 在这里表示JavaScript对象 View：视图层， 在这里表示DOM(HTML操作的元素) ViewModel：连接视图和数据的中间件， Vue.js就是MVVM中的View Model层的实现者 在MVVM架构中， 是不允许数据和视图直接通信的， 只能通过ViewModel来通信， 而View Model就是定义了一个Observer观察者 ViewModel能够观察到数据的变化， 并对视图对应的内容进行更新 ViewModel能够监听到视图的变化， 并能够通知数据发生改变 至此， 我们就明白了， Vue.js就是一个MV VM的实现者， 他的核心就是实现了DOM监听与数据绑定 （2）为什么要使用Vue.js 轻量级， 体积小是一个重要指标。Vue.js压缩后有只有20多kb(Angular压缩后56kb+，React压缩后44kb+) 移动优先。更适合移动端， 比如移动端的Touch事件 易上手，学习曲线平稳，文档齐全 吸取了Angular(模块化) 和React(虚拟DOＭ) 的长处， 并拥有自己独特的功能，如：计算属性 开源，社区活跃度高 4.4、第一个Vue程序 【说明】IDEA可以安装Vue的插件! 注意：Vue不支持IE 8及以下版本， 因为Vue使用了IE 8无法模拟的ECMAScript 5特性。但它支持所有兼容ECMAScript 5的浏览器。 （1）下载地址 开发版本 包含完整的警告和调试模式：https：//yuejs.org/js/vue.js 删除了警告， 30.96KB min+gzip：https：//vuejs.org/js/vue.min.js CDN &lt;script src=“https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js”&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; （2）代码编写 Vue.js的核心是实现了MVVM模式， 她扮演的角色就是View Model层， 那么所谓的第一个应用程序就是展示她的数据绑定功能，操作流程如下： 1、创建一个HTML文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2、引入Vue.js &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; 3、创建一个Vue实例 &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ message:&quot;hello,vue!&quot; } }); &lt;/script&gt; 说明： el: '#vue'：绑定元素的ID data:{message:'Hello Vue!'}：数据对象中有一个名为message的属性，并设置了初始值 Hello Vue！ 4、将数据绑定到页面元素 &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; 说明：只需要在绑定的元素中使用双花括号将Vue创建的名为message属性包裹起来， 即可实现数据绑定功能， 也就实现了View Model层所需的效果， 是不是和EL表达式非常像? （3）完整的HTML &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ message:&quot;hello,vue!&quot; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （4）测试 为了能够更直观的体验Vue带来的数据绑定功能， 我们需要在浏览器测试一番， 操作流程如下： 1、在浏览器上运行第一个Vue应用程序， 进入开发者工具 2、在控制台输入vm.message=‘HelloWorld’， 然后回车， 你会发现浏览器中显示的内容会直接变成HelloWorld 此时就可以在控制台直接输入vm.message来修改值， 中间是可以省略data的， 在这个操作中， 我并没有主动操作DOM， 就让页面的内容发生了变化， 这就是借助了Vue的数据绑定功能实现的； MV VM模式中要求View Model层就是使用观察者模式来实现数据的监听与绑定， 以做到数据与视图的快速响应。 五、基础语法指令 4.1、v-bind 我们已经成功创建了第一个Vue应用!看起来这跟渲染一个字符串模板非常类似， 但是Vue在背后做了大量工作。现在数据和DOM已经被建立了关联， 所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新! 我们还可以使用v-bind来绑定元素特性! 上代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ message: '页面加载于 ' + new Date().toLocaleString() } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 你看到的v-bind等被称为指令。指令带有前缀v以表示它们是Vue提供的特殊特性。可能你已经猜到了， 它们会在渲染的DOM上应用特殊的响应式行为在这里，该指令的意思是：“将这个元素节点的title特性和Vue实例的message属性保持一致”。 如果你再次打开浏览器的JavaScript控制台， 输入app， message=‘新消息’，就会再一次看到这个绑定了title特性的HTML已经进行了更新。 4.2、v-if， v-else 什么是条件判断语句，就不需要我说明了吧，以下两个属性! v-if v-else 上代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ ok: true } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试： 1.在浏览器上运行，打开控制台! 2.在控制台输入vm.ok=false然后回车，你会发现浏览器中显示的内容会直接变成NO 注：使用v-*属性绑定数据是不需要双花括号包裹的 v-else-if v-if v-else-if v-else 注：===三个等号在JS中表示绝对等于(就是数据与类型都要相等)上代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;type==='A'&quot;&gt;A&lt;/h1&gt; &lt;h1 v-else-if=&quot;type==='B'&quot;&gt;B&lt;/h1&gt; &lt;h1 v-else-if=&quot;type==='D'&quot;&gt;D&lt;/h1&gt; &lt;h1 v-else&gt;C&lt;/h1&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ type: 'A' } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.3、v-for v-for 格式说明 &lt;div id=&quot;app&quot;&gt; &lt;li v-for=&quot;(item,index) in items&quot;&gt; {{item.message}}---{{index}} &lt;/li&gt; &lt;/div&gt; 注：items是数组，item是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！ 上代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;li v-for=&quot;(item,index) in items&quot;&gt; {{item.message}}---{{index}} &lt;/li&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, /*Model：数据*/ data:{ items:[ {message:'狂神说Java'}, {message:'狂神说前端'}, {message:'狂神说运维'} ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试：在控制台输入vm.items.push({message：'狂神说运维'})，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条狂神说运维. 4.4、v-on v-on监听事件 emsp;事件有Vue的事件、和前端页面本身的一些事件!我们这里的click是vue的事件， 可以绑定到Vue中的methods中的方法事件! 上代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ message:'Hello World' }, methods:{ sayHi:function(event){ //'this'在方法里面指向当前Vue实例 alert(this.message); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击测试 Vue还有一些基本的使用方式， 大家有需要的可以再跟着官方文档看看， 因为这些基本的指令几乎我们都见过了，一通百通!掌握学习的方式! 六、表单双绑、组件 6.1、什么是双向数据绑定 Vue.js是一个MV VM框架， 即数据双向绑定， 即当数据发生变化的时候， 视图也就发生变化， 当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。 值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vue x那么数据流也是单项的，这时就会和双向数据绑定有冲突。 （1）为什么要实现数据的双向绑定 在Vue.js中，如果使用vuex， 实际上数据还是单向的， 之所以说是数据双向绑定，这是用的UI控件来说， 对于我们处理表单， Vue.js的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。 6.2、在表单中使用双向数据绑定 你可以用v-model指令在表单、及元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇， 但v-model本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 注意：v-model会忽略所有表单元素的value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源。你应该通过JavaScript在组件的data选项中声明初始值! （1）单行文本 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 输入的文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot; value=&quot;hello&quot;&gt;{{message}} &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ message:&quot;&quot; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （2）多行文本 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 多行文本：&lt;textarea v-model=&quot;pan&quot;&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：{{pan}} &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ pan:&quot;Hello hello!&quot; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （3）单复选框 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 单复选框： &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &amp;nbsp;&amp;nbsp; &lt;label for=&quot;checkbox&quot;&gt;{{checked}}&lt;/label&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ checked:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （4）多复选框 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 多复选框： &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &amp;nbsp;&amp;nbsp; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;join&quot; value=&quot;Join&quot; v-model=&quot;checkedNames&quot;&gt; &amp;nbsp;&amp;nbsp; &lt;label for=&quot;join&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &amp;nbsp;&amp;nbsp; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;span&gt;选中的值：{{checkedNames}}&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ checkedNames:[] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （6）单选按钮 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; 单选框按钮 &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;span&gt;选中的值：{{picked}}&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ picked:'Two' } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （7）下拉框 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;pan&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;pan&quot;&gt;女 &lt;p&gt;选中了：{{pan}}&lt;/p&gt;--&gt; 下拉框: &lt;select v-model=&quot;pan&quot;&gt; &lt;option value=&quot;&quot; disabled&gt;---请选择---&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;D&lt;/option&gt; &lt;/select&gt; &lt;span&gt;value:{{pan}}&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ pan:&quot;A&quot; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：v-model表达式的初始值未能匹配任何选项，元系将被渲染为“未选中”状态。 在iOS中， 这会使用户无法选择第一个选项，因为这样的情况下，iOS不会触发change事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 6.3、什么是组件 组件是可复用的Vue实例， 说白了就是一组可以重复使用的模板， 跟JSTL的自定义标签、Thymeleal的th:fragment等框架有着异曲同工之妙，通常一个应用会以一棵嵌套的组件树的形式来组织： 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 （1）第一个Vue组件 注意：在实际开发中，我们并不会用以下方式开发组件，而是采用vue-cli创建，vue模板文件的方式开发，以下方法只是为了让大家理解什么是组件。 使用Vue.component()方法注册组件，格式如下： &lt;div id=&quot;app&quot;&gt; &lt;pan&gt;&lt;/pan&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //先注册组件 Vue.component(&quot;pan&quot;,{ template:'&lt;li&gt;Hello&lt;/li&gt;' }); //再实例化Vue var vm = new Vue({ el:&quot;#app&quot;, }); &lt;/script&gt; 说明： Vue.component()：注册组件 pan：自定义组件的名字 template：组件的模板 （2）使用props属性传递参数 像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用props属性了！ 注意：默认规则下props属性里的值不能为大写； &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--组件：传递给组件中的值：props--&gt; &lt;pan v-for=&quot;item in items&quot; v-bind:panh=&quot;item&quot;&gt;&lt;/pan&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义组件 Vue.component(&quot;pan&quot;,{ props:['panh'], template:'&lt;li&gt;{{panh}}&lt;/li&gt;' }); var vm = new Vue({ el:&quot;#app&quot;, data:{ items:[&quot;java&quot;,&quot;Linux&quot;,&quot;前端&quot;] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 说明： v-for=&quot;item in items&quot;：遍历Vue实例中定义的名为items的数组，并创建同等数量的组件 v-bind:panh=&quot;item&quot;：将遍历的item项绑定到组件中props定义名为item属性上；= 号左边的panh为props定义的属性名，右边的为item in items 中遍历的item项的值 七、Axios异步通信 7.1、什么是Axios Axios是一个开源的可以用在浏览器端和Node JS的异步通信框架， 她的主要作用就是实现AJAX异步通信，其功能特点如下： 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持Promise API[JS中链式编程] 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF(跨站请求伪造) GitHub：https://github.com/axios/axios 中文文档：http://www.axios-js.com/ 7.2、为什么要使用Axios 由于Vue.js是一个视图层框架并且作者(尤雨溪) 严格准守SoC(关注度分离原则)所以Vue.js并不包含AJAX的通信功能， 为了解决通信问题， 作者单独开发了一个名为vue-resource的插件， 不过在进入2.0版本以后停止了对该插件的维护并推荐了Axios框架。少用jQuery， 因为它操作Dom太频繁! 7.3、第一个Axios应用程序 咱们开发的接口大部分都是采用JSON格式， 可以先在项目里模拟一段JSON数据， 数据内容如下：创建一个名为data.json的文件并填入上面的内容， 放在项目的根目录下 { &quot;name&quot;: &quot;狂神说Java&quot;, &quot;url&quot;: &quot;https://blog.kuangstudy.com&quot;, &quot;page&quot;: 1, &quot;isNonProfit&quot;: true, &quot;address&quot;: { &quot;street&quot;: &quot;含光门&quot;, &quot;city&quot;: &quot;陕西西安&quot;, &quot;country&quot;: &quot;中国&quot; }, &quot;links&quot;: [ { &quot;name&quot;: &quot;bilibili&quot;, &quot;url&quot;: &quot;https://space.bilibili.com/95256449&quot; }, { &quot;name&quot;: &quot;狂神说Java&quot;, &quot;url&quot;: &quot;https://blog.kuangstudy.com&quot; }, { &quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;https://www.baidu.com/&quot; } ] } 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-binf=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--v-cloak 解决闪烁问题--&gt; &lt;style&gt; [v-cloak]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue&quot;&gt; &lt;div&gt;地名：{{info.name}}&lt;/div&gt; &lt;div&gt;地址：{{info.address.country}}--{{info.address.city}}--{{info.address.street}}&lt;/div&gt; &lt;div&gt;链接：&lt;a v-binf:href=&quot;info.url&quot; target=&quot;_blank&quot;&gt;{{info.url}}&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--引入js文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#vue&quot;, //data：属性：vm data(){ return{ info:{ name:null, address:{ country:null, city:null, street:null }, url:null } } }, mounted(){//钩子函数 axios .get('data.json') .then(response=&gt;(this.info=response.data)); } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 说明： 在这里使用了v-bind将a:href的属性值与Vue实例中的数据进行绑定 使用axios框架的get方法请求AJAX并自动将数据封装进了Vue实例的数据对象中 我们在data中的数据结构必须和Ajax响应回来的数据格式匹配！ 7.4、Vue的生命周期 官方文档：https://cn.vuejs.org/v2/guide/instance.html#生命周期图示 Vue实例有一个完整的生命周期，也就是从开始创建初女台化数据、编译模板、挂载DOM、渲染一更新一渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法，可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。 八、计算属性、内容分发、自定义事件 1、什么是计算属性 计算属性的重点突出在属性两个字上(属性是名词)，首先它是个属性其次这个属性有计算的能力(计算是动词)，这里的计算就是个函数：简单点说，它就是一个能够将计算结果缓存起来的属性(将行为转化成了静态的属性)，仅此而已；可以想象为缓存! 上代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;currentTime1:{{currentTime1()}}&lt;/p&gt; &lt;p&gt;currentTime2:{{currentTime2}}&lt;/p&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ message:&quot;pan&quot; }, methods:{ currentTime1:function(){ return Date.now();//返回一个时间戳 } }, computed:{ currentTime2:function(){//计算属性：methods，computed方法名不能重名，重名之后，只会调用methods的方法 this.message; return Date.now();//返回一个时间戳 } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：methods和computed里的东西不能重名 说明： methods：定义方法， 调用方法使用currentTime1()， 需要带括号 computed：定义计算属性， 调用属性使用currentTime2， 不需要带括号：this.message是为了能够让currentTime2观察到数据变化而变化 如何在方法中的值发生了变化，则缓存就会刷新!可以在控制台使用vm.message=”q in jiang&quot;， 改变下数据的值，再次测试观察效果! 结论： 调用方法时，每次都需要讲行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销； 8.2、内容分发 在Vue.js中我们使用&lt;slot&gt;元素作为承载分发内容的出口，作者称其为插槽，可以应用在组合组件的场景中； 测试 比如准备制作一个待办事项组件(todo) ， 该组件由待办标题(todo-title) 和待办内容(todo-items)组成，但这三个组件又是相互独立的，该如何操作呢? 第一步定义一个待办事项的组件 &lt;div id=&quot;app&quot;&gt; &lt;todo&gt;&lt;/todo&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component('todo',{ template:'&lt;div&gt;\\ &lt;div&gt;代办事项&lt;/div&gt;\\ &lt;ul&gt;\\ &lt;li&gt;学习狂神说Java&lt;/li&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }) &lt;/script&gt; 第二步 我们需要让，代办事项的标题和值实现动态绑定，怎么做呢？我们可以留一个插槽！ 1-将上面的代码留出一个插槽，即slot Vue.component('todo',{ template:'&lt;div&gt;\\ &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); 2-定义一个名为todo-title的待办标题组件 和 todo-items的待办内容组件 Vue.component('todo-title',{ props:['title'], template:'&lt;div&gt;{{title}}&lt;/div&gt;' }); 12345 //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！ Vue.component(&quot;todo-items&quot;,{ props:[&quot;item&quot;,&quot;index&quot;], template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot; }); 3-实例化Vue并初始化数据 var vm = new Vue({ el:&quot;#vue&quot;, data:{ todoItems:['test1','test2','test3'] } }); 4-将这些值，通过插槽插入 &lt;div id=&quot;vue&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; title=&quot;秦老师系列课程&quot;&gt;&lt;/todo-title&gt; &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt; &lt;!--如下为简写--&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items &lt;/todo&gt; &lt;/div&gt; 说明：我们的todo-title和todo-items组件分别被分发到了todo组件的todo-title和todo-items插槽中 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;vue&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title&quot;&gt;&lt;/todo-title&gt; &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;{item,index} in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt; &lt;!--如下为简写--&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item=&quot;item&quot;&gt;&lt;/todo-items &lt;/todo&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component('todo',{ template:'&lt;div&gt;\\ &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); Vue.component('todo-title',{ props:['title'], template:'&lt;div&gt;{{title}}&lt;/div&gt;' }); //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！ Vue.component(&quot;todo-items&quot;,{ props:[&quot;item&quot;,&quot;index&quot;], template:&quot;&lt;li&gt;{{index+1}},{{item}}&lt;/li&gt;&quot; }); var vm = new Vue({ el:&quot;#vue&quot;, data:{ title:&quot;秦老师系列课程&quot;, todoItems:['test1','test2','test3'] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 8.3、自定义事件 通以上代码不难发现，数据项在Vue的实例中， 但删除操作要在组件中完成， 那么组件如何才能删除Vue实例中的数据呢?此时就涉及到参数传递与事件分发了， Vue为我们提供了自定义事件的功能很好的帮助我们解决了这个问题； 使用this.$emit(‘自定义事件名’， 参数) ， 操作过程如下： 1-在vue的实例中增加了methods对象并定义了一个名为removeTodoltems的方法 var vm = new Vue({ el:&quot;#vue&quot;, data:{ title_text:&quot;秦老师系列课程&quot;, todoItems:['test1','test2','test3'] }, methods:{ removeItems:function(index){ console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;); //splice（） 方法向/从数组中添加/删除项目，然后返回被删除的项目，其中index this.todoItems.splice(index,1); } } }); 2-修改todo-items待办内容组件的代码，增加一个删除按钮，并且绑定事件！ Vue.component(&quot;todo-items&quot;,{ props:[&quot;item_p&quot;,&quot;index_p&quot;], template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;, methods:{ remove:function (index) { //这里的remove是自定义事件名称，需要在HTML中使用v-on:remove的方式 //this.$emit 自定义事件分发 this.$emit('remove',index); } } }); 3-修改todo-items待办内容组件的HTML代码，增加一个自定义事件，比如叫remove，可以和组件的方法绑定，然后绑定到vue的方法！ &lt;!--增加了v-on:remove=&quot;removeTodoItems(index)&quot;自定义事件，该组件会调用Vue实例中定义的--&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt; 对上一个代码进行修改，实现删除功能 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层，模板--&gt; &lt;div id=&quot;vue&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; :title=&quot;title_text&quot;&gt;&lt;/todo-title&gt; &lt;!--&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt;--&gt; &lt;!--如下为简写--&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; :item_p=&quot;item&quot; :index_p=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot; :key=&quot;index&quot;&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; &lt;!--1.导入Vue.js--&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component('todo',{ template:'&lt;div&gt;\\ &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); Vue.component('todo-title',{ props:['title'], template:'&lt;div&gt;{{title}}&lt;/div&gt;' }); //这里的index，就是数组的下标，使用for循环遍历的时候，可以循环出来！ Vue.component(&quot;todo-items&quot;,{ props:[&quot;item_p&quot;,&quot;index_p&quot;], template:&quot;&lt;li&gt;{{index_p+1}},{{item_p}} &lt;button @click='remove_methods'&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;, methods:{ remove_methods:function (index) { //this.$emit 自定义事件分发 this.$emit('remove',index); } } }); var vm = new Vue({ el:&quot;#vue&quot;, data:{ title_text:&quot;秦老师系列课程&quot;, todoItems:['test1','test2','test3'] }, methods:{ removeItems:function(index){ console.log(&quot;删除了&quot;+this.todoItems[index]+&quot;OK&quot;); this.todoItems.splice(index,1); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 逻辑理解 8.4、Vue入门小结 核心：数据驱动，组件化 优点：借鉴了AngularJS的模块化开发和React的虚拟Dom，虚拟Dom就是把Demo操作放到内存中执行； 常用的属性： v-if v-else-if v-else v-for v-on绑定事件，简写@ v-model数据双向绑定 v-bind给组件绑定参数，简写： 组件化： 组合组件slot插槽 组件内部绑定事件需要使用到this.$emit(&quot;事件名&quot;,参数); 计算属性的特色，缓存计算数据 遵循SoC关注度分离原则，Vue是纯粹的视图框架，并不包含，比如Ajax之类的通信功能，为了解决通信问题，我们需要使用Axios框架做异步通信； 说明 Vue的开发都是要基于NodeJS，实际开发采用Vue-cli脚手架开发，vue-router路由，vuex做状态管理；Vue UI，界面我们一般使用ElementUI（饿了么出品），或者ICE（阿里巴巴出品）来快速搭建前端项目~~ 官网： https://element.eleme.cn/#/zh-CN https://ice.work/ 九、第一个vue-cli项目 9.1、什么是vue-cli vue-cli官方提供的一个脚手架，用于快速生成一个vue的项目模板； 预先定义好的目录结构及基础代码，就好比咱们在创建Maven项目时可以选择创建一个骨架项目，这个估计项目就是脚手架，我们的开发更加的快速； 项目的功能 统一的目录结构 本地调试 热部署 单元测试 集成打包上线 9.2、需要的环境 Node.js：http://nodejs.cn/download/ 安装就是无脑的下一步就好，安装在自己的环境目录下 Git：https://git-scm.com/doenloads 镜像：https://npm.taobao.org/mirrors/git-for-windows/ 确认nodejs安装成功： cmd下输入node -v，查看是否能够正确打印出版本号即可！ cmd下输入npm -v，查看是否能够正确打印出版本号即可！ 这个npm，就是一个软件包管理工具，就和linux下的apt软件安装差不多！ 安装Node.js淘宝镜像加速器（cnpm） 这样的话，下载会快很多~ # -g 就是全局安装 npm install cnpm -g # 或使用如下语句解决npm速度慢的问题 npm install --registry=https://registry.npm.taobao.org 安装的过程可能有点慢~，耐心等待！虽然安装了cnpm，但是尽量少用！ 安装的位置：C:\\Users\\administrator\\AppData\\Roaming\\npm 安装vue-cli cnpm instal1 vue-cli-g #测试是否安装成功#查看可以基于哪些模板创建vue应用程序，通常我们选择webpack vue list 123 9.3、第一个vue-cli应用程序 1.创建一个Vue项目，我们随便建立一个空的文件夹在电脑上，我这里在D盘下新建一个目录 D:\\Project\\vue-study; 2.创建一个基于webpack模板的vue应用程序 #1、首先需要进入到对应的目录 cd D:\\Project\\vue-study #2、这里的myvue是顶日名称，可以根据自己的需求起名 vue init webpack myvue 一路都选择no即可； 说明： Project name：项目名称，默认回车即可 Project description：项目描述，默认回车即可 Author：项目作者，默认回车即可 Install vue-router：是否安装vue-router，选择n不安装（后期需要再手动添加） Use ESLint to lint your code:是否使用ESLint做代码检查，选择n不安装（后期需要再手动添加) Set up unit tests:单元测试相关，选择n不安装（后期需要再手动添加） Setupe2etests with Nightwatch：单元测试相关，选择n不安装（后期需要再手动添加） Should we run npm install for you after the,project has been created:创建完成后直接初始化，选择n，我们手动执行；运行结果！ （1）初始化并运行 cd myvue npm install npm run dev 执行完成后，目录多了很多依赖 当出现问题时，可以查看提示进行处理如下 十、webpack使用 10.1、什么是Webpack 本质上， webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler) 。当webpack处理应用程序时， 它会递归地构建一个依赖关系图(dependency graph) ， 其中包含应用程序需要的每个模块， 然后将所有这些模块打包成一个或多个bundle. Webpack是当下最热门的前端资源模块化管理和打包工具， 它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过loader转换， 任何形式的资源都可以当做模块， 比如Commons JS、AMD、ES 6、CSS、JSON、Coffee Script、LESS等； 伴随着移动互联网的大潮， 当今越来越多的网站已经从网页模式进化到了WebApp模式。它们运行在现代浏览器里， 使用HTML 5、CSS 3、ES 6等新的技术来开发丰富的功能， 网页已经不仅仅是完成浏览器的基本需求； WebApp通常是一个SPA(单页面应用) ， 每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JS代码，这给前端的开发流程和资源组织带来了巨大挑战。 前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 10.2、模块化的演进 Script标签 &lt;script src = &quot;module1.js&quot;&gt;&lt;/script&gt; &lt;script src = &quot;module2.js&quot;&gt;&lt;/script&gt; &lt;script src = &quot;module3.js&quot;&gt;&lt;/script&gt; 这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的调用都是一个作用域。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照&lt;script&gt;的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonsJS 服务器端的NodeJS遵循CommonsJS规范，该规范核心思想是允许模块通过require方法来同步加载所需依赖的其它模块，然后通过exports或module.exports来导出需要暴露的接口。 require(&quot;module&quot;); require(&quot;../module.js&quot;); export.doStuff = function(){}; module.exports = someValue; 优点： 服务器端模块便于重用 NPM中已经有超过45万个可以使用的模块包 简单易用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务端的NodeJS •Browserify，浏览器端的CommonsJS实现，可以使用NPM的模块，但是编译打包后的文件体积较大 modules-webmake，类似Browserify，但不如Browserify灵活 wreq，Browserify的前身 AMD Asynchronous Module Definition规范其实主要一个主要接口define(id?,dependencies?,factory);它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行。 define(&quot;module&quot;,[&quot;dep1&quot;,&quot;dep2&quot;],functian(d1,d2){ return someExportedValue; }); require（[&quot;module&quot;,&quot;../file.js&quot;],function(module，file){}) 优点 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅 不符合通用的模块化思维方式，是一种妥协的实现 实现 RequireJS curl CMD Commons Module Definition规范和AMD很相似，尽保持简单，并与CommonsJS和NodeJS的Modules规范保持了很大的兼容性。 define(function(require,exports,module){ var $=require(&quot;jquery&quot;); var Spinning = require(&quot;./spinning&quot;); exports.doSomething = ...; module.exports=...; }); 优点： 依赖就近，延迟执行 可以很容易在NodeJS中运行缺点 依赖SPM打包，模块的加载逻辑偏重 实现 Sea.js coolie ES6模块 EcmaScript 6标准增加了JavaScript语言层面的模块体系定义。ES 6模块的设计思想， 是尽量静态化， 使编译时就能确定模块的依赖关系， 以及输入和输出的变量。Commons JS和AMD模块，都只能在运行时确定这些东西。 import &quot;jquery&quot; export function doStuff(){} module &quot;localModule&quot;{} 优点 容易进行静态分析 面向未来的Ecma Script标准 缺点 原生浏览器端还没有实现该标准 全新的命令，新版的Node JS才支持 实现 Babel 大家期望的模块 系统可以兼容多种模块风格， 尽量可以利用已有的代码， 不仅仅只是JavaScript模块化， 还有CSS、图片、字体等资源也需要模块化。 10.3、安装Webpack WebPack是一款模块加载器兼打包工具， 它能把各种资源， 如JS、JSX、ES 6、SASS、LESS、图片等都作为模块来处理和使用。 安装： npm install webpack -g npm install webpack-cli -g 测试安装成功 webpack -v webpack-cli -v 配置 创建 webpack.config.js配置文件 entry：入口文件， 指定Web Pack用哪个文件作为项目的入口 output：输出， 指定WebPack把处理完成的文件放置到指定路径 module：模块， 用于处理各种类型的文件 plugins：插件， 如：热更新、代码重用等 resolve：设置路径指向 watch：监听， 用于设置文件改动后直接打包 module.exports = { entry:&quot;&quot;, output:{ path:&quot;&quot;, filename:&quot;&quot; }, module:{ loaders:[ {test:/\\.js$/,;\\loade:&quot;&quot;} ] }, plugins:{}, resolve:{}, watch:true } 直接运行webpack命令打包 10.4、使用webpack 创建项目 创建一个名为modules的目录，用于放置JS模块等资源文件 在modules下创建模块文件，如hello.js，用于编写JS模块相关代码 //暴露一个方法：sayHi exports.sayHi = function(){ document.write(&quot;&lt;div&gt;Hello Webpack&lt;/div&gt;&quot;); } 在modules下创建一个名为main.js的入口文件，用于打包时设置entry属性 //require 导入一个模块，就可以调用这个模块中的方法了 var hello = require(&quot;./hello&quot;); hello.sayHi(); 在项目目录下创建webpack.config.js配置文件，使用webpack命令打包 module.exports = { entry:&quot;./modules/main.js&quot;, output:{ filename:&quot;./js/bundle.js&quot; } } 在项目目录下创建HTML页面，如index.html，导入webpack打包后的JS文件 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在IDEA控制台中直接执行webpack；如果失败的话，就使用管理员权限运行即可！ 运行HTML看效果 说明 # 参数--watch 用于监听变化 webpack --watch 十一、vue-router路由 11.1、说明 学习的时候，尽量的打开官方的文档 Vue Router是Vue.js官方的路由管理器。它和Vue.js的核心深度集成， 让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于Vue js过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的CSS class的链接 HTML5 历史模式或hash模式， 在IE 9中自动降级 自定义的滚动行为 11.2、安装 基于第一个vue-cli进行测试学习； 先查看node modules中是否存在vue-router vue-router是一个插件包， 所以我们还是需要用n pm/cn pm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。 npm install vue-router --save-dev 如果在一个模块化工程中使用它，必须要通过Vue.use()明确地安装路由功能： import Vue from 'vue' import VueRouter from 'vue-router' Vue.use(VueRouter); 11.3、测试 1、先删除没有用的东西 2、components 目录下存放我们自己编写的组件 3、定义一个Content.vue 的组件 &lt;template&gt; &lt;div&gt; &lt;h1&gt;内容页&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:&quot;Content&quot; } &lt;/script&gt; Main.vue组件 &lt;template&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:&quot;Main&quot; } &lt;/script&gt; 4、安装路由，在src目录下，新建一个文件夹：router，专门存放路由，配置路由index.js，如下 import Vue from'vue' //导入路由插件 import Router from 'vue-router' //导入上面定义的组件 import Content from '../components/Content' import Main from '../components/Main' //安装路由 Vue.use(Router) ; //配置路由 export default new Router({ routes:[ { //路由路径 path:'/content', //路由名称 name:'content', //跳转到组件 component:Content },{ //路由路径 path:'/main', //路由名称 name:'main', //跳转到组件 component:Main } ] }); 5、在main.js中配置路由 import Vue from 'vue' import App from './App' //导入上面创建的路由配置目录 import router from './router'//自动扫描里面的路由配置 //来关闭生产模式下给出的提示 Vue.config.productionTip = false; new Vue({ el:&quot;#app&quot;, //配置路由 router, components:{App}, template:'&lt;App/&gt;' }); 6、在App.vue中使用路由 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- router-link：默认会被渲染成一个&lt;a&gt;标签，to属性为指定链接 router-view：用于渲染路由匹配到的组件 --&gt; &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/content&quot;&gt;内容&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ name:'App' } &lt;/script&gt; &lt;style&gt;&lt;/style&gt; 十二、实战快速上手 我们采用实战教学模式并结合ElementUI组件库，将所需知识点应用到实际中，以最快速度带领大家掌握Vue的使用； 12.1、创建工程 注意：命令行都要使用管理员模式运行 1、创建一个名为hello-vue的工程vue init webpack hello-vue 2、安装依赖， 我们需要安装vue-router、element-ui、sass-loader和node-sass四个插件 #进入工程目录 cd hello-vue #安装vue-routern npm install vue-router --save-dev #安装element-ui npm i element-ui -S #安装依赖 npm install # 安装SASS加载器 cnpm install sass-loader node-sass --save-dev #启功测试 npm run dev 3、Npm命令解释： npm install moduleName：安装模块到项目目录下 npm install -g moduleName：-g的意思是将模块安装到全局，具体安装到磁盘哪个位置要看npm config prefix的位置 npm install -save moduleName：–save的意思是将模块安装到项目目录下， 并在package文件的dependencies节点写入依赖，-S为该命令的缩写 npm install -save-dev moduleName:–save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖，-D为该命令的缩写 12.2、创建登录页面 把没有用的初始化东西删掉！ 在源码目录中创建如下结构： assets：用于存放资源文件 components：用于存放Vue功能组件 views：用于存放Vue视图组件 router：用于存放vue-router配置 创建首页视图，在views目录下创建一个名为Main.vue的视图组件： &lt;template&gt; &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:&quot;Main&quot; } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 创建登录页视图在views目录下创建名为Login.vue的视图组件，其中el-*的元素为ElementUI组件； &lt;template&gt; &lt;div&gt; &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt; &lt;h3 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=&quot;账号&quot; prop=&quot;username&quot;&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.username&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;onsubmit('loginForm')&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=&quot;温馨提示&quot; :visible.sync=&quot;dialogVisiable&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Login&quot;, data(){ return{ form:{ username:'', password:'' }, //表单验证，需要在 el-form-item 元素中增加prop属性 rules:{ username:[ {required:true,message:&quot;账号不可为空&quot;,trigger:&quot;blur&quot;} ], password:[ {required:true,message:&quot;密码不可为空&quot;,tigger:&quot;blur&quot;} ] }, //对话框显示和隐藏 dialogVisible:false } }, methods:{ onSubmit(formName){ //为表单绑定验证功能 this.$refs[formName].validate((valid)=&gt;{ if(valid){ //使用vue-router路由到指定界面，该方式称为编程式导航 this.$router.push('/main'); }else{ this.dialogVisible=true; return false; } }); } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; .login-box{ border:1px solid #DCDFE6; width: 350px; margin:180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399; } .login-title{ text-align:center; margin: 0 auto 40px auto; color: #303133; } &lt;/style&gt; 创建路由，在router目录下创建一个名为index.js的vue-router路由配置文件 //导入vue import Vue from 'vue'; import VueRouter from 'vue-router'; //导入组件 import Main from &quot;../views/Main&quot;; import Login from &quot;../views/Login&quot;; //使用 Vue.use(VueRouter); //导出 export default new VueRouter({ routes: [ { //登录页 path: '/main', component: Main }, //首页 { path: '/login', component: Login }, ] }) APP.vue &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', } &lt;/script&gt; &lt;style&gt; #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &lt;/style&gt; main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from &quot;./router&quot; import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(router) Vue.use(ElementUI) /* eslint-disable no-new */ new Vue({ el: '#app', router, render:h=&gt;h(App) }) 测试：在浏览器打开 http://localhost:8080/#/login 如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.0.2，需要退回到7.3.1 ； 去package.json文件里面的 &quot;sass-loader&quot;的版本更换成7.3.1，然后重新cnpm install就可以了； 12.3、路由嵌套 嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。 demo 1、 创建用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件； Profile.vue &lt;template&gt; &lt;h1&gt;个人信息&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;UserProfile&quot; } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 2、在用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件； List.vue &lt;template&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;UserList&quot; } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 3、 修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下： Main.vue &lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;el-menu :default-openeds=&quot;['1']&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt;用户管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;!--插入的地方--&gt; &lt;router-link to=&quot;/user/profile&quot;&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt; &lt;!--插入的地方--&gt; &lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt;内容管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;分类管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;内容列表&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;!--在这里展示视图--&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Main&quot; } &lt;/script&gt; &lt;style scoped lang=&quot;scss&quot;&gt; .el-header { background-color: #B3C0D1; color: #333; line-height: 60px; } .el-aside { color: #333; } &lt;/style&gt; 4、 配置嵌套路由修改 router 目录下的 index.js 路由配置文件，使用children放入main中写入子模块，代码如下 index.js //导入vue import Vue from 'vue'; import VueRouter from 'vue-router'; //导入组件 import Main from &quot;../views/Main&quot;; import Login from &quot;../views/Login&quot;; //导入子模块 import UserList from &quot;../views/user/List&quot;; import UserProfile from &quot;../views/user/Profile&quot;; //使用 Vue.use(VueRouter); //导出 export default new VueRouter({ routes: [ { //登录页 path: '/main', component: Main, // 写入子模块 children: [ { path: '/user/profile', component: UserProfile, }, { path: '/user/list', component: UserList, }, ] }, //首页 { path: '/login', component: Login }, ] }) 5、 路由嵌套实战效果图 图 路由嵌套效果图 12.4、参数传递 这里演示如果请求带有参数该怎么传递 demo 用的还是上述例子的代码 修改一些代码 这里不放重复的代码了 第一种取值方式 1、 修改路由配置, 主要是router下的index.js中的 path 属性中增加了 :id 这样的占位符 { path: '/user/profile/:id', name:'UserProfile', component: UserProfile } 2、传递参数 此时我们在Main.vue中的route-link位置处 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径； &lt;!--name是组件的名字 params是传的参数 如果要传参数的话就需要用v:bind:来绑定--&gt; &lt;router-link :to=&quot;{name:'UserProfile',params:{id:1}}&quot;&gt;个人信息&lt;/router-link&gt; 3、在要展示的组件Profile.vue中接收参数 使用 {{$route.params.id}}来接收 Profile.vue 部分代码 &lt;template&gt; &lt;!-- 所有的元素必须在根节点下--&gt; &lt;div&gt; &lt;h1&gt;个人信息&lt;/h1&gt; {{$route.params.id}} &lt;/div&gt; &lt;/template&gt; 第二种取值方式 使用props 减少耦合 1、修改路由配置 , 主要在router下的index.js中的路由属性中增加了 props: true 属性 { path: '/user/profile/:id', name:'UserProfile', component: UserProfile, props: true } 2、传递参数和之前一样 在Main.vue中修改route-link地址 &lt;!--name是组件的名字 params是传的参数 如果要传参数的话就需要用v:bind:来绑定--&gt; &lt;router-link :to=&quot;{name:'UserProfile',params:{id:1}}&quot;&gt;个人信息&lt;/router-link&gt; 3、在Profile.vue接收参数为目标组件增加 props 属性 Profile.vue &lt;template&gt; &lt;div&gt; 个人信息 {{ id }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['id'], name: &quot;UserProfile&quot; } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 图 传参效果图 12.5、组件重定向 重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如： 在router下面index.js的配置 { path: '/main', name: 'Main', component: Main }, { path: '/goHome', redirect: '/main' } 说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件； 使用的话，只需要在Main.vue设置对应路径即可； &lt;el-menu-item index=&quot;1-3&quot;&gt; &lt;router-link to=&quot;/goHome&quot;&gt;回到首页&lt;/router-link&gt; &lt;/el-menu-item&gt; 12.6、路由模式与 404 路由模式有两种 hash：路径带 # 符号，如 http://localhost/#/login history：路径不带 # 符号，如 http://localhost/login 修改路由配置，代码如下： export default new Router({ mode: 'history', routes: [ ] }); 404 demo 1.创建一个NotFound.vue视图组件 NotFound.vue &lt;template&gt; &lt;div&gt; &lt;h1&gt;404,你的页面走丢了&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;NotFound&quot; } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 2.修改路由配置index.js import NotFound from '../views/NotFound' { path: '*', component: NotFound } 3.效果图 图 404效果图 路由钩子与异步请求 beforeRouteEnter：在进入路由前执行 beforeRouteLeave：在离开路由前执行 在Profile.vue中写 export default { name: &quot;UserProfile&quot;, beforeRouteEnter: (to, from, next) =&gt; { console.log(&quot;准备进入个人信息页&quot;); next(); }, beforeRouteLeave: (to, from, next) =&gt; { console.log(&quot;准备离开个人信息页&quot;); next(); } } 参数说明： to：路由将要跳转的路径信息 from：路径跳转前的路径信息 next：路由的控制参数 next() 跳入下一个页面 next(’/path’) 改变路由的跳转方向，使其跳到另一个路由 next(false) 返回原来的页面 next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例 在钩子函数中使用异步请求 1、安装 Axios cnpm install --save vue-axios 2、main.js引用 Axios import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。 数据和之前用的json数据一样 需要的去上述axios例子里 // 静态数据存放的位置 static/mock/data.json 4.在 beforeRouteEnter 中进行异步请求 Profile.vue export default { //第二种取值方式 // props:['id'], name: &quot;UserProfile&quot;, //钩子函数 过滤器 beforeRouteEnter: (to, from, next) =&gt; { //加载数据 console.log(&quot;进入路由之前&quot;) next(vm =&gt; { //进入路由之前执行getData方法 vm.getData() }); }, beforeRouteLeave: (to, from, next) =&gt; { console.log(&quot;离开路由之前&quot;) next(); }, //axios methods: { getData: function () { this.axios({ method: 'get', url: 'http://localhost:8080/static/mock/data.json' }).then(function (response) { console.log(response) }) } } } 5.路由钩子和axios结合图 图 效果图 ","link":"https://ganhan999.github.io/post/Java Vue/"},{"title":"中等54. 螺旋矩阵","content":"题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 利用余数作为改方向的手段，并且遍历的顺序是右下左上， dx = [0, 1, 0, -1] # 方向：右，下，左，上 dy = [1, 0, -1, 0] # 注：与通常平面坐标系 记号 不同 到了尽头了就变一次 大神做法1： class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix: return [] x = y = 0 # 矩阵元素位置初始化 res = [] # 初始化，存储遍历后的矩阵元素 dx = [0, 1, 0, -1] # 方向：右，下，左，上 dy = [1, 0, -1, 0] # 注：与通常平面坐标系 记号 不同 di = 0 # 初始化方向变量 visited = set() # 初始化集合，存储已走过的坐标 m, n = len(matrix), len(matrix[0]) # 矩阵的行列 for i in range(m * n): # res.append(matrix[x][y]) # 存储遍历矩阵过的元素 visited.add((x, y)) # 存储遍历过的坐标 tx, ty = x + dx[di], y + dy[di] # 先记录下一步坐标，用于判断下一步怎么走 if 0 &lt;= tx &lt; m and 0 &lt;= ty &lt; n and (tx, ty) not in visited: # 判断坐标是否需变向，且没有遍历过 x, y = tx, ty else: di = (di + 1) % 4 # 改变方向，右下左上为一圈，防止方向坐标越界 x, y = x + dx[di], y + dy[di] # 下一步坐标 return res &quot;&quot;&quot;&quot;&quot;&quot; 可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。 定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。 例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。 大神做法2： class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix or not matrix[0]: return list() rows, columns = len(matrix), len(matrix[0]) order = list() left, right, top, bottom = 0, columns - 1, 0, rows - 1 while left &lt;= right and top &lt;= bottom: for column in range(left, right + 1): order.append(matrix[top][column]) for row in range(top + 1, bottom + 1): order.append(matrix[row][right]) if left &lt; right and top &lt; bottom: for column in range(right - 1, left, -1): order.append(matrix[bottom][column]) for row in range(bottom, top, -1): order.append(matrix[row][left]) left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return order &quot;&quot;&quot;&quot;&quot;&quot; 利用zip函数，每次都把那一行或者那一列pop出来，然后用zip函数生成新的矩阵 太妙了大神做法3： class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: res = [] while matrix: res += matrix.pop(0) matrix = list(zip(*matrix))[::-1] return res ","link":"https://ganhan999.github.io/post/54、螺旋矩阵/"},{"title":"中等50. Pow(x, n)","content":"题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归 每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def myPow(self, x: float, n: int) -&gt; float: def quickMul(N): if N == 0: return 1.0 y = quickMul(N // 2) return y * y if N % 2 == 0 else y * y * x#当是奇数的时候会乘以x，特殊情况当是1的时候，返回1.0*1.0*x。 return quickMul(n) if n &gt;= 0 else 1.0 / quickMul(-n)#如果n是负数，则取倒数，再做运算 &quot;&quot;&quot;&quot;&quot;&quot; 利用迭代，节省栈内存 大神做法2： class Solution: def myPow(self, x: float, n: int) -&gt; float: def quickMul(N): ans = 1.0 # 贡献的初始值为 x x_contribute = x # 在对 N 进行二进制拆分的同时计算答案 while N &gt; 0: if N % 2 == 1: # 如果 N 二进制表示的最低位为 1，那么需要计入贡献 ans *= x_contribute # 将贡献不断地平方 x_contribute *= x_contribute # 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可 N //= 2 return ans return quickMul(n) if n &gt;= 0 else 1.0 / quickMul(-n) ","link":"https://ganhan999.github.io/post/50、Pow(x, n)/"},{"title":"中等49. 字母异位词分组","content":"题目 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;] 输出: [ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 直接构造哈希表（字典形式），排序后的字母当作键，原字母当成值 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: mp = collections.defaultdict(list) for st in strs: key = &quot;&quot;.join(sorted(st))#sorted(&quot;abc&quot;) ---&gt;['a', 'b', 'c'] mp[key].append(st)#如果是普通的字典，那么这里就会报错，如果是defaultdict，默认值就是一个空列表 return list(mp.values()) 直接构造哈希表（字典形式），将计数的字母表当作键，原字母当成值 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法2： class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: mp = collections.defaultdict(list) for st in strs: counts = [0] * 26 for ch in st: counts[ord(ch) - ord(&quot;a&quot;)] += 1 # 需要将 list 转换成 tuple 才能进行哈希 mp[tuple(counts)].append(st) return list(mp.values()) 直接构造哈希表（字典形式），排序后的字母当作键，原字母当成值 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法3： class Solution: prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103] def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: mp = collections.defaultdict(list) for st in strs: c=1 counts = [0] * 26 for cc in st: c *= Solution.prime[ord(cc)-97] mp[c].append(st) return list(mp.values()) python中defaultdict用法详解 ''' 当我使用普通的字典时，用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此， print(dict[element]),但前提是element字典里，如果不在字典里就会报错。 这时defaultdict就能排上用场了，defaultdict的作用是在于，当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值。 作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0 ''' ","link":"https://ganhan999.github.io/post/49、字母异位词分组/"},{"title":"中等48. 旋转图像I","content":"题目 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 先水平翻转，再主对角线反转 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix) # 水平翻转 for i in range(n // 2): for j in range(n): matrix[i][j], matrix[n - i - 1][j] = matrix[n - i - 1][j], matrix[i][j] # 主对角线翻转 for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] ","link":"https://ganhan999.github.io/post/48、旋转图像/"},{"title":"中等47. 全排列 II","content":"题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 如果要比较两个列表是否一样，一个容易想到的办法是对列表分别排序，然后逐个比对。既然要排序，我们就可以 在搜索之前就对候选数组排序，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复列表。 if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: def dfs(nums, size, depth, path, used, res): if depth == size: res.append(path.copy()) return for i in range(size): if not used[i]: if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:#还没被撤销的节点则可以构成一组完整的结，如果被撤销了那么就是重复的结。 continue used[i] = True path.append(nums[i]) dfs(nums, size, depth + 1, path, used, res) used[i] = False path.pop() size = len(nums) if size == 0: return [] nums.sort() used = [False] * len(nums) res = [] dfs(nums, size, 0, [], used, res) return res ","link":"https://ganhan999.github.io/post/47、全排列 II/"},{"title":"java接口和抽象类的区别和作用（功能、用途、好处）","content":"Java接口： 总结了4点关于JAVA中接口存在的意义： ​ 1、重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。 2、简单、规范性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。 3、维护、拓展性：比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。 ​ 可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。 ​ 如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。 4、安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些（一般软件服务商考虑的比较多）。 那么什么是接口呢？ 接口是一种能力 1：接口的命名规则与类型不同。如果修饰符是public。则该接口在整个项目中可见 ，如果省略修饰符 则该接口只能在该包可见 2：接口中可以定义常量，不能定义变量，接口中的属性都会自动用public static final修饰，即接口中的属性都是全局静态常量，接口中的常量必须在定义时指定初始值 3：接口中所有的方法抽象方法。接口中的方法都会自动用public abstract修饰。即接口中只有全局抽象方法， 4：和抽象类一样，接口不能被实例化，接口中不能有狗构造方法 5：接口之间可以通过extends 实现继承关系，一个接口可以继承多个接口。但接口不能继承类 6：接口的实现类必须实现接口的全部方法，否则必须定义为抽象类 7：一个类只能有一个直接父类，但可以通过implements实现多个接口，当雷在继承父类的同时有实现了多个接口时，extends关键字必须位于implements关键字之前 接口的注意事项： 01.接口不能实例化，因为接口是比抽象类抽象程度更高的类型 02一个类如果实现了某个接口，必须重写该接口中的所有方法 03.接口不能有构造，但是抽象类可以有 04.接口中所有方法都公有的抽象方法 05.接口中的所有字段必须都是公有的静态常量 06.接口本身也是一种数据类型 07.接口只是为实现它的类定义了规范，保证实现类方法签名和接口中对应方法一致。 08.通过接口可以实现多继承 09.一个借口中最好只定义一个方法，防止接口污染 java中接口的特点： 接口中的方法，永远都被public来修饰 接口中没有构造方法，也不能实例化接口对象 接口中只有方法的声明，没有方法体 接口中只有常量，如果定义变量，在编译的时候都会默认加上“public static final” 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类 静态方法不能被子类重写（覆盖），因此接口中不定声明静态方法 使用接口可以实现多继承 抽象类： 抽象类就是不能使用new方法进行实例化的类（不能被实例化，可以有多个抽象方法），即没有具体实例对象的类，抽象类有点类似于“模板”的作用,目的是根据其格式来创建和修改新的类，对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象，当一个类被声明为抽象类时，要在这个类前面加上修饰符abstract,在抽象类中的成员方法可以包括一般方法和抽象方法 抽象类的关键字：abstract abstract 关键字，和哪些关键字不能共存？ final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。 private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。 而抽象方法出现的就是需要被复写。 static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了 java中抽象类的特点： 如果一个类中有抽象方法，那么这个类一定是抽象类 抽象类中不一定有抽象方法 抽象类中可以存在抽象方法 抽象类中可以存在构造方法 抽象类中可以存在普通属性、方法、静态属性和静态方法 抽象类中的抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的 7，抽象方法和抽象类都必须被abstract关键字修饰。 8，抽象类不可以用new创建对象。因为调用抽象方法没意义 9：抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法 接口和抽象类的区别之处： 接口中所有的方法隐含都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的 抽象类可以在不提供接口方法实现的情况下实现接口 java接口中声明的变量默认都是final的，抽象类可以包含非final变量 java接口中的成员函数默认都是public的，抽象类中的成员函数可以是private，protected或者是public的 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是如果它包含main方法的话是可以被调用的 8：抽象类中可以有普通方法，接口中不能。 9：抽象类可以有构造，接口不能 10：抽象类中可以有普通字段，而接口中不行 11：抽象类不能实现多继承，接口可以 12：符合isa关系的选用抽象类，符合hasa关系的选用接口比抽象类抽象程度更高 ","link":"https://ganhan999.github.io/post/Java 接口和抽象类/"},{"title":"中等46. 全排列","content":"题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 用回溯的模板做，建立树形结构 1 2 3 2 3 1 3 1 2 3 2 3 1 2 1 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: self.res = [] def backtrack(path,nums): if not nums: self.res.append(path[:]) return for i in range(len(nums)): path.append(nums[i]) backtrack(path, nums[:i]+nums[i+1:])#把除了自己的数字取掉 path.pop() backtrack([],nums) return self.res &quot;&quot;&quot;&quot;&quot; 大神做法2： 见缝插针法，依次将每个数插入缝中 class Solution: def permute(self, nums): res = [[nums[0]]] tem = [] n = len(nums) for i in range(1,n): for k in res: for j in range(len(k)+1): k.insert(j,nums[i])#在索引为j的位置插入元素 tem.append(k[:]) k.pop(j)#删除索引为j的元素 res=tem tem=[] return res &quot;&quot;&quot;&quot;&quot; 大神做法3： 利用动态维护数组，标记已经填过和待填的数组，这样就不用添加path了，当待填数字为0的时候就表示已经形成了一组有效的数组 class Solution: def permute(self, nums): def backtrack(first=0): # 所有数都填完了 if first == n: res.append(nums[:]) for i in range(first, n): # 动态维护数组 nums[first], nums[i] = nums[i], nums[first] # 继续递归填下一个数 backtrack(first + 1) # 撤销操作 nums[first], nums[i] = nums[i], nums[first] n = len(nums) res = [] backtrack() return res ","link":"https://ganhan999.github.io/post/46、全排列/"},{"title":"Java SpringMVC","content":"1 介绍 学习视频：https://www.bilibili.com/video/BV1aE41167Tu 笔记是B站狂神说相关视频的学习笔记 Spring:IOC和AOP必须掌握 SpringMVC:执行流程必须掌握 官网：https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html 1.1 什么是MVC？ Model：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View:负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（调度员）： 接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最常用的MVC：（Model）Bean +（view） Jsp +（Controller） Servlet [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6GeCrArV-1596422947892)(E:\\Java\\markdown_notes\\photos\\image-20200423211601751.png)] 1.2 Model1时代 分为：视图层V和模型层M；由视图层的view来控制分发数据并展示给用户 缺点：JSP职责不单一，过重，不便于维护 1.3 Model2时代（MVC延续至今） 流程：分为了Contrller,Model,View 访问流程： 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 1.4 回顾Servlet创建 创建maven,父工程：pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ssl&lt;/groupId&gt; &lt;artifactId&gt;SpringMVC&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--父工程导入依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--资源过滤器，防止导入资源失败问题，最好在父子pom.xml里都加入一下代码--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 创建子工程，idea右键Add Framwork Support添加web支持 实现HelloServlet继承HttpServlet接口，并创建/WEB-INF/jsp/test.jsp public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1 获得参数 //2 调用业务层 //3 视图转发或者重定向 req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); } } web.xml中注册HelloServlet,测试跳转：http://localhost:8080/springmvc_01_servlet//helloServlet &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ssl.web.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 2 第一个SpringMVC 概念：SpringMVC是Spring框架中的一个分支，是基于Java实现MVC的轻量级Web框架 核心：Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计的。 2.1 执行原理 SpringMVC底层工作原理： DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 假设url为 : http://localhost:8080/SpringMVC/hello 服务器域名：http://localhost:8080 web站点：/SpringMVC hello表示控制器：/hello 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 2.2 不使用注解开发 了解具体的执行过程=面试谈资。虽然开发中不会这么麻烦的使用，但必须看完-理解-继续学习 1 配置web.xml 完成DispatcherServlet，关联resource配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet:SpringMVC核心--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个SpringMvc的resource配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMvc_servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--匹配所有的请求： / :只匹配请求，不包含所有的.jsp /*:匹配所有的请求，包括jsp页面 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 2 配置springMvc_servlet.xml 获得视图解析器、映射器、适配器，绑定跳转url &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--处理器映射器HandlerMapping:查找访问的url控制器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;!--处理器适配器HandlerAdapter：controller将处理好的数据返回给HandlerAdapter--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!--视图解析器ViewResolver：将后端处理好的数据和视图传给DispatchServlet，DS再交给ViewResolver先解析一遍，确认无误再传给前端 必须熟悉，以后还要学模版引擎Thymeleaf/Freemarker... 1 获取ModeAndView的数据 2 解析ModeAndView的视图名字 3 拼接视图名字，找到对应的视图 WEB-INF/jsp/hello.jsp --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--BeanNameUrlHandlerMapping处理器：绑定跳转的url=页面访问的网址--&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.ssl.controller.HelloController&quot;/&gt; &lt;/beans&gt; 3 /WEB-INF/jsp/hello.jsp &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--接受传递的参数--%&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 4 HelloController实现Controller 访问：http://localhost:8080/springmvc_02_hellomvc/hello public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //1 创建modelAndView ModelAndView mv = new ModelAndView(); //2 调用业务层，这里没有，就不写 //3 封装对象，放在mv中添加 mv.addObject(&quot;msg&quot;, &quot;Hello SpringMvc&quot;); //4 封装要跳转的视图，WEB-INF/jsp/hello.jsp mv.setViewName(&quot;hello&quot;); return mv; } } 5 SpringMVC原理回顾 反复观看，理解原理！ 2.3 使用注解开发 1 web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--与前面一样--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMvc_servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 2 springMvc_servlet.xml 注解省略了映射器、适配器，专注于写视图解析器；跳转的Controller也不用配置进Spring &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=&quot;com.ssl.controller&quot;/&gt; &lt;!--让SpringMvc不处理静态资源。让.css,.js等不进视图解析器--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--注解加载映射器、适配器，不用之前那么麻烦配置了--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 3 /WEB-INF/jsp/hello.jsp &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 4 HelloController 简化了实现的接口，使用@注解配置映射器 访问：http://localhost:8080/springmvc_03_annotation/hello @Controller public class HelloController { /** * @param model 模型 * @return 被视图解析器处理：访问&quot;/WEB-INF/jsp/hello.jsp资源 * 访问的url:RequestMapping(&quot;/hello&quot;) */ @RequestMapping(&quot;/hello&quot;) public String hello(Model model) { //封装数据 model.addAttribute(&quot;msg&quot;, &quot;Hello SpringMvc_annotation&quot;); //被视图解析器处理：访问&quot;/WEB-INF/jsp/hello.jsp资源 return &quot;hello&quot;; } 3 Controller和RestFul 配置web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring_mvc_servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- &lt;filter&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;filter-class&gt;com.ssl.filter.EncodeFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;--&gt; &lt;filter&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; spring_mvc_servlet.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=&quot;com.ssl.controller&quot;/&gt; &lt;!--让SpringMvc不处理静态资源。让.css,.js等不进视图解析器--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--注解加载映射器、适配器，不用之前那么麻烦配置了--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--以上的是定死的代码， 以下是配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--不使用注解开发的适配器：/demo1,注意点是id需要配置/--&gt; &lt;bean id=&quot;/demo&quot; class=&quot;com.ssl.controller.ControllerDemo1&quot;/&gt; &lt;/beans&gt; 3.1 Controller 不使用注解，极其不推荐使用，因为： 配置麻烦：&lt;bean id=&quot;/demo&quot; class=&quot;com.ssl.controller.ControllerDemo1&quot;/&gt;，并且需要 implements Controller 不够灵活，太费力气，浪费时间 访问：http://localhost:8080/springmvc_04_controller/demo public class ControllerDemo1 implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;demo1&quot;,&quot;demo1:Controller会返回一个modelAndView&quot;); modelAndView.setViewName(&quot;demo1&quot;); return modelAndView; } } 3.2 @Controller 使用注解开发，@Controller注册进Spring容器，如果返回值是String，并且有具体的页面可以跳转，那么就会被视图解析器解析 访问：http://localhost:8080/springmvc_04_controller/demo2 @Controller public class ControllerDemo2 { @RequestMapping(&quot;/demo2&quot;) public String test1(Model model) { model.addAttribute(&quot;demo2&quot;, &quot;demo2&quot;); return &quot;demo2&quot;; } } 3.3 @RequestMapping 可以在类和方法上配置url访问路径 访问：http://localhost:8080/springmvc_04_controller/controller/demo3 @Controller @RequestMapping(&quot;/controller&quot;) public class ControllerDemo3 { @RequestMapping(&quot;/demo3&quot;) public String test1(Model model) { model.addAttribute(&quot;demo3&quot;, &quot;demo3&quot;); return &quot;demo3&quot;; } } 3.4 RestFul风格 优点： 最大的优势是安全，看不出源代码的参数和意义 实现地址复用，使得get和post访问url相同，框架会自动进行类型转换 高效：支持缓存 缺点： 不像原生的url见名知意，url理解不直观 实现方式： 1：url @GetMapping(&quot;/addRest/{a}/{b}&quot;) + 参数 @PathVariable int a, @PathVariable int b 访问：http://localhost:8080/springmvc_04_controller/addRest/1/2 2：url @PostMapping(&quot;/addRest/{a}/{b}&quot;) + 参数不变 @PathVariable int a, @PathVariable int b 使用Postman中的post访问：http://localhost:8080/springmvc_04_controller/addRest/1/2 @Controller public class RestFulController { /** * 原生的url：http://localhost:8080/springmvc_04/add?a=1&amp;b=1 */ @RequestMapping(&quot;/add&quot;) public String getAdd1(int a, int b, Model model) { int result = a + b; model.addAttribute(&quot;add&quot;, &quot;原生的url：结果为&quot; + result); return &quot;add&quot;; } /** * RestFul方式一：method = get * RequestMapping(&quot;/addRest/{a}/{b}&quot; method=requestMethod.GET) = @GetMapping() * http://localhost:8080/springmvc_04/addRest/1/1 */ @GetMapping(&quot;/addRest/{a}/{b}&quot;) public String getAdd2(@PathVariable int a, @PathVariable int b, Model model) { int result = a + b; model.addAttribute(&quot;add&quot;, &quot;Rest的url：结果为&quot; + result); return &quot;addRest&quot;; } /** * 复用相同的url * RestFul方式二：method=post，使用RestFul的话，请求的url和GET就一样了 */ @PostMapping(&quot;/addRest/{a}/{b}&quot;) public String getAdd3(@PathVariable int a, @PathVariable int b, Model model) { int result = a + b; model.addAttribute(&quot;add&quot;, &quot;Rest的url：结果为&quot; + result); return &quot;addRest&quot;; } } 3.5 重定向和转发 可以使用原生的request转发或者response重定向 推荐使用SpringMvc的return “forward:xxx”/&quot;redirect:xxx&quot; @Controller public class ModelTest1 { //原生的转发：返回值是void，没有经过视图解析器；原生的重定向同样如此，都不走视图解析器，直接重定向 @RequestMapping(&quot;/test1&quot;) public void test1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String id = request.getSession().getId(); System.out.println(id); request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request,response); } //SpringMvc转发：测试结果是不走视图解析器，url没变是转发 @RequestMapping(&quot;/test2&quot;) public String test2(Model model) { model.addAttribute(&quot;demo1&quot;,&quot;这是test2中的Spring转发&quot;); return &quot;forward:/WEB-INF/jsp/demo1.jsp&quot;; } //SpringMvc重定向：测试结果是不走视图解析器 @RequestMapping(&quot;/test3&quot;) public String test3() { System.out.println(&quot;跳转回首页index.jsp&quot;); return &quot;redirect:index.jsp&quot;; } } 3.6 接受请求参数和数据回显 前端提交的name和后端映射器接受的形参名一样，则直接接受 前端提交的name和后端映射器接受的形参名不用一样，再形参前 @RequestParam(&quot;xxx&quot;) 更改名称一致 养成习惯：无论是否一样，都必须加上@RequestParam 后端参数封装如果成一个pojo，前端传过来的name会自动pojo中的成员属性，不匹配的属性=null/0 如何解决中文乱码问题？请看下节！ @Controller public class UserController { /** http://localhost:8080/springmvc_04/t1?id=1&amp;name=abc&amp;age=18 * @param user SpringMvc 会自动封装数据到参数里的pojo，不匹配的属性=null/0 */ @GetMapping(&quot;/t1&quot;) public String getUser(User user){ System.out.println(user); return &quot;test1&quot;; } } 3.7 Model，ModelAndView等 Model：精简版，适合初学者，大多数情况封装参数，设置转发视图层就够用 ModelMap：继承了LinkedHashMap，有它的方法和特性 ModelAndView：可以在存储数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转 怎么学习：用80%的时间学号基础，18%时间研究框架，2%学点英文，剩下不会的看官方文档 4 乱码问题 方法一：web.xml里面配置的SpringMvc自带的过滤器 CharacterEncodingFilter &lt;url-pattern&gt;/\\*&lt;/url-pattern&gt;：因为要跳转到xxx.jsp页面，所以url是/*(≠/) &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置SpringMVC--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring_mvc_servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--web容器解决中文乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 方法二：一劳永逸，但需要重启Tomcat服务器，修改Tomcat里面的server.xml配置文件：URIEncoding = &quot;UTF-8&quot; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding = &quot;UTF-8&quot;/&gt; &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt; 5 JSON 5.1 前端初识Json 前端展示两者数据，学会js和json互相转换 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;json&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //user是一个js对象 var user = { name: &quot;张三&quot;, age: 18, sex: &quot;男&quot; }; //后端传的json其实是一个字符串，前端将后端传的json转换成js对象渲染在页面上 //jsonUser:模拟后端传的json数据 //js转换成json var jsonUser = JSON.stringify(user); console.log(jsonUser); //jsUser：js是一个对象 //json转换成js var jsUser = JSON.parse(jsonUser); console.log(jsUser) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 5.2 Jackson Databind 使用 Jackson Databind可以快速生成json数据 1 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; json=一个字符串，所以会有中文乱码问题，需要在springmvc.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=&quot;com.ssl.controller&quot;/&gt; &lt;!--让SpringMvc不处理静态资源。让.css,.js等不进视图解析器--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--注解加载映射器、适配器，解决Json数据中文乱码问题--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--配置视图解析器，明确json数据不走数据解析器，直接传给前端--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 2 编写Controller @RestControoler:该类下所有方法不走视图解析器，返回一个json数据 @ResponseBody：该方法不走视图解析器，返回一个json数据 访问：http://localhost:8080/springmvc_05_json/t1，页面显示一个json数据，不经过视图解析器 回顾日期：new SimpleDateFormat(&quot;yyyy-MM-dd:HH:mm:ss&quot;) @RestController public class UserController { /* 概念：前后端分离的项目，后端代码不走视图解析器，后端传给前端的是json数据 方法上：注解@ResponseBody指定该方法不走视图解析器，会直接返回一个String=json数据就是一个字符串 类上：注解@RestController指定该类下的所有方法都不走视图解析器 Json返回一个对象 */ @RequestMapping(&quot;/t1&quot;) public String json1() throws JsonProcessingException { User user = new User(1, &quot;张三&quot;, 20); ObjectMapper jacksonMapper = new ObjectMapper(); String str_user = jacksonMapper.writeValueAsString(user); //user.toString()是自己指定的String但是公司通常是允许的，通常是使用第三方工具来返回String //str_user有中文乱码问题，springMvc可以统一配置 return str_user; } /** * Json返回一个List */ @RequestMapping(&quot;/t2&quot;) public String json2() throws JsonProcessingException { User user1 = new User(1, &quot;张三&quot;, 20); User user2 = new User(2, &quot;张三&quot;, 21); User user3 = new User(3, &quot;张三&quot;, 22); User user4 = new User(4, &quot;张三&quot;, 23); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); return new ObjectMapper().writeValueAsString(list); } /** * json返回一个日期格式 */ @RequestMapping(&quot;/t3&quot;) public String json3() throws JsonProcessingException { //方式一：原始纯java日期转换：推荐使用 // String date = new SimpleDateFormat(&quot;yyyy-MM-dd:HH-mm-ss&quot;).format(new Date()); ObjectMapper objectMapper = new ObjectMapper(); //方式二：使用mapper来制定日期格式，先关闭时间戳表示 objectMapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, false); objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd:HH:mm:ss&quot;)); Date date = new Date(); return objectMapper.writeValueAsString(date); } @Test public void DateTest1() { //传统的java日期格式转换 String date = new SimpleDateFormat(&quot;yyyy-MM-dd:HH:mm:ss&quot;).format(new Date()); System.out.println(date); } } 5.3 FastJson 阿里巴巴官方提供的，实现Json数据的另一个工具，比JackSon Databind更方便 1 导包 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; 2 编写Controller 比Jackson使用更方便 @RequestMapping(&quot;/t4&quot;) public String json4() throws JsonProcessingException { User user1 = new User(1, &quot;张三&quot;, 20); User user2 = new User(2, &quot;张三&quot;, 21); User user3 = new User(3, &quot;张三&quot;, 22); User user4 = new User(4, &quot;张三&quot;, 23); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); String jsonString = JSON.toJSONString(list); return jsonString; } 6 SSM整合 6.1 环境 IDEA+Mysq5.7+Tomca5.7+Maven3.6 数据库 create database `ssmbuild`; use `ssmbuild`; CREATE TABLE `books` ( `bookId` int(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` varchar(100) NOT NULL COMMENT '书名', `bookCounts` int(11) NOT NULL COMMENT '数量', `detail` varchar(200) NOT NULL COMMENT '描述', KEY `bookId` (`bookId`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ssl&lt;/groupId&gt; &lt;artifactId&gt;ssmbuild&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--依赖:junit,数据库驱动，连接池，Servlet，jsp，mybatis,mybatis-mvc,Spring,SpringMVC--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--Maven资源过滤设置--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 6.2 开发流程 需求分析+设计数据库+业务+传给前端页面 整体效果： 6.3 整合Mybatis mybatis-config.xml 数据库连接交给Spring-dao.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!--核心配置文件--&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!--配置数据源，交给Spring去做--&gt; &lt;!--取别名--&gt; &lt;typeAliases&gt; &lt;!--resultMap:默认类名小写为使用id--&gt; &lt;package name=&quot;com.ssl.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.ssl.dao.BookMapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; # db.properties配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8 username=root password=123456 6.4 整合Spring 1 spring-dao.xml 数据库连接读取db.properties有bug，手动连接jdbcurl和user &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1 关联数据库配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;!--2 连接池 这次使用c3p0的连接池.常见的数据库： dbcp:半自动操作，不能自动连接 c3p0：自动化操作，并且可以配置到对象中 druid,hikari(SpringBoot)--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;!--c3p0的私有属性--&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!--关闭连接后，不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!--3 sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--绑定数据库--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定Mybatis的配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--4 配置dao接口扫描包，动态的实现了dao接口可以注入到Spring容器中,不用写mapperImpl.xml--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--扫描要扫描的dao的包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.ssl.dao&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 2 spring-service.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1 扫描service下的包--&gt; &lt;context:component-scan base-package=&quot;com.ssl.service&quot;/&gt; &lt;!--2 将我们的所有业务类，注入到Spring,这里使用bean配置，平时是使用注解--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.ssl.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;!--3 声明式事务配置--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--4 AOP横切事务，这里用不到--&gt; &lt;/beans&gt; 3 application.xml 导入其他配置进spring主配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt; &lt;/beans&gt; 6.5 整合SpringMVC 增加web项目的支持 web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--SpringMVC配置--&gt; &lt;!--1 DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--2 乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--3 Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; spring-mvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1 注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3 扫描包：Controller--&gt; &lt;context:component-scan base-package=&quot;com.ssl.controller&quot;/&gt; &lt;!--4 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 6.6 dao层 BookMapper接口和BookMapperMapper.xml public interface BookMapper { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(@Param(&quot;bookId&quot;) int id); //修改一本书 int updateBook(Books books); //查询一本书根据id Books queryBookById(@Param(&quot;bookId&quot;)int id); //查询全部书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(@Param(&quot;bookName&quot;) String bookName); } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--核心配置文件--&gt; &lt;mapper namespace=&quot;com.ssl.dao.BookMapper&quot;&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName, bookCounts, detail) values (#{bookName},#{bookCounts},#{detail}); &lt;/insert&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookId = #{bookId} &lt;/delete&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName=#{bookName}, bookCounts=#{bookCounts}, detail=#{detail} where bookId=#{bookId}; &lt;/update&gt; &lt;select id=&quot;queryBookById&quot; parameterType=&quot;int&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookId = #{bookId}; &lt;/select&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books; &lt;/select&gt; &lt;select id=&quot;queryBookByName&quot; parameterType=&quot;String&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookName=#{bookName} &lt;/select&gt; &lt;/mapper&gt; 6.7 service层 public interface BookService { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(int id); //修改一本书 int updateBook(Books books); //查询一本书根据id Books queryBookById(int id); //查询全部书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(String bookName); } public class BookServiceImpl implements BookService { //注入Dao层 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books books) { return bookMapper.addBook(books); } @Override public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } @Override public int updateBook(Books books) { return bookMapper.updateBook(books); } @Override public Books queryBookById(int id) { return bookMapper.queryBookById(id); } @Override public List&lt;Books&gt; queryAllBook() { return bookMapper.queryAllBook(); } @Override public Books queryBookByName(String bookName) { return bookMapper.queryBookByName(bookName); } } 6.8 controller层 @Controller @RequestMapping(&quot;/book&quot;) public class BookController { @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; //查询全部的书籍，并且返回到一个书籍展示页面 @RequestMapping(&quot;/allBook&quot;) public String list(Model model) { List&lt;Books&gt; books = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, books); return &quot;allBook&quot;; } //跳转到增加书籍页面 @RequestMapping(&quot;/toAddBook&quot;) public String toAddBook() { return &quot;addBook&quot;; } //添加书籍 @RequestMapping(&quot;/addBook&quot;) public String addBook(Books books) { int result = bookService.addBook(books); if (result &gt; 0) { System.out.println(&quot;添加书籍成功&quot;); } return &quot;redirect:/book/allBook&quot;; } @RequestMapping(&quot;/toUpdateBook&quot;) public String toUpdate(int bookId, Model model) { Books books = bookService.queryBookById(bookId); model.addAttribute(&quot;book&quot;, books); return &quot;updateBook&quot;; } /* 没有提交事务操作，更新会失败 */ @RequestMapping(&quot;/updateBook&quot;) public String updateBook(Books books) { int result = bookService.updateBook(books); if (result &gt; 0) { System.out.println(&quot;修改书籍成功&quot;); } return &quot;redirect:/book/allBook&quot;; } /* 删除书籍，回顾RestFul风格 */ @RequestMapping(&quot;/deleteBook/{bookId}&quot;) public String deleteBook(@PathVariable(&quot;bookId&quot;) int bookId) { int result = bookService.deleteBookById(bookId); if (result &gt; 0) { System.out.println(&quot;删除书籍成功&quot;); } return &quot;redirect:/book/allBook&quot;; } @RequestMapping(&quot;/queryBook&quot;) public String queryBook(String queryBookName, Model model) { Books books = bookService.queryBookByName(queryBookName); //复用，这样就显示一个 List&lt;Books&gt; list = new ArrayList&lt;&gt;(); list.add(books); if (books == null) { list= bookService.queryAllBook(); model.addAttribute(&quot;errMsg&quot;,&quot;未查任何书籍&quot;); } model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; } } 6.9 前端页面 index.xml &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;style&gt; /*消除字体蓝色下划线*/ a { text-decoration: none; color: black; font-size: 18px; } h3 { width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;进入书籍展示页面&lt;/a&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; WEB-INF/jsp/addBook.jsp &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;%--BootStrap美化界面--%&gt; &lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;%--屏幕分成12列--%&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%--BootStrap官网拿&quot;表单&quot;数据 name属性保证pojo属性名称一致 required保证必须提交--%&gt; &lt;form action=&quot;${pageContext.request.contextPath}/book/addBook&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bName&quot;&gt;书籍名称:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;bookName&quot; class=&quot;form-control&quot; id=&quot;bName&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bCount&quot;&gt;书籍数量：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; class=&quot;form-control&quot; id=&quot;bCount&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bDesc&quot;&gt;书籍描述：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;detail&quot; class=&quot;form-control&quot; id=&quot;bDesc&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;form-control&quot; value=&quot;添加&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; WEB-INF/jsp/allBook.jsp &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%-- Created by IntelliJ IDEA. User: 宋林 Date: 2020/3/31 Time: 20:50 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;书籍展示页面&lt;/title&gt; &lt;%--BootStrap美化界面--%&gt; &lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;%--屏幕分成12列--%&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt; 书籍列表——————————显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 column&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增书籍&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;显示全部书籍&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4 column&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-md-8 column&quot;&gt; &lt;form action=&quot;${pageContext.request.contextPath}/book/queryBook&quot; method=&quot;post&quot; style=&quot;float: right&quot;&gt; &lt;%--前端未传任何信息，就显示错误提示信息：未查任何书籍--%&gt; &lt;span style=&quot;color: red;font-weight: bold&quot;&gt;${errMsg}&lt;/span&gt; &lt;%--class=&quot;form-inline&quot;保证在同一行--%&gt; &lt;input type=&quot;text&quot; name=&quot;queryBookName&quot; class=&quot;form-inline&quot; placeholder=&quot;请输入要查询的书籍名称&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;table class=&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;%--书籍从数据库中查询出来，从这个list中遍历出来，foreach--%&gt; &lt;tbody&gt; &lt;c:forEach var=&quot;book&quot; items=&quot;${list}&quot;&gt; &lt;tr&gt; &lt;td&gt;${book.bookId}&lt;/td&gt; &lt;td&gt;${book.bookName}&lt;/td&gt; &lt;td&gt;${book.bookCounts}&lt;/td&gt; &lt;td&gt;${book.detail}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?bookId=${book.bookId}&quot;&gt;修改&lt;/a&gt; &amp;nbsp; | &amp;nbsp; &lt;a href=&quot;${pageContext.request.contextPath}/book/deleteBook/${book.bookId}&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; WEB-INF/jsp/updateBook.jsp &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;%--BootStrap美化界面--%&gt; &lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;%--屏幕分成12列--%&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%--BootStrap官网拿&quot;表单&quot;数据 name属性保证pojo属性名称一致 required保证必须提交--%&gt; &lt;form action=&quot;${pageContext.request.contextPath}/book/updateBook&quot; method=&quot;post&quot;&gt; &lt;%--提交失败：没有回显：问题： 1. 事务没有提交 2. sql执行失败，没有提交BookId，需要前端的隐藏域 --%&gt; &lt;%--添加bookId的隐藏域--%&gt; &lt;input type=&quot;hidden&quot; name=&quot;BookId&quot; value=&quot;${book.bookId}&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bName&quot;&gt;书籍名称:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;bookName&quot; class=&quot;form-control&quot; id=&quot;bName&quot; value=&quot;${book.bookName}&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bCount&quot;&gt;书籍数量：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; class=&quot;form-control&quot; id=&quot;bCount&quot; value=&quot;${book.bookCounts}&quot;required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bDesc&quot;&gt;书籍描述：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;detail&quot; class=&quot;form-control&quot; id=&quot;bDesc&quot; value=&quot;${book.detail}&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;form-control&quot; value=&quot;添加&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 7 Ajax 7.1 概念 Ajax就是一个异步无刷新请求，无需更新整个页面就异步加载一些数据，交互性更强 模拟异步请求 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模拟Ajax异步请求&lt;/title&gt; &lt;script&gt; function go() { var url = document.getElementById(&quot;url&quot;).value; document.getElementById(&quot;iframe1&quot;).src = url; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;请输入地址：&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;url&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;go()&quot;&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;iframe id=&quot;iframe1&quot; style=&quot;width:100%;height: 500px&quot;&gt; &lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 7.2 使用JQ使用Ajax 1 初试Ajax &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--加载动态的JQ资源--%&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* AJax后盾必须懂的东西： url：后端接受的地址 data：后端接受到的请求参数，json数据格式=前后端分离时候，后端传的数据便于前端接受就是json数据 success:后端接受成功返回的函数 error:后盾失败接受返回的函数 */ function username() { $.post({ url: &quot;${pageContext.request.contextPath}/a1&quot;, data: {&quot;name&quot;: $(&quot;#username&quot;).val()}, success: function (data, status) { console.log(&quot;data:&quot; + data); console.log(&quot;status:&quot; + status); } }) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--实现Ajax异步请求 1 绑定单击事件 2 单击事件函数使用Jq：$.post({}) --%&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot; onclick=&quot;username()&quot;&gt; &lt;/body&gt; &lt;/html&gt; 2 Ajax实现异步加载 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /*页面加载完*/ $(function () { /*绑定btn单击事件*/ $(&quot;#btn&quot;).click(function () { /*JQ使用Ajax异步请求*/ $.post(&quot;${pageContext.request.contextPath}/a2&quot;, function (data) { // data接受返回的值 //console.log(data); var html = &quot;&quot;; for (let i = 0; i &lt; data.length; i++) { html += &quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; + +&quot;&lt;tr&gt;&quot; } $(&quot;#content&quot;).html(html); }); }); }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;加载数据&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 3 实现登录验证 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function nameFun() { $.post({ url: &quot;${pageContext.request.contextPath}/a3&quot;, data: {&quot;name&quot;: $(&quot;#name&quot;).val()}, success: function (data) { //console.log(data); if (data.toString() === &quot;用户名成功&quot;) { $(&quot;#userInfo&quot;).css(&quot;color&quot;, &quot;green&quot;); } else { $(&quot;#userInfo&quot;).css(&quot;color&quot;, &quot;red&quot;); } $(&quot;#userInfo&quot;).html(data); } }) } function passwordFun() { $.post({ url: &quot;${pageContext.request.contextPath}/a3&quot;, data: {&quot;password&quot;: $(&quot;#password&quot;).val()}, success: function (data) { if (data.toString() === &quot;密码正确&quot;) { $(&quot;#userPasswordInfo&quot;).css(&quot;color&quot;, &quot;green&quot;); }else { $(&quot;#userPasswordInfo&quot;).css(&quot;color&quot;, &quot;red&quot;); } $(&quot;#userPasswordInfo&quot;).html(data); } }) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onclick=&quot;nameFun()&quot;&gt; &lt;%--span提示信息--%&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 用户密码:&lt;input type=&quot;password&quot; id=&quot;password&quot; onclick=&quot;passwordFun()&quot;&gt; &lt;span id=&quot;userPasswordInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; appliacation.xml添加json乱码问题 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1 自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=&quot;com.ssl.controller&quot;/&gt; &lt;!--2 注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 使用JQ，使用静态资源过滤需要引用，动态就不需要--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--注解加载映射器、适配器，解决Json数据中文乱码问题--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--3 以上的是定死的代码，以下是配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 7.3 后端需要的前端知识 HTML+CSS+Js（超级熟练） Js必会？： 函数闭包？ DOM id,name.tag create,remove BOM：浏览器对象模型 window document 8 拦截器 8.1 概念 数据独立性：Servlet中的是过滤器，而拦截器是SpringMVC框架独有的，独享request和response 拦截器只会拦截访问的控制器方法，如果访问的是jsp/html/css等式不会拦截的 拦截器是基于AOP思想的，和AOP实现是一样的，在application.xml中配置 &lt;!--拦截器配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**是拦截之后所有的请求，比如/admin/a1/2131 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.ssl.config.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 8.2 自定义拦截器 实现 HandlerInterceptor public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //return true：执行下一个拦截器 System.out.println(&quot;===========处理前,这里进行拦截处理=================&quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;===========处理后，通常进行日志管理=================&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;===========清洁中=================&quot;); } } applica.xml配置 &lt;!--拦截器配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- /**是拦截之后所有的请求，比如/admin/a1/2131 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.ssl.config.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 8.3 登录验证判断 public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HttpSession session = request.getSession(); request.getRequestURL(); //URL:http://localhost:8080/springmvc_07_interceptor/user//main System.out.println(&quot;URL:&quot; + request.getRequestURL()); //URI:/springmvc_07_interceptor/user//main System.out.println(&quot;URI:&quot; + request.getRequestURI()); if (session.getAttribute(&quot;username&quot;) == null || session.getAttribute(&quot;password&quot;) == null) { request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); } else if (session.getAttribute(&quot;username&quot;).equals(&quot;admin&quot;) &amp;&amp; session.getAttribute(&quot;password&quot;).equals(&quot;123456&quot;)) { return true; } if (request.getRequestURI().contains(&quot;ogin&quot;)) { return true; } request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; } } @Controller @RequestMapping(&quot;/user&quot;) public class LoginController { @RequestMapping(&quot;/main&quot;) public String main() { //沒登陸就不等進入首頁 return &quot;main&quot;; } @RequestMapping(&quot;/goLogin&quot;) public String goLogin() { return &quot;login&quot;; } @RequestMapping(&quot;/login&quot;) public String login(String username, String password, HttpSession session, Model model) { session.setAttribute(&quot;username&quot;, username); session.setAttribute(&quot;password&quot;, password); model.addAttribute(&quot;username&quot;, username); return &quot;main&quot;; } @RequestMapping(&quot;/outUser&quot;) public String outUser(HttpSession session) { session.removeAttribute(&quot;username&quot;); session.removeAttribute(&quot;password&quot;); return &quot;main&quot;; } } 9 文件上传 前端form添加enctype=“multipart/form-data”,method=“post” &lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;/form&gt; 后端pom导包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入高版本的api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Spring自带的文件上传,application.xml配置 &lt;!--4 文件上传配置--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!--最大上传大小：单位是1字节--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt; &lt;/bean&gt; @RestController public class FileController { @RequestMapping(&quot;/upFile&quot;) public String upFile(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { //设置文件保存路径 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); System.out.println(&quot;path:&quot; + path); File realPath = new File(path); if (!realPath.exists()) { realPath.mkdir(); } System.out.println(&quot;上传的文件地址：&quot; + realPath); //CommonsMultipartFile的方法写文件，简化 file.transferTo(new File(realPath + &quot;/&quot; + file.getOriginalFilename())); return &quot;redirect:/index.jsp&quot;; } } 10 文件下载 方式一：写方法下载 @RequestMapping(value = &quot;/download&quot;) public String downLoad(HttpServletResponse response, HttpServletRequest request) throws IOException { //手动设置，要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;1.png&quot;; //设置响应头 response.reset();//设置页面不缓存，清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;multipart/form-data&quot;);//二进制传输数据 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path, fileName); //读取文件-输入流 InputStream input = new FileInputStream(file); //写入文件-输出流 OutputStream out = response.getOutputStream(); byte[] buff = new byte[1024]; int index = 0; while ((index = input.read(buff)) != -1) { out.write(buff,0,index); out.flush(); } input.close(); out.close(); return &quot;redirect:/index.jsp&quot;; } 方式二：标签直接web下静态获取 &lt;a href=&quot;${pageContext.request.contextPath}/static/1.png&quot;&gt;图片下载&lt;/a&gt;b ","link":"https://ganhan999.github.io/post/Java SpringMVC/"},{"title":"IDEA Debug 笔记","content":"Debug 设置 使用File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger可以打开Debug设置界面，如下图 Transport表示设置 Debug 连接方式，默认是 Socket。Shared memory 是 Windows 特有的一个属性，一般在 Windows 系统下建议使用此设置，相对于 Socket 会快点 Debug 常用快捷键 快捷键 介绍 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Alt + Shift + F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Debug 技巧 Debug 时查看对象的几种方法 1. 在Variables窗口直接查看 2. 使用快捷键 Alt + F8 这种方法还可以对变量进行一定的加工，比如 或者 3. 拖动对象到 Watches窗口 4. 鼠标悬停在对象上 2 秒左右 快速跳过后面的断点 当我们需要过掉后面的所有断点的时候，我们不需要去掉这些断点，只需要点击左下角Mute Breakpoints，之后，所有断点变成灰色，然后我们再按快捷键 F9 即可过掉当前和后面所有的断点，如图 ## 设置断点进入条件 1. 在断点上点击鼠标右键 2. 使用快捷键 Ctrl + Shift + F8 断点进入条件在对循环进行调试时会经常用到，常用于观察循环变量满足某一条件时的循环体执行情况 更复杂的步入条件 可以设置断点在跳过多少次后开始步入，这在循环中也比较常用，比如要查看一个变量循环 3 次后的结果，设置方法如下图 对于某些不重要的断点，只要步入一次就够了，就可以勾选Remnove once hit，让它步入之后自动删除，如下图 对于某些场景的断点，需要其他断点先触发之后再进行触发，可以如下图选择。默认选择的是： None ## 从方法体中跳出 有时候当我们步入方法体之后，还想回退到方法体外。可以点击 Drop Frame 按钮实现，如下图 其他 如下图 ","link":"https://ganhan999.github.io/post/IDEA Debug 笔记/"},{"title":"中等43. 字符串相乘","content":"题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = &quot;2&quot;, num2 = &quot;3&quot; 输出: &quot;6&quot; 示例 2: 输入: num1 = &quot;123&quot;, num2 = &quot;456&quot; 输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 做加法，小学竖列式 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def multiply(self, num1: str, num2: str) -&gt; str: if num1 == &quot;0&quot; or num2 == &quot;0&quot;: return &quot;0&quot; ans = &quot;0&quot; m, n = len(num1), len(num2) for i in range(n - 1, -1, -1): add = 0 y = int(num2[i]) curr = [&quot;0&quot;] * (n - i - 1) for j in range(m - 1, -1, -1): product = int(num1[j]) * y + add curr.append(str(product % 10)) add = product // 10 if add &gt; 0: curr.append(str(add)) curr = &quot;&quot;.join(curr[::-1]) ans = self.addStrings(ans, curr) return ans def addStrings(self, num1: str, num2: str) -&gt; str:#字符串累加 i, j = len(num1) - 1, len(num2) - 1 add = 0 ans = list() while i &gt;= 0 or j &gt;= 0 or add != 0: x = int(num1[i]) if i &gt;= 0 else 0 y = int(num2[j]) if j &gt;= 0 else 0 result = x + y + add ans.append(str(result % 10)) add = result // 10 i -= 1 j -= 1 return &quot;&quot;.join(ans[::-1]) &quot;&quot;&quot;&quot;&quot; 大神做法2： 先转int，再乘法，再转字符串 class Solution: def multiply(self, num1: str, num2: str) -&gt; str: # 先将字符串倒序 from collections import deque dq_1 = deque(num1) dq_2 = deque(num2) dq_1.reverse() dq_2.reverse() num1 = &quot;&quot;.join(dq_1) num2 = &quot;&quot;.join(dq_2) # 根据长度按数字的位数来恢复数值 l1 = len(num1) l2 = len(num2) number1 = 0 number2 = 0 for i, j in zip(num1, range(l1)):#假设num1=“123&quot;,zip(num1, range(l1))等于[(1, 0), (2, 1), (3, 2)]，这个方法太妙了 number1 += int(i) * 10 ** j for i, j in zip(num2, range(l2)): number2 += int(i) * 10 ** j return str(number1 * number2) ","link":"https://ganhan999.github.io/post/43、字符串相乘/"},{"title":"中等40. 组合总和 II","content":"题目 定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 将数组先排序的思路来自于这个问题：去掉一个数组中重复的元素。很容易想到的方案是：先对数组 升序 排序，重复的元素一定不是排好序以后相同的连续数组区域的第 1 个元素。也就是说，剪枝发生在：同一层数值相同的结点第 2、3 ... 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比第 1 个结点更多，并且是第 1 个结点的子集。（说明：这段文字很拗口，大家可以结合具体例子，在纸上写写画画进行理解。） &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: def dfs(begin, path, residue): if residue == 0: res.append(path[:]) return for index in range(begin, size):#这里就避免了重复顺序的问题 if candidates[index] &gt; residue: break if index &gt; begin and candidates[index - 1] == candidates[index]:#避免同一层的数字前后相同，见后面解析 continue dfs(index+1, path + [candidates[index]], residue - candidates[index])#这里index+1是为了每个元素只出现一次 size = len(candidates) if size == 0: return [] path = [] candidates.sort() res = [] dfs(0, path, target) return res #复现成功！ ''' 这个避免重复当思想是在是太重要了。 这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即 1 / \\ 2 2 这种情况不会发生 但是却允许了不同层级之间的重复即： / \\ 5 5 例2 1 / 2 这种情况确是允许的 / 2 为何会有这种神奇的效果呢？ 首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。 可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。 那么如何保留例2呢？ 那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的， 例2的两个2是处在不同层级上的。 在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中， 必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。 第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur &gt; begin. ''' ","link":"https://ganhan999.github.io/post/40、组合总数II/"},{"title":"Java Spring5","content":"1.1、简介 Spring：春天—&gt; 给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 SSH : Struct2 + Spring + Hibernate! SSM : SpringMvc + Spring + Mybatis! 官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2、优点 Spring是一个开源免费的框架 , 容器 Spring是一个轻量级的框架 , 非侵入式的 . 控制反转 IoC , 面向切面 Aop 对事物的支持 , 对框架的支持 总结一句话：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 1.3、组成 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 1.4、拓展 在Spring的官网有这个介绍：现代化的java开发！说白就是基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud Spring CLoud是基于SpringBoot实现的 因为现在大所述公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用 弊端：发展太久了之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”！ 2、IOC理论推导 2.1、IoC基础 1.UserDao接口 2.UserDaoImpl实现类 3.UserService业务接口 4.UserServiceImpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要更具用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 我们使用一个Set接口实现，已经发生了革命性的变化！ private UserDao userDao; // 利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 之前，程序是主动创建对象！控制权在程序员手上！ 使用了set注入之后，程序不再有主动性，而是变成了被动的接受对象！ 这种思想从本质上实现了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上！这是IOC的原型！ \\ 2.2、IOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 3、HelloSpring 导入Jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 . &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编写代码 1、编写一个Hello实体类 package Com.Sun.pojo; public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Hello{&quot; + &quot;name='&quot; + name + '\\'' + '}'; } } 2、编写我们的spring文件 , 这里我们命名为beans.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理 类型 变量名 = new 类型(); Hello hello = new Hello(); bean = 对象 new Hello(); id = 变量名 class = new的对象 property 相当于给对象中的属性设置一个变量 --&gt; &lt;bean id=&quot;hello&quot; class=&quot;Com.Sun.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;你好Spring&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 3、我们可以去进行测试了 . public class MyTest { public static void main(String[] args) { // 获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以 Hello hello = (Hello)context.getBean(&quot;hello&quot;); System.out.println(hello); } } 思考问题？ Hello 对象是谁创建的 ? hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过new ClassPathXmlApplicationContext去浏览一下底层源码 **OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! ** 4、IOC创建对象的方式 1.使用无参构造创建对象，默认！ &lt;!--无参构造器--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Sun&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 2.假设我们要使用有参构造创建对象。 下标赋值 &lt;!--有参构造器1，下标赋值--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;Sun&quot;/&gt; &lt;/bean&gt; 类型 &lt;!--有参构造器2，类型，但同类型只能一个，不建议使用--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Sun&quot;/&gt; &lt;/bean&gt; 参数名 &lt;!--有参构造器3，参数名--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Sun&quot;/&gt; &lt;/bean&gt; 总结：在配置文件加载的时候。其中管理的对象都已经初始化了！ 5、Spring配置 5.1、别名 &lt;!--别名，如果添加了别名也可以使用别名获取到这个对象--&gt; &lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt; 5.2、Bean的配置 &lt;!-- id:bean的唯一标识符，也就是相当于我们学的对象名 class：bean 对象所对应的权限定名：包名 + 类型 name: 也是别名,而且name更高级，可以起多个别名，通过逗号空格分号等分割 --&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; name=&quot;user2,u3,u4&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;Sun&quot;/&gt; &lt;/bean&gt; 5.3、import 团队的合作通过import来实现 ,可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的 张三 beans.xml 李四 beans2.xml 王五 beans3.xml applicationContext &lt;import resource=&quot;beans.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;import resource=&quot;beans3.xml&quot;/&gt; 使用的时候，直接使用总的配置就可以了 6、依赖注入 6.1、构造器注入 前面已经说过了 6.2、set方式注入【重点】 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 【环境搭建】 复杂类型 Address.java public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return &quot;Address{&quot; + &quot;address='&quot; + address + '\\'' + '}'; } } 真实测试对象 Student.java public class Student { private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String[] getBooks() { return books; } public void setBooks(String[] books) { this.books = books; } public List&lt;String&gt; getHobbies() { return hobbies; } public void setHobbies(List&lt;String&gt; hobbies) { this.hobbies = hobbies; } public Map&lt;String, String&gt; getCard() { return card; } public void setCard(Map&lt;String, String&gt; card) { this.card = card; } public Set&lt;String&gt; getGames() { return games; } public void setGames(Set&lt;String&gt; games) { this.games = games; } public String getWife() { return wife; } public void setWife(String wife) { this.wife = wife; } public Properties getInfo() { return info; } public void setInfo(Properties info) { this.info = info; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, address=&quot; + address.toString + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbies=&quot; + hobbies + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, wife='&quot; + wife + '\\'' + &quot;, info=&quot; + info + '}'; } } beans.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;Com.Sun.pojo.Address&quot; &gt; &lt;property name=&quot;address&quot; value=&quot;福州&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;Com.Sun.pojo.Student&quot;&gt; &lt;!--第一种，普通值注入 value--&gt; &lt;property name=&quot;name&quot; value=&quot;小程&quot;/&gt; &lt;!--第二种： Bean注入 ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--第三种： 数组注入 --&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;Java&lt;/value&gt; &lt;value&gt;C++&lt;/value&gt; &lt;value&gt;Python&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--第四种：list注入--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;学习&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--第五种：map注入--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;1234567890&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;1987654320&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--第六种：set注入--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;和平精英&lt;/value&gt; &lt;value&gt;王者荣耀&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--第七种：null注入--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--第七种：Properties注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;url&quot;&gt;1234567hgfdxcvb&lt;/prop&gt; &lt;prop key=&quot;passwoed&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student)context.getBean(&quot;student&quot;); System.out.println(student); } } 6.3、拓展方式注入 我们可以使用p命令空间和c命令空间进行注入 官方解释： 使用！ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间可以直接注入属性的值 property--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot;/&gt; &lt;!--c命名空间可以通过构造器注入 construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;Com.Sun.pojo.User&quot; c:name=&quot;小李&quot; c:age=&quot;22&quot;/&gt; &lt;/beans&gt; 测试： @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;UserBeans.xml&quot;); User user = context.getBean(&quot;user2&quot;, User.class); System.out.println(user.toString()); } 注意点：p命名和c命名空间不能直接使用，需要引入xml约束! xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 6.4、Bean的作用域 单例模式(Spring默认机制)（适用于单线程） &lt;!--p命名空间可以直接注入属性的值 property--&gt; &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt; 原型模式：每次从容器中get的时候，都会产生一个现对象！(适用于多线程) &lt;!--c命名空间可以通过构造器注入 construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;Com.Sun.pojo.User&quot; c:name=&quot;小李&quot; c:age=&quot;22&quot; scope=&quot;prototype&quot;/&gt; 其余的request、session、application这些个只能在web开发中使用到 7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性！ 在Spring中有三种自动装配的方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean【重要】 这里我们主要讲第三种：自动化的装配bean。 7.1、测试 环境搭建：一个人有两个宠物 7.2、ByName自动装配 &lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;!-- byName:会自动在容器上下文中套接，和自己对象的set方法后面的值相对应的beanid --&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;/bean&gt; 7.3、ByType自动装配 &lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;!-- byType:会自动在容器上下文中套接，和自己对象属性类型相同的beanid --&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;/bean&gt; 小结： byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致 7.4、使用注解实现自动装配 jdk1.5支持的注解，Spring2.5就支持注解了！ The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. 要使用注解需知： 导入约束：context支持 配置注解的支持：context:annotation-config/ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; @Autowired注解 需要导入 spring-aop的包！ 直接在属性上使用即可！也可以在set方式上使用！ 使用Autowired我们可以不用编写set方法，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName和类型byType！ 正常1（byName） &lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt; 正常2（byType） &lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog1&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt; 正常3（混合使用，先类型后名字） &lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt; 不正常（多种类型且名字也不匹配，报错） &lt;bean id=&quot;cat2&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;cat1&quot; class=&quot;Com.Sun.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog1&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;dog2&quot; class=&quot;Com.Sun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;Com.Sun.pojo.People&quot;/&gt; 科普： @Nullable 字段标记了这个注解，说明这个字段可以为null 1 public @interface Autowired { boolean required() default true; } 测试代码 public class People { //如果显示的定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name; } 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifilter(value=“xxx”)去配合@Autowired的使用，指定一个唯一的bean对象注入 public class People { @Autowired @Qualifier(value=&quot;dog1&quot;) private Dog dog; @Autowired @Qualifier(value=&quot;cat1&quot;) private Cat cat; } Resource注解 public class People { @Resource(name = &quot;cat1&quot;) private Cat cat; @Resource private Dog dog; private String name; } 小结： @Resource和@Autowired 都是用来自动装配的，都可以放在属性字段上 实现方式不同 @Autowired默认通过bytype的方式实现，如果有多个类型，则通过byname实现，如果两个都找不到，就报错！ @Resource默认通过byname的方式实现，如果找不到名字，则通过bytype实现，如果两个都找不到，就报错！ 执行的顺序不同： @Autowired默认通过bytype的方式实现 @Resource默认通过byname的方式实现 类型重复的话，如果名字不是默认的（如cat11，cat111，而没有默认的cat） @Autowired配合@Qualifier(value = “cat11”)使用 @Resource直接使用@Resource(name = “cat11”) 8.使用注解开发 在Spring4之后，要使用注解开发，必须要保证aop的包导入了 使用注解需要导入context约束，增加注解的支持！ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; bean // 等价于 &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;/&gt; @Component 属性如何注入@Value(“xxx”) @Component public class User { //相当于&lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; @Value(&quot;小明&quot;) public String name; } 衍生的注解 @Component有几个衍生的注解，我们在web开发中，会按照mvc三层架构分层！ dao【@Repository】 service 【@Service】 controller 【@Controller】 这四个注解功能都是一样的，都是代表将某个注册类注入到Spring中，装配Bean 自动装配置 @Autowired：自动装配通过类型、名字 如果Autowired不能唯一自动装配上属性，则需要通过@Qualifilter(value=“xxx”) @Nullable：字段标记了这个注解，说明这个字段可以为null @Resource：自动装配通过名字、类型 作用域 @Scope // 等价于 &lt;bean id=&quot;user&quot; class=&quot;Com.Sun.pojo.User&quot;/&gt; @Component @Scope(&quot;singleton&quot;) public class User { //相当于&lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; @Value(&quot;小明&quot;) private String name; public String getName() { return name; } public void setName(String name) { this.name=name; } } 小结 xml与注解 xml更加万能，适用于任何场合！维护简单方便 注解不是自己的类用不了，维护相对复杂 xml与注解的最佳实践： xml用来管理bean; 注解只负责完成属性的注入; 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解支持 &lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt; &lt;context:component-scan base-package=&quot;Com.Sun&quot;/&gt; &lt;context:annotation-config/&gt; 9.使用java的方式配置Spring 我们现在要完全不适用Spring的xml配置了，全权交给java来做 javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！ 实体类 //这里这个注解的意思，就是说明这个类被Spring接管了。注解到了容器中 @Component public class User { @Value(&quot;小明&quot;) public String name; public String getName() { return name; } public void setName(String name) { this.name=name; } @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + '}'; } } 配置文件 //这个也被Spring容器托管，注册到容器里，因为他本来就是一个@Component， // @Component代表这是一个配置类，就和我们之前看的beans.xml是一样的 @Configuration @ComponentScan(&quot;Com.Sun.pojo&quot;) @Import(MyConfig2.class) public class Appconfig_01 { //注册一个bean，就相当于我们之前写的一个bean标签， //这个方法的名字就相当于bean标签的id属性 //这个方法的返回值,就相当于bean标签中的class属性 @Bean public User getUser(){ return new User(); } } 测试类！ public class Mytest { public static void main(String[] args) { // 如果完全使用了配置类的方式去做,我们就只能通过AnnotationConfig 上下文来获取容器,通过配置类的class对象加载! AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Appconfig_01.class); User user = (User) context.getBean(&quot;getUser&quot;); System.out.println(user.toString()); } } 这种纯java的配置方式，在SpringBoot中随处可见！ 10、代理模式 为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】 代理模式的分类： 静态代理 动态代理 10.1、静态代理 角色分析： 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作 客户：访问代理对象的人！ 代码步骤： 接口 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent { public void rent() { } } 代理角色 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent() { seeHouse(); fare(); contract(); host.rent(); } //看房 public void seeHouse() { System.out.println(&quot;中介带你看房&quot;); } //收中介费 public void fare() { System.out.println(&quot;收中介费&quot;); } //收中介费 public void contract() { System.out.println(&quot;签租赁合同&quot;); } } 客户端访问代理角色 public class Client { public static void main(String[] args) { //房东要租房子 Host host = new Host(); //代理，中介帮房东租房子，但是代理一般会有一些附属操作 Proxy proxy = new Proxy(host); //你不用面对房东，直接面对中介 proxy.rent(); } } 静态代理模式的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 缺点： 一个真实角色就会产生一个代理角色； 代码量会翻倍-开发效率会变低 10.2 、加深理解 代码： 接口 public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色：改动原有的业务代码，在公司中是大忌！ //真实对象 public class UserServiceImpl implements UserService { public void add() { System.out.println(&quot;增加了一个用户&quot;); } public void delete() { System.out.println(&quot;删除了一个用户&quot;); } public void update() { System.out.println(&quot;修改了一个用户&quot;); } public void query() { System.out.println(&quot;查询了一个用户&quot;); } } 需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 设置一个代理类来处理日志！代理角色 public class UserServiceProxy implements UserService { private UserService userService; public void setUserService(UserService userService) { this.userService = userService; } public void add() { log(&quot;add&quot;); userService.add(); } public void delete() { log(&quot;delete&quot;); userService.delete(); } public void update() { log(&quot;update&quot;); userService.update(); } public void query() { log(&quot;query&quot;); userService.query(); } //日志方法 private void log(String msg) { System.out.println(&quot;使用了&quot; + msg + &quot;方法&quot;); } } 客户端访问代理角色 public class Client { public static main(String[] args) { UserService userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); } } 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 聊聊AOP：纵向开发，横向开发 10.3、动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是 我们直接写好的！ 动态代理分为两大类：基于接口的动态代理、基于类的动态代理 基于接口：JDK动态代理【我们在这里使用】 基于类：cglib java字节码实现：javasist 需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序 10.3.1【InvocationHandler：调用处理程序】 Object invoke(Object proxy, Method method, Object[] args)； //参数 //proxy - 调用该方法的代理实例 //method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 //args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 10.3.2【Proxy : 代理】 //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 //抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(&quot;房屋出租&quot;); } } ProxyInvocationHandler. java 即代理角色 public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(&quot;带房客看房&quot;); } //收中介费 public void fare(){ System.out.println(&quot;收中介费&quot;); } } Client . java //租客 public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); } } 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！ 10.3.3深化理解 我们来使用动态代理实现代理我们后面写的UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName){ System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); } } 测试！ public class Test { public static void main(String[] args) { //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); } } 测试，增删改查，查看结果！ 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态 一个动态代理类可以代理多个类，只要是实现了同一个接口即可【核心】 11、AOP 11.1、什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 11.2、Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 … 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。Log 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。Log方法 目标（Target）：被通知对象。接口 代理（Proxy）：向目标对象应用通知之后创建的对象。代理类 切入点（PointCut）：切面通知 执行的 “地点”的定义。method 连接点（JointPoint）：与切入点匹配的执行点。invoke SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 通知类型 连接点 实现接口 前置通知 方法前 org.springframework.aop.MethodBeforeAdvice 后置通知 方法后 org.springframework.aop.AfterReturningAdvice 环绕通知 方法前后 org.aopalliance.intercept.MethodInterceptor 异常抛出通知 方法抛出异常 org.springframework.aop.ThrowsAdvice 引介通知 类中增加新的方法属性 org.springframework.aop.IntroductionInterceptor 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 11.3、使用Spring实现Aop 【重点】使用AOP织入，需要导入一个依赖包！ &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 方式一：使用Spring的API接口【主要SpringAPI接口实现】 首先编写我们的业务接口和实现类 public interface UserService { public void add(); public void delete(); public void update(); public void select(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(&quot;增加用户&quot;); } @Override public void delete() { System.out.println(&quot;删除用户&quot;); } @Override public void update() { System.out.println(&quot;更新用户&quot;); } @Override public void select() { System.out.println(&quot;查询用户&quot;); } } 写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 public class log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); } } public class AfterLog implements AfterReturningAdvice { //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); } } 在spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;Com.Sun.Service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;Com.Sun.Log.log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;Com.Sun.Log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试 public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.select(); } } Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . **Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . ** 方式二：自定义来实现【主要是切面定义】 目标业务类不变依旧是userServiceImpl 写我们自己的一个切入类 public class DiyPointCut { public void before() { System.out.println(&quot;==========方法执行前============&quot;); } public void after() { System.out.println(&quot;==========方法执行后============&quot;); } } 去spring中配置 &lt;!--方式二：自定义类--&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;diy&quot; class=&quot;Com.Sun.Diy.DiyPointCut&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--自定义切面，ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;!--通知--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试： @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService)context.getBean(&quot;userService&quot;); userService.add(); } 方式三：使用注解实现！ 编写一个注解实现的增强类 //方式三：使用注解的方式实现AOP @Aspect//标注这个类是一个切面 public class AnnotationPointCut { @Before(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;) public void before() { System.out.println(&quot;==========方法执行前============&quot;); } @After(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;) public void after() { System.out.println(&quot;==========方法执行后============&quot;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(&quot;execution(* Com.Sun.Service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;==========环绕前============&quot;); //获取签名 //Signature signature = jp.getSignature(); //System.out.println(&quot;signature:&quot; + signature); //执行方法 Object proceed = jp.proceed(); System.out.println(&quot;==========环绕后============&quot;); } } 在Spring配置文件中，注册bean，并增加支持注解的配置 &lt;!--方式三：注解--&gt; &lt;bean id=&quot;annotationPointCut&quot; class=&quot;Com.Sun.Annotation.AnnotationPointCut&quot;/&gt; &lt;!--开启注解支持: JDK（默认proxy-target-class=&quot;false&quot;） cglib(&quot;true“)--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot;/&gt; 12、整合Mybatis 步骤： 导入相关jar包 junit &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; mybatis &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; mysql数据库：mysql-connector-java &lt;!--mysqlq驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.22&lt;/version&gt; &lt;/dependency&gt; spring相关的：spring-webmvc &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; aspectJ AOP 织入器 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; mybatis-spring整合包【重点】 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;&gt; 配置Maven静态资源过滤问题！【约定大于配置】 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 编写配置文件 测试 12.1、回忆mybatis 编写实体类 import lombok.Data; @Data public class User { public int id; public String name; public String pwd; } 编写核心配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=ture&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;Com/Sun/Dao/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写接口 public interface UserMapper { public List&lt;User&gt; selectUser(); } 编写Mapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;Com.Sun.Dao.UserMapper&quot;&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;Com.Sun.pojo.User&quot;&gt; select * from mybatis.user; &lt;/select&gt; &lt;/mapper&gt; MybatisUtils package com.Sun.Uitls; //sqlSessionFactory --&gt; sqlSession import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { static SqlSessionFactory sqlSessionFactory = null; static { try { //使用Mybatis第一步 ：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例. // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ //SqlSession sqlSession = sqlSessionFactory.openSession(); //return sqlSession; return sqlSessionFactory.openSession(); } } 测试 package Com.Sun.Test; import Com.Sun.Dao.UserMapper; import Com.Sun.Until.MybatisUtils; import Com.Sun.pojo.User; import org.apache.ibatis.session.SqlSession; import java.util.List; public class MyTest { public static void main(String[] args) { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; allUser =mapper.getAllUser(); for (User user : allUser) { System.out.println(user); } sqlSession.close(); } } 12.2、Mybatis-Spring 引入Spring之前需要了解mybatis-spring包中的一些重要类； mybatis-spring官网 什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 知识基础 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring 框架 Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 整合方式一 引入配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 编写数据源配置 &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=ture&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;cgj532416&quot;/&gt; &lt;/bean&gt; sqlSessionFactory &lt;!--配置SqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:Com/Sun/Dao/UserMapper.xml&quot;/&gt; &lt;/bean&gt; sqlSessionTemplate &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入,没有set注入，只能使用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 需要给接口加实现类【新加的】 public class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; getAllUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getAllUser(); } } 将自己写的实现类，注入到Spring中 &lt;bean id=&quot;userDao&quot; class=&quot;Com.Sun.Dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt; 测试使用即可 public static void main(String[] args) throws Exception{ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); UserMapper userDao = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; allUser = userDao.getAllUser(); for (User user : allUser) { System.out.println(user.toString()); } } 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 为了给mybatis-config.xml留点面子(使用方便)，在其中将别名和设置留下来 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;Com.Sun.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- &lt;settings&gt; &lt;setting&gt;&lt;/setting&gt; &lt;/settings&gt; --&gt; &lt;/configuration&gt; **整合实现二 ** mybatis-spring1.2.3版以上的才有这个 . 官方文档截图 : dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 测试： 将我们上面写的UserDaoImpl修改一下 public class UserDaoImpl2 extends SqlSessionDaoSupport implements UserMapper { @Override public List&lt;User&gt; getAllUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); List&lt;User&gt; allUser = mapper.getAllUser(); return allUser; } } 修改bean的配置 &lt;bean id=&quot;userDao&quot; class=&quot;Com.Sun.Dao.UserDaoImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 测试 @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userDao = (UserMapper) context.getBean(&quot;userDao&quot;); for (User user : userDao.getAllUser()) { System.out.println(user); } } 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ 13、声明式事务 13.1、回顾事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎 确保完整性和一致性 事务的ACID原则 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 多个业务可能操作同一个资源，防止数据损坏 持久性（durability） 事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中！ 13.2、Spring中的事务管理 声明式事务：AOP 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理 编程式事务：需要在代码中，进行事务的管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 使用Spring管理事务，注意头文件的约束导入 : tx xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 配置事务的通知 &lt;!--配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 123456789101112 spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 配置AOP（导入aop的头文件！） &lt;!--配置aop织入事务--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* Com.Sun.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt; &lt;/aop:config&gt; 思考： 为什么需要事务？ 如果不配置，可能存在数据提交不一致的情况； 如果我们不在Spring中去配置声明式事务，我们需要在代码中手动配置事务！ 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ ","link":"https://ganhan999.github.io/post/Java Spring/"},{"title":"中等39. 组合总和","content":"题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ] 示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 回溯法 以 target = 7 为 根结点 ，创建一个分支的时 做减法 ； 每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。 边的值就是题目中给出的 candidate 数组的每个元素的值； 减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点； 所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。 &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: def dfs(candidates, begin, size, path, res, target): if target &lt; 0: return if target == 0: res.append(path) return for index in range(begin, size): dfs(candidates, index, size, path + [candidates[index]], res, target - candidates[index]) size = len(candidates) if size == 0: return [] path = [] res = [] dfs(candidates, 0, size, path, res, target) return res #复现成功！ &quot;&quot;&quot;&quot;&quot; 大神做法2： 剪枝提速 根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的； 排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。 class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: def dfs(candidates, begin, size, path, res, target): if target == 0: res.append(path) return for index in range(begin, size): residue = target - candidates[index] if residue &lt; 0:#在循环内判断是否要剪枝 break dfs(candidates, index, size, path + [candidates[index]], res, residue) size = len(candidates) if size == 0: return [] candidates.sort() path = [] res = [] dfs(candidates, 0, size, path, res, target) return res ","link":"https://ganhan999.github.io/post/39、组合总数/"},{"title":"中等36. 有效的数独","content":"题目 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 示例 1: 输入: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: true 示例 2: 输入: [ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 本体思路 一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保： 行中没有重复的数字。 列中没有重复的数字。 3 x 3 子数独内没有重复的数字。 实际上，所有这一切都可以在一次迭代中完成。 #大神做法1： class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row = [{} for _ in range(9)] col = [{} for _ in range(9)] grid = [[{} for _ in range(3)] for _ in range(3)] for i in range(9): for j in range(9): if board[i][j] != '.': tmp = int(board[i][j]) row[i][tmp] = row[i].get(tmp, 0) + 1#如果已经存在该数字，那么就继续加一，没有就从0开始 col[j][tmp] = col[j].get(tmp, 0) + 1 grid[i//3][j//3][tmp] = grid[i//3][j//3].get(tmp, 0) + 1 if row[i].get(tmp) &gt; 1 or col[j].get(tmp) &gt; 1 or grid[i//3][j//3].get(tmp) &gt; 1:#如果对应的value大于1说明，存在两次，直接退出循环 return False return True ","link":"https://ganhan999.github.io/post/36、 有效的数独/"},{"title":"Java Mybatis","content":"MyBatis 1、简介 1.1 什么是Mybatis MyBatis 是一款优秀的持久层框架; 它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2 持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（Jdbc）,io文件持久化。 为什么要持久化？ 有一些对象，不能让他丢掉 内存太贵 1.3 持久层 Dao层、Service层、Controller层 完成持久化工作的代码块 层界限十分明显 1.4 为什么需要MyBatis 帮助程序员将数据存入到数据库中 方便 传统的JDBC代码太复杂了，简化，框架，自动化 不用MyBatis也可以，技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2、第一个Mybatis程序 思路：搭建环境 --&gt; 导入MyBatis --&gt; 编写代码 --&gt; 测试 2.1 搭建环境 新建项目 创建一个普通的maven项目 删除src目录 （就可以把此工程当做父工程了，然后创建子工程） 导入maven依赖 &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--mysqlq驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建一个Module 2.2 创建一个模块 编写mybatis的核心配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!--configuration核心配置文件--&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 编写mybatis工具类 //sqlSessionFactory --&gt; sqlSession public class MybatisUtils { static SqlSessionFactory sqlSessionFactory = null; static { try { //使用Mybatis第一步 ：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例. // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 2.3 编写代码 实体类 Dao接口 public interface UserDao { public List&lt;User&gt; getUserList(); } 接口实现类 （由原来的UserDaoImpl转变为一个Mapper配置文件） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace=绑定一个指定的Dao/Mapper接口--&gt; &lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from USER &lt;/select&gt; &lt;/mapper&gt; 测试 注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么? 核心配置文件中注册mappers junit测试 @Test public void test(){ //1.获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //2.执行SQL // 方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlSession sqlSession.close(); } 可能会遇到的问题： 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 3、CURD 1. namespace namespace中的包名要和Dao/Mapper接口的包名一致 2. select 选择，查询语句； id：就是对应的namespace中的方法名； resultType : Sql语句执行的返回值； parameterType : 参数类型； 编写接口 public interface UserMapper { //查询所有用户 public List&lt;User&gt; getUserList(); //插入用户 public void addUser(User user); } 编写对应的mapper中的sql语句 &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into user (id,name,password) values (#{id}, #{name}, #{password}) &lt;/insert&gt; 测试 @Test public void test2() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(3,&quot;黑子&quot;,&quot;666&quot;); mapper.addUser(user); //增删改一定要提交事务 sqlSession.commit(); //关闭sqlSession sqlSession.close(); } 注意：增删改查一定要提交事务： sqlSession.commit(); 3. Insert 4. update 5. Delete 6. 万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应该考虑使用Map! UserMapper接口 //用万能Map插入用户 public void addUser2(Map&lt;String,Object&gt; map); UserMapper.xml &lt;!--对象中的属性可以直接取出来 传递map的key--&gt; &lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into user (id,name,password) values (#{userid},#{username},#{userpassword}) &lt;/insert&gt; 测试 @Test public void test3(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,4); map.put(&quot;username&quot;,&quot;王虎&quot;); map.put(&quot;userpassword&quot;,789); mapper.addUser2(map); //提交事务 sqlSession.commit(); //关闭资源 sqlSession.close(); } Map传递参数，直接在sql中取出key即可！ 【parameter=“map”】 对象传递参数，直接在sql中取出对象的属性即可！ 【parameter=“Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map , 或者注解！ 7. 模糊查询 模糊查询这么写？ Java代码执行的时候，传递通配符% % List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符 select * from user where name like &quot;%&quot;#{value}&quot;%&quot; 4、配置解析 1. 核心配置文件 mybatis-config.xml Mybatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 2. 环境配置 environments MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 学会使用配置多套运行环境！ MyBatis默认的事务管理器就是JDBC ，连接池：POOLED 3. 属性 properties 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.poperties】 编写一个配置文件 db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username=root password=root 在核心配置文件中引入 &lt;!--引用外部配置文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的 4. 类型别名 typeAliases 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置. 意在降低冗余的全限定类名书写。 &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt; &lt;/typeAliases&gt; 也可以指定一个包，每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author,；若有注解，则别名为其注解值。见下面的例子： &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议用第二种扫描包的方式。 第一种可以DIY别名，第二种不行，如果非要改，需要在实体上增加注解。 @Alias(&quot;author&quot;) public class Author { ... } 5. 设置 Settings 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 6. 其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins 插件 mybatis-generator-core mybatis-plus 通用mapper 7. 映射器 mappers MapperRegistry：注册绑定我们的Mapper文件； 方式一：【推荐使用】 &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 方式二：使用class文件绑定注册 &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt; &lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下 方式三：使用包扫描进行注入 &lt;mappers&gt; &lt;package name=&quot;com.kuang.dao&quot;/&gt; &lt;/mappers&gt; 8. 作用域和生命周期 声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory: 说白了就可以想象为：数据库连接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。 因此SqlSessionFactory的最佳作用域是应用作用域（ApplocationContext）。 最简单的就是使用单例模式或静态单例模式。 SqlSession： 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 5、解决属性名和字段名不一致的问题 1. 问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 测试出现问题 // select * from user where id = #{id} // 类型处理器 // select id,name,pwd from user where id = #{id} 解决方法： 起别名 &lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select id,name,pwd as password from USER where id = #{id} &lt;/select&gt; 2. resultMap 结果集映射 id name pwd id name password &lt;!--结果集映射--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt; select * from USER &lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。 6、日志 6.1 日志工厂 如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！ 曾经：sout、debug 现在：日志工厂 SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在MyBatis中具体使用哪一个日志实现，在设置中设定 STDOUT_LOGGING &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; 6.2 Log4j 什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件； 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程； 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/rzp.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sq1.PreparedStatement=DEBUG 配置settings为log4j实现 测试运行 Log4j简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class对象 Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 logger.info(&quot;info: 测试log4j&quot;); logger.debug(&quot;debug: 测试log4j&quot;); logger.error(&quot;error:测试log4j&quot;); info debug error 7、分页 思考：为什么分页？ 减少数据的处理量 7.1 使用Limit分页 SELECT * from user limit startIndex,pageSize 使用MyBatis实现分页，核心SQL 接口 //分页 List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml &lt;!--分页查询--&gt; &lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from user limit #{startIndex},#{pageSize} &lt;/select&gt; 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,1); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; list = mapper.getUserByLimit(map); for (User user : list) { System.out.println(user); } } 7.2 RowBounds分页 不再使用SQL实现分页 接口 //分页2 List&lt;User&gt; getUserByRowBounds(); mapper.xml &lt;!--分页查询2--&gt; &lt;select id=&quot;getUserByRowBounds&quot;&gt; select * from user limit #{startIndex},#{pageSize} &lt;/select&gt; 测试 public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kaung.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 7.3 分页插件 8、使用注解开发 8.1 面向接口开发 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法； 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现； 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构； 8.2 使用注解开发 注解在接口上实现 @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口 &lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt; &lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理 MyBatis详细执行流程 8.3 注解CURD //方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解 @Delete(&quot;delete from user where id = ${uid}&quot;) int deleteUser(@Param(&quot;uid&quot;) int id); 关于@Param( )注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名 #{} 和 ${} 9、Lombok Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。 使用步骤： 在IDEA中安装Lombok插件 在项目中导入lombok的jar包 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 在程序上加注解 @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog @Data @Builder @SuperBuilder @Singular @Delegate @Value @Accessors @Wither @With @SneakyThrows @val 说明： @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String password; } 10、多对一处理 多个学生一个老师； alter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id) 1. 测试环境搭建 导入lombok 新建实体类Teacher,Student 建立Mapper接口 建立Mapper.xml文件 在核心配置文件中绑定注册我们的Mapper接口或者文件 【方式很多，随心选】 测试查询是否能够成功 2. 按照查询嵌套处理 &lt;!-- 思路： 1. 查询所有的学生信息 2. 根据查询出来的学生的tid寻找特定的老师 (子查询) --&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独出来 对象：association 集合：collection--&gt; &lt;collection property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #{id} &lt;/select&gt; 3.按照结果嵌套处理 &lt;!--按照结果进行查询--&gt; &lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid , s.name sname, t.name tname from student s,teacher t where s.tid=t.id &lt;/select&gt; &lt;!--结果封装，将查询出来的列封装到对象属性中--&gt; &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 回顾Mysql多对一查询方式: 子查询 （按照查询嵌套） 联表查询 （按照结果嵌套） 11、一对多处理 一个老师多个学生； 对于老师而言，就是一对多的关系； 1. 环境搭建 实体类 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students; } 2. 按照结果嵌套嵌套处理 &lt;!--按结果嵌套查询--&gt; &lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt; SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t WHERE s.tid = t.id AND tid = #{tid} &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection javaType=&quot;&quot;指定属性的类型！ 集合中的泛型信息，我们使用ofType获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType用来指定实体类中的类型 ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一，属性名和字段的问题 如果问题不好排查错误，可以使用日志，建议使用Log4j 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化 12、动态SQL 什么是动态SQL：动态SQL就是根据不同的条件生成不同的SQL语句 所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 搭建环境 CREATE TABLE `mybatis`.`blog` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '博客id', `title` varchar(30) NOT NULL COMMENT '博客标题', `author` varchar(30) NOT NULL COMMENT '博客作者', `create_time` datetime(0) NOT NULL COMMENT '创建时间', `views` int(30) NOT NULL COMMENT '浏览量', PRIMARY KEY (`id`) ) 创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private int id; private String title; private String author; private Date createTime;// 属性名和字段名不一致 private int views; } 编写实体类对应Mapper接口和Mapper.xml文件 IF &lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title!=null&quot;&gt; and title = #{title} &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; choose (when, otherwise) trim、where、set SQL片段 有的时候，我们可能会将一些功能的部分抽取出来，方便服用！ 使用SQL标签抽取公共部分可 &lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title!=null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/sql&gt; 在需要使用的地方使用Include标签引用即可 &lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt; &lt;/select&gt; 注意事项： 最好基于单标来定义SQL片段 不要存在where标签 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL，再对应的去修改成我们的动态SQL实现通用即可 13、缓存 13.1 简介 查询 ： 连接数据库，耗资源 一次查询的结果，给他暂存一个可以直接取到的地方 --&gt; 内存：缓存 我们再次查询的相同数据的时候，直接走缓存，不走数据库了 什么是缓存[Cache]？ 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据可以使用缓存？ 经常查询并且不经常改变的数据 【可以使用缓存】 13.2 MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。 MyBatis系统中默认定义了两级缓存： 一级缓存 和 二级缓存 默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 13.3 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Session中查询两次记录 @Test public void test1() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); System.out.println(&quot;=====================================&quot;); User user2 = mapper.getUserById(1); System.out.println(user2 == user); } 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 sqlSession.clearCache(); 13.4 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查询出的数据会放在自己对应的缓存（map）中 一级缓存开启（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 步骤： 开启全局缓存 &lt;!--显示的开启全局缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在Mapper.xml中使用缓存 &lt;!--在当前Mapper.xml中使用二级缓存--&gt; &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题：我们需要将实体类序列化，否则就会报错 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会放在一级缓存中 只有当前会话提交，或者关闭的时候，才会提交到二级缓存中 13.5 缓存原理 注意： 只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true” &lt;select id=&quot;getUserById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt; select * from user where id = #{id} &lt;/select&gt; 13.6 自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 导包 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; 在mapper中指定使用我们的ehcache缓存实现 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; ","link":"https://ganhan999.github.io/post/Java Mybatis/"},{"title":"中等34. 在排序数组中查找元素的第一个和最后一个位置","content":"题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 本体思路 二分查找，先找左边的数，如果mid等于target那么右边的target不可能是最左边的数。反之亦然。 #大神做法1： class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: size = len(nums) if size == 0: return [-1, -1] first_position = self.__find_first_position(nums, size, target) if first_position == -1: return [-1, -1] last_position = self.__find_last_position(nums, size, target) return [first_position, last_position] def __find_first_position(self, nums, size, target): left = 0 right = size - 1 while left &lt; right: mid = (left + right) // 2 if nums[mid] &lt; target: left = mid + 1 elif nums[mid] == target: right = mid else: # nums[mid] &gt; target right = mid - 1 if nums[left] == target: return left else: return -1 def __find_last_position(self, nums, size, target): left = 0 right = size - 1 while left &lt; right: mid = (left + right + 1) // 2 #这里是因为如果存在8，8的情况，那么需要去上整数才可以得到最右边的数 if nums[mid] &gt; target: right = mid - 1 elif nums[mid] == target: left = mid else: # nums[mid] &lt; target left = mid + 1 # 由于能走到这里，说明在数组中一定找得到目标元素，因此这里不用再做一次判断 因为左边已经找到了数 return left ","link":"https://ganhan999.github.io/post/34、在排序数组中查找元素的第一个和最后一个位置 - 副本/"},{"title":"Java Web","content":"1、基本概念 1.1、前言 web开发： web，网页的意思，www.baidu.com· 静态web html,sss 提供给所有人看的数据始终不会发生变化！ 动态web 淘宝，几乎是所有的网站； 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！ 技术栈：Servlet/ISP，ASP，PHP 1.2、web应用程序web应用程序： 可以提供浏览器访问的程序； a.html、b.html.….多个web资源，这些web资源可以被外界访问，对外界提供服务； 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。 URL 这个统一的web资源会被放在同一个文件夹下，web应用程序&gt;Tomcat：服务器 一个web应用由多部分组成（静态web，动态web) html,sss,is jsp,servlet Java程序 jar包 配置文件（Properties) Web酸用程序编写完毕后，若想提供给外界访问；需费一个服务蔬来统一管理 1.3、静态web *.htm， *.html这些都是网员的后境、如果服务器上一直存在这些东四，我们就可以直接进行读取、需要网络； 静态web存在的缺点 Web页面无法动态更新，所有用户看到都是同一个页面 轮播图，点击特效：伪动态 JavaScript[实际开发中，它用的最多] VBScript 它无法和数据库交互（数据无法持久化，用户无法交互） 1.4、 动态web 页面会动态展示，“web页面的展示效果因人而异” 缺点： 加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布； 停机维护优点： Web页面可以动态更新，所有用户看到都不是同一个页面 它可以与数据库交互（数据持久化：注册，商品信息，用户信息………） 2、web服务器 2.1、技术讲解 ASP: 微软：国内最早流行的就是ASP； ·在HTML中嵌入了VB的脚本，ASP+COM； ·在ASP开发中，基本一个页面都有几干行的业务代码，页面极其换乱 ·维护成本高！ C# IIS php: PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP） ·无法承载大访问量的情况（局限性） jSP/Servlet: B/S；浏览和服务器C/S：客户端和服务器 sun公司主推的B/S架构 基于Java语言的（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响； 语法像ASP，ASP-&gt;JSP，加强市场强度； 2.2、web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息； lIS 微软的；ASP.,Windows中自带的 Tomcat 面向百度编程： Tomcat是Apache 软件基金会（Apache Software Foundation)的jakarta项目中的一个核心项目，最新的Servlet 和ISP 规范总是能在Tomcat中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受lava爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试ISP程序的首选。对于一个Java初学web的人来说，它是最佳的选择 Tomcat 实际上运行JSP页面和Serlet。Tornct最新版易9.0 工作3-5年之后，可以尝试手写Tomcat服务器； 下载tomcat： 安装or解压 了解配置文件及目录结构 这个东西的作用 3、Tomcat 3.1安装tomcat tomcat 官网：http://tomcat.apache.org/ 3.2、Tomcat启动和配置 文件夹作用: 访问测试：http://localhost:8080/ 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 可以修改 conf/logging.properties 中的 java.util.logging.ConsoleHandler.encoding = GBK 解决乱码问题 3.3、配置 可以配置启动的端口号 tomcat的默认端口号为：8080 mysql:3306 http:80 https：443 &lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 可以配置主机的名称 默认的主机名为：localhost-&gt;127.0.0.1 默认网站应用存放的位置为：webapps &lt;Host name=&quot;www.qinjiang.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 高难度面试题： 请你谈谈网站是如何进行访问的！ 输入一个域名；回车 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问 127.0.0.1 www.qinjiang.com 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到； 4.可以配置一下环境变量（可选性） 3.4、发布一个web网站 不会就先模仿 将自己写的网站，放到服务器（Tomcat)中指定的web应用的文件夹（webapps)下，就可以访问了 网站应该有的结构 --webapps ：Tomcat服务器的web目录 -ROOT -kuangstudy ：网站的目录名 - WEB-INF -classes : java程序 -lib：web应用所依赖的jar包 -web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img -..... HTTP协议：面试 Maven:构建工具 Maven安装包 Servlet入门 HelloWorld! Servlet配置 ·原理 4、Http 4.1、什么是HTTPHTTP (超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。 文本：html，字符串，… 超文本：图片，音乐，视频，定位，地图.…… 端口:80 Https:安全的 4.2、两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接 http2.0 HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。 4.3、Http请求 客户端–发请求（Request）–服务器 百度： Request URL:https://www.baidu.com/ 请求地址 Request Method:GET get方法/post方法 Status Code:200 OK 状态码：200 Remote（远程） Address:14.215.177.39:443 Accept:text/html Accept-Encoding:gzip, deflate, br Accept-Language:zh-CN,zh;q=0.9 语言 Cache-Control:max-age=0 Connection:keep-alive 1、请求行 请求行中的请求方式：GET 请求方式：Get,Post,HEAD,DELETE,PUT,TRACT.… get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 2、消息头 Accept：告诉浏览器，它所支持的数据类型 Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1 Accept-Language：告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection：告诉浏览器，请求完成是断开还是保持连接 HOST：主机..../. 4.4、Http响应 服务器–响应…….客户端 百度： Cache-Control:private 缓存控制 Connection:Keep-Alive 连接 Content-Encoding:gzip 编码 Content-Type:text/html 类型 1、响应体 Accept：告诉浏览器，它所支持的数据类型 Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1 Accept-Language：告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection：告诉浏览器，请求完成是断开还是保持连接 HOST：主机..../. Refresh：告诉客户端，多久刷新一次； Location：让网页重新定位； 2、响应状态码 200：请求响应成功200 3xx:请求重定向·重定向：你重新到我给你新位置去； 4xx:找不到资源404·资源不存在； 5xx:服务器代码错误 500 502:网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？ 5、Maven 我为什么要学习这个技术？ 在Javaweb开发中，需要使用大量的jar包，我们手动去导入； 如何能够让一个东西自动帮我导入和配置这个jar包。 由此，Maven诞生了！ 5.1 Maven项目架构管理工具 我们目前用来就是方便导入jar包的！ Maven的核心思想：约定大于配置 有约束，不要去违反。 Maven会规定好你该如何去编写我们Java代码，必须要按照这个规范来； 5.2下载安装Maven 官网：https://maven.apache.org/ 下载完成后，解压即可； 小狂神友情建议：电脑上的所有环境都放在一个文件夹下，方便管理； 5.3配置环境变量 在我们的系统环境变量中配置如下配置： M2_HOME maven目录下的bin目录 MAVEN_HOME maven的目录 在系统的path中配置%MAVEN_HOME%\\bin 测试Maven是否安装成功，保证必须配置完毕！ 5.4阿里云镜像 镜像：mirrors 作用：加速我们的下载 国内建议使用阿里云的镜像 &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; D:Enmvironment\\apache-maven-3.6.2conf\\ettings.xml （狂神老师配置源和仓库的文件位置） 5.5本地仓库 在本地的仓库，远程仓库； 建立一个本地仓库：localRepository &lt;localRepository&gt;D:\\Environment\\apache-maven-3.6.2\\maven-repo&lt;/localRepository&gt; 5.6 ~ 5.13笔记-下载地址 （拒接度盘）下载地址：https://wo-bell.lanzous.com/ibuibxi 后面的 5.6 ~ 5.13 + 案例演示 (图) 后面第 5 剩下部分的笔记建议配合狂神的 “javaweb-06：IDEA中Maven的操作”、“javaweb-07：解决大家遇到的一些问题” 仔细（回）看 6、Servlet 6.1、Servlet简介 Servlet就是sun公司开发动态web的一门技术 Sun在这些APi中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类，实现Serlet接口 把开发好java类部署到web服务器中。 把实现了Servlet接口的Java程序叫做，Servlet 6.2、HelloServlet Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServled 6.2、HelloServlet 构建一个普通的Maven项目，等理面的sc目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就题Maven主工程； 关于Maven父子工程的理解； 父项目中会有 &lt;modules&gt; &lt;module&gt;servlet-01&lt;/module&gt; &lt;/modules&gt; 子项目会有 &lt;parent&gt; &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; 父项目中的java子项目可以直接使用 son extends father Maven环境优化 修改web.xml为最新的 将maven的结构搭建完整 . 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet public class HelloServlet extends HttpServlet { //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //ServletOutputStream outputStream = resp.getOutputStream(); PrintWriter writer = resp.getWriter(); //响应流 writer.print(&quot;Hello,Serlvet&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写Servlet的映射 为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需 要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径； &lt;!--注册Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--Servlet的请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Tomcat 注意：配置项目发布的路径就可以了 启动测试，OK！ 6.3、Servlet原理 Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会： 6.4、Mapping问题 一个Servlet可以指定一个映射路径 . &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 一个servlet可以指定多个映射路径 &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 一个servlet可以指定通用映射路径 &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 默认请求路径 &lt;!--默认请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 指定一些后缀或者前缀等等… &lt;!--可以自定义后缀实现请求映射 注意点，*前面不能加项目映射的路径 hello/sajdlkajda.qinjiang --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.qinjiang&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； &lt;!--404--&gt; &lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 6.5、ServletContext web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用； 1、共享数据 我在这个Servlet中保存的数据，可以在另外一个servlet中拿到； public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //this.getInitParameter() 初始化参数 //this.getServletConfig() Servlet配置 //this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = &quot;秦疆&quot;; //数据 context.setAttribute(&quot;username&quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username } } public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;名字&quot;+username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;getc&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.GetServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getc&lt;/servlet-name&gt; &lt;url-pattern&gt;/getc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 测试访问结果； 2、获取初始化参数 &lt;!--配置一些web应用初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt; &lt;/context-param&gt; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String url = context.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); } 3、请求转发 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); System.out.println(&quot;进入了ServletDemo04&quot;); //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径 //requestDispatcher.forward(req,resp); //调用forward实现请求转发； context.getRequestDispatcher(&quot;/gp&quot;).forward(req,resp); } 4、读取资源文件 Properties 在java目录下新建properties 在resources目录下新建properties 发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath: 思路：需要一个文件流 username=root12312 password=zxczxczxc public class ServletDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(&quot;username&quot;); String pwd = prop.getProperty(&quot;password&quot;); resp.getWriter().print(user+&quot;:&quot;+pwd); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 访问测试即可ok; 6.6、HttpServletResponse web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest 对象，代表响应的一个HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 1、简单分类 负责向浏览器发送数据的方法 servletOutputstream getOutputstream() throws IOException; Printwriter getwriter() throws IOException; 负责向浏览器发送响应头的方法 void setCharacterEncoding(String var1)； void setContentLength(int var1)； void setContentLengthLong(long var1); void setContentType(String var1)； void setDateHeader(String varl,long var2) void addDateHeader(String var1,long var2) void setHeader(String var1,String var2); void addHeader(String var1,String var2)； void setIntHeader(String var1,int var2); void addIntHeader(String varl,int var2); 响应的状态码 2、下载文件 向浏览器输出消息（一直在讲，就不说了） 下载文件 要获取下载文件的路径 下载的文件名是啥？ 设置想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入到bufer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 要获取下载文件的路径 String realPath = &quot;F:\\\\班级管理\\\\西开【19525】\\\\2、代码\\\\JavaWeb\\\\javaweb-02-servlet\\\\response\\\\target\\\\classes\\\\秦疆.png&quot;; System.out.println(&quot;下载文件的路径：&quot;+realPath); // 2. 下载的文件名是啥？ String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;) + 1); // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码 resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName,&quot;UTF-8&quot;)); // 4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(realPath); // 5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; // 6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！ while ((len=in.read(buffer))&gt;0){ out.write(buffer,0,len); } in.close(); out.close(); } 3、验证码功能 验证怎么来的? 前端实现 后端实现，需要用到Java的图片类，生产一个图片 package com.kuang.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如何让浏览器3秒自动刷新一次; resp.setHeader(&quot;refresh&quot;,&quot;3&quot;); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D) image.getGraphics(); //笔 //设置图片的背景颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.BLUE); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(&quot;image/jpeg&quot;); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(&quot;expires&quot;,-1); resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;); //把图片写给浏览器 ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream()); } //生成随机数 private String makeNum(){ Random random = new Random(); String num = random.nextInt(9999999) + &quot;&quot;; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 7-num.length() ; i++) { sb.append(&quot;0&quot;); } num = sb.toString() + num; return num; } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } &lt;servlet&gt; &lt;servlet-name&gt;ImageServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.ImageServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Imageservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/img&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 常见场景: 用户登录 void sendRedirect(String var1) throws IOException; 测试： @override protected void doGet(HttpservletRequest req, HttpservletResponse resp) throws ServletException, IOException { resp. sendRedirect(&quot;/r/img&quot;);//重定向 /* resp. setHeader(&quot;Location&quot;,&quot;/r/img&quot;); resp. setstatus (302); */ } index.jsp &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hel1o World!&lt;/h2&gt; 《%--这里超交的路径,需要寻找到项目的路径--%&gt; &lt;%--${pageContext. request, contextPath}代表当前的项目--%&gt; &lt;form action=&quot;${pageContext. request.contextPath}/login&quot; method=&quot;get&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; RequestTest.java public class RequestTest extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //处理方求 String username = req.getParameter( s: &quot;username&quot;); String password req.getParameter( s: &quot;password&quot;); System.out.println(username+&quot;:&quot;+password); resp.sendRedirect(s: &quot;/r/success.jsp&quot;); } 重定向页面success.jsp &lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;success&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; web.xml配置 &lt;servlet&gt; &lt;servlet-name&gt;requset&lt;/servlet-name&gt; &lt;servlet-class&gt;com. kuang. servlet. RequestTest&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;requset&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 导入依赖的jar包 &lt;dependencies&gt; &lt;!-- https://mvnrepository. com/artifact/javax. servLet/javax. servlet-opi --&gt; &lt;dependency&gt; &lt;groupld&gt;javax.servlet&lt;/grouptd&gt; &lt;artifactId&gt;javax. servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax. servLet.jsp/javax. servLet.jsp-opi --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupld&gt; &lt;artifactId&gt;javax. servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 6.7、HttpServletRequest HttpServletRequest代表客户端的请求,用户通过Http协议访问服务器, HTTP请求中的所有信息会被封装到HttpServletRequest,通过这个HttpServletRequest的方法,获得客户端的所有信息; 获取参数,请求转发 自己创建类，且需要继承HttpServlet类 @Override protected void doGet(HttpservletRequest req. HttpservletResponse resp) throws ServletException, IOException { req. setcharacterEncoding(&quot;utf-8&quot;); resp.setcharacterEncoding(&quot;utf-8&quot;); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String[] hobbys = req.getParameterValues(&quot;hobbys&quot;); System.out.println(&quot;==========&quot;); //后台接收中文乱码问题 System. out.println(username); System. out.println(password); System. out.println(Arrays.tostring(hobbys)); System. out.println(&quot;============&quot;); system. out.println(req.getContextPath()); //通过请求转发 //这里的/代表当前的web应用 req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp); } 7、Cookie、Session 7.1、会话 会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话； 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话； 你能怎么证明你是西开的学生？ 你 西开 发票 西开给你发票 学校登记 西开标记你来过了 一个网站，怎么证明你来过？ 客户端 服务端 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie 服务器登记你来过了，下次你来的时候我来匹配你； seesion 7.2、保存会话的两种技术 cookie 客户端技术 （响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！ 常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！ 7.3、Cookie 从请求中拿到cookie信息 服务器响应给客户端cookie Cookie[] cookies = req.getCookies(); //获得Cookie cookie.getName(); //获得cookie中的key cookie.getValue(); //获得cookie中的vlaue new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookie cookie.setMaxAge(24*60*60); //设置cookie的有效期 resp.addCookie(cookie); //响应给客户端一个cookie cookie：一般会保存在本地的 用户目录下 appdata； 一个网站cookie是否存在上限！聊聊细节问题 一个Cookie只能保存一个信息； 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie； Cookie大小有限制4kb； 300个cookie浏览器上限 删除Cookie； 不设置有效期，关闭浏览器，自动失效； 设置有效期时间为 0 ； 编码解码： URLEncoder.encode(&quot;秦疆&quot;,&quot;utf-8&quot;) URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;) 7.4、Session（重点） 什么是Session： 服务器会给每一个用户（浏览器）创建一个Seesion对象； 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息…… … … … Session和cookie的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费） Session对象由服务创建； 使用场景： 保存一个登录用户的信息； 购物车信息； 在整个网站中经常会使用的数据，我们将它保存在Session中； 使用Session： package com.kuang.servlet; import com.kuang.pojo.Person; import javax.servlet.ServletException; import javax.servlet.http.*; import java.io.IOException; public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决乱码问题 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到Session HttpSession session = req.getSession(); //给Session中存东西 session.setAttribute(&quot;name&quot;,new Person(&quot;秦疆&quot;,1)); //获取Session的ID String sessionId = session.getId(); //判断Session是不是新创建 if (session.isNew()){ resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId); }else { resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId); } //Session创建的时候做了什么事情； // Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId); // resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } //得到Session HttpSession session = req.getSession(); Person person = (Person) session.getAttribute(&quot;name&quot;); System.out.println(person.toString()); HttpSession session = req.getSession(); session.removeAttribute(&quot;name&quot;); //手动注销Session session.invalidate(); 会话自动过期：web.xml配置 &lt;!--设置Session默认的失效时间--&gt; &lt;session-config&gt; &lt;!--15分钟后Session自动失效，以分钟为单位--&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; 8、JSP 8.1、什么是JSP Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！ 最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据； 8.2、JSP原理 思路：JSP到底怎么执行的！ 代码层面没有任何问题 服务器内部工作 tomcat中有一个work目录； IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录 我电脑的地址： C:\\Users\\Administrator.IntelliJIdea2018.1\\system\\tomcat\\Unnamed_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 发现页面转变成了Java程序！ 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！ JSP最终也会被转换成为一个Java类！ JSP 本质上就是一个Servlet //初始化 public void _jspInit() { } //销毁 public void _jspDestroy() { } //JSPService public void _jspService(.HttpServletRequest request,HttpServletResponse response) 判断请求 内置一些对象 final javax.servlet.jsp.PageContext pageContext; //页面上下文 javax.servlet.http.HttpSession session = null; //session final javax.servlet.ServletContext application; //applicationContext final javax.servlet.ServletConfig config; //config javax.servlet.jsp.JspWriter out = null; //out final java.lang.Object page = this; //page：当前 HttpServletRequest request //请求 HttpServletResponse response //响应 输出页面前增加的代码 response.setContentType(&quot;text/html&quot;); //设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; 以上的这些个对象我们可以在JSP页面中直接使用！ 在JSP页面中； 只要是 JAVA代码就会原封不动的输出； 如果是HTML代码，就会被转换为： out.write(&quot;&lt;html&gt;\\r\\n&quot;); 这样的格式，输出到前端！ 8.3、JSP基础语法 任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！ JSP表达式 &lt;%--JSP表达式 作用：用来将程序的输出，输出到客户端 &lt;%= 变量或者表达式%&gt; --%&gt; &lt;%= new java.util.Date()%&gt; jsp脚本片段 &lt;%--jsp脚本片段--%&gt; &lt;% int sum = 0; for (int i = 1; i &lt;=100 ; i++) { sum+=i; } out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;); %&gt; 脚本片段的再实现 &lt;% int x = 10; out.println(x); %&gt; &lt;p&gt;这是一个JSP文档&lt;/p&gt; &lt;% int y = 2; out.println(y); %&gt; &lt;hr&gt; &lt;%--在代码嵌入HTML元素--%&gt; &lt;% for (int i = 0; i &lt; 5; i++) { %&gt; &lt;h1&gt;Hello,World &lt;%=i%&gt; &lt;/h1&gt; &lt;% } %&gt; JSP声明 &lt;%! static { System.out.println(&quot;Loading Servlet!&quot;); } private int globalVar = 0; public void kuang(){ System.out.println(&quot;进入了方法Kuang！&quot;); } %&gt; JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！ 在JSP，嵌入Java代码即可！ &lt;%%&gt; &lt;%=%&gt; &lt;%!%&gt; &lt;%--注释--%&gt; JSP的注释，不会在客户端显示，HTML就会！ 8.4、JSP指令 &lt;%@page args.... %&gt; &lt;%@include file=&quot;&quot;%&gt; &lt;%--@include会将两个页面合二为一--%&gt; &lt;%@include file=&quot;common/header.jsp&quot;%&gt; &lt;h1&gt;网页主体&lt;/h1&gt; &lt;%@include file=&quot;common/footer.jsp&quot;%&gt; &lt;hr&gt; &lt;%--jSP标签 jsp:include：拼接页面，本质还是三个 --%&gt; &lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt; &lt;h1&gt;网页主体&lt;/h1&gt; &lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt; 8.5、9大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【SerlvetContext】 存东西 config 【SerlvetConfig】 out page ，不用了解 exception pageContext.setAttribute(&quot;name1&quot;,&quot;秦疆1号&quot;); //保存的数据只在一个页面中有效 request.setAttribute(&quot;name2&quot;,&quot;秦疆2号&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(&quot;name3&quot;,&quot;秦疆3号&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(&quot;name4&quot;,&quot;秦疆4号&quot;); //保存的数据只在服务器中有效，从打开服务器到关闭服务器 request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车； application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据； 8.6、JSP标签、JSTL标签、EL表达式 &lt;!-- JSTL表达式的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- standard标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; EL表达式： ${ } 获取数据 执行运算 获取web开发的常用对象 JSP标签 &lt;%--jsp:include--%&gt; &lt;%-- http://localhost:8080/jsptag.jsp?name=kuangshen&amp;age=12 --%&gt; &lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt; &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt; &lt;/jsp:forward&gt; JSTL表达式 JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！ 格式化标签 SQL标签 XML 标签 核心标签 （掌握部分） JSTL标签库使用步骤 引入对应的 taglib 使用其中的方法 在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误 c：if &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;if测试&lt;/h4&gt; &lt;hr&gt; &lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt; &lt;%-- EL表达式获取表单中的数据 ${param.参数名} --%&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${param.username}&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt; &lt;c:if test=&quot;${param.username=='admin'}&quot; var=&quot;isAdmin&quot;&gt; &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt; &lt;/c:if&gt; &lt;%--自闭合标签--%&gt; &lt;c:out value=&quot;${isAdmin}&quot;/&gt; &lt;/body&gt; c:choose c:when &lt;body&gt; &lt;%--定义一个变量score，值为85--%&gt; &lt;c:set var=&quot;score&quot; value=&quot;55&quot;/&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${score&gt;=90}&quot;&gt; 你的成绩为优秀 &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;=80}&quot;&gt; 你的成绩为一般 &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;=70}&quot;&gt; 你的成绩为良好 &lt;/c:when&gt; &lt;c:when test=&quot;${score&lt;=60}&quot;&gt; 你的成绩为不及格 &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/body&gt; c:forEach &lt;% ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;(); people.add(0,&quot;张三&quot;); people.add(1,&quot;李四&quot;); people.add(2,&quot;王五&quot;); people.add(3,&quot;赵六&quot;); people.add(4,&quot;田六&quot;); request.setAttribute(&quot;list&quot;,people); %&gt; &lt;%-- var , 每一次遍历出来的变量 items, 要遍历的对象 begin, 哪里开始 end, 到哪里 step, 步长 --%&gt; &lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot;&gt; &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt; &lt;/c:forEach&gt; &lt;hr&gt; &lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt; &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt; &lt;/c:forEach&gt; 9、JavaBean 实体类 JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法； 一般用来和数据库的字段做映射 ORM； ORM ：对象关系映射 表—&gt;类 字段–&gt;属性 行记录----&gt;对象 people表 id name age address 1 秦疆1号 3 西安 2 秦疆2号 18 西安 3 秦疆3号 100 西安 class People{ private int id; private String name; private int id; private String address; } class A{ new People(1,&quot;秦疆1号&quot;,3，&quot;西安&quot;); new People(2,&quot;秦疆2号&quot;,3，&quot;西安&quot;); new People(3,&quot;秦疆3号&quot;,3，&quot;西安&quot;); } 过滤器 文件上传 邮件发送 JDBC 复习 ： 如何使用JDBC , JDBC crud， jdbc 事务 10、MVC三层架构 什么是MVC： Model view Controller 模型、视图、控制器 10.1、以前的架构 用户直接访问控制层，控制层就可以直接操作数据库； servlet--CRUD--&gt;数据库 弊端：程序十分臃肿，不利于维护 servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 架构：没有什么是加一层解决不了的！ 程序猿调用 ↑ JDBC （实现该接口） ↑ Mysql Oracle SqlServer ....（不同厂商） 10.2、MVC三层架构 Model 业务处理 ：业务逻辑（Service） 数据持久层：CRUD （Dao - 数据持久化对象） View 展示数据 提供链接发起Servlet请求 （a，form，img…） Controller （Servlet） 接收用户的请求 ：（req：请求参数、Session信息….） 交给业务层处理对应的代码 控制视图的跳转 登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库 11、Filter （重点） 比如 Shiro安全框架技术就是用Filter来实现的 Filter：过滤器 ，用来过滤网站的数据； 处理中文乱码 登录验证…. （比如用来过滤网上骂人的话，我***我自己 0-0） Filter开发步骤： 导包 编写过滤器 导包不要错 （注意） 实现Filter接口，重写对应的方法即可 ```java public class CharacterEncodingFilter implements Filter { //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！ public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&quot;CharacterEncodingFilter初始化&quot;); } //Chain : 链 /* 1. 过滤中的所有代码，在过滤特定请求的时候都会执行 2. 必须要让过滤器继续同行 chain.doFilter(request,response); */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(&quot;CharacterEncodingFilter执行前....&quot;); chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！ System.out.println(&quot;CharacterEncodingFilter执行后....&quot;); } //销毁：web服务器关闭的时候，过滤器会销毁 public void destroy() { System.out.println(&quot;CharacterEncodingFilter销毁&quot;); } } 1. 在web.xml中配置 Filter ```xml &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt; &lt;!-- 别偷懒写个 /* --&gt; &lt;/filter-mapping&gt; 12、监听器 实现一个监听器的接口；（有n种监听器） 编写一个监听器 实现监听器的接口… 依赖的jar包 //统计网站在线人数 ： 统计session public class OnlineCountListener implements HttpSessionListener { //创建session监听： 看你的一举一动 //一旦创建Session就会触发一次这个事件！ public void sessionCreated(HttpSessionEvent se) { ServletContext ctx = se.getSession().getServletContext(); System.out.println(se.getSession().getId()); Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;); if (onlineCount==null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count+1); } ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount); } //销毁session监听 //一旦销毁Session就会触发一次这个事件！ public void sessionDestroyed(HttpSessionEvent se) { ServletContext ctx = se.getSession().getServletContext(); Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;); if (onlineCount==null){ onlineCount = new Integer(0); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count-1); } ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount); } /* Session销毁： 1. 手动销毁 getSession().invalidate(); 2. 自动销毁 */ } web.xml中注册监听器 &lt;!--注册监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt; &lt;/listener&gt; 看情况是否使用！ 13、过滤器、监听器常见应用 监听器：GUI编程中经常使用； public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(&quot;中秋节快乐&quot;); //新建一个窗体 Panel panel = new Panel(null); //面板 frame.setLayout(null); //设置窗体的布局 frame.setBounds(300,300,500,500); frame.setBackground(new Color(0,0,255)); //设置背景颜色 panel.setBounds(50,50,300,300); panel.setBackground(new Color(0,255,0)); //设置背景颜色 frame.add(panel); frame.setVisible(true); //监听事件，监听关闭事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); } }); } } 用户登录之后才能进入主页！用户注销后就不能进入主页了！ 用户登录之后，向Sesison中放入用户的数据 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！ HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; if (request.getSession().getAttribute(Constant.USER_SESSION)==null){ response.sendRedirect(&quot;/error.jsp&quot;); } chain.doFilter(request,response); 14、JDBC 什么是JDBC ： Java连接数据库！ 需要jar包的支持： java.sql javax.sql mysql-conneter-java… 连接驱动（必须要导入） 实验环境搭建 CREATE TABLE users( id INT PRIMARY KEY, `name` VARCHAR(40), `password` VARCHAR(40), email VARCHAR(60), birthday DATE ); INSERT INTO users(id,`name`,`password`,email,birthday) VALUES(1,'张三','123456','zs@qq.com','2000-01-01'); INSERT INTO users(id,`name`,`password`,email,birthday) VALUES(2,'李四','123456','ls@qq.com','2000-01-01'); INSERT INTO users(id,`name`,`password`,email,birthday) VALUES(3,'王五','123456','ww@qq.com','2000-01-01'); SELECT * FROM users; 导入数据库依赖 &lt;!--mysql的驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; IDEA中连接数据库： JDBC 固定步骤： 加载驱动 连接数据库,代表数据库 向数据库发送SQL的对象Statement : CRUD 编写SQL （根据业务，不同的SQL） 执行SQL 关闭连接（先开的后关） public class TestJdbc { public static void main(String[] args) throws ClassNotFoundException, SQLException { //配置信息 //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码 String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.连接数据库,代表数据库 Connection connection = DriverManager.getConnection(url, username, password); //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD Statement statement = connection.createStatement(); //4.编写SQL String sql = &quot;select * from users&quot;; //5.执行查询SQL，返回一个 ResultSet ： 结果集 ResultSet rs = statement.executeQuery(sql); while (rs.next()){ System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;)); System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;)); System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;)); } //6.关闭连接，释放资源（一定要做） 先开后关 rs.close(); statement.close(); connection.close(); } } 预编译SQL public class TestJDBC2 { public static void main(String[] args) throws Exception { //配置信息 //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码 String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.连接数据库,代表数据库 Connection connection = DriverManager.getConnection(url, username, password); //3.编写SQL String sql = &quot;insert into users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;; //4.预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1； preparedStatement.setString(2,&quot;狂神说Java&quot;);//给第二个占位符？ 的值赋值为狂神说Java； preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？ 的值赋值为123456； preparedStatement.setString(4,&quot;24736743@qq.com&quot;);//给第四个占位符？ 的值赋值为1； preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())； //5.执行SQL int i = preparedStatement.executeUpdate(); if (i&gt;0){ System.out.println(&quot;插入成功@&quot;); } //6.关闭连接，释放资源（一定要做） 先开后关 preparedStatement.close(); connection.close(); } } 事务 要么都成功，要么都失败！ ACID原则：保证数据的安全。 开启事务 事务提交 commit() 事务回滚 rollback() 关闭事务 转账： A:1000 B:1000 A(900) --100--&gt; B(1100) Junit单元测试 依赖 &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 简单使用 @Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！ @Test public void test(){ System.out.println(&quot;Hello&quot;); } 失败的时候是红色： 搭建一个环境 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(40), money FLOAT ); INSERT INTO account(`name`,money) VALUES('A',1000); INSERT INTO account(`name`,money) VALUES('B',1000); INSERT INTO account(`name`,money) VALUES('C',1000); 6789 @Test public void test() { //配置信息 //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码 String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; Connection connection = null; //1.加载驱动 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.连接数据库,代表数据库 connection = DriverManager.getConnection(url, username, password); //3.通知数据库开启事务,false 开启 connection.setAutoCommit(false); String sql = &quot;update account set money = money-100 where name = 'A'&quot;; connection.prepareStatement(sql).executeUpdate(); //制造错误 //int i = 1/0; String sql2 = &quot;update account set money = money+100 where name = 'B'&quot;; connection.prepareStatement(sql2).executeUpdate(); connection.commit();//以上两条SQL都执行成功了，就提交事务！ System.out.println(&quot;success&quot;); } catch (Exception e) { try { //如果出现异常，就通知数据库回滚事务 connection.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } SMBMS(超市管理项目) 数据库： 项目如何搭建？ 考虑是不是用maven？ jar包，依赖 搭建项目准备工作 搭建一个maven web 项目 配置Tomcat 测试项目是否能够跑起来 导入项目中需要的jar包; jsp，Servlet，mysql驱动jstl，stand… 构建项目包结构 编写实体类 ROM映射:表-类映射 编写基础公共类 1、数据库配置文件（mysql5.xx和8.xx的编写有差异） driver=com.mysql.jdbc.Driver #在和mysql传递数据的过程中，使用unicode编码格式，并且字符集设置为utf-8 url=jdbc:mysql://127.0.0.1:3306/smbms?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8 user=root password=root 12345 2、编写数据库的公共类 package dao; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Properties; /** * 操作数据库的基类--静态类 * @author Administrator * */ public class BaseDao { static{//静态代码块,在类加载的时候执行 init(); } private static String driver; private static String url; private static String user; private static String password; //初始化连接参数,从配置文件里获得 public static void init(){ Properties params=new Properties(); String configFile = &quot;database.properties&quot;; InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile); try { params.load(is); } catch (IOException e) { e.printStackTrace(); } driver=params.getProperty(&quot;driver&quot;); url=params.getProperty(&quot;url&quot;); user=params.getProperty(&quot;user&quot;); password=params.getProperty(&quot;password&quot;); } /** * 获取数据库连接 * @return */ public static Connection getConnection(){ Connection connection = null; try { Class.forName(driver); connection = DriverManager.getConnection(url, user, password); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } return connection; } /** * 查询操作 * @param connection * @param pstm * @param rs * @param sql * @param params * @return */ public static ResultSet execute(Connection connection,PreparedStatement pstm,ResultSet rs, String sql,Object[] params) throws Exception{ pstm = connection.prepareStatement(sql); for(int i = 0; i &lt; params.length; i++){ pstm.setObject(i+1, params[i]); } rs = pstm.executeQuery(); return rs; } /** * 更新操作 * @param connection * @param pstm * @param sql * @param params * @return * @throws Exception */ public static int execute(Connection connection,PreparedStatement pstm, String sql,Object[] params) throws Exception{ int updateRows = 0; pstm = connection.prepareStatement(sql); for(int i = 0; i &lt; params.length; i++){ pstm.setObject(i+1, params[i]); } updateRows = pstm.executeUpdate(); return updateRows; } /** * 释放资源 * @param connection * @param pstm * @param rs * @return */ public static boolean closeResource(Connection connection,PreparedStatement pstm,ResultSet rs){ boolean flag = true; if(rs != null){ try { rs.close(); rs = null;//GC回收 } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); flag = false; } } if(pstm != null){ try { pstm.close(); pstm = null;//GC回收 } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); flag = false; } } if(connection != null){ try { connection.close(); connection = null;//GC回收 } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); flag = false; } } return flag; } } . 3、编写字符编码过滤器 导入静态资源 登录功能实现 编写前端页面 设置首页 1.设置欢迎首页 &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 编写dao层登录用户登录的接口 public User getLoginUser(Connection connection, String userCode) throws Exception; 编写dao层接口的实现类 import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import dao.BaseDao; import pojo.User; public class UserDaoImpl implements UserDao{ //持久层只做查询数据库的内容 public User getLoginUser(Connection connection, String userCode) throws Exception{ //准备三个对象 PreparedStatement pstm = null; ResultSet rs = null; User user = null; //判断是否连接成功 if(null != connection){ String sql = &quot;select * from smbms_user where userCode=?&quot;; Object[] params = {userCode}; rs = BaseDao.execute(connection, pstm, rs, sql, params); if(rs.next()){ user = new User(); user.setId(rs.getInt(&quot;id&quot;)); user.setUserCode(rs.getString(&quot;userCode&quot;)); user.setUserName(rs.getString(&quot;userName&quot;)); user.setUserPassword(rs.getString(&quot;userPassword&quot;)); user.setGender(rs.getInt(&quot;gender&quot;)); user.setBirthday(rs.getDate(&quot;birthday&quot;)); user.setPhone(rs.getString(&quot;phone&quot;)); user.setAddress(rs.getString(&quot;address&quot;)); user.setUserRole(rs.getInt(&quot;userRole&quot;)); user.setCreatedBy(rs.getInt(&quot;createdBy&quot;)); user.setCreationDate(rs.getTimestamp(&quot;creationDate&quot;)); user.setModifyBy(rs.getInt(&quot;modifyBy&quot;)); user.setModifyDate(rs.getTimestamp(&quot;modifyDate&quot;)); } BaseDao.closeResource(null, pstm, rs); } return user; } } 业务层接口 //用户登录 public User login(String userCode, String userPassword); 业务层实现类 import java.sql.Connection; //import org.junit.Test; import dao.BaseDao; import dao.user.UserDao; import dao.user.UserDaoImpl; import pojo.User; public class UserServiceImpl implements UserService{ //业务层都会调用dao层.所以我们要引入Dao层（重点） //只处理对应业务 private UserDao userDao; public UserServiceImpl(){ userDao = new UserDaoImpl(); } public User login(String userCode,String userPassword) { // TODO Auto-generated method stub Connection connection = null; //通过业务层调用对应的具体数据库操作 User user = null; try { connection = BaseDao.getConnection(); user = userDao.getLoginUser(connection, userCode); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ BaseDao.closeResource(connection, null, null); } return user; } /*@Test public void test() { UserServiceImpl userService = new UserServiceImpl(); String userCode = &quot;admin&quot;; String userPassword = &quot;12345678&quot;; User admin = userService.login(userCode, userPassword); System.out.println(admin.getUserPassword()); } */ } 编写Servlet import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import pojo.User; import util.Constants; import service.user.UserService; import service.user.UserServiceImpl; @SuppressWarnings(&quot;serial&quot;) public class LoginServlet extends HttpServlet{ //接受用户参数、调用业务层、转发视图 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 System.out.println(&quot;login ============ &quot; ); //获取用户名和密码 String userCode = req.getParameter(&quot;userCode&quot;); String userPassword = req.getParameter(&quot;userPassword&quot;); //调用service方法，进行用户匹配 UserService userService = new UserServiceImpl(); User user = userService.login(userCode,userPassword); if(null != user){//登录成功 //放入session req.getSession().setAttribute(Constants.USER_SESSION,user); //页面跳转（frame.jsp） resp.sendRedirect(&quot;jsp/frame.jsp&quot;); }else{ //页面跳转（login.jsp）带出提示信息--转发 req.setAttribute(&quot;error&quot;, &quot;用户名或密码不正确&quot;); req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 doGet(req, resp); } } 注册Servlet &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.user.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 测试访问,保证以上功能可以成功 登录功能优化 注销功能 思路：移除session，返回登录页面 public class LogoutServlet extends HttpServlet { public void doPOST(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //清除session request.getSession().removeAttribute(Constants.USER_SESSION); response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;);//返回登录页面 } } 注册xml &lt;servlet&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.user.LogoutServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/logout.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 12345678 登录拦截优化 编写一个过滤器，并注册 import java.io.IOException; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import pojo.User; import util.Constants; public class SysFilter implements Filter{ public void init(FilterConfig filterConfig) throws ServletException{ } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { // TODO 自动生成的方法存根 HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)resp; //过滤器，从session中获取用户 User user = (User)request.getSession().getAttribute(Constants.USER_SESSION); if(user == null){//已经被移除或者注销了，或者未登录 response.sendRedirect(&quot;/smbms/error.jsp&quot;); }else { chain.doFilter(req, resp); } } @Override public void destroy() { // TODO 自动生成的方法存根 } } 注册xml &lt;!-- 用户登录过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.SysFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 测试，登录，注销，权限，都要保证OK 密码修改 导入前端素材 &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath }/jsp/pwdmodify.jsp&quot;&gt;密码修改&lt;/a&gt;&lt;/li&gt; 写项目，建议从底层向上写 UserDao接口 //修改当前用户密码 public int updatePwd(Connection connection,int id,int password)throws SQLException, Exception; UserDao接口实现类 @Override//修改当前密码 public int updatePwd(Connection connection, int id, int password) throws Exception { // TODO 自动生成的方法存根 PreparedStatement pstm = null; int execute =0; if(connection!=null) { String sql = &quot;update smbms_user set = userPassword = ? where id = ?&quot;; Object[] params = {password,id}; execute = BaseDao.execute(connection, pstm, sql, params); BaseDao.closeResource(null, pstm, null); } return execute; } UserService层 public boolean updatePwd(int id,int password)throws SQLException, Exception; UserService实现类 public boolean updatePwd(int id, int password) throws SQLException, Exception { // TODO 自动生成的方法存根 Connection connection = null; boolean flag = false; //修改密码 try { connection = BaseDao.getConnection(); if(userDao.updatePwd(connection, id, password)&gt;0) { flag = true; } } catch (SQLException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } finally { BaseDao.closeResource(connection, null, null); } return flag; } servlet记得实现复用，要提取出方法！ 在 dao层 和 service层 自己写映射类和实现类 下面是 servlet层 的主体 public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 String method = req.getParameter(&quot;method&quot;); if (method != &quot;savepwd&quot; &amp;&amp; method != null) { this.updatePwd(req, resp); } //实现复用~~~~~~ // 想添加新的增删改查，直接用if(method != &quot;savepwd&quot; &amp;&amp; method != null); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 doGet(req, resp); } public void updatePwd(HttpServletRequest req, HttpServletResponse resp) { // 通过session获得用户id Object o = req.getSession().getAttribute(Constants.USER_SESSION); String newpassword = req.getParameter(&quot;newpassword&quot;); boolean flag = false; if (o != null &amp;&amp; newpassword != null) { UserService userService = new UserServiceImpl(); try { flag = userService.updatePwd(((User) o).getId(), newpassword); } catch (SQLException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (Exception e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } if (flag) { req.setAttribute(&quot;message&quot;, &quot;密码修改成功，请退出，使用新密码登录&quot;); // 密码修改成功,移除session(移除后不能再次修改密码,建议不移除) req.getSession().removeAttribute(Constants.USER_SESSION); } else { // 密码修改失败 req.setAttribute(&quot;message&quot;, &quot;密码修改失败&quot;); } } else { // 密码修改有问题 req.setAttribute(&quot;message&quot;, &quot;新密码有问题&quot;); } try { req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req, resp); } catch (ServletException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } } 注册xml &lt;servlet&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.user.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/user.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 测试 优化密码修改使用Ajax 阿里巴巴的fastjson &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; 后台代码修改 导入阿里的包 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; import java.io.IOException; import java.io.PrintWriter; //import java.io.Writer; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.mysql.cj.util.StringUtils; import com.mysql.cj.xdevapi.JsonArray; //import com.mysql.cj.util.StringUtils; import pojo.User; import service.user.UserService; import service.user.UserServiceImpl; import util.Constants; @SuppressWarnings(&quot;serial&quot;) public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 String method = req.getParameter(&quot;method&quot;); if (method.equals( &quot;savepwd&quot;) &amp;&amp; method != null) { this.updatePwd(req, resp); }else if (method.equals( &quot;pwdmodify&quot;) &amp;&amp; method != null) { } // 想添加新的增删改查，直接用if(method != &quot;savepwd&quot; &amp;&amp; method != null); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO 自动生成的方法存根 doGet(req, resp); } public void updatePwd(HttpServletRequest req, HttpServletResponse resp) { // 通过session获得用户id Object o = req.getSession().getAttribute(Constants.USER_SESSION); String newpassword = req.getParameter(&quot;newpassword&quot;); boolean flag = false; if (o != null &amp;&amp; newpassword != null) { UserService userService = new UserServiceImpl(); try { flag = userService.updatePwd(((User) o).getId(), newpassword); } catch (SQLException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (Exception e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } if (flag) { req.setAttribute(&quot;message&quot;, &quot;密码修改成功，请退出，使用新密码登录&quot;); // 密码修改成功,移除session(移除后不能再次修改密码,建议不移除) req.getSession().removeAttribute(Constants.USER_SESSION); } else { // 密码修改失败 req.setAttribute(&quot;message&quot;, &quot;密码修改失败&quot;); } } else { // 密码修改有问题 req.setAttribute(&quot;message&quot;, &quot;新密码有问题&quot;); } try { req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req, resp); } catch (ServletException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } public void pqdmodify(HttpServletRequest req, HttpServletResponse resp) { // 通过session获得用户id Object o = req.getSession().getAttribute(Constants.USER_SESSION); String oldpassword = req.getParameter(&quot;oldpassword&quot;); Map&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(o==null) {//session失效，session过期了 resultMap.put(&quot;result&quot;,&quot;seesionerror&quot;); }else if(StringUtils.isNullOrEmpty(oldpassword)){//输入密码为空 resultMap.put(&quot;result&quot;,&quot;error&quot;); }else {// String userPassword = ((User)o).getUserPassword();//seesion中的用户密码 if(oldpassword.equals(userPassword)) { resultMap.put(&quot;result&quot;,&quot;true&quot;); }else { resultMap.put(&quot;result&quot;,&quot;false&quot;); } } try { resp.setContentType(&quot;application/josn&quot;); PrintWriter writer = resp.getWriter(); /* * resultMap = [&quot;result&quot;,&quot;sessionerror&quot;,&quot;result&quot;,error] * josn格式={key,value */ //writer.write(JSONArray.toJSONString(resultMap)); writer.write(JsonArray.class.toString()); writer.flush(); writer.close(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } } 测试 用户管理实现 导入分页的工具类-PageSupport 用户列表页面导入-userlist.jsp 1、获取用户数量 UserDao //根据用户名或者角色查询用户总数 public int getUserCount(Connection connection,String username ,int userRole)throws SQLException, Exception; UserDaoImpl @Override public int getUserCount(Connection connection, String userName, int userRole) throws Exception { // TODO Auto-generated method stub PreparedStatement pstm = null; ResultSet rs = null; int count = 0; if(connection != null){ StringBuffer sql = new StringBuffer(); sql.append(&quot;select count(1) as count from smbms_user u,smbms_role r where u.userRole = r.id&quot;); List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); if(!StringUtils.isNullOrEmpty(userName)){ sql.append(&quot; and u.userName like ?&quot;); list.add(&quot;%&quot;+userName+&quot;%&quot;); } if(userRole &gt; 0){ sql.append(&quot; and u.userRole = ?&quot;); list.add(userRole); } Object[] params = list.toArray(); System.out.println(&quot;sql ----&gt; &quot; + sql.toString()); rs = BaseDao.execute(connection, pstm, rs, sql.toString(), params); if(rs.next()){ count = rs.getInt(&quot;count&quot;); } BaseDao.closeResource(null, pstm, rs); } return count; } UserService //查询记录数 public int getUserCount(String username, int userRole); UserServiceImpl //查询记录数 @Override public int getUserCount(String queryUserName, int queryUserRole) { // TODO Auto-generated method stub Connection connection = null; int count = 0; System.out.println(&quot;queryUserName ---- &gt; &quot; + queryUserName); System.out.println(&quot;queryUserRole ---- &gt; &quot; + queryUserRole); try { connection = BaseDao.getConnection(); count = userDao.getUserCount(connection, queryUserName,queryUserRole); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ BaseDao.closeResource(connection, null, null); } //System.out.println(&quot;count&quot;+count); return count; } 2、获取用户列表 1.UserDao //通过条件查询-userList public List&lt;User&gt; getUserList(Connection connection, String userName, int userRole, int currentPageNo, int pageSize)throws Exception; UserDaoImpl @Override public List&lt;User&gt; getUserList(Connection connection, String userName,int userRole,int currentPageNo, int pageSize) throws Exception { // TODO Auto-generated method stub PreparedStatement pstm = null; ResultSet rs = null; List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); if(connection != null){ StringBuffer sql = new StringBuffer(); sql.append(&quot;select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r where u.userRole = r.id&quot;); List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); if(!StringUtils.isNullOrEmpty(userName)){ sql.append(&quot; and u.userName like ?&quot;); list.add(&quot;%&quot;+userName+&quot;%&quot;); } if(userRole &gt; 0){ sql.append(&quot; and u.userRole = ?&quot;); list.add(userRole); } //在数据库中，分页显示 limit startIndex，pageSize；总数 //当前页 (当前页-1)*页面大小 //0,5 1,0 01234 //5,5 5,0 56789 //10,5 10,0 10~ sql.append(&quot; order by creationDate DESC limit ?,?&quot;); currentPageNo = (currentPageNo-1)*pageSize; list.add(currentPageNo); list.add(pageSize); Object[] params = list.toArray(); System.out.println(&quot;sql ----&gt; &quot; + sql.toString()); rs = BaseDao.execute(connection, pstm, rs, sql.toString(), params); while(rs.next()){ User _user = new User(); _user.setId(rs.getInt(&quot;id&quot;)); _user.setUserCode(rs.getString(&quot;userCode&quot;)); _user.setUserName(rs.getString(&quot;userName&quot;)); _user.setGender(rs.getInt(&quot;gender&quot;)); _user.setBirthday(rs.getDate(&quot;birthday&quot;)); _user.setPhone(rs.getString(&quot;phone&quot;)); _user.setUserRole(rs.getInt(&quot;userRole&quot;)); _user.setUserRoleName(rs.getString(&quot;userRoleName&quot;)); userList.add(_user); } BaseDao.closeResource(null, pstm, rs); } return userList; } UserService //根据条件查询用户列表 public List&lt;User&gt; getUserList(String queryUserName, int queryUserRole, int currentPageNo, int pageSize); UserServiceImpl @Override public List&lt;User&gt; getUserList(String queryUserName,int queryUserRole,int currentPageNo, int pageSize) { // TODO Auto-generated method stub Connection connection = null; List&lt;User&gt; userList = null; System.out.println(&quot;queryUserName ---- &gt; &quot; + queryUserName); System.out.println(&quot;queryUserRole ---- &gt; &quot; + queryUserRole); System.out.println(&quot;currentPageNo ---- &gt; &quot; + currentPageNo); System.out.println(&quot;pageSize ---- &gt; &quot; + pageSize); try { connection = BaseDao.getConnection(); userList = userDao.getUserList(connection, queryUserName,queryUserRole,currentPageNo,pageSize); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ BaseDao.closeResource(connection, null, null); } return userList; } 3、获取角色操作 为了我们的职责统一，我们可以把角色的操作单独放在一个包中，和pojo类对应。。。 RoleDao //获取角色列表 public List&lt;Role&gt; getRoleList(Connection connection)throws Exception; RoleDaoIpml public class RoleDaoImpl implements RoleDao { @Override public List&lt;Role&gt; getRoleList(Connection connection) throws Exception { PreparedStatement pstm = null; ResultSet rs = null; List&lt;Role&gt; roleList = new ArrayList&lt;Role&gt;(); if (connection != null) { String sql = &quot;select * from smbms_role&quot;; Object[] params = {}; rs = BaseDao.execute(connection, pstm, rs, sql, params); while (rs.next()) { Role _role = new Role(); _role.setId(rs.getInt(&quot;id&quot;)); _role.setRoleCode(rs.getString(&quot;roleCode&quot;)); _role.setRoleName(rs.getString(&quot;roleName&quot;)); roleList.add(_role); } BaseDao.closeResource(null, pstm, rs); } return roleList; } } RoleService public interface RoleService { //角色列表查询 public List&lt;Role&gt; getRoleList(); } RoleServiceIpml public class RoleServiceImpl implements RoleService{ private RoleDao roleDao; public RoleServiceImpl(){ roleDao = new RoleDaoImpl(); } @Override public List&lt;Role&gt; getRoleList() { Connection connection = null; List&lt;Role&gt; roleList = null; try { connection = BaseDao.getConnection(); roleList = roleDao.getRoleList(connection); } catch (Exception e) { e.printStackTrace(); }finally{ BaseDao.closeResource(connection, null, null); } return roleList; } } 4、用户显示的Servlet 获取用户前端的数据（查询） 判断请求是否需要执行，看参数的值判断 为了实现分页，需要计算出当前页面和总页面，页面大小… 用户列表展示 返回前端 //重点、难点 private void query(HttpServletRequest req, HttpServletResponse resp) { // TODO 自动生成的方法存根 //查询用户列表 //从前端获取数据 //查询用户列表 String queryUserName = req.getParameter(&quot;queryname&quot;); String temp = req.getParameter(&quot;queryUserRole&quot;); String pageIndex = req.getParameter(&quot;pageIndex&quot;); int queryUserRole = 0; //获取用户列表 UserServiceImpl userService = new UserServiceImpl(); List&lt;User&gt; userList = null; //第一此请求肯定是走第一页，页面大小固定的 //设置页面容量 int pageSize = 5;//把它设置在配置文件里,后面方便修改 //当前页码 int currentPageNo = 1; if(queryUserName == null){ queryUserName = &quot;&quot;; } if(temp != null &amp;&amp; !temp.equals(&quot;&quot;)){ queryUserRole = Integer.parseInt(temp); } if(pageIndex != null) { currentPageNo = Integer.parseInt(pageIndex); } //获取用户总数（分页 上一页：下一页的情况） //总数量（表） int totalCount = userService.getUserCount(queryUserName,queryUserRole); //总页数支持 PageSupport pageSupport = new PageSupport(); pageSupport.setCurrentPageNo(currentPageNo); pageSupport.setPageSize(pageSize); pageSupport.setTotalCount(totalCount); int totalPageCount =pageSupport.getTotalPageCount();//总共有几页 //(totalCount+pageSize-1/pageSize)取整 // pageSupport.getTotalCount() //System.out.println(&quot;totalCount =&quot;+totalCount); //System.out.println(&quot;pageSize =&quot;+pageSize); //System.out.println(&quot;totalPageCount =&quot;+totalPageCount); //控制首页和尾页 //如果页面小于 1 就显示第一页的东西 if(currentPageNo &lt; 1) { currentPageNo = 1; }else if(currentPageNo &gt; totalPageCount) {//如果页面大于了最后一页就显示最后一页 currentPageNo =totalPageCount; } userList = userService.getUserList(queryUserName, queryUserRole, currentPageNo, pageSize); req.setAttribute(&quot;userList&quot;, userList); RoleServiceImpl roleService = new RoleServiceImpl(); List&lt;Role&gt; roleList = roleService.getRoleList(); req.setAttribute(&quot;roleList&quot;, roleList); req.setAttribute(&quot;totalCount&quot;, totalCount); req.setAttribute(&quot;currentPageNo&quot;, currentPageNo); req.setAttribute(&quot;totalPageCount&quot;, totalPageCount); req.setAttribute(&quot;queryUserName&quot;, queryUserName); req.setAttribute(&quot;queryUserRole&quot;, queryUserRole); //返回前端 try { req.getRequestDispatcher(&quot;userlist.jsp&quot;).forward(req, resp); } catch (ServletException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } 小黄鸭调试法：自言自语 项目原理流程图： 剩下的手打一遍，然后各种打错排查，，， 虽然不建议 ，但还是直接导入文件算了，粘贴复制也行0-0（前提是自己先码一遍） 源码在最后 SMBMS项目源码链接： Eclipse版（个人手打版，已排错，可运行） https://www.lanzoux.com/iGLJTdusuyf ","link":"https://ganhan999.github.io/post/Java Web/"},{"title":"中等33. 搜索旋转排序数组","content":"题目 升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。 请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 本体思路 题目要求算法时间复杂度必须是 O(\\log n)O(logn) 的级别，这提示我们可以使用二分搜索的方法。 但是数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分搜索吗？答案是可以的。 可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。 拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分， 其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。 #大神做法1： class Solution: def search(self, nums: List[int], target: int) -&gt; int: if not nums: return -1 l, r = 0, len(nums) - 1 while l &lt;= r: mid = (l + r) // 2 if nums[mid] == target: return mid if nums[0] &lt;= nums[mid]: if nums[0] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if nums[mid] &lt; target &lt;= nums[len(nums) - 1]: l = mid + 1 else: r = mid - 1 return -1 ","link":"https://ganhan999.github.io/post/33、搜索旋转排序数组/"},{"title":"Java Ajax","content":"Ajax AjAX=Asynchronous javaScript and XML(异步的javaScript和XML)。 Ajax不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术 C/S 增加B/S的体验性 B/S：未来的主流，并且会爆发式的持续增长； H5+网页+客户端+手机端 使用JQuery需要先导入jQuery的js文件； Copy@Controller @RequestMapping(&quot;/ajax&quot;) public class AjaxController{ //第一种方式，服务器要返回一个字符串，直接使用response @RequestMapping(&quot;/a1&quot;) public void ajax(String name,HttpServletResponse response){ if(&quot;admin&quot;.equals(name)){ response.getWriter().print(&quot;true&quot;); }else{ response.getWriter().print(&quot;false&quot;); } } } @RequestMapping(&quot;/a2&quot;) @ResponseBody public List&lt;User&gt; ajax2(){ List&lt;User&gt; list =new ArrayList&lt;&gt;(); User user1 =new User(&quot;豪&quot;,1,&quot;男&quot;); User user2=new User(&quot;豪&quot;,1,&quot;男&quot;); list.add(user1); list.add(user2); return list; //由于加了@ResponseBody注解，他会返回一个字符串 } ajax 写法 Copy&lt;script type=&quot;text/javascript&quot;&gt; function a1() { //所有参数： //url:待载入页面的URL地址，Json //data:待发送Key/value参数 //success:载入成功时回调函数 //data：封装了服务器返回的数据 //status：状态 $.ajax({ url:&quot;${pageContext.request.contextPath}/ajax/a1&quot;, data:{&quot;name&quot;:$(&quot;txtName&quot;).val()}, success:function (data,status) { console.log(data) console.log(status) } }); //将文本输入的值， $(&quot;txtName&quot;).val(); // //发送给服务器， // //接受服务器返回的数据 } Copy&lt;script&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ $.post(&quot;${pageContest.request.contextPath}/ajax/a2&quot;,function(data){ console.log(data); var html=&quot;&quot;; for(var i=0;i&lt;data.length;i++){ html+=&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+data[i].name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+data[i].age+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+data[i].sex+&quot;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot; } $(&quot;#content&quot;).html(html); }) }) }) &lt;/script&gt; 第三种# Copy@RequestMapping(&quot;/a3&quot;) @ResponseBody public String ajax3(String name,String pwd){ String msg=&quot;&quot;; if(name!=null){ if(&quot;admin&quot;.equals(name)){ msg=&quot;ok&quot;; }else{ msg=&quot;用户名有误&quot;； } } if(pwd != null){ if(&quot;123456&quot;.equals(pwd)){ msg=&quot;ok&quot;; }else{ msg=&quot;密码输入有误&quot;; } } return msg; } Copy&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; function a1(){ $.post({ url:&quot;${pageContext.request.contextPath}/ajax/a3&quot;, data:{&quot;name&quot;:$(&quot;#name&quot;).val()}, success:function(data){ if(data.toString()=='ok'){ //信息核对成功 $('#userInfo').css(&quot;color&quot;,&quot;green&quot;); }else{ $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); } $(&quot;#userInfo&quot;).html(data); } }) } function a2(){ $.post(&quot;${pageContext.request.contextPath}/ajax/a3&quot;,{&quot;pwd&quot;:$(&quot;pwd&quot;).val()},function(data){ if(data.toString()='ok'){//信息核对成功 $('#pwdInfo').css(&quot;color&quot;,&quot;green&quot;); }else{ $('#pwdInfo').css(&quot;color&quot;,&quot;red&quot;); } $(&quot;#pwdInfo&quot;).html(data); }) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名： &lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码： &lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Ajax 总结： 使用jQuery需要导入JQuery，使用Vue就导入Vue，两个都用，自己原生态实现 三步曲： 1.编写对应处理的Controller,返回消息或者字符串汇总json格式的数据 2.编写ajax请求 1.url: Controller 请求 2.data： 键值对 3 . SUCCESS: 回调函数 3.给Ajax绑定事件，点击click，失去焦点onblur,键盘弹起keyup ","link":"https://ganhan999.github.io/post/Java Ajax/"},{"title":"中等31. 下一个排列","content":"题目 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。 示例 1： 输入：nums = [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums = [3,2,1] 输出：[1,2,3] 示例 3： 输入：nums = [1,1,5] 输出：[1,5,1] 示例 4： 输入：nums = [1] 输出：[1] 本体思路 以358764为例 1、从右到左，找到第一个左侧小于右侧的下标值i 2、再次从右到左，找到第一个大于nums[i]的数以及下标j，然后i 和 j对应的数进行互换 3、i下标后面的数按从小到大排序 时间复杂度O(n) 空间复杂度为O(1) #大神做法1： class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; if len(nums) == 1: return # 记录是否存在下一个更大的排列 begin = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if nums[i] &lt; nums[i+1]: # 第一种情况：最后两个数颠倒位置 if i == len(nums) - 2: nums[i], nums[i + 1] = nums[i + 1], nums[i] return # 第二种情况：排序后找到可以替换当前位置的数字 else: self.reverse(nums, begin) j = bisect.bisect(nums, nums[begin - 1], lo=begin) nums[i], nums[j] = nums[j], nums[i] return else: begin = i if begin == 0: self.reverse(nums) def reverse(self, nums, begin=0)：#避免使用切片造成额外的空间 length = len(nums) - 1 while begin &lt; length: nums[begin], nums[length] = nums[length], nums[begin] begin += 1 length -= 1 ","link":"https://ganhan999.github.io/post/31、下一个排列/"},{"title":"中等29. 两数相除","content":"题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 解释: 7/-3 = truncate(-2.33333..) = -2 本体思路 题干中说明不能用乘法和除法, 那么我们可以用减法, 被除数最多可以减多少个除数还能保证是非负的即可. #大神做法1： class Solution: def divide(self, dividend, divisor): sig = True if dividend*divisor &gt; 0 else False # 判断二者相除是正or负 dividend, divisor= abs(dividend), abs(divisor) # 将被除数和除数都变成正数 count = 0 # 用来表示减去了多少个除数，也就是商为多少 while divisor &lt;= dividend: # 当被除数小于除数的时候终止循环 dividend -= divisor count += 1 res = count if sig == True else -count # 给结果加上符号 return max(min(res, 2**31-1), -2**31) &quot;&quot;&quot;&quot;&quot;&quot; 大神做法2： 比如 divide(20, 3)： 先将3不断翻倍，知道超过20，翻1次为2倍得6，翻2次为4倍得12，翻3次为8倍的24 这时4倍12是我们需要的值 递归 4 + divide(20-12, 3) 递归出口为：被除数 &lt; 除数时返回0， 被除数 == 除数时返回1 需要额外处理被除数和除数不同号 用翻倍的形式减少时间！！ class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: def recursion(dividend, divisor): if dividend &lt; divisor: return 0 if dividend == divisor: return 1 nn = 1 dd = divisor while True: if dividend &gt; dd: n = nn nn += nn d = dd dd += dd#翻倍 elif dividend == dd: return nn else: return n + recursion(dividend - d, divisor) if dividend &gt;= 0: if divisor &gt; 0: positive = True else: positive = False else: if divisor &gt; 0: positive = False else: positive = True ans = recursion(abs(dividend), abs(divisor)) if positive: if ans &gt; 2 ** 31 - 1: return 2 ** 31 - 1 else: return ans else: return -ans ","link":"https://ganhan999.github.io/post/29、两数相除/"},{"title":"中等24. 两两交换链表中的节点","content":"题目 &quot;&quot;&quot; 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] &quot;&quot;&quot; 本体思路 我们来一一分析下，假设链表总长是偶数，那么递归函数执行到终止条件时，head 就等于 null。 如果链表链表总长是偶数，那么递归函数执行到终止条件时，head.next 就等于 null。 递归函数内，我们要改变 1-&gt;2 的指向，将其改为 2-&gt;1。 那后面的节点怎么办呢？不用担心，这是由下一层递归函数来解决。下一层递归函数返回后的节点是 4， 就是4-&gt;3-&gt;...这样的了，也就是后面的节点都已经串联好了。所以我们只需要将 1 节点指向 4 就可以啦。 递归出口：当前节点或者下一个节点为空，返回 方法内容：当前节点next，指向当前节点，指针互换 返回值：返回交换完成的节点 #大神做法1： class Solution(object): def swapPairs(self, head): # 递归的终止条件 if not (head and head.next): return head # 假设链表是 1-&gt;2-&gt;3-&gt;4 # 这句就先保存节点2 tmp = head.next # 继续递归，处理节点3-&gt;4 # 当递归结束返回后，就变成了4-&gt;3 # 于是head节点就指向了4，变成1-&gt;4-&gt;3 head.next = self.swapPairs(tmp.next) # 将2节点指向1 tmp.next = head return tmp &quot;&quot;&quot; 大神做法2： 利用stack 我们利用一个 stack，然后不断迭代链表，每次取出两个节点放入 stack 中，再从 stack 中拿出两个节点。 借助 stack 后进先出的特点，放进去的时候是 1,2 。拿出来的时候就是 2，1 两个节点了。 再把这两个节点串联起来，重复这个逻辑遍历完整个链表，就可以做到两两反转的效果了。 虽然用到了 stack，但因为只存了两个元素，所以空间复杂度还是 O(1)O(1)，时间复杂度是 O(n)O(n)。 class Solution(object): def swapPairs(self, head): if not (head and head.next): return head p = ListNode(-1) # 用stack保存每次迭代的两个节点 # head指向新的p节点，函数结束时返回head.next即可 cur,head,stack = head,p,[] while cur and cur.next: # 将两个节点放入stack中 _,_ = stack.append(cur),stack.append(cur.next) # 当前节点往前走两步 cur = cur.next.next # 从stack中弹出两个节点，然后用p节点指向新弹出的两个节点 p.next = stack.pop() p.next.next = stack.pop() p = p.next.next # 注意边界条件，当链表长度是奇数时，cur就不为空 if cur: p.next = cur else: p.next = None return head.next ","link":"https://ganhan999.github.io/post/24、两两交换链表中的节点/"},{"title":"中等19. 删除链表的倒数第N个节点","content":"题目 &quot;&quot;&quot; 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. &quot;&quot;&quot; 本体思路 一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历， 得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历， 当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。 #我的做法： class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: def getlength(head): length=0 while head: length+=1 head=head.next return length dummy=ListNode(0,head) length=getlength(head) cur=dummy for i in range(1,length-n+1): cur=cur.next cur.next=cur.next.next &quot;&quot;&quot; 大神做法： 用栈 我们也可以在遍历链表的同时将所有节点依次入栈。 根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点， 并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。 class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummy = ListNode(0, head) stack = list() cur = dummy while cur: stack.append(cur) cur = cur.next for i in range(n): stack.pop() prev = stack[-1] prev.next = prev.next.next return dummy.next &quot;&quot;&quot; 大神做法2： 快慢指针 快指针先走n个节点，然后再通知遍历，这样当快指针到最后的时候，慢指针指向了倒数第n个结点。 class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummy = ListNode(0, head) first = head second = dummy for i in range(n): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next ","link":"https://ganhan999.github.io/post/19、删除链表的倒数第N个节点 /"},{"title":"中等18. 四数之和","content":"题目 &quot;&quot;&quot; 给你一个包含 n 个整数的数组 nums， 判断 nums 中是否存在三个元素 a，b，c ， 使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] &quot;&quot;&quot; 本体思路 我们仍然可以在 O(N^3)O(N 3) 的时间复杂度内通过增加条件判断使得速度得到很大提升。主要考虑以下几点： 1、指针依次是 p,k,i,j，如果 nums[p] + 3 * nums[p + 1] &gt; target， 因为 nums 按升序排列，所以之后的数肯定都大于 target 直接 break； 2、如果 nums[p] + 3 * nums[-1] &lt; target，那么当前的 nums[p] 加其余三个数一定小于 target，故 p 直接下一位即可，continue； k 和 p 判断完全一样，只是将 3 变成了 2，target 变成了 target - nums[p]。 3、同样地，为了避免结果重复，某个指针遇到相同的数需要直接跳过，这与三数之和是一样的。 排序后，先固定p，再固定k，然后就是双指针选择i和j #大神做法： class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: nums.sort() n = len(nums) res = [] p = 0 # p, k, i, j while p &lt; n - 3: # 文中提到的条件1和条件2，可以直接跳过 if nums[p] + 3 * nums[p + 1] &gt; target: break if nums[p] + 3 * nums[-1] &lt; target: while p &lt; n - 4 and nums[p] == nums[p + 1]: p += 1 p += 1 continue k = p + 1#已经确定p的位置了 while k &lt; n - 2: # k 和 p 的判断是一样的 if nums[p] + nums[k] + 2 * nums[k + 1] &gt; target: break if nums[p] + nums[k] + 2 * nums[-1] &lt; target: while k &lt; n - 3 and nums[k] == nums[k + 1]: k += 1 k += 1 continue i = k + 1 j = n - 1 new_target = target - nums[p] - nums[k] while i &lt; j: if nums[i] + nums[j] &gt; new_target: j -= 1 elif nums[i] + nums[j] &lt; new_target: i += 1 else: res.append([nums[p],nums[k],nums[i],nums[j]]) i += 1 j -= 1 while i &lt; j and nums[i] == nums[i - 1]: i += 1 # 避免结果重复 while i &lt; j and nums[j] == nums[j + 1]: j -= 1 # 避免结果重复 while k &lt; n - 3 and nums[k] == nums[k + 1]: k += 1# 避免结果重复 k += 1#p没变，p进入下一个值 while p &lt; n - 4 and nums[p] == nums[p + 1]: p += 1# 避免结果重复 p += 1#p进入下一个值 return res ","link":"https://ganhan999.github.io/post/18、四数之和/"},{"title":"送给所有的做题家","content":"你们是当今社会下的产物，你们是未来社会的栋梁，发一分光，发一份热，不被外界所干扰，不为内心所蒙蔽。 ","link":"https://ganhan999.github.io/post/送给所有的做题家/"},{"title":"Java MySQL","content":"MySQL01：初识MySQL 为什么学习数据库 1、岗位技能需求 2、现在的世界,得数据者得天下 3、存储数据的方法 4、程序,网站中,大量数据如何长久保存? 5、数据库是几乎软件体系中最核心的一个存在。 什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 保存,并能安全管理数据(如:增删改查等),减少冗余… 数据库总览 : 关系型数据库 ( SQL ) MySQL , Oracle , SQL Server , SQLite , DB2 , … 关系型数据库通过外键关联来建立表与表之间的关系 非关系型数据库 ( NOSQL ) Redis , MongoDB , … 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定 什么是DBMS 数据库管理系统 ( DataBase Management System ) 数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据 为什么要说这个呢? 因为我们要学习的MySQL应该算是一个数据库管理系统. MySQL简介 概念 : 是现在流行的开源的,免费的 关系型数据库 历史 : 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。 特点 : 免费 , 开源数据库 小巧 , 功能齐全 使用便捷 可运行于Windows或Linux操作系统 可适用于中小型甚至大型网站应用 官网 : https://www.mysql.com/ 安装MySQL 这里建议大家使用压缩版,安装快,方便.不复杂. 软件下载 mysql5.7 64位下载地址: https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip 电脑是64位的就下载使用64位版本的！ 安装步骤 1、下载后得到zip压缩包. 2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19 3、添加环境变量：我的电脑-&gt;属性-&gt;高级-&gt;环境变量 选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹 4、编辑 my.ini 文件 ,注意替换路径位置 [mysqld] basedir=D:\\Program Files\\mysql-5.7\\ datadir=D:\\Program Files\\mysql-5.7\\data\\ port=3306 skip-grant-tables 5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install (安装mysql) 6、再输入 mysqld --initialize-insecure --user=mysql 初始化数据文件 7、然后再次启动mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空） 8、进入界面后更改root密码 update mysql.user set authentication_string=password('123456') where user='root'and Host = 'localhost'; 9、刷新权限 flush privileges; 10、修改 my.ini文件删除最后一句skip-grant-tables 11、重启mysql即可正常使用 net stop mysql net start mysql 12、连接上测试出现以下结果就安装好了 一步步去做 , 理论上是没有任何问题的 . 如果您以前装过,现在需要重装,一定要将环境清理干净 . 好了,到这里大家都装好了,因为刚接触,所以我们先不学习命令. 这里给大家推荐一个工具 : SQLyog . 即便有了可视化工具,可是基本的DOS命名大家还是要记住! SQLyog 可手动操作,管理MySQL数据库的软件工具 特点 : 简洁 , 易用 , 图形化 使用SQLyog管理工具自己完成以下操作 : 连接本地MySQL数据库 新建MySchool数据库 字段 GradeID : int(11) , Primary Key (pk) GradeName : varchar(50) 数据库名称MySchool 新建数据库表(grade) 在历史记录中可以看到相对应的数据库操作的语句 . 连接数据库 打开MySQL命令窗口 在DOS命令行窗口进入 安装目录\\mysql\\bin 可设置环境变量，设置了环境变量，可以在任意目录打开！ 连接数据库语句 : mysql -h 服务器主机地址 -u 用户名 -p 用户密码 注意 : -p后面不能加空格,否则会被当做密码的内容,导致登录失败 ! 几个基本的数据库操作命令 : update user set password=password('123456')where user='root'; 修改密码 flush privileges; 刷新数据库 show databases; 显示所有数据库 use dbname；打开某个数据库 show tables; 显示数据库mysql中所有的表 describe user; 显示表mysql数据库中user表的列信息 create database name; 创建数据库 use databasename; 选择数据库 exit; 退出Mysql ? 命令关键词 : 寻求帮助 -- 表示注释 MySQL02：数据库操作 结构化查询语句分类 数据库操作 命令行操作数据库 创建数据库 : create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 对比工具操作数据库 学习方法： 对照SQLyog工具自动生成的语句学习 固定语法中的单词需要记忆 创建数据表 属于DDL的一种，语法 : create table [if not exists] `表名`( '字段名1' 列类型 [属性][索引][注释], '字段名2' 列类型 [属性][索引][注释], #... '字段名n' 列类型 [属性][索引][注释] )[表类型][表字符集][注释]; 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键). 数据值和列类型 列类型 : 规定数据库中该列存放的数据类型 数值类型 字符串类型 日期和时间型数值类型 NULL值 理解为 “没有值” 或 “未知值” 不要用NULL进行算术运算 , 结果仍为NULL 数据字段属性 UnSigned 无符号的 声明该数据列不允许负数 . ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值 -- 目标 : 创建一个school数据库 -- 创建学生表(列,字段) -- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email -- 创建表之前 , 一定要先选择数据库 CREATE TABLE IF NOT EXISTS `student` ( `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` datetime DEFAULT NULL COMMENT '生日', `address` varchar(100) DEFAULT NULL COMMENT '地址', `email` varchar(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 -- 查看数据库的定义 SHOW CREATE DATABASE school; -- 查看数据表的定义 SHOW CREATE TABLE student; -- 显示表结构 DESC student; -- 设置严格检查模式(不能容错了)SET sql_mode='STRICT_TRANS_TABLES'; 数据表的类型 设置数据表的类型 CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释 )ENGINE = MyISAM (or InnoDB) -- 查看mysql所支持的引擎类型 (表类型) SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型： 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 . 注意 : * . frm – 表结构定义文件 * . MYD – 数据文件 ( data ) * . MYI – 索引文件 ( index ) InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件 : 设置数据表字符集 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 : 创建时通过命令来设置 , 如 : CREATE TABLE 表名()CHARSET = utf8; 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定 修改数据库 修改表 ( ALTER TABLE ) 修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名 添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性] 修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性] ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] 删除字段 : ALTER TABLE 表名 DROP 字段名 删除数据表 语法：DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 其他 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\' 5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 （关键字） 7. 清除已有语句：\\c MySQL03：DML语言 外键 外键概念 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。 外键作用 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。使两张表形成关联，外键只能引用外表中的列的值或使用空值。 创建外键 建表时指定外键约束 -- 创建外键的方式一 : 创建子表同时创建外键 -- 年级表 (id\\年级名称) CREATE TABLE `grade` ( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级ID', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号) CREATE TABLE `student` ( `studentno` INT(4) NOT NULL COMMENT '学号', `studentname` VARCHAR(20) NOT NULL DEFAULT '匿名' COMMENT '姓名', `sex` TINYINT(1) DEFAULT '1' COMMENT '性别', `gradeid` INT(10) DEFAULT NULL COMMENT '年级', `phoneNum` VARCHAR(50) NOT NULL COMMENT '手机', `address` VARCHAR(255) DEFAULT NULL COMMENT '地址', `borndate` DATETIME DEFAULT NULL COMMENT '生日', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', `idCard` VARCHAR(18) DEFAULT NULL COMMENT '身份证号', PRIMARY KEY (`studentno`), KEY `FK_gradeid` (`gradeid`), CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 建表后修改 -- 创建外键方式二 : 创建子表完毕后,修改子表添加外键 ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`); 删除外键 操作：删除 grade 表，发现报错 注意 : 删除具有主外键关系的表时 , 要先删子表 , 后删主表 -- 删除外键 ALTER TABLE student DROP FOREIGN KEY FK_gradeid; -- 发现执行完上面的,索引还在,所以还要删除索引 -- 注:这个索引是建立外键的时候默认生成的 ALTER TABLE student DROP INDEX FK_gradeid; DML语言 数据库意义 ： 数据存储、数据管理 管理数据库数据方法： 通过SQLyog等管理工具管理数据库数据 通过DML语句管理数据库数据 DML语言 ：数据操作语言 用于操作数据库对象中所包含的数据 包括 : INSERT (添加数据语句) UPDATE (更新数据语句) DELETE (删除数据语句) 添加数据 INSERT命令 语法： INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') 注意 : 字段或值之间用英文逗号隔开 . ’ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 . 可同时插入多条数据 , values 后用英文逗号隔开 . -- 使用语句如何增加语句? -- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') INSERT INTO grade(gradename) VALUES ('大一'); -- 主键自增,那能否省略呢? INSERT INTO grade VALUES ('大二'); -- 查询:INSERT INTO grade VALUE ('大二')错误代码：1136 Column count doesn`t match value count at row 1 -- 结论:'字段1,字段2...'该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致. -- 一次插入多条数据 INSERT INTO grade(gradename) VALUES ('大三'),('大四'); 练习题目 自己使用INSERT语句为课程表subject添加数据 . 使用到外键. 修改数据 update命令 语法： UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHEREcondition]; 注意 : column_name 为要更改的数据列 value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果 condition 为筛选条件 , 如不指定则修改该表的所有列数据 where条件子句 可以简单的理解为 : 有条件地从表中筛选数据 测试： -- 修改年级信息 UPDATE grade SET gradename = '高中' WHERE gradeid = 1; 删除数据 DELETE命令 语法： DELETE FROM 表名 [WHERE condition]; 注意：condition为筛选条件 , 如不指定则删除该表的所有列数据 -- 删除最后一个数据 DELETE FROM grade WHERE gradeid = 5 TRUNCATE命令 作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ; 语法： TRUNCATE [TABLE] table_name; -- 清空年级表 TRUNCATE grade 注意：区别于DELETE命令 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快 不同 : 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说） 测试： -- 创建一个测试表 CREATE TABLE `test` ( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入几个测试数据 INSERT INTO test(coll) VALUES('row1'),('row2'),('row3'); -- 删除表数据(不带where条件的delete) DELETE FROM test; -- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志. -- 删除表数据(truncate) TRUNCATE TABLE test; -- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志. -- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后 -- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失) -- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失) MySQL04：使用DQL查询数据 DQL语言 DQL( Data Query Language 数据查询语言 ) 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中最核心,最重要的语句 使用频率最高的语句 SELECT语法 SELECT [ALL | DISTINCT] {* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]} FROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT {[offset,]row_count | row_countOFFSET offset}]; -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选的 , { }括号代表必选得 指定查询字段 -- 查询表中所有的数据列结果 , 采用 **&quot; \\* &quot;** 符号; 但是效率低，不推荐 . -- 查询所有学生信息 SELECT * FROM student; -- 查询指定列(学号 , 姓名) SELECT studentno,studentname FROM student; AS 子句作为别名 作用： 可给数据列取一个新别名 可给表取一个新别名 可把经计算或总结的结果用另一个新名称来代替 -- 这里是为列取别名(当然as关键词可以省略) SELECT studentno AS 学号,studentname AS 姓名 FROM student; -- 使用as也可以为表取别名 SELECT studentno AS 学号,studentname AS 姓名 FROM student AS s; -- 使用as,为查询结果取一个新名字 -- CONCAT()函数拼接字符串 SELECT CONCAT('姓名:',studentname) AS 新姓名 FROM student; DISTINCT关键字的使用 作用 : 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条 -- # 查看哪些同学参加了考试(学号) 去除重复项 SELECT * FROM result; -- 查看考试成绩 SELECT studentno FROM result; -- 查看哪些同学参加了考试 SELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL) 使用表达式的列 数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成 应用场景 : SELECT语句返回结果列中使用 SELECT语句中的ORDER BY , HAVING等子句中使用 DML语句中的 where 条件语句中使用表达式 -- selcet查询中可以使用表达式 SELECT @@auto_increment_increment; -- 查询自增步长 SELECT VERSION(); -- 查询版本号 SELECT 100*3-1 AS 计算结果; -- 表达式 -- 学员考试成绩集体提分一分查看 SELECT studentno,StudentResult+1 AS '提分后' FROM result; 避免SQL返回结果中包含 ’ . ’ , ’ * ’ 和括号等干扰开发语言程序. where条件语句 作用：用于检索数据表中 符合条件 的记录 搜索条件可由一个或多个逻辑表达式组成 , 结果一般为真或假. 逻辑操作符 测试 -- 满足条件的查询(where) SELECT Studentno,StudentResult FROM result; -- 查询考试成绩在95-100之间的 SELECT Studentno,StudentResult FROM result WHERE StudentResult&gt;=95 AND StudentResult&lt;=100; -- AND也可以写成 &amp;&amp; SELECT Studentno,StudentResult FROM result WHERE StudentResult&gt;=95 &amp;&amp; StudentResult&lt;=100; -- 模糊查询(对应的词:精确查询) SELECT Studentno,StudentResult FROM result WHERE StudentResult BETWEEN 95 AND 100; -- 除了1000号同学,要其他同学的成绩 SELECT studentno,studentresult FROM result WHERE studentno!=1000; -- 使用NOT SELECT studentno,studentresult FROM result WHERE NOT studentno=1000; 模糊查询 ：比较操作符 注意： 数值数据类型的记录之间才能进行算术运算 ; 相同数据类型的数据之间才能进行比较 ; 测试： -- 模糊查询 between and \\ like \\ in \\ null -- ============================================= -- LIKE -- ============================================= -- 查询姓刘的同学的学号及姓名 -- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符) SELECT studentno,studentname FROM student WHERE studentname LIKE '刘%'; -- 查询姓刘的同学,后面只有一个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘_'; -- 查询姓刘的同学,后面只有两个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘__'; -- 查询姓名中含有 嘉 字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '%嘉%'; -- 查询姓名中含有特殊字符的需要使用转义符号 '\\' -- 自定义转义符关键字: ESCAPE ':' -- ============================================= -- IN -- ============================================= -- 查询学号为1000,1001,1002的学生姓名 SELECT studentno,studentname FROM student WHERE studentno IN (1000,1001,1002); -- 查询地址在北京,南京,河南洛阳的学生 SELECT studentno,studentname,address FROM student WHERE address IN ('北京','南京','河南洛阳'); -- ============================================= -- NULL 空 -- ============================================= -- 查询出生日期没有填写的同学 -- 不能直接写=NULL , 这是代表错误的 , 用 is null SELECT studentname FROM student WHERE BornDate IS NULL; -- 查询出生日期填写的同学 SELECT studentname FROM student WHERE BornDate IS NOT NULL; -- 查询没有写家庭住址的同学(空字符串不等于null) SELECT studentname FROM student WHERE Address='' OR Address IS NULL; 连接查询 JOIN 对比 七种Join： 测试 /* 连接查询 如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询 内连接 inner join 查询两个表中的结果集中的交集 外连接 outer join 左外连接 left join (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充) 右外连接 right join (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充) 等值连接和非等值连接 自连接 */ -- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数) SELECT * FROM student; SELECT * FROM result; /*思路: (1):分析需求,确定查询的列来源于两个类,student result,连接查询 (2):确定使用哪种连接查询?(内连接) */ SELECT s.studentno,studentname,subjectno,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno -- 右连接(也可实现) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s RIGHT JOIN result r ON r.studentno = s.studentno -- 等值连接 SELECT s.studentno,studentname,subjectno,StudentResult FROM student s , result r WHERE r.studentno = s.studentno -- 左连接 (查询了所有同学,不考试的也会查出来) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno -- 查一下缺考的同学(左连接应用场景) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno WHERE StudentResult IS NULL -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno 自连接 /* 自连接 数据表与自身进行连接 需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称 */ -- 创建一个表 CREATE TABLE `category` ( `categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主题id', `pid` INT(10) NOT NULL COMMENT '父id', `categoryName` VARCHAR(50) NOT NULL COMMENT '主题名字', PRIMARY KEY (`categoryid`) ) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 -- 插入数据 INSERT INTO `category` (`categoryid`, `pid`, `categoryName`) VALUES('2','1','信息技术'), ('3','1','软件开发'), ('4','3','数据库'), ('5','1','美术设计'), ('6','3','web开发'), ('7','5','ps技术'), ('8','2','办公信息'); -- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称) -- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接) SELECT a.categoryName AS '父栏目',b.categoryName AS '子栏目' FROM category AS a,category AS b WHERE a.`categoryid`=b.`pid` -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno -- 查询学员及所属的年级(学号,学生姓名,年级名) SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称 FROM student s INNER JOIN grade g ON s.`GradeId` = g.`GradeID` -- 查询科目及所属的年级(科目名称,年级名称) SELECT subjectname AS 科目名称,gradename AS 年级名称 FROM SUBJECT sub INNER JOIN grade g ON sub.gradeid = g.gradeid -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' 排序和分页 测试 /*============== 排序 ================ 语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 */ -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) -- 按成绩降序排序 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC /*============== 分页 ================ 语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 好处 : (用户体验,网络传输,查询压力) 推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数] */ -- 每页显示5条数据 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC , studentno LIMIT 0,5 -- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='JAVA第一学年' ORDER BY StudentResult DESC LIMIT 0,10 子查询 /*============== 子查询 ================ 什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字; */ -- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列 -- 方法一:使用连接查询 SELECT studentno,r.subjectno,StudentResult FROM result r INNER JOIN `subject` sub ON r.`SubjectNo`=sub.`SubjectNo` WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC; -- 方法二:使用子查询(执行顺序:由里及外) SELECT studentno,subjectno,StudentResult FROM result WHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '数据库结构-1' ) ORDER BY studentresult DESC; -- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名 -- 方法一:使用连接查询 SELECT s.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo` = r.`StudentNo` INNER JOIN `subject` sub ON sub.`SubjectNo` = r.`SubjectNo` WHERE subjectname = '高等数学-2' AND StudentResult&gt;=80 -- 方法二:使用连接查询+子查询 -- 分数不小于80分的学生的学号和姓名 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult&gt;=80 -- 在上面SQL基础上,添加需求:课程为 高等数学-2 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) -- 方法三:使用子查询 -- 分步写简单sql语句,然后将其嵌套起来 SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) ) /* 练习题目: 查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数) 使用子查询,查询郭靖同学所在的年级名称 */ MySQL05：MySQL函数 常用函数 数据函数 SELECT ABS(-8); /*绝对值*/ SELECT CEILING(9.4); /*向上取整*/ SELECT FLOOR(9.4); /*向下取整*/ SELECT RAND(); /*随机数,返回一个0-1之间的随机数*/ SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数 SELECT CHAR_LENGTH('狂神说坚持就能成功'); /*返回字符串包含的字符数*/ SELECT CONCAT('我','爱','程序'); /*合并字符串,参数可以有多个*/ SELECT INSERT('我爱编程helloworld',1,2,'超级热爱'); /*替换字符串,从某个位置开始替换某个长度*/ SELECT LOWER('KuangShen'); /*小写*/ SELECT UPPER('KuangShen'); /*大写*/ SELECT LEFT('hello,world',5); /*从左边截取*/ SELECT RIGHT('hello,world',5); /*从右边截取*/ SELECT REPLACE('狂神说坚持就能成功','坚持','努力'); /*替换字符串*/ SELECT SUBSTR('狂神说坚持就能成功',4,6); /*截取字符串,开始和长度*/ SELECT REVERSE('狂神说坚持就能成功'); /*反转 -- 查询姓周的同学,改成邹 SELECT REPLACE(studentname,'周','邹') AS 新名字 FROM student WHERE studentname LIKE '周%'; 日期和时间函数 SELECT CURRENT_DATE(); /*获取当前日期*/ SELECT CURDATE(); /*获取当前日期*/ SELECT NOW(); /*获取当前日期和时间*/ SELECT LOCALTIME(); /*获取当前日期和时间*/ SELECT SYSDATE(); /*获取当前日期和时间*/ -- 获取年月日,时分秒 SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); SELECT HOUR(NOW()); SELECT MINUTE(NOW()); SELECT SECOND(NOW()); 系统信息函数 SELECT VERSION(); /*版本*/ SELECT USER(); /*用户*/ 聚合函数 函数名称 描述 COUNT() 返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】 SUM() 返回数字字段或表达式列作统计，返回一列的总和。 AVG() 通常为数值字段或表达列作统计，返回一列的平均值 MAX() 可以为数值字段，字符字段或表达式列作统计，返回最大的值。 MIN() 可以为数值字段，字符字段或表达式列作统计，返回最小的值。 -- 聚合函数 /*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/ -- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不同，它会统计该字段不为null的记录条数。 下面它们之间的一些对比： 1）在表没有主键时，count(1)比count(*)快 2）有主键时，主键作为计算条件，count(主键)效率最高； 3）若表格只有一个字段，则count(*)效率较高。 */ SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 最高分 FROM result; SELECT MIN(StudentResult) AS 最低分 FROM result; 题目： -- 查询不同课程的平均分,最高分,最低分 -- 前提:根据不同的课程进行分组 SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno HAVING 平均分&gt;80; /* where写在group by前面. 要是放在分组后面的筛选 要使用HAVING.. 因为having是从前面筛选的字段再筛选，而where是从数据表中的&gt;字段直接进行的筛选的 */ MD5 加密 一、MD5简介 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 二、实现数据加密 新建一个表 testmd5 CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 INSERT INTO testmd5 VALUES(1,'kuangshen','123456'),(2,'qinjiang','456789') 如果我们要对pwd这一列数据进行加密，语法是： update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如kuangshen)的密码加密： INSERT INTO testmd5 VALUES(3,'kuangshen2','123456') update testmd5 set pwd = md5(pwd) where name = 'kuangshen2'; 插入新的数据自动加密 INSERT INTO testmd5 VALUES(4,'kuangshen3',md5('123456')); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） SELECT * FROM testmd5 WHERE `name`='kuangshen' AND pwd=MD5('123456'); 小结 -- ================ 内置函数 ================ -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分 time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分 date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); MySQL06：事务和索引 事务 什么是事务 事务就是将一组SQL语句放在同一批次内去执行 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 事务的ACID原则 百度 ACID 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consist) 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 隔离性(Isolated) 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 基本语法 -- 使用set语句来改变自动提交模式 SET autocommit = 0; /*关闭*/ SET autocommit = 1; /*开启*/ -- 注意: --- 1.MySQL中默认是自动提交 --- 2.使用事务时应先关闭自动提交 -- 开始一个事务,标记事务的起始点 START TRANSACTION -- 提交一个事务给数据库 COMMIT -- 将事务回滚,数据回到本次事务的初始状态 ROLLBACK -- 还原MySQL数据库的自动提交 SET autocommit =1; -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 测试 /* 课堂测试题目 A在线买一款价格为500元商品,网上银行转账. A的银行卡余额为2000,然后给商家B支付500. 商家B一开始的银行卡余额为10000 创建数据库shop和创建表account并插入2条数据 */ CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci; USE `shop`; CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, `cash` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account (`name`,`cash`) VALUES('A',2000.00),('B',10000.00) -- 转账实现 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION; -- 开始一个事务,标记事务的起始点 UPDATE account SET cash=cash-500 WHERE `name`='A'; UPDATE account SET cash=cash+500 WHERE `name`='B'; COMMIT; -- 提交事务 # rollback; SET autocommit = 1; -- 恢复自动提交 索引mysql 索引的作用 提高查询速度 确保数据的唯一性 可以加速表和表之间的连接 , 实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间 全文检索字段进行搜索优化. 分类 主键索引 (Primary Key) 唯一索引 (Unique) 常规索引 (Index) 全文索引 (FullText) 主键索引 主键 : 某一个属性组能唯一标识一条记录 特点 : 最常见的索引类型 确保数据记录的唯一性 确定特定数据记录在数据库中的位置 唯一索引 作用 : 避免同一个表中某数据列中的值重复 与主键索引的区别 主键索引只能有一个 唯一索引可能有多个 CREATE TABLE `Grade`( `GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY, `GradeName` VARCHAR(32) NOT NULL UNIQUE -- 或 UNIQUE KEY `GradeID` (`GradeID`) ) 常规索引 作用 : 快速定位特定数据 注意 : index 和 key 关键字都可以设置常规索引 应加在查询找条件的字段 不宜添加太多常规索引,影响数据的插入,删除和修改操作 CREATE TABLE `result`( -- 省略一些代码 INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加 ) -- 创建后添加 ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`); 全文索引 百度搜索：全文索引 作用 : 快速定位特定数据 注意 : 只能用于MyISAM类型的数据表 只能用于CHAR , VARCHAR , TEXT数据列类型 适合大型数据集 /* #方法一：创建表时 CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) ); #方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ; #方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; #删除索引：DROP INDEX 索引名 ON 表名字; #删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY; #显示索引信息: SHOW INDEX FROM student; */ /*增加全文索引*/ ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`); /*EXPLAIN : 分析SQL语句执行性能*/ EXPLAIN SELECT * FROM student WHERE studentno='1000'; /*使用全文索引*/ -- 全文搜索通过 MATCH() 函数完成。 -- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。 EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST('love'); /* 开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况 MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引； MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引; 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。 测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。 */ 拓展：测试索引 建表app_user： CREATE TABLE `app_user` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT '' COMMENT '用户昵称', `email` varchar(50) NOT NULL COMMENT '用户邮箱', `phone` varchar(20) DEFAULT '' COMMENT '手机号', `gender` tinyint(4) unsigned DEFAULT '0' COMMENT '性别（0:男；1：女）', `password` varchar(100) NOT NULL COMMENT '密码', `age` tinyint(4) DEFAULT '0' COMMENT '年龄', `create_time` datetime DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='app用户表' 批量插入数据：100w DROP FUNCTION IF EXISTS mock_data; DELIMITER $$ CREATE FUNCTION mock_data() RETURNS INT BEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i &lt; num DO INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`, `age`) VALUES(CONCAT('用户', i), '24736743@qq.com', CONCAT('18', FLOOR(RAND()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100)); SET i = i + 1; END WHILE; RETURN i; END; SELECT mock_data(); 索引效率测试 无索引 SELECT * FROM app_user WHERE name = '用户9999'; -- 查看耗时 SELECT * FROM app_user WHERE name = '用户9999'; SELECT * FROM app_user WHERE name = '用户9999'; mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 992759 filtered: 10.00 Extra: Using where 1 row in set, 1 warning (0.00 sec) 创建索引 CREATE INDEX idx_app_user_name ON app_user(name); 测试普通索引 mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ref possible_keys: idx_app_user_name key: idx_app_user_name key_len: 203 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) 索引准则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表建议不要加索引 索引一般应加在查找条件的字段 索引的数据结构 -- 我们可以在创建上述索引的时候，为其指定索引类型，分两类 hash类型的索引：查询单条快，范围查询慢 btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） -- 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引； MySQL07：权限及如何设计数据库 用户管理 使用SQLyog 创建用户，并授予权限演示 基本命令 /* 用户和权限管理 */ ------------------ 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES -- 增加用户 CREATE USER kuangshen IDENTIFIED BY '123456' CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER kuangshen TO kuangshen2 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 -- 删除用户 DROP USER kuangshen2 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 -- 查看权限 SHOW GRANTS FOR root@localhost; SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限解释 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 /* 表维护 */ -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... MySQL备份 数据库备份必要性 保证重要数据不丢失 数据转移 MySQL数据库备份方法 mysqldump备份工具 数据库管理工具,如SQLyog 直接拷贝数据库文件和相关配置文件 mysqldump客户端 作用 : 转储数据库 搜集数据库进行备份 将数据转移到另一个SQL服务器,不一定是MySQL服务器 -- 导出 1. 导出一张表 -- mysqldump -uroot -p123456 school student &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 -- mysqldump -uroot -p123456 school student result &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 -- mysqldump -uroot -p123456 school &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 -- mysqldump -uroot -p123456 -B school &gt;D:/a.sql mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 -- 导入 1. 在登录mysql的情况下：-- source D:/a.sql source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 规范化数据库设计 为什么需要数据库设计 当数据库比较复杂时我们需要设计数据库 糟糕的数据库设计 : 数据冗余,存储空间浪费 数据更新和插入的异常 程序性能差 良好的数据库设计 : 节省数据的存储空间 能够保证数据的完整性 方便进行数据库应用系统的开发 软件项目开发周期中数据库设计 : 需求分析阶段: 分析客户的业务和数据处理需求 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整. 设计数据库步骤 收集信息 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务. 标识实体[Entity] 标识数据库要管理的关键对象或实体,实体一般是名词 标识每个实体需要存储的详细信息[Attribute] 标识实体之间的关系[Relationship] 三大范式 问题 : 为什么需要数据规范化? 不合规范的表设计会导致的问题： 信息重复 更新异常 插入异常 无法正确表示信息 删除异常 丢失有效信息 三大范式 第一范式 (1st NF) 第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式 第二范式(2nd NF) 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求每个表只描述一件事情 第三范式(3rd NF) 如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范化和性能的关系 为满足某种商业目标 , 数据库性能比规范化数据库更重要 在数据规范化的同时 , 要综合考虑数据库的性能 通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间 e [, tbl_name] … [option] … option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} – 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] … ### MySQL备份 数据库备份必要性 - 保证重要数据不丢失 - 数据转移 MySQL数据库备份方法 - mysqldump备份工具 - 数据库管理工具,如SQLyog - 直接拷贝数据库文件和相关配置文件 **mysqldump客户端** 作用 : - 转储数据库 - 搜集数据库进行备份 - 将数据转移到另一个SQL服务器,不一定是MySQL服务器 [外链图片转存中...(img-kwwnyH4I-1604630594823)] – 导出 导出一张表 – mysqldump -uroot -p123456 school student &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 导出多张表 – mysqldump -uroot -p123456 school student result &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 导出所有表 – mysqldump -uroot -p123456 school &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 导出一个库 – mysqldump -uroot -p123456 -B school &gt;D:/a.sql mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 – 导入 在登录mysql的情况下：-- source D:/a.sql source 备份文件 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 ### 规范化数据库设计 ### 为什么需要数据库设计 **当数据库比较复杂时我们需要设计数据库** **糟糕的数据库设计 :** - 数据冗余,存储空间浪费 - 数据更新和插入的异常 - 程序性能差 **良好的数据库设计 :** - 节省数据的存储空间 - 能够保证数据的完整性 - 方便进行数据库应用系统的开发 **软件项目开发周期中数据库设计 :** - 需求分析阶段: 分析客户的业务和数据处理需求 - 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整. **设计数据库步骤** - 收集信息 - - 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务. - 标识实体[Entity] - - - 标识数据库要管理的关键对象或实体,实体一般是名词 - 标识每个实体需要存储的详细信息[Attribute] - 标识实体之间的关系[Relationship] ### 三大范式 **问题 : 为什么需要数据规范化?** 不合规范的表设计会导致的问题： - 信息重复 - 更新异常 - 插入异常 - - 无法正确表示信息 - 删除异常 - - 丢失有效信息 &gt; 三大范式 **第一范式 (1st NF)** 第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式 **第二范式(2nd NF)** 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求每个表只描述一件事情 **第三范式(3rd NF)** 如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 **规范化和性能的关系** 为满足某种商业目标 , 数据库性能比规范化数据库更重要 在数据规范化的同时 , 要综合考虑数据库的性能 通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间 通过在给定的表中插入计算列,以方便查询 ","link":"https://ganhan999.github.io/post/Java MySQL/"},{"title":"中等22. 括号生成","content":"题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 输入：n = 3 输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 本体思路 递归，深度遍历 如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量， 我们可以放一个右括号。 那么我们在什么情况下添加左括号呢？很明显，最多能添加 n 个左括号， 在递归调用的时候，在能传递到最底层的共用字符串中先添加 ”(“ ，然后 left-1，递归调用就可以。 那什么时候添加右括号呢？当左括号个数大于右括号的个数时添加右括号。 总之，向下搜索要满足两个条件： 插入数量不超过n (可以插入的前提是 ( 的数量大于 ） #大神做法1： class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: ans = [] def backtrack(S, left, right): if len(S) == 2 * n: ans.append(''.join(S)) return if left &lt; n: S.append('(') backtrack(S, left+1, right) S.pop() if right &lt; left: S.append(')') backtrack(S, left, right+1) S.pop() backtrack([], 0, 0) return ans &quot;&quot;&quot;&quot;&quot;&quot; 大神做法2： 当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。 它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。 那么，剩下 n-1 组括号有可能在哪呢？ 【这里是重点，请着重理解】 剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。 既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历： &quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】 其中 p + q = n-1，且 p q 均为非负整数。 事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。 注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。 class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: if n == 0: return [] total_l = [] total_l.append([None]) # 0组括号时记为None total_l.append([&quot;()&quot;]) # 1组括号只有一种情况 for i in range(2,n+1): # 开始计算i组括号时的括号组合 l = [] for j in range(i): # 开始遍历 p q ，其中p+q=i-1 , j 作为索引 now_list1 = total_l[j] # p = j 时的括号组合情况 now_list2 = total_l[i-1-j] # q = (i-1) - j 时的括号组合情况 for k1 in now_list1: for k2 in now_list2: if k1 == None: k1 = &quot;&quot; if k2 == None: k2 = &quot;&quot; el = &quot;(&quot; + k1 + &quot;)&quot; + k2 l.append(el) # 把所有可能的情况添加到 l 中 total_l.append(l) # l这个list就是i组括号的所有情况，添加到total_l中，继续求解i=i+1的情况 return total_l[n] ","link":"https://ganhan999.github.io/post/22、括号生成/"},{"title":"送给十年后的自己的一份答卷","content":"1、你现在有选择的余地嘛？ 2、你现在能保证实现财务自由嘛？ 3、你找到了你的那个她嘛？ 4、你身体还健康嘛？ 5、你父母享福了嘛？ 6、你还在熬夜嘛？ 7、你还在坚持跑步嘛？ 8、你还会和以前的好友偶尔联系嘛？ 9、请与我答复 谢谢 ","link":"https://ganhan999.github.io/post/送给十年后的自己的一份答卷/"},{"title":"中等17. 电话号码的字母组合","content":"题目 &quot;&quot;&quot; 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. &quot;&quot;&quot; 本体思路 深度遍历，例如abc def ghi的组合，先adg adh …… #我的做法： class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return [] phone = {'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z']} def backtrack(conbination, nextdigit): if len(nextdigit) == 0: res.append(conbination) else: for letter in phone[nextdigit[0]]: backtrack(conbination + letter, nextdigit[1:]) res = [] backtrack('', digits) return res &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： 广度遍历，利用队列 class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return [] phone = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] queue = [''] # 初始化队列 for digit in digits: for _ in range(len(queue)): tmp = queue.pop(0) for letter in phone[ord(digit) - 50]: # 这里我们不使用 int() 转换字符串，使用ASCII码 queue.append(tmp + letter) return queue ","link":"https://ganhan999.github.io/post/17、电话号码的字母组合/"},{"title":"Java JavaScript","content":"0、前端知识体系 想要成为真正的“互联网Java全栈工程师”还有很长的一段路要走，其中前端是绕不开的一门必修课。本阶段课程的主要目的就是带领Java后台程序员认识前端、了解前端、掌握前端，为实现成为“互联网Java全栈工程师”再向前迈进一步。 0.1、前端三要素 HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容 CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式。 JavaScript（行为）：是一种弱类型脚本语言，其源码不需经过编译，而是由浏览器解释运行，用于控制网页的行为 0.2、结构层（HTML） 太简单，略 0.3、表现层（CSS） CSS层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下： 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护； 这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为【CSS预处理器】的工具,提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大的提高了前端在样式上的开发效率。 什么是CSS预处理器 CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只需要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”。 常用的CSS预处理器有哪些 SASS：基于Ruby ，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。 LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以如果我们后台人员如果需要的话，建议使用LESS。 0.4、行为层（JavaScript） JavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需要经过编译，而是将文本格式的字符代码发送给浏览器，由浏览器解释运行。 JavaScript框架 JQuery：大家熟知的JavaScript库，优点就是简化了DOM操作，缺点就是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6，7，8； Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用了TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代–&gt;2 代，除了名字，基本就是两个东西；截止发表博客时已推出了Angular6） React：Facebook 出品，一款高性能的JS前端框架；特点是提出了新概念 【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言； Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和React(虚拟 DOM) 的优点； Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery 提供的AJAX 通信功能； UI框架 Ant-Design：阿里巴巴出品，基于React的UI框架 ElementUI、iview、ice：饿了么出品，基于Vue的UI框架 BootStrap：Teitter推出的一个用于前端开发的开源工具包 AmazeUI：又叫“妹子UI”，一款HTML5跨屏前端框架 JavaScript构建工具 Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript WebPack：模块打包器，主要作用就是打包、压缩、合并及按序加载 注：以上知识点已将WebApp开发所需技能全部梳理完毕 0.5、三端同一 混合开发（Hybrid App） 主要目的是实现一套代码三端统一（PC、Android：.apk、iOS：.ipa）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种： 云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud 本地打包： Cordova（前身是 PhoneGap） 微信小程序 详见微信官网，这里就是介绍一个方便微信小程序UI开发的框架：WeUI 1、什么是Javascript 1.1、概述 javaScript是一门世界上最流行的脚本语言 Java，JavaScript 10天 一个合格的后端人员，必须精通JavaScript 1.2、历史 见百度 ECMAScript它可以理解为JavaScript的一个标准 最新版本已经到es6版本~ 但是大部分浏览器还只停留在支持es5代码上！ 开发环境–线上环境，版本不一致 2、快速入门 2.1、引入JavaScript 1、内部标签 &lt;script&gt; //.... &lt;script&gt; 2、外部引入 hj.js test.html &lt;!--外部引入 注意：script必须成对出现 --&gt; &lt;script src=&quot;js/hj.js&quot;&gt;&lt;/script&gt; &lt;!--不用显示定义type，也默认就是javaScript--&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--script标签内，写Javascript代码--&gt; &lt;!--&lt;script&gt; alert(&quot;hello,world&quot;); &lt;/script&gt;--&gt; &lt;!--外部引入 注意：script必须成对出现 --&gt; &lt;script src=&quot;js/hj.js&quot;&gt;&lt;/script&gt; &lt;!--不用显示定义type，也默认就是javaScript--&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这里也可以存放--&gt; &lt;/body&gt; &lt;/html&gt; 2.2、基本语法入门 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--JavaScript严格区分大小写--&gt; &lt;script&gt; // 1. 定义变量 变量类型 变量名 = 变量值 var score = 1 ; //alert(num) // 2. 条件控制 if (score &gt; 60 &amp;&amp; score &lt; 70){ alert(&quot;60~70&quot;); }else if(score &gt; 70 &amp;&amp; score &lt; 80){ alert(&quot;70~80&quot;); }else{ alert(&quot;other&quot;) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 浏览器必备调试须知： 2.3、数据类型 数值，文本，图形，音频，视频 变量 var a number js不区分小树和整数，Number 123//整数123 123.1//浮点数123.1 1.123e3//科学计数法 -99//负数 NaN //not a number Infinity // 表示无限大 字符串 ‘abc’ “abc” 布尔值 true，false 逻辑运算 &amp;&amp; 两个都为真，结果为真 || 一个为真，结果为真 ! 真即假，假即真 比较运算符 ！！！重要！ = 1，&quot;1&quot; == 等于（类型不一样，值一样，也会判断为true） === 绝对等于（类型一样，值一样，结果为true） 这是一个JS的缺陷，坚持不要使用 == 比较 须知： NaN === NaN，这个与所有的数值都不相等，包括自己 只能通过isNaN（NaN）来判断这个数是否是NaN 浮点数问题 console.log((1/3) === (1-2/3)) 尽量避免使用浮点数进行运算，存在精度问题！ Math.abs(1/3-(1-2/3))&lt;0.00000001 null 和 undefined null 空 undefined 未定义 数组 Java的数组必须是相同类型的对象~，JS中不需要这样 //保证代码的可读性，尽量使用[] var arr = [1,2,3,4,5,'hello',null,true]; //第二种定义方法 new Array(1,2,3,4,5,'hello'); 取数字下标：如果越界了，就会 报undefined undefined 1 对象 对象是大括号，数组是中括号 每个属性之间使用逗号隔开，最后一个属性不需要逗号 // Person person = new Person(1,2,3,4,5); var person = { name:'Tom', age:3, tags:['js','java','web','...'] } 取对象值 person.name &gt; &quot;Tom&quot; person.age &gt; 3 2.4、严格检查格式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 前提：IDEA需要设置支持ES6语法 'use strict';严格检查模式，预防JavaScript的随意性导致产生的一些问题 必须写在JavaScript的第一行！ 局部变量建议都使用let去定义~ --&gt; &lt;script&gt; 'use strict'; //全局变量 let i=1 //ES6 let &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 3、数据类型 3.1、字符串 1、正常字符串我们使用 单引号，或者双引号包裹 2、注意转义字符 \\ \\' \\n \\t \\u4e2d \\u##### Unicode字符 \\x41 Ascall字符 3、多行字符串编写 //tab 上面 esc下面 var msg = `hello world 你好呀 nihao ` 4、模板字符串 //tab 上面 esc下面 let name = 'Tom'; let age = 3; var msg = `你好，${name}` 5、字符串长度 str.length 6、字符串的可变性，不可变 7、大小写转换 //注意，这里是方法，不是属性了 student.toUpperCase(); student.toLowerCase(); 8、student.indexof(‘t’) 9、substring，从0开始 [) student.substring(1)//从第一个字符串截取到最后一个字符串 student.substring(1,3)//[1,3) 3.2、数组 Array可以包含任意的数据类型 var arr = [1,2,3,4,5,6];//通过下标取值和赋值 1、长度 arr.length 注意：假如给arr.lennth赋值，数组大小就会发生变化~，如果赋值过小，元素就会丢失 2、indexOf，通过元素获得下标索引 arr.indexOf(2) 字符串的&quot;1&quot;和数字 1 是不同的 **3、slice（）**截取Array的一部分，返回的一个新数组，类似于String中substring 4、push()，pop()尾部 push：压入到尾部 pop：弹出尾部的一个元素 5、unshift(),shift() 头部 unshift：压入到头部 shift：弹出头部的一个元素 6、排序sort() (3)[&quot;B&quot;,&quot;C&quot;,&quot;A&quot;] arr.sort() (3)[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;] 7、元素反转reverse() (3)[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;] arr.reverse() (3)[&quot;C&quot;,&quot;B&quot;,&quot;A&quot;] 8、concat() 注意：concat()并没有修改数组，只是会返回一个新的数组 9、连接符join 打印拼接数组，使用特定的字符串连接 10、多维数组 数组：存储数据（如何存，如何取，方法都可以自己实现！） 3.3、对象 若干个键值对 var 对象名 = { 属性名：属性值， 属性名：属性值， 属性名：属性值 } //定义了一个person对象，它有四个属性 var person = { name:&quot;Tom&quot;, age:3, email:&quot;123456798@QQ.com&quot;, score:66 } Js中对象，{…}表示一个对象，建制对描述属性xxx：xxx，多个属性之间用逗号隔开，最后一个属性不加逗号！ JavaScript中的所有的键都是字符串，值是任意对象！ 1、对象赋值 2、使用一个不存在的对象属性，不会报错！undefined 3、动态的删减属性，通过delete删除对象的属性 4、动态的添加，直接给新的属性添加值即可 5、判断属性值是否在这个对象中！xxx in xxx 6、判断一个属性是否是这个对象自身拥有的 hasOwnProperty() 3.4、流程控制 if判断 while循环，避免程序死循环 for循环 forEach循环 ES5.1特性 for …in-------下标 3.5、Map和Set ES6的新特性~ Map Set：无序不重复的集合 3.6、iterator es6新特性 作业：使用iterator来遍历迭代我们Map，Set！ 遍历数组 遍历Map 遍历set 4、函数 4.1、定义函数 定义方式一 绝对值函数 一旦执行到return代表函数结束，返回结果！ 如果没有执行return，函数执行完也会返回结果，结果就是undefined 定义方式二 function(x){…}这是一个匿名函数。但是可以吧结果赋值给abs，通过abs就可以调用函数！ 方式一和方式二等价！ 调用函数 abs(10)//10 abs(-10) //10 参数问题：javaScript可以传任意个参数，也可以不传递参数~ 参数进来是否存在问题？ 假设不存在参数，如何规避？ arguments arguments是一个JS免费赠送的关键字； 代表，传递进来的所有参数，是一个数组！ 问题：arguments包含所有的参数，我们有时候想使用多余的参数来进行附加操作。需要排除已有参数~ rest 以前： ES6引入的新特性，获取除了已经定义的参数之外的所有参数~… rest参数只能写在最后面，必须用…标识。 4.2、变量的作用域 在javascript中，var定义变量实际是有作用于的。 假设在函数体重声明，则在函数体外不可以使用~（闭包） 如果两个函数使用了相同的变量名，只要在函数内部就不冲突 内部函数可以访问外部函数的成员，反之则不行 假设，内部函数变量和外部函数变量，重名！ 假设在JavaScript中，函数查找变量从自身函数开始~， 由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。 提升变量的作用域 结果：x undefined 说明：js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值； 这个是在javascript建立之初就存在的特性。 养成规范：所有 的变量定义都放在函数的头部，不要乱放，便于代码维护； 全局变量 全局对象window alert() 这个函数本身也是一个window的变量； javascript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，就会报错 Refrence 规范 由于我们的所有变量都会绑定到window上，。如果不同的js文件，使用了相同的全局变量，就会产生冲突—&gt;如何减少这样的冲突？ 把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突问题~ jQuery中就是使用的该方法：jQuery.name，简便写法：$() 局部作用域 ES6的let关键字，解决了局部作用域冲突的问题！ 建议大家都用let去定义局部作用域的变量； 常量 在ES6之前，怎么定义常量：只有用全部大写字母命名的变量就是常量；建议不要修改这样的值。 在ES6引入了常量关键字 const 4.3、方法 定义方法 方法就是把函数放在对象的里面，对象只有两个东西：属性和方法 this.代表什么？拆开上main的代码看看 this是无法指向的，是默认指向调用它的那个对象的； apply 在js中可以控制this指向 5、内部对象 标准对象 5.1、Date 基本使用 转换 5.2、JSON JSON是什么 在javascript中，一切皆为对象，任何js支持的类型都可以用JSON表示 格式 对象都用{} 数组都用[] 所有的键值对 都是用key:value JSON字符串和js对象转化 很多人搞不清楚，JSON和JS对象的区别 5.3、AJAX 原生的js写法 xhr异步请求 jQuery封装好的方法$(#name).ajax(&quot;&quot;) axios请求 6、面向对象编程 原型对象 javascript、java、c#------面向对象；但是javascript有些区别！ 类：模板 对象：具体实例 在javascript中，需要大家转换一下思维方式！ 原型： class集继承 class关键字，是在ES6引入的 1、定义一个类、属性、方法 2、继承 &lt;script&gt; //ES6之后======================== //定义一个学生的类 class Student{ constructor(name){ this.name = name; } hello(){ alert('hello'); } } class XiaoStudent extends Student{ constructor(name,grade){ super(name); this.grade = grade; } myGrade(){ alert('我是一名小学生'); } } var xiaoming = new Student(&quot;xiaoming&quot;); var xiaohong = new XiaoStudent(&quot;xiaohong&quot;,1); &lt;/script&gt; 本质：查看对象原型 原型链 proto: 7、操作BOM对象（重点） 浏览器介绍 javascript和浏览器关系？ BOM：浏览器对象模型 IE6~11 Chrome Safari FireFox Opera 三方 QQ浏览器 360浏览器 window window代表浏览器窗口 Navigator（不建议使用） Navigator封装了浏览器的信息 大多数时候，我们不会使用navigator对象，因为会被认为修改! 不建议使用这些属性来判断和编写代码 screen 代表屏幕尺寸 location(重要) location代表当前页面的URL信息 document（内容DOM） document代表当前的页面，HTML DOM文档树 获取具体的文档树节点 获取cookie 劫持cookie原理 www.taobao.com 服务器端可以设置cookie为httpOnly history（不建议使用 ） history代表浏览器的历史记录 8、操作DOM对象（重点） DOM：文档对象模型 核心 浏览器网页就是一个Dom树形结构！ 更新：更新Dom节点 遍历Dom节点：得到Dom节点 删除：删除一个Dom节点 添加：添加一个新的节点 要操作一个Dom节点，就必须要先获得这个Dom节点 获得Dom节点 这是原生代码，之后我们尽量都使用jQuery(); 更新节点 操作文本 操作css 删除节点 删除节点的步骤：先获取父节点，再通过父节点删除自己 注意：删除多个节点的时候，children是在时刻变化的，删除节点的时候一定要注意。 插入节点 我们获得了某个Dom节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是这个Dom节点已经存在元素了，我们就不能这么干了！会产生覆盖 追加 创建一个新的标签 &lt;script&gt; var js = document.getElementById('js');//已经存在的节点 var list = document.getElementById('list'); //通过JS创建一个新的节点 var newP = document.creatElement('p');//创建一个p标签 newP.id = 'newP'; newP.innerText = 'Hello,Kuangshen'; //创建一个标签节点 var myScript = document.creatElement('script'); myScript.setAttribute('type','text/javascript'); //可以创建一个style标签 var myStyle = document.creatElement('style');//创建了一个空style标签 myStyle.setAttribute('type','text/css'); myStyle.innerHTML = 'body{background-color:chartreuse;}';//设置标签内容 document.getElementByTagName('head')[0].appendChild(myStyle); &lt;/script&gt; insertBefore var ee = document.getElementById('ee'); var js = document.getElementById('js'); var list = document.getElementById('list'); //要包含的节点.insertBefore(newNode,targetNode) list.insertBefore(js,ee); 9、操作表单 表单是什么？form-----DOM树 文本框----text 下拉框----select 单选框----radio 多选框----checkbox 隐藏域----hidden 密码框----password … 表单的目的提交信息 获得要提交的信息 &lt;body&gt; &lt;form action = &quot;post&quot;&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; id = &quot;username&quot; /&gt; &lt;/p&gt; &lt;!--多选框的值就是定义好的value--&gt; &lt;p&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;man&quot; id = &quot;boy&quot;/&gt;男 &lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;woman&quot; id = &quot;girl&quot;/&gt;女 &lt;/p&gt; &lt;/form&gt; &lt;script&gt; var input_text = document.getElementById(&quot;username&quot;); var boy_radio = document.getElementById(&quot;boy&quot;); var girl_radio = document.getElementById(&quot;girl&quot;); //得到输入框的值 input_text.value //修改输入框的值 input_text.value = &quot;value&quot;; //对于单选框，多选框等等固定的值，boy_radio.value只能取到当前的值 boy_radio.checked;//查看返回的结果，是否为true，如果为true，则被选中。 girl_radio.checked = true;//赋值 &lt;/script&gt; &lt;/body&gt; 提交表单。md5加密密码，表单优化 &lt;!DOCTYPE html&gt; &lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--MD5加密工具类--&gt; &lt;script src = &quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--表达绑定提交事件 οnsubmit= 绑定一个提交检测的函数，true，false 将这个结果返回给表单，使用onsubmit接收 --&gt; &lt;form action = &quot;https://www.baidu.com&quot; method = &quot;post&quot; onsubmit = &quot;return aaa()&quot;&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; id = &quot;username&quot; name = &quot;username&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密码：&lt;/span&gt;&lt;input type=&quot;password&quot; id = &quot;password&quot; /&gt; &lt;/p&gt; &lt;input type = &quot;hidden&quot; id = &quot;md5-password&quot; name = &quot;password&quot;&gt; &lt;!--绑定事件 onclick 被点击--&gt; &lt;button type = &quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function aaa(){ alert(1); var username = document.getElementById(&quot;username&quot;); var pwd = document.getElementById(&quot;password&quot;); var md5pwd = document.getElementById(&quot;md5-password&quot;); //pwd.value = md5(pwd,value); md5pwd.value = mad5(pwd.value); //可以校验判断表单内容，true就是通过提交，false就是阻止提交 return false; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10、jQuery javaScript和jQuery的关系？ jQuery库，里面存在大量的JavaScript函数 获取jQuery 公式：$(selector).action() &lt;!DOCTYPE html&gt; &lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;lib/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;&quot; id = &quot;test-jquery&quot;&gt;点我&lt;/a&gt; &lt;script&gt; //选择器就是css选择器 $('#test-jquery').click(function(){ alert('hello,jQuery!'); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 选择器 //原生js，选择器少，麻烦不好记 //标签 document.getElementByTagName(); //id document.getElementById(); //class document.getElementByClassName(); //jQuery css中的选择器它全部都能用！ $('p').click();//标签选择器 $('#id1').click();//id选择器 $('.class1').click;//class选择器 文档工具站：http://jquery.cuishifeng.cn/ 事件 鼠标事件、键盘事件，其他事件 mousedown()(jQuery)----按下 mouseenter()(jQuery) mouseleave()(jQuery) mousemove()(jQuery)----移动 mouseout()(jQuery) mouseover()(jQuery) mouseup()(jQuery) &lt;!DOCTYPE html&gt; &lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;lib/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #divMove{ width:500px; height:500px; border:1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--要求：获取鼠标当前的一个坐标--&gt; mouse：&lt;span id = &quot;mouseMove&quot;&gt;&lt;/span&gt; &lt;div id = &quot;divMove&quot;&gt; 在这里移动鼠标试试 &lt;/div&gt; &lt;script&gt; //当网页元素加载完毕之后，响应事件 //$(document).ready(function(){}) $(function(){ $('#divMove').mousemove(function(e){ $('#mouseMove').text('x:'+e.pageX+&quot;y:&quot;+e.pageY) }) }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 操作DOM 节点文本操作 $('#test-ul li[name=python]').text();//获得值 $('#test-ul li[name=python]').text('设置值');//设置值 $('#test-ul').html();//获得值 $('#test-ul').html('&lt;strong&gt;123&lt;/strong&gt;');//设置值 CSS的操作 $('#test-ul li[name=python]').css({&quot;color&quot;,&quot;red&quot;}); 元素的显示和隐藏，：本质display:none $('#test-ul li[name=python]').show(); $('#test-ul li[name=python]').hide(); 娱乐测试 $(window).width() $(window).height() $('#test-ul li[name=python]').toggle(); 未来ajax()； $('#form').ajax() $.ajax({url:&quot;test.html&quot;,context:document.body,success:function(){ $(this).addClass(&quot;done&quot;); }}) 小技巧 1、如何巩固JS（看jQuery源码，看游戏源码！） 2、巩固HTML、CSS（扒网站，全部down下来，然后对应修改看效果~） ","link":"https://ganhan999.github.io/post/Java JavaScript/"},{"title":"中等16. 最接近的三数之和","content":"题目 &quot;&quot;&quot; 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 &quot;&quot;&quot; 本体思路 和上一题差不多，排序＋双指针法，排序后可以化简为双指针的twosum题 #我的做法： class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: n = len(nums) if (not nums or n &lt; 3): return [] nums.sort() d = float('inf') for i in range(n): if (i &gt; 0 and nums[i] == nums[i - 1]): continue L = i + 1 R = n - 1 while (L &lt; R): x = (nums[i] + nums[L] + nums[R]) - target if (nums[i] + nums[L] + nums[R] == target): return nums[i] + nums[L] + nums[R] if abs(x)&lt;d: ans = nums[i] + nums[L] + nums[R] d=abs(x) if x&gt;0: R=R-1 else: L = L + 1 return ans ","link":"https://ganhan999.github.io/post/16、最接近的三数之和/"},{"title":"中等15. 三数之和","content":"题目 &quot;&quot;&quot; 给你一个包含 n 个整数的数组 nums， 判断 nums 中是否存在三个元素 a，b，c ， 使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] &quot;&quot;&quot; 本体思路 排序＋双指针法，排序后可以化简为双指针的twosum题 #我的做法： class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n = len(nums) res = [] if (not nums or n &lt; 3): return [] nums.sort() for i in range(n): if (nums[i] &gt; 0): return res if (i &gt; 0 and nums[i] == nums[i - 1]):#加i&gt;0是为了避免[0,0,0,0]的情况 continue L = i + 1 R = n - 1 while (L &lt; R): if (nums[i] + nums[L] + nums[R] == 0): res.append([nums[i], nums[L], nums[R]]) while (L &lt; R and nums[L] == nums[L + 1]): L = L + 1 while (L &lt; R and nums[R] == nums[R - 1]): R = R - 1 L = L + 1 R = R - 1 elif (nums[i] + nums[L] + nums[R] &gt; 0): R = R - 1 else: L = L + 1 return res ","link":"https://ganhan999.github.io/post/15、三数之和/"},{"title":"中等12. 整数转罗马数字","content":"题目 &quot;&quot;&quot; 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。 这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: &quot;III&quot; 示例 2: 输入: 4 输出: &quot;IV&quot; 示例 3: 输入: 9 输出: &quot;IX&quot; 示例 4: 输入: 58 输出: &quot;LVIII&quot; 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: &quot;MCMXCIV&quot; 解释: M = 1000, CM = 900, XC = 90, IV = 4. &quot;&quot;&quot; 本体思路 贪心算法 #我的做法： class Solution: def intToRoman(self, num: int) -&gt; str: # 使用哈希表，按照从大到小顺序排列 hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'} res = '' for key in hashmap: if num // key != 0: count = num // key # 比如输入4000，count 为 4 res += hashmap[key] * count num %= key return res &quot;&quot;&quot; #大神做法 暴力算法 &quot;&quot;&quot; class Solution: def intToRoman(self, num: int) -&gt; str: M = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;] # 1000，2000，3000 C = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;] # 100~900 X = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;] # 10~90 I = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;] # 1~9 return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10] ","link":"https://ganhan999.github.io/post/12、整数转罗马数字 /"},{"title":"Java CSS","content":"1、CSS的3种导入方式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--内部样式--&gt; &lt;style&gt; h1{ color: green; } &lt;/style&gt; &lt;!--外部样式--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--优先级：就近原则--&gt; &lt;!--行内样式：在标签元素中，编写一个style属性，编写样式即可--&gt; &lt;h1 style=&quot;color: red&quot;&gt;这是标签&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2、选择器 2.1基本选择器 2.1.1标签选择器 选择一类标签 标签{} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; h1{ color: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标签1&lt;/h1&gt; &lt;h1&gt;标签2&lt;/h1&gt; &lt;h1&gt;标签3&lt;/h1&gt; &lt;h1&gt;标签4&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.1.2类选择器(class) 选择所有class一致的标签，跨标签，格式：.类名{} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*类选择器的格式 .class的名称{} 好处：可以多个标签归类，是同一个class，可以复用 */ .demo1{ color: blue; } .demo2{ color: red; } .demo3{ color: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class =&quot;demo1&quot;&gt;类选择器：demo1&lt;/h1&gt; &lt;h1 class=&quot;demo2&quot;&gt;类选择器：demo2&lt;/h1&gt; &lt;h1 class=&quot;demo3&quot;&gt;类选择器：demo3&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.1.3id 选择器 全局唯一，格式：#id名{} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择器：id必须保证全局唯一 #id名称{} 不遵循就近原则，优先级是固定的 id选择器 &gt; 类选择器 &gt; 标签选择器 */ #demo1{ color: aqua; } .demo2{ color: red; } #demo2{ color: orange; } h1{ color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=&quot;demo1&quot;&gt;id选择器：demo1&lt;/h1&gt; &lt;h1 class=&quot;demo2&quot; id = &quot;demo2&quot;&gt;id选择器：demo2&lt;/h1&gt; &lt;h1 class=&quot;demo2&quot;&gt;id选择器：demo3&lt;/h1&gt; &lt;h1&gt;id选择器：demo4&lt;/h1&gt; &lt;h1&gt;id选择器：demo5&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; **注意：**优先级：id &gt; class &gt; 标签 2.2层次选择器 2.2.1后代选择器 在某个元素的后面 /*后代选择器*/ &lt;style&gt; body p{ background:red; } &lt;/style&gt; 2.2.2子选择器 子类一代 /*子选择器*/ &lt;style&gt; body&gt;p{ background:orange; } &lt;/style&gt; 2.2.3相邻的兄弟选择器 注意：同辈只有一个，相邻（向下） /*相邻兄弟选择器：只有一个，相邻（向下）*/ &lt;style&gt; .active+p{ background: red } &lt;/style&gt; &lt;body&gt; &lt;p class=&quot;active&quot;&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 2.2.4通用选择器 注意：当前选中元素的向下的所有兄弟元素 &lt;style&gt; /*通用兄弟选择器，当前选中元素的向下的所有兄弟元素*/ .active~p{ background:red; } &lt;/style&gt; &lt;body&gt; &lt;p class=&quot;active&quot;&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 2.3结构伪类选择器 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*ul的第一个子元素*/ ul li:first-child{ background: aqua; } /*ul的最后一个子元素*/ ul li:last-child{ background: blue; } /*选中p1：定位到父元素，选择当前的第一个元素 选择当前p元素 的父级元素，选中父级元素的第一个，并且是当前元素才生效！ */ p:nth-child(1){ background: orange; } /*选中父元素下的，第2个p元素*/ p:nth-of-type(2){ background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt; &lt;ul&gt; &lt;li&gt;l1&lt;/li&gt; &lt;li&gt; &lt;p&gt;p5&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p6&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;p7&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 2.4属性选择器（常用） 标签[属性名=属性值(正则)]{} 正则： =表示绝对等于 *=表示包含 ^=表示以...开头 $=表示以...结尾 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .demo a{ display: block; height: 50px; width: 50px; float:left; border-radius: 10px; background: blue; text-align: center; color: beige; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; } /*属性名，属性名=属性值（正则） =表示绝对等于 *=表示包含 ^=表示以...开头 $=表示以...结尾 存在id属性的元素 a[]{} */ /* a[id]{ background: red; }*/ /*id=first的元素*/ /* a[id=first]{ background: aqua; }*/ /*class中有links元素*/ /* a[class = &quot;links item2 first2&quot;]{ background: orange; }*/ /*a[class*=&quot;links&quot;]{ background: black ; }*/ /*选中href中以http开头的元素*/ a[href^=&quot;http&quot;]{ background: orange; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;demo&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot; class=&quot;links item first&quot; id=&quot;first&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;/adad/faf&quot; class=&quot;links item2 first2&quot; &gt;2&lt;/a&gt; &lt;a href=&quot;qwe123&quot; class=&quot;links item3 first3&quot; &gt;3&lt;/a&gt; &lt;a href=&quot;eweqe&quot; class=&quot;links item4 first4&quot; &gt;4&lt;/a&gt; &lt;a href=&quot;rrrrr&quot; class=&quot;links item5 first5&quot; &gt;5&lt;/a&gt; &lt;a href=&quot;ttt&quot; class=&quot;links item6 first6&quot; &gt;6&lt;/a&gt; &lt;a href=&quot;yyy&quot; class=&quot;links item7 first7&quot; &gt;7&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3、美化网页元素 3.1为什么要美化网页 有效的传递页面信息 美化网页，页面漂亮才能吸引客户 凸显页面的主题 提高用户的体验 span标签：重点要突出的字，使用span标签套起来 font-family：字体 font-size：字体大小 font-weight：字体粗细 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #study{ font-size: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; 学习&lt;span id=&quot;study&quot;&gt;CSS&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 3.2字体样式 font-weight:bolder;/*也可以填px，但数值不能超过900,900相当于bloder*/ /*常用写法：*/ font:oblique bloder 12px &quot;楷体&quot; 3.3文本样式 颜色–&gt;color 文本对齐方式–&gt;text-align：center 首行缩进–&gt;text-indent：2em 行高–&gt;line-height：300px； 下划线–&gt;text-decoration color:red;/*红色*/ text-align: center;/*居中*/ text-decoration:underline/*下划线*/ text-decoration:line-through/*中划线*/ text-decoration:overline/*上划线*/ text-decoration:none/*超链接去下划线*/ 图片、文字水平对齐 img,span{vetical-align:middle} 3.4文本，阴影和超链接伪类 &lt;style&gt; a{/*超链接有默认的颜色*/ text-decoration:none;/*下划线设置为空*/ color:#000000; } a:hover{/*鼠标悬浮的状态*/ color:orange; } a:active{/*鼠标按住未释放的状态*/ color:green } a:visited{/*点击之后的状态*/ color:red } &lt;/style&gt; 阴影： /* 第一个参数：表示水平偏移 第二个参数：表示垂直偏移 第三个参数：表示模糊半径 第四个参数：表示颜色 */ text-shadow:5px 5px 5px 颜色 3.5列表ul li /*list-style{ none:去掉原点 circle：空心圆 decimal：数字 square：正方形 }*/ ul li{ height:30px; list-style:none; text-indent:1em; } a{ text-decoration:none; font-size:14px; color:#000; } a:hover{ color:orange; text-decoration:underline } /*放在div中，作为导航栏*/ &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt; #nav{ width:300px; } 3.6列表ul li /*list-style{ none:去掉原点 circle：空心圆 decimal：数字 square：正方形 }*/ ul li{ height:30px; list-style:none; text-indent:1em; } a{ text-decoration:none; font-size:14px; color:#000; } a:hover{ color:orange; text-decoration:underline } /*放在div中，作为导航栏*/ &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt; #nav{ width:300px; } 3.7背景 背景颜色：background 背景图片 background-image:url(&quot;&quot;);/*默认是全部平铺的*/ background-repeat:repeat-x/*水平平铺*/ background-repeat:repeat-y/*垂直平铺*/ background-repeat:no-repeat/*不平铺*/ 综合使用 background:red url(&quot;图片相对路劲&quot;) 270px 10px no-repeat background-position：/*定位：背景位置*/ 4、盒子模型 4.1什么是盒子模型 margin：外边距 padding：内边距 border：边框 4.2边框 border：粗细 样式 颜色 边框的粗细 边框的样式 边框的颜色 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #nav{ text-align: center; width: 300px; height: 200px; border:1px solid red; } #user input{ border: 2px solid green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;nav&quot;&gt; &lt;h1&gt;会员登录&lt;/h1&gt; &lt;form action=&quot;#&quot;&gt; &lt;div id=&quot;user&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;邮箱：&lt;/span&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4.3外边距----妙用：居中 margin-left/right/top/bottom–&gt;表示四边，可分别设置，也可以同时设置如下 margin:0 0 0 0/*分别表示上、右、下、左；从上开始顺时针*/ /*例1：居中*/ margin:0 auto /*auto表示左右自动*/ /*例2：*/ margin:4px/*表示上、右、下、左都为4px*/ /*例3*/ margin:10px 20px 30px/*表示上为10px，左右为20px，下为30px*/ 盒子的计算方式： margin+border+padding+内容的大小 总结： body总有一个默认的外边距 margin:0 常见操作：初始化 margin:0; padding:0; text-decoration:none; 4.4圆角边框----border-radius border-radius有四个参数（顺时针），左上-&gt;右上-&gt;右下-&gt;左下 圆圈：圆角=半径 5、浮动 5.1标准文档流 块级元素：独占一行 h1~h6 、p、div、 列表… 行内元素：不独占一行 span、a、img、strong 注： 行内元素可以包含在块级元素中，反之则不可以。 5.2、display（重要） block：块元素 inline：行内元素 inline-block：是块元素，但是可以内联，在一行 这也是一种实现行内元素排列的方式，但是我们很多情况用float none：消失 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--block 块元素 inline 行内元素 inline-block 是块元素，但是可以内联 ，在一行 --&gt; &lt;style&gt; div{ width: 100px; height: 100px; border: 1px solid red; display: inline-block; } span{ width: 100px; height: 100px; border: 1px solid red; display: inline-block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div块元素&lt;/div&gt; &lt;span&gt;span行内元素&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 5.3float：left/right左右浮动 clear：both 5.4overflow及父级边框塌陷问题 clear： right：右侧不允许有浮动元素 left：左侧不允许有浮动元素 both：两侧不允许有浮动元素 none： 解决塌陷问题方案： 方案一：增加父级元素的高度； 方案二：增加一个空的div标签，清除浮动 &lt;div class = &quot;clear&quot;&gt;&lt;/div&gt; &lt;style&gt; .clear{ clear:both; margin:0; padding:0; } &lt;/style&gt; 方案三：在父级元素中增加一个overflow：hidden overflow:hidden/*隐藏*/ overflow：scoll/*滚动*/ 方案四：父类添加一个伪类:after #father:after{ content:''; display:block; clear:both; } 小结： 浮动元素增加空div-&gt;简单、代码尽量避免空div 设置父元素的高度-&gt;简单，元素假设没有了固定的高度，就会超出 overflow-&gt;简单，下拉的一些场景避免使用 父类添加一个伪类:after（推荐）-&gt;写法稍微复杂，但是没有副作用，推荐使用 5.5display与float对比 display：方向不可以控制 float：浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题。 6、定位 6.1、相对定位 相对定位：positon：relstive； 相对于原来的位置，进行指定的偏移，相对定位的话，它仍然在标准文档流中，原来的位置会被保留 top:-20px; left:20px; bottom:-10px; right:20px; 7、css总结 ","link":"https://ganhan999.github.io/post/Java CSS/"},{"title":"11、盛最多水的容器","content":"题目 &quot;&quot;&quot; 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 示例 3： 输入：height = [4,3,2,1,4] 输出：16 示例 4： 输入：height = [1,2,1] 输出：2 &quot;&quot;&quot; 本体思路 暴力法 #我的做法： class Solution: def maxArea(self, height: List[int]) -&gt; int: res=0 for i in range(len(height)): for j in range(i+1,len(height)): res=max(res,(j-i)*min(height[i],height[j])) return res &quot;&quot;&quot; #大神做法 双指针法 首先写下一个测试例子， 8 1 1 1 11 9 13 15 10 12 观察数据找规律。随便看一个范围比如【11...12】，能否找到比这更好的解？那么我们发现9肯定不能是左边的板，因为9本来就比11矮，还靠12更近，那【9...12】的面积肯定要更小啊，13倒是有可能！ 规律：只有从最左开始升序的数字才可能是左板！【8】 1 1 1 【11】 9 【13】【15】10 12， 不在【】里的统统不可能是左板。 同理，只有从最右开始升序的数字才可能是右板！ 8 1 1 1 11 13 【15】 10 【12】 有了第三步的规律，其实离答案已经很近了： 【8】 1 1 1 【11】 9 【13】【15】 10 12 可能的左板在【】里 8 1 1 1 11 9 13 【15】 10 【12】 可能的右板在【】里 我们从最左边开始向右遍历可能的左板(8-&gt;11-&gt;13-&gt;15)，从最右边开始向左遍历可能的右板(12-&gt;15) 开始是【8...12】，面积是8*9=72 那接下来到底是从左往右的8-&gt;11呢还是从右往左的12-&gt;15呢？如果是12-&gt;15， 那明显面积是变小了；而8-&gt;11,面积可能增大！所以我们每次选择较短的板， 往左（或右）移，记录面积，直到左右碰头为止。 正确性：按照上面的思路下来，正确性就很明显了。 &quot;&quot;&quot; class Solution: def maxArea(self, height: List[int]) -&gt; int: i, j, res = 0, len(height) - 1, 0 while i &lt; j: if height[i] &lt; height[j]: res = max(res, height[i] * (j - i)) i += 1 else: res = max(res, height[j] * (j - i)) j -= 1 return res ","link":"https://ganhan999.github.io/post/11、盛最多水的容器/"},{"title":"中等8. 字符串转换整数","content":"题目 &quot;&quot;&quot; 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 示例 1: 输入: &quot;42&quot; 输出: 42 示例 2: 输入: &quot; -42&quot; 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: &quot;4193 with words&quot; 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: &quot;words and 987&quot; 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: &quot;-91283472332&quot; 输出: -2147483648 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 &quot;&quot;&quot; 本体思路 遍历每一个元素，判断是不是正负号或者数字 #我的做法： class Solution: def myAtoi(self, s: str) -&gt; int: if s==&quot;&quot;: return 0 state=1 flag=0 s1=&quot;&quot; for i in s: if flag==0: if i==&quot;-&quot;: s1+=i flag=1 elif i==&quot;+&quot;: s1 += i flag=1 elif i.isnumeric(): s1 += i flag=1 elif i.isspace(): continue else: return 0 else: if i.isnumeric(): s1 += i else: break if flag==0: return 0 if s1[0]==&quot;-&quot;: state=0 s1=s1[1:] elif s1[0] == &quot;+&quot;: s1=s1[1:] s1=self.atoi(s1) if state==0: s1=-s1 if s1&gt;=-2 ** 31 and s1&lt;=(2 ** 31) - 1: return s1 elif s1&lt;-2 ** 31: return -2 ** 31 else: return (2 ** 31) - 1 def atoi(self,s)://字符串转数字 s = s[::-1] num = 0 for i, v in enumerate(s): offset = ord(v) - ord('0') num += offset * (10 ** i) return num &quot;&quot;&quot; #大神做法1 正则表达式 &quot;&quot;&quot; class Solution: def myAtoi(self, str: str) -&gt; int: import re mathes=re.match('[ ]*([+-]?\\d+)',str) if not mathes: return 0 ans=int(mathes.group(1)) return min(max(ans,-2**31),2**31-1) ","link":"https://ganhan999.github.io/post/8、字符串转换整数/"},{"title":"Java HTML","content":" 初始HTML 网页基本标签 图像，超链接，网页布局 列表，表格，媒体元素 表单及表单应用 表单初级验证 1.初识HTML 什么是HTML HTML Hyper Text Markup Language（超文本标记语言） HTML发展史 HTML的优势 世界知名浏览器厂商对HTML5的支持 微软 Google 苹果 Opera Mozilla 市场的需求 跨平台 W3C标准 W3C World Wide Web Consortium 成立于1994年，Web技术领域最权威和具影响力的国际中立性技术标准机构 http://www.w3.org/ http://www.chinaw3c.org/ W3C标准包括 结构化标准语言（HTML、XML） 表现标准语言（CSS） 行为标准（DOM、ECMAScript） 常见IDE 记事本 Dreamweaver IDEA（咱们用IDEA） WebStorm …等等 HTML基本结构 2.网页基本信息 网页基本信息 &lt;!-- DOCTYPE：告诉浏览器，我们要使用什么规范 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!-- head标签代表网页头部 --&gt; &lt;head&gt; &lt;!-- meta描述性标签，它用来描述我们网站一些信息 --&gt; &lt;!-- meta一般用来做SEO --&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;狂神说Java&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;来这个地方学习Java&quot;&gt; &lt;!-- title网页标题 --&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;!-- body标签代表网页主题 --&gt; &lt;body&gt; Hello，World！ &lt;/body&gt; &lt;/html&gt; 3.网页基本标签 网页基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;基本标签学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--标题标签--&gt; &lt;h1&gt;一级标签&lt;/h1&gt; &lt;h2&gt;二级标签&lt;/h2&gt; &lt;h3&gt;三级标签&lt;/h3&gt; &lt;h4&gt;四级标签&lt;/h4&gt; &lt;h5&gt;五级标签&lt;/h5&gt; &lt;h6&gt;六级标签&lt;/h6&gt; &lt;!--段落标签--&gt; &lt;p&gt;跑得快跑得快&lt;/p&gt; &lt;p&gt;一只没有耳朵&lt;/p&gt; &lt;p&gt;一只没有尾巴&lt;/p&gt; &lt;p&gt;真奇怪真奇怪&lt;/p&gt; &lt;p&gt;两只老虎两只老虎&lt;/p&gt; &lt;!--水平标签--&gt; &lt;hr/&gt; &lt;!--换行标签--&gt; 跑得快跑得快&lt;br&gt; 一只没有耳朵&lt;br&gt; 一只没有尾巴&lt;br&gt; 真奇怪真奇怪&lt;br&gt; 两只老虎两只老虎&lt;br&gt; &lt;hr/&gt; &lt;!-- 粗体，斜体--&gt; 粗体：&lt;strong&gt;i love you&lt;/strong&gt; 斜体：&lt;em&gt;i love you&lt;/em&gt; &lt;br/&gt; &lt;!--特殊符号--&gt; 空格： 空&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;格 &lt;!--特殊符号--&gt; &lt;br/&gt; &amp;gt; &lt;br/&gt; &amp;lt; &lt;br/&gt; &amp;copy;版权所有 &lt;!-- 特殊符号记忆方式： &amp;开头 ;结尾 --&gt; &lt;/body&gt; &lt;/html&gt; 4.图像标签 图像标签 常见的图像格式 JPG GIF PNG BMP（位图） … &lt;img src=&quot;path&quot; alt=&quot;text&quot; title=&quot;text&quot; width=&quot;x&quot; height=&quot;y&quot; /&gt; src：图像地址 alt：图像的替代文字 title：鼠标悬停提示文字 width：图像宽度 height：图像高度 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图像标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--img学习 src：图片地址 相对地址(推荐使用)，绝对地址 --&gt; &lt;img src=&quot;../resources/img/1.jpg&quot; alt=&quot;狂神头像&quot; title=&quot;悬停文字&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5.超链接标签应用 链接标签 文本超链接 图像超链接 &lt;a href=&quot;链接路径&quot; target=&quot;目标窗口位置&quot;&gt;链接文本或图像&lt;/a&gt; 1 超链接 页面间链接：从一个页面跳转到另一个页面 锚链接 功能性链接 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;链接标签学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--使用name作为标记--&gt; &lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt; &lt;!--锚标签 1.需要一个锚标记 2.跳转到标记 --&gt; &lt;a href=&quot;#down&quot;&gt;回到底部&lt;/a&gt; &lt;!--a标签 href:必填，表示要跳转到那个页面 target:表示窗口再哪里打开 _blank:再新标签中打开 _self:在自己的网页中打开 --&gt; &lt;a href=&quot;1.我的第一个HTML.html&quot; target=&quot;_blank&quot;&gt;点击我跳转到页面&lt;/a&gt; &lt;a href=&quot;https://baidu.com&quot; target=&quot;_self&quot;&gt;点击我跳转到百度&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;1.我的第一个HTML.html&quot;&gt; &lt;img src=&quot;../resources/img/1.jpg&quot; alt=&quot;狂神头像&quot; title=&quot;悬停文字&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; &lt;/a&gt; &lt;!--锚标签 1.需要一个锚标记 2.跳转到标记 --&gt; &lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt; &lt;a name=&quot;down&quot;&gt;底部&lt;/a&gt; &lt;!--功能性链接 邮件链接：mailto； QQ链接： --&gt; &lt;a href=&quot;mailto:8629303@qq.com&quot;&gt;点击联系我&lt;/a&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::53&quot; alt=&quot;点击联系我&quot; title=&quot;点击联系我&quot;/&gt; &lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 6.行内元素和块元素 行内元素和块元素 块元素 无论内容多少，该元素独占一行 （p、h1-h6…） 行内元素 内容撑开宽度，左右都是行内元素的可以排在一行 （a、strong、em…） 7.列表标签 列表 什么是列表 列表就是信息资源的一种展示形式。它可以使信息结构化和条理化，并以列表的样式显示出来，以便浏览者能更快捷的获得相应信息 列表的分类 无序列表 有序列表 自定义列表 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;列表学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--有序列表--&gt; &lt;ol&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt; &lt;li&gt;C/C++&lt;/li&gt; &lt;/ol&gt; &lt;hr&gt; &lt;!--无序列表--&gt; &lt;ul&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt; &lt;li&gt;C/C++&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;!--自定义列表 dl：标签 dt：列表名称 dd：列表内容 应用范围：公司网站底部 --&gt; &lt;dl&gt; &lt;dt&gt;学科&lt;/dt&gt; &lt;dd&gt;Java&lt;/dd&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dd&gt;Linux&lt;/dd&gt; &lt;dd&gt;C&lt;/dd&gt; &lt;dt&gt;位置&lt;/dt&gt; &lt;dd&gt;湖南&lt;/dd&gt; &lt;dd&gt;广东&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; &lt;/html&gt; 8.表格标签 表格 为什么使用表格 简单通用 结构稳定 基本结构 单元格 行 列 跨行 跨列 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--表格table 行：tr 列：td --&gt; &lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;!--colspan 跨列--&gt; &lt;td colspan=&quot;4&quot;&gt;1-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--rowspan 跨行--&gt; &lt;td rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;td&gt;2-3&lt;/td&gt; &lt;td&gt;2-4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3-2&lt;/td&gt; &lt;td&gt;3-3&lt;/td&gt; &lt;td&gt;3-4&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 9.媒体元素 视频和音频 视频元素：video 音频元素：audio &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;媒体元素学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--音频和视频 src：资源路径 controls：控制条 autoplay ：自动播放 --&gt; &lt;video src=&quot;../resources/video/xxx.mp4&quot; controls autoplay&gt;&lt;/video&gt; &lt;audio src=&quot;../resources/audio/xxx.mp3&quot; controls autoplay&gt;&lt;/audio&gt; &lt;/body&gt; &lt;/html&gt; 10.页面结构分析 页面结构分析 元素名 描述 header 标题头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或页面的一块区域） section Web网页中的一块独立区域 article 独立的文章内容 aside 相关内容或应用 nav 导航类辅助内容 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面结构分析&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h2&gt;页面头部&lt;/h2&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;页面主体&lt;/h2&gt; &lt;/section&gt; &lt;footer&gt; &lt;h2&gt;页面底部&lt;/h2&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 11.iframe内联框架 iframe内联框架 &lt;iframe src=&quot;path&quot; name=&quot;mainFrame&quot;&gt;&lt;/iframe&gt; path:引用网页地址 mainFrame:框架标识名 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;内联框架&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--iframe内联框架 src：地址 w-h：宽度高度 --&gt; &lt;iframe src=&quot;http://baidu.com&quot; frameborder=&quot;0&quot; width=&quot;300px&quot; height=&quot;300px&quot;&gt; &lt;/iframe&gt; &lt;iframe src=&quot;&quot; name=&quot;hello&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;a href=&quot;1.我的第一个HTML.html&quot; target=&quot;hello&quot;&gt;点击跳转&lt;/a&gt; &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=55631961&amp;bvid=BV1x4411V75C&amp;cid=97257627&amp;page=10&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 12.初始表单post和get提交 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;!--表单form action：表单提交的位置，可以是网站，也可以是一个请求处理地址 method：post，get 提交方式 get方式提交：外面可以在url中看到外面提交的信息，不安全，高效 post方式提交，比较安全，可以传输大文件 --&gt; &lt;form action=&quot;1.我的第一个HTML.html&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框--&gt; &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;!--密码框--&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 13.文本框和单选框 表单元素格式 属性 说明 type 指定元素的类型。text、password、checkbox、radio、submit、reset、file、hidden、image、button，默认text name 指定表单元素的名称 value 元素的初始值。type为radio时必须指定一个值 size 指定表单元素的初始宽度。但type为text或password时，表单元素的大小以字符为单位。对于其他类型，宽度以像素为单位。 maxlength type为text或password时，输入的最大字符数 checked type为radio或checkbox时，指定按钮是否被选中 14.按钮和多选框 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;!--表单form action：表单提交的位置，可以是网站，也可以是一个请求处理地址 method：post，get 提交方式 get方式提交：外面可以在url中看到外面提交的信息，不安全，高效 post方式提交，比较安全，可以传输大文件 --&gt; &lt;form action=&quot;1.我的第一个HTML.html&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框 value=&quot;好帅&quot; 默认初始值 maxlength=&quot;8&quot; 最长能写几个字符 size=&quot;30&quot; 文本框的长度 --&gt; &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;/p&gt; &lt;!--密码框--&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;!--单选框标签 type=&quot;radio&quot;：单选框的值 value：单选框的值 name：表示组 --&gt; &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot; checked/&gt;女 &lt;!--多选框 type=&quot;checkbox&quot; --&gt; &lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot; checked&gt;敲代码 &lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; name=&quot;hobby&quot;&gt;游戏 &lt;/p&gt; &lt;!--按钮 input type=&quot;button&quot; 普通按钮 input type=&quot;image&quot; 图片按钮 input type=&quot;submit&quot; 提交按钮 input type=&quot;reset&quot; 重置按钮 --&gt; &lt;p&gt; &lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;../resources/img/1.jpg&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 15.列表框文本域和文件域 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;!--表单form action：表单提交的位置，可以是网站，也可以是一个请求处理地址 method：post，get 提交方式 get方式提交：外面可以在url中看到外面提交的信息，不安全，高效 post方式提交，比较安全，可以传输大文件 --&gt; &lt;form action=&quot;1.我的第一个HTML.html&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框 value=&quot;好帅&quot; 默认初始值 maxlength=&quot;8&quot; 最长能写几个字符 size=&quot;30&quot; 文本框的长度 --&gt; &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;/p&gt; &lt;!--密码框--&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;!--单选框标签 type=&quot;radio&quot;：单选框的值 value：单选框的值 name：表示组 --&gt; &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot; checked/&gt;女 &lt;!--多选框 type=&quot;checkbox&quot; --&gt; &lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot; checked&gt;敲代码 &lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; name=&quot;hobby&quot;&gt;游戏 &lt;/p&gt; &lt;!--按钮 input type=&quot;button&quot; 普通按钮 input type=&quot;image&quot; 图片按钮 input type=&quot;submit&quot; 提交按钮 input type=&quot;reset&quot; 重置按钮 --&gt; &lt;p&gt; &lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;../resources/img/1.jpg&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt; &lt;/p&gt; &lt;!--下拉框，列表框 --&gt; &lt;p&gt;国家： &lt;select name=&quot;列表名称&quot;&gt; &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;us&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;eth&quot; selected&gt;瑞士&lt;/option&gt; &lt;option value=&quot;yd&quot;&gt;印度&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;!--文本域--&gt; &lt;p&gt;反馈： &lt;textarea name=&quot;textarea&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;!--文件域 --&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;上传&quot; name=&quot;upload&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 16.搜索框滑块和简单验证 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;!--表单form action：表单提交的位置，可以是网站，也可以是一个请求处理地址 method：post，get 提交方式 get方式提交：外面可以在url中看到外面提交的信息，不安全，高效 post方式提交，比较安全，可以传输大文件 --&gt; &lt;form action=&quot;1.我的第一个HTML.html&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框 value=&quot;好帅&quot; 默认初始值 maxlength=&quot;8&quot; 最长能写几个字符 size=&quot;30&quot; 文本框的长度 --&gt; &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;/p&gt; &lt;!--密码框--&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;!--单选框标签 type=&quot;radio&quot;：单选框的值 value：单选框的值 name：表示组 --&gt; &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot; checked/&gt;女 &lt;!--多选框 type=&quot;checkbox&quot; --&gt; &lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot; checked&gt;敲代码 &lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; name=&quot;hobby&quot;&gt;游戏 &lt;/p&gt; &lt;!--按钮 input type=&quot;button&quot; 普通按钮 input type=&quot;image&quot; 图片按钮 input type=&quot;submit&quot; 提交按钮 input type=&quot;reset&quot; 重置按钮 --&gt; &lt;p&gt; &lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;../resources/img/1.jpg&quot;&gt; &lt;/p&gt; &lt;!--下拉框，列表框 --&gt; &lt;p&gt;国家： &lt;select name=&quot;列表名称&quot;&gt; &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;us&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;eth&quot; selected&gt;瑞士&lt;/option&gt; &lt;option value=&quot;yd&quot;&gt;印度&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;!--文本域--&gt; &lt;p&gt;反馈： &lt;textarea name=&quot;textarea&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;!--文件域 --&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;上传&quot; name=&quot;upload&quot;&gt; &lt;/p&gt; &lt;!--邮件验证--&gt; &lt;p&gt;邮件： &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt; &lt;/p&gt; &lt;!--URL--&gt; &lt;p&gt;URL： &lt;input type=&quot;url&quot; name=&quot;url&quot;&gt; &lt;/p&gt; &lt;!--数字--&gt; &lt;p&gt;数字： &lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;0&quot; size=&quot;10&quot;&gt; &lt;/p&gt; &lt;!--滑块--&gt; &lt;p&gt;音量： &lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;2&quot;&gt; &lt;/p&gt; &lt;!--搜索框--&gt; &lt;p&gt;搜索： &lt;input type=&quot;search&quot; name=&quot;search&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 17.表单的应用 表单的应用 隐藏域：hidden 只读：readonly 禁用：disabled &lt;!--增强鼠标可用性，点击label，光标自动到text上--&gt; &lt;p&gt; &lt;label for=&quot;mark&quot;&gt;你点我试试&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mark&quot;&gt; &lt;/p&gt; 18.表单初级验证 表单初级验证 常用方式 placeholder：提示信息 required：非空判断 pattern：正则表达式 &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/p&gt; &lt;p&gt;名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt;&lt;/p&gt; &lt;!--常用的正则：https://www.jb51.net/tools/regexsc.htm--&gt; &lt;p&gt;自定义邮箱： &lt;input type=&quot;text&quot; name=&quot;diy&quot; pattern=&quot;/^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/&quot;&gt; &lt;/p&gt; ","link":"https://ganhan999.github.io/post/Java HTML/"},{"title":"中等6. Z字形变换","content":"题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 输出: &quot;LDREOEIIECIHNTSG&quot; 解释: L D R E O E I I E C I H N T S G &quot;&quot;&quot; 先创建一个二维数组，然后遍历字符串，然后对应的一个个加入数组中，这里的flag是用来改变下标变化趋势的。 &quot;&quot;&quot; #我的做法： class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows &lt; 2: return s res = [&quot;&quot; for _ in range(numRows)] i, flag = 0, -1 for c in s: res[i] += c if i == 0 or i == numRows - 1: flag = -flag i += flag return &quot;&quot;.join(res) &quot;&quot;&quot; #大神做法1 这道题只是需要相应的字符串，不要求输出，明显难度降低了， 因为这个图像是有规律的，发现每一满列对于行元素到下一满列对应行的元素距离是固定的， 为k= (numRows-1)*2，我们便可以以此为基础进行定位，逐行添加字符拼接成字符串。 时间复杂度实际是遍历一趟字符串s为O（n），空间复杂度O（n） class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows==1: return s ans=&quot;&quot; n=len(s) for i in range(numRows): k=i while k&lt;n: ans+=s[k] k+=2*(numRows-1) if i!=0 and i!=numRows-1 and k-2*i &lt;n: ans+=s[k-2*i] return ans ","link":"https://ganhan999.github.io/post/6、Z 字形变换/"},{"title":"Java JVM","content":"jvm虚拟机狂神说 JVM探究 请你谈谈对JVM的理解? java8虚拟机和之前的变化更新 什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析? JVM常用的调优参数有哪些? 内存快照如何抓取? 怎么分析Domp文件 ? 知道吗? 谈谈JVM中,类加载器你的认识? 1.jvm的位置 2.jvm的体系结构 3.类加载器 4.双亲委派机制 虚拟机自带的加载器 启动类 (根) 加载器 扩展类加载器 应用程序加载器 app—&gt;扩展类(ext) ----&gt; (启动类)根加载器(rt) —&gt; 1.类加载器收到类加载的请求 2.将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器(根加载器rt) 3.启动类加载器检查是否能够加载当前这个类, 能够加载就结束了, 使用当前加载器,否则抛出异常,通知子类加载器进行加载. 4.重复步骤3. 5.沙箱安全机制 Java安全模型的核心就是Java沙箱(sandbox) , 什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。 沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。 在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱Sandbox)机制。如下图所示JDK1.0安全模型 图 JDK1.0安全模型 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型 图 JDK1.1安全模型 在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 图 JDK1.2安全模型 当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6) 图 JDK1.6安全模型 组成沙箱的基本组件 ●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 ●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用  它防止恶意代码去干涉善意的代码;  它守护了被信任的类库边界;  它将代码归入保护域,确定了代码可以进行哪些操作。 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用; 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 ●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。 ●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 ●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:  安全提供者  消息摘要  数字签名  加密  鉴别 6.Native*  native :凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层c语言的库!  会进入本地方法栈  调用本地方法本地接口 JNI (Java Native Interface)  JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: C、C++  Java诞生的时候C、C++横行，想要立足，必须要有调用C、C++的程序  它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法  在最终执行的时候，加载本地方法库中的方法通过JNI  例如：Java程序驱动打印机，管理系统，掌握即可，在企业级应用比较少  private native void start0();  //调用其他接口:Socket. . WebService~. .http~ Native Method Stack 它的具体做法是Native Method Stack中登记native方法，在( Execution Engine )执行引擎执行的时候加载Native Libraies。[本地库] Native Interface本地接口 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序, Java在诞生的时候是C/C++横行的时候，想要立足，必须有调用C、C++的程序，于是就在内存中专门开辟了块区域处理标记为native的代码，它的具体做法是在Native Method Stack 中登记native方法,在( Execution Engine )执行引擎执行的时候加载Native Libraies。 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用Socket通信,也可以使用Web Service等等，不多做介绍! 7.pc寄存器 8.方法区 Method Area 方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间; 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关 图 类实例化后 9.栈 图 为什么main()先执行，最后结束~ 栈:先进后出 桶:后进先出 队列:先进先出( FIFO : First Input First Output ) 栈:栈内存,主管程序的运行,生命周期和线程同步; 线程结束，栈内存也就是释放,对于栈来说,不存在垃圾回收问题 一旦线程结束，栈就Over! 栈内存中: 8大基本类型+对象引用+实例的方法 栈运行原理:栈帧 栈满了: StackOverflowError 图 栈的位置示意图 图 栈帧图解 栈底部子帧指向上一个栈的方法 上一个栈的父帧指向栈底部方法 10.三种JVM ●Sun公司HotSpot Java Hotspot™ 64-Bit Server VM (build 25.181-b13,mixed mode) ●BEA JRockit ●IBM J9VM 我们学习都是: Hotspot 11.堆 Heap, 一个JVM只有一个堆内存，堆内存的大小是可以调节的。 类加载器读取了类文件后，一般会把什么东西放到堆中? 类, 方法，常量,变量~，保存我们所有引用类型的真实对象; 堆内存中还要细分为三个区域: ●新生区(伊甸园区) Young/New ●养老区old ●永久区Perm 图 堆内存详细划分 GC垃圾回收,主要是在伊甸园区和养老区~ 假设内存满了,OOM,堆内存不够! java.lang.OutOfMemoryError:Java heap space 永久存储区里存放的都是Java自带的 例如lang包中的类 如果不存在这些，Java就跑不起来了 在JDK8以后，永久存储区改了个名字(元空间) 图 堆内存溢出 12.新生区、老年区 新生区 ●类:诞生和成长的地方，甚至死亡; ●伊甸园，所有的对象都是在伊甸园区new出来的! ●幸存者区(0,1) 图 重GC和轻GC 伊甸园满了就触发轻GC，经过轻GC存活下来的就到了幸存者区，幸存者区满之后意味着新生区也满了，则触发重GC，经过重GC之后存活下来的就到了养老区。 真理:经过研究，99%的对象都是临时对象!| 13.永久区 这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境~ 这个区域不存在垃圾回收，关闭虚拟机就会释放内存 ●jdk1.6之前:永久代,常量池是在方法区; ●jdk1.7:永久代,但是慢慢的退化了，去永久代，常量池在堆中 ●jdk1.8之后:无永久代,常量池在元空间 图 JVM探究 元空间：逻辑上存在，物理上不存在 (因为存储在本地磁盘内) 所以最后并不算在JVM虚拟机内存中 14.堆内存调优 测试代码 public static void main(String[] args) { String s = &quot;&quot;; while (true) { s += &quot;11111111111111111111111111111111111111111111111111111&quot;; } } 图 虚拟机放入参数 图 控制台报错 到最后会报OOM（OutOfMemory）堆内存溢出报错 在一个项目中，突然出现了OOM故障,那么该如何排除 研究为什么出错~ ●能够看到代码第几行出错:内存快照分析工具，MAT, Jprofiler ●Dubug, 一行行分析代码! MAT, Jprofiler作用 ●分析Dump内存文件,快速定位内存泄露; ●获得堆中的数据 ●获得大的对象~ MAT是eclipse集成使用 在这里不学 Jprofile使用 1.在idea中下载jprofile插件 2.联网下载jprofile客户端 3.在idea中VM参数中写参数 -Xms1m -Xmx8m -XX: +HeapDumpOnOutOfMemoryError 4.运行程序后在jprofile客户端中打开找到错误 告诉哪个位置报错 命令参数详解 // -Xms设置初始化内存分配大小/164 // -Xmx设置最大分配内存，默以1/4 // -XX: +PrintGCDetails // 打印GC垃圾回收信息 // -XX: +HeapDumpOnOutOfMemoryError //oom DUMP 15. GC 图 GC的作用区 JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~ ●新生代 ●幸存区(form，to) ●老年区 GC两种类:轻GC (普通的GC)， 重GC (全局GC) GC常见面试题目: ●JVM的内存模型和分区~详细到每个区放什么? 图 JVM内存模型和分区 ●堆里面的分区有哪些? Eden, form, to, 老年区,说说他们的特点! ●GC的算法有哪些? 标记清除法，标记整理,复制算法，引用计数器 ●轻GC和重GC分别在什么时候发生? 16.常用算法 引用计数法 复制算法 好处:没有内存的碎片 坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况) 复制算法最佳使用场景:对象存活度较低的时候:新生区; 标记清除算法 优点:不需要额外的空间 缺点:两次扫描,严重浪费时间,会产生内存碎片 标记压缩(优化标记清除) 三部曲:标记,清除.压缩 17、如何选择四种算法: 内存效率:复制算法&gt;标记清除算法&gt;标记压缩算法(时间复杂度) 内存整齐度:复制算法=标记压缩算法&gt;标记清除算法 内存利用率:标记压缩算法=标记清除算法&gt;复制算法 难道没有一个最优的算法吗? 答案:没有,没有最好的算法,只有最合适的算法----&gt;GC:分带收集算法 年轻代: 存活率低 复制算法 老年代： 区域大：存活率 标记清除（内存碎片不是太多）+标记压缩混合实现 18、JMM 1.什么是JMM？ JMM ：（java Memory Model 缩写）java内存模型 2.他是干什么的？ 解决共享对象可见性的问题：volilate 3.他该如何学习 JMM ：抽象的概念，理论 ","link":"https://ganhan999.github.io/post/Java JVM/"},{"title":"Java JUC并发编程","content":"1. 什么是JUC JUC就是java.util.concurrent下面的类包，专门用于多线程的开发。 2. 线程和进程 进程是操作系统中的应用程序、是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位 一个进程往往可以包含多个线程，至少包含一个 1）进程 一个程序，QQ.EXE Music.EXE；数据+代码+pcb 一个进程可以包含多个线程，至少包含一个线程！ Java默认有几个线程？2个线程！ main线程、GC线程 2）线程 开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的) 对于Java而言：Thread、Runable、Callable进行开启线程的。 提问？JAVA真的可以开启线程吗？ 开不了的！ Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。 public synchronized void start() { /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } //这是一个C++底层，Java是没有权限操作底层硬件的 private native void start0(); 3）并发 多线程操作同一个资源。 CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。 并发编程的本质：充分利用CPU的资源！ 4）并行 并行： 多个人一起行走 CPU多核，多个线程可以同时执行。 我们可以使用线程池！ 获取cpu的核数 public class Test1 { public static void main(String[] args) { //获取cpu的核数 System.out.println(Runtime.getRuntime().availableProcessors()); } } 5）线程的状态 public enum State { //运行 NEW, //运行 RUNNABLE, //阻塞 BLOCKED, //等待 WAITING, //超时等待 TIMED_WAITING, //终止 TERMINATED; } 6）wait/sleep 1、来自不同的类 wait =&gt; Object sleep =&gt; Thread 一般情况企业中使用休眠是： TimeUnit.DAYS.sleep(1); //休眠1天 TimeUnit.SECONDS.sleep(1); //休眠1s 2、关于锁的释放 wait 会释放锁； sleep睡觉了，不会释放锁； 3、使用的范围是不同的 wait 必须在同步代码块中； sleep 可以在任何地方睡； 4、是否需要捕获异常 wait是不需要捕获异常； sleep必须要捕获异常； 3.Lock 1）传统的 synchronized package com.marchsoft.juctest; import lombok.Synchronized; /** * Description：synchronized * * @author jiaoqianjin * Date: 2020/8/10 21:36 **/ public class Demo01 { public static void main(String[] args) { final Ticket ticket = new Ticket(); new Thread(()-&gt;{ for (int i = 0; i &lt; 40; i++) { ticket.sale(); } },&quot;A&quot;).start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 40; i++) { ticket.sale(); } },&quot;B&quot;).start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 40; i++) { ticket.sale(); } },&quot;C&quot;).start(); } } // 资源类 OOP 属性、方法 class Ticket { private int number = 30; //卖票的方式 public synchronized void sale() { if (number &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张票剩余&quot; + number + &quot;张票&quot;); } } } 2）Lock 公平锁： 十分公平，必须先来后到~； 非公平锁： 十分不公平，可以插队；(默认为非公平锁) package com.marchsoft.juctest; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Description： * * @author jiaoqianjin * Date: 2020/8/10 22:05 **/ public class LockDemo { public static void main(String[] args) { final Ticket2 ticket = new Ticket2(); new Thread(() -&gt; { for (int i = 0; i &lt; 40; i++) { ticket.sale(); } }, &quot;A&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 40; i++) { ticket.sale(); } }, &quot;B&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 40; i++) { ticket.sale(); } }, &quot;C&quot;).start(); } } //lock三部曲 //1、 Lock lock=new ReentrantLock(); //2、 lock.lock() 加锁 //3、 finally=&gt; 解锁：lock.unlock(); class Ticket2 { private int number = 30; // 创建锁 Lock lock = new ReentrantLock(); //卖票的方式 public synchronized void sale() { lock.lock(); // 开启锁 try { if (number &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张票剩余&quot; + number + &quot;张票&quot;); } }finally { lock.unlock(); // 关闭锁 } } } 3. Synchronized 与Lock 的区别 1、Synchronized 内置的Java关键字，Lock是一个Java类 2、Synchronized 无法判断获取锁的状态，Lock可以判断 3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！可能会遇到死锁 4、Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个trylock去尝试获取锁，不会造成长久的等待。 5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁； 6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码； 4. 生产者和消费者的关系 1）Synchronzied 版本 package com.marchsoft.juctest; /** * Description： * * @author jiaoqianjin * Date: 2020/8/10 22:33 **/ public class ConsumeAndProduct { public static void main(String[] args) { Data data = new Data(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;A&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;B&quot;).start(); } } class Data { private int num = 0; // +1 public synchronized void increment() throws InterruptedException { // 判断等待 if (num != 0) { this.wait(); } num++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 this.notifyAll(); } // -1 public synchronized void decrement() throws InterruptedException { // 判断等待 if (num == 0) { this.wait(); } num--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 -1 执行完毕 this.notifyAll(); } } 2）存在问题（虚假唤醒） 问题，如果有四个线程，会出现虚假唤醒 解决方式 ，if 改为while即可，防止虚假唤醒 结论：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。 这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后 package com.marchsoft.juctest; /** * Description： * * @author jiaoqianjin * Date: 2020/8/10 22:33 **/ public class ConsumeAndProduct { public static void main(String[] args) { Data data = new Data(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;A&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;B&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;C&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;D&quot;).start(); } } class Data { private int num = 0; // +1 public synchronized void increment() throws InterruptedException { // 判断等待 while (num != 0) { this.wait(); } num++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 this.notifyAll(); } // -1 public synchronized void decrement() throws InterruptedException { // 判断等待 while (num == 0) { this.wait(); } num--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 -1 执行完毕 this.notifyAll(); } } 3）Lock版 package com.marchsoft.juctest; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Description： * * @author jiaoqianjin * Date: 2020/8/11 9:48 **/ public class LockCAP { public static void main(String[] args) { Data2 data = new Data2(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;A&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;B&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;C&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, &quot;D&quot;).start(); } } class Data2 { private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); // +1 public void increment() throws InterruptedException { lock.lock(); try { // 判断等待 while (num != 0) { condition.await(); } num++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 condition.signalAll(); }finally { lock.unlock(); } } // -1 public void decrement() throws InterruptedException { lock.lock(); try { // 判断等待 while (num == 0) { condition.await(); } num--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num); // 通知其他线程 +1 执行完毕 condition.signalAll(); }finally { lock.unlock(); } } } 4）Condition的优势 精准的通知和唤醒的线程！ 如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~ package com.marchsoft.juctest; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Description： * A 执行完 调用B * B 执行完 调用C * C 执行完 调用A * * @author jiaoqianjin * Date: 2020/8/11 9:58 **/ public class ConditionDemo { public static void main(String[] args) { Data3 data3 = new Data3(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { data3.printA(); } },&quot;A&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { data3.printB(); } },&quot;B&quot;).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { data3.printC(); } },&quot;C&quot;).start(); } } class Data3 { private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int num = 1; // 1A 2B 3C public void printA() { lock.lock(); try { // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 1) { condition1.await(); } System.out.println(Thread.currentThread().getName() + &quot;==&gt; AAAA&quot; ); num = 2; condition2.signal(); }catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } } public void printB() { lock.lock(); try { // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 2) { condition2.await(); } System.out.println(Thread.currentThread().getName() + &quot;==&gt; BBBB&quot; ); num = 3; condition3.signal(); }catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } } public void printC() { lock.lock(); try { // 业务代码 判断 -&gt; 执行 -&gt; 通知 while (num != 3) { condition3.await(); } System.out.println(Thread.currentThread().getName() + &quot;==&gt; CCCC&quot; ); num = 1; condition1.signal(); }catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } } } /* A==&gt; AAAA B==&gt; BBBB C==&gt; CCCC A==&gt; AAAA B==&gt; BBBB C==&gt; CCCC ... */ 5. 8锁现象 如何判断锁的是谁！锁到底锁的是谁？ 锁会锁住：对象、Class 深刻理解我们的锁 问题1 两个同步方法，先执行发短信还是打电话 public class dome01 { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -&gt; { phone.sendMs(); }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone.call(); }).start(); } } class Phone { public synchronized void sendMs() { System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } } 输出结果为 发短信 打电话 为什么？ 如果你认为是顺序在前？ 这个答案是错误的！ 问题2： 我们再来看：我们让发短信 延迟4s public class dome01 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -&gt; { try { phone.sendMs(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone.call(); }).start(); } } class Phone { public synchronized void sendMs() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } } 现在结果是什么呢？ 结果：还是先发短信，然后再打电话！ why？ 原因：并不是顺序执行，而是synchronized 锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待 问题三 加一个普通方法 public class dome01 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -&gt; { try { phone.sendMs(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone.hello(); }).start(); } } class Phone { public synchronized void sendMs() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } public void hello() { System.out.println(&quot;hello&quot;); } } 输出结果为 hello 发短信 原因：hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放 问题四 如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？ public class dome01 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -&gt; { try { phone1.sendMs(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone2.call(); }).start(); } } class Phone { public synchronized void sendMs() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } public void hello() { System.out.println(&quot;hello&quot;); } } 输出结果 打电话 发短信 原因：两个对象两把锁，不会出现等待的情况，发短信睡了4s,所以先执行打电话 问题五、六 如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？ （1）我们先来使用一个对象调用两个方法！ 答案是：先发短信,后打电话 （2）如果我们使用两个对象调用两个方法！ 答案是：还是先发短信，后打电话 原因是什么呢？ 为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？ 原因是：对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！ 问题七 如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？ public class dome01 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); // Phone phone2 = new Phone(); new Thread(() -&gt; { try { phone1.sendMs(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone1.call(); }).start(); } } class Phone { public static synchronized void sendMs() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } public void hello() { System.out.println(&quot;hello&quot;); } } 输出结果 打电话 发短信 原因：因为一个锁的是Class类的模板，一个锁的是对象的调用者。所以不存在等待，直接运行。 问题八 如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么？ public class dome01 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -&gt; { try { phone1.sendMs(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { phone2.call(); }).start(); } } class Phone { public static synchronized void sendMs() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(&quot;发短信&quot;); } public synchronized void call() { System.out.println(&quot;打电话&quot;); } public void hello() { System.out.println(&quot;hello&quot;); } } 输出结果 打电话 发短信 原因：两把锁锁的不是同一个东西 小解 new 出来的 this 是具体的一个对象 static Class 是唯一的一个模板 6. 集合不安全 1）List 不安全 //java.util.ConcurrentModificationException 并发修改异常！ public class ListTest { public static void main(String[] args) { List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=10;i++){ new Thread(()-&gt;{ arrayList.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(arrayList); },String.valueOf(i)).start(); } } } 会导致 java.util.ConcurrentModificationException 并发修改异常！ ArrayList 在并发情况下是不安全的 解决方案： public class ListTest { public static void main(String[] args) { /** * 解决方案 * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;=10; i++) { new Thread(() -&gt; { list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); },String.valueOf(i)).start(); } } } CopyOnWriteArrayList：写入时复制！ COW 计算机程序设计领域的一种优化策略 核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。 读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。 多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题； CopyOnWriteArrayList比Vector厉害在哪里？ Vector底层是使用synchronized关键字来实现的：效率特别低下。 CopyOnWriteArrayList使用的是Lock锁，效率会更加高效！ 2）set 不安全 Set和List同理可得: 多线程情况下，普通的Set集合是线程不安全的； 解决方案还是两种： 使用Collections工具类的synchronized包装的Set类 使用CopyOnWriteArraySet 写入复制的JUC解决方案 public class SetTest { public static void main(String[] args) { /** * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); */ // Set&lt;String&gt; set = new HashSet&lt;&gt;(); Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 1; i &lt;= 30; i++) { new Thread(() -&gt; { set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); },String.valueOf(i)).start(); } } } HashSet底层是什么？ hashSet底层就是一个HashMap； 3）Map不安全 默认加载因子是0.75,默认的初始容量是16 同样的HashMap基础类也存在并发修改异常！ public class MapTest { public static void main(String[] args) { //map 是这样用的吗？ 不是，工作中不使用这个 //默认等价什么？ new HashMap&lt;&gt;(16,0.75); /** * 解决方案 * 1. Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); * Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); */ Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); //加载因子、初始化容量 for (int i = 1; i &lt; 100; i++) { new Thread(()-&gt;{ map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5)); System.out.println(map); },String.valueOf(i)).start(); } } } TODO:研究ConcurrentHashMap底层原理： 7. Callable 1、可以有返回值； 2、可以抛出异常； 3、方法不同，run()/call() public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { for (int i = 1; i &lt; 10; i++) { MyThread1 myThread1 = new MyThread1(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread1); // 放入Thread中使用，结果会被缓存 new Thread(futureTask,String.valueOf(i)).start(); // 这个get方法可能会被阻塞，如果在call方法中是一个耗时的方法，所以一般情况我们会把这个放在最后，或者使用异步通信 int a = futureTask.get(); System.out.println(&quot;返回值:&quot; + s); } } } class MyThread1 implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { System.out.println(&quot;call()&quot;); return 1024; } } 8. 常用的辅助类 1）CountDownLatch public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { // 总数是6 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + &quot;==&gt; Go Out&quot;); countDownLatch.countDown(); // 每个线程都数量 -1 },String.valueOf(i)).start(); } countDownLatch.await(); // 等待计数器归零 然后向下执行 System.out.println(&quot;close door&quot;); } } 主要方法： countDown 减一操作； await 等待计数器归零 await 等待计数器归零，就唤醒，再继续向下运行 2）CyclickBarrier 其实 public class CyclicBarrierDemo { public static void main(String[] args) { // 主线程 CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -&gt; { System.out.println(&quot;召唤神龙&quot;); }); for (int i = 1; i &lt;= 7; i++) { // 子线程 int finalI = i; new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + &quot;收集了第&quot; + finalI + &quot;颗龙珠&quot;); try { cyclicBarrier.await(); // 加法计数 等待 } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } 3）Semaphore public class SemaphoreDemo { public static void main(String[] args) { // 线程数量，停车位，限流 Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt;= 6; i++) { new Thread(() -&gt; { // acquire() 得到 try { semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); }catch (Exception e) { e.printStackTrace(); }finally { semaphore.release(); // release() 释放 } }).start(); } } } Thread-1抢到车位 Thread-0抢到车位 Thread-2抢到车位 Thread-0离开车位 Thread-2离开车位 Thread-1离开车位 Thread-5抢到车位 Thread-3抢到车位 Thread-4抢到车位 Thread-5离开车位 Thread-3离开车位 Thread-6抢到车位 Thread-4离开车位 Thread-6离开车位 Process finished with exit code 0 原理： semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！ semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！ 作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！ 9. 读写锁 public class ReadWriteLockDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); int num = 6; for (int i = 1; i &lt;= num; i++) { int finalI = i; new Thread(() -&gt; { myCache.write(String.valueOf(finalI), String.valueOf(finalI)); },String.valueOf(i)).start(); } for (int i = 1; i &lt;= num; i++) { int finalI = i; new Thread(() -&gt; { myCache.read(String.valueOf(finalI)); },String.valueOf(i)).start(); } } } /** * 方法未加锁，导致写的时候被插队 */ class MyCache { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); public void write(String key, String value) { System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;); map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;); } public void read(String key) { System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;线程写读取ok&quot;); } } 2线程开始写入 2线程写入ok 3线程开始写入 3线程写入ok 1线程开始写入 # 插入了其他线程的写入，导致数据不一致 4线程开始写入 4线程写入ok 1线程写入ok 6线程开始写入 6线程写入ok 5线程开始写入 5线程写入ok 1线程开始读取 1线程写读取ok 2线程开始读取 2线程写读取ok 3线程开始读取 3线程写读取ok 4线程开始读取 4线程写读取ok 5线程开始读取 6线程开始读取 6线程写读取ok 5线程写读取ok Process finished with exit code 0 所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。 我们也可以采用synchronized这种重量锁和轻量锁 lock去保证数据的可靠。 但是这次我们采用更细粒度的锁：ReadWriteLock 读写锁来保证 public class ReadWriteLockDemo { public static void main(String[] args) { MyCache2 myCache = new MyCache2(); int num = 6; for (int i = 1; i &lt;= num; i++) { int finalI = i; new Thread(() -&gt; { myCache.write(String.valueOf(finalI), String.valueOf(finalI)); },String.valueOf(i)).start(); } for (int i = 1; i &lt;= num; i++) { int finalI = i; new Thread(() -&gt; { myCache.read(String.valueOf(finalI)); },String.valueOf(i)).start(); } } } class MyCache2 { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public void write(String key, String value) { lock.writeLock().lock(); // 写锁 try { System.out.println(Thread.currentThread().getName() + &quot;线程开始写入&quot;); map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;线程写入ok&quot;); }finally { lock.writeLock().unlock(); // 释放写锁 } } public void read(String key) { lock.readLock().lock(); // 读锁 try { System.out.println(Thread.currentThread().getName() + &quot;线程开始读取&quot;); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;线程写读取ok&quot;); }finally { lock.readLock().unlock(); // 释放读锁 } } } 1线程开始写入 1线程写入ok 6线程开始写入 6线程写入ok 3线程开始写入 3线程写入ok 2线程开始写入 2线程写入ok 5线程开始写入 5线程写入ok 4线程开始写入 4线程写入ok 1线程开始读取 5线程开始读取 2线程开始读取 1线程写读取ok 3线程开始读取 2线程写读取ok 6线程开始读取 6线程写读取ok 5线程写读取ok 4线程开始读取 4线程写读取ok 3线程写读取ok Process finished with exit code 0 10. 阻塞队列 1）BlockQueue 是Collection的一个子类 什么情况下我们会使用阻塞队列 多线程并发处理、线程池 BlockingQueue 有四组api 方式 抛出异常 不会抛出异常，有返回值 阻塞，等待 超时等待 添加 add offer put offer(timenum.timeUnit) 移出 remove poll take poll(timenum,timeUnit) 判断队首元素 element peek - - /** * 抛出异常 */ public static void test1(){ //需要初始化队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.add(&quot;a&quot;)); System.out.println(blockingQueue.add(&quot;b&quot;)); System.out.println(blockingQueue.add(&quot;c&quot;)); //抛出异常：java.lang.IllegalStateException: Queue full // System.out.println(blockingQueue.add(&quot;d&quot;)); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //如果多移除一个 //这也会造成 java.util.NoSuchElementException 抛出异常 System.out.println(blockingQueue.remove()); } ======================================================================================= /** * 不抛出异常，有返回值 */ public static void test2(){ ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;)); //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常 System.out.println(blockingQueue.offer(&quot;d&quot;)); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); //弹出 如果没有元素 只会返回null 不会抛出异常 System.out.println(blockingQueue.poll()); } ======================================================================================= /** * 等待 一直阻塞 */ public static void test3() throws InterruptedException { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); //一直阻塞 不会返回 blockingQueue.put(&quot;a&quot;); blockingQueue.put(&quot;b&quot;); blockingQueue.put(&quot;c&quot;); //如果队列已经满了， 再进去一个元素 这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止 // blockingQueue.put(&quot;d&quot;); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //如果我们再来一个 这种情况也会等待，程序会一直运行 阻塞 System.out.println(blockingQueue.take()); } ======================================================================================= /** * 等待 超时阻塞 * 这种情况也会等待队列有位置 或者有产品 但是会超时结束 */ public static void test4() throws InterruptedException { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); blockingQueue.offer(&quot;a&quot;); blockingQueue.offer(&quot;b&quot;); blockingQueue.offer(&quot;c&quot;); System.out.println(&quot;开始等待&quot;); blockingQueue.offer(&quot;d&quot;,2, TimeUnit.SECONDS); //超时时间2s 等待如果超过2s就结束等待 System.out.println(&quot;结束等待&quot;); System.out.println(&quot;===========取值==================&quot;); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(&quot;开始等待&quot;); blockingQueue.poll(2,TimeUnit.SECONDS); //超过两秒 我们就不要等待了 System.out.println(&quot;结束等待&quot;); } 2）同步队列 同步队列 没有容量，也可以视为容量为1的队列； 进去一个元素，必须等待取出来之后，才能再往里面放入一个元素； put方法 和 take方法； Synchronized 和 其他的BlockingQueue 不一样 它不存储元素； put了一个元素，就必须从里面先take出来，否则不能再put进去值！ 并且SynchronousQueue 的take是使用了lock锁保证线程安全的。 package com.marchsoft.queue; import java.util.concurrent.BlockingDeque; import java.util.concurrent.BlockingQueue; /** * Description： * * @author jiaoqianjin * Date: 2020/8/12 10:02 **/ public class SynchronousQueue { public static void main(String[] args) { BlockingQueue&lt;String&gt; synchronousQueue = new java.util.concurrent.SynchronousQueue&lt;&gt;(); // 网queue中添加元素 new Thread(() -&gt; { try { System.out.println(Thread.currentThread().getName() + &quot;put 01&quot;); synchronousQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot;put 02&quot;); synchronousQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot;put 03&quot;); synchronousQueue.put(&quot;3&quot;); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); // 取出元素 new Thread(()-&gt; { try { System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take()); System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take()); System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take()); }catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } Thread-0put 01 Thread-1take1 Thread-0put 02 Thread-1take2 Thread-0put 03 Thread-1take3 Process finished with exit code 0 11. 线程池 线程池：三大方式、七大参数、四种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 ===&gt; 池化技术 线程池、JDBC的连接池、内存池、对象池 等等。。。。 资源的创建、销毁十分消耗资源 池化技术：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。 1）线程池的好处： 1、降低资源的消耗； 2、提高响应的速度； 3、方便管理； 线程复用、可以控制最大并发数、管理线程； 2）线程池：三大方法 ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程 ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小 ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的 //工具类 Executors 三大方法； public class Demo01 { public static void main(String[] args) { ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程 ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小 ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的 //线程池用完必须要关闭线程池 try { for (int i = 1; i &lt;=100 ; i++) { //通过线程池创建线程 threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName()+ &quot; ok&quot;); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } } } 3）七大参数 public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大的线程池大小 long keepAliveTime, //超时了没有人调用就会释放 TimeUnit unit, //超时单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动 RejectedExecutionHandler handler //拒绝策略 ) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的ThreadPoolExecutor来创建线程池。 public class PollDemo { public static void main(String[] args) { // 获取cpu 的核数 int max = Runtime.getRuntime().availableProcessors(); ExecutorService service =new ThreadPoolExecutor( 2, max, 3, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); try { for (int i = 1; i &lt;= 10; i++) { service.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + &quot;ok&quot;); }); } }catch (Exception e) { e.printStackTrace(); } finally { service.shutdown(); } } } 4）拒绝策略 1. new ThreadPoolExecutor.AbortPolicy()： //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常 超出最大承载，就会抛出异常：队列容量大小+maxPoolSize 2. new ThreadPoolExecutor.CallerRunsPolicy()： //该拒绝策略为：哪来的去哪里 main线程进行处理 3. new ThreadPoolExecutor.DiscardPolicy(): //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。 4. new ThreadPoolExecutor.DiscardOldestPolicy()： //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常 5）如何设置线程池的大小 1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小 // 获取cpu 的核数 int max = Runtime.getRuntime().availableProcessors(); ExecutorService service =new ThreadPoolExecutor( 2, max, 3, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); 2、I/O密集型： 在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。 12. 四大函数式接口 新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算 函数式接口：只有一个方法的接口 1）Function 函数型接口 public class FunctionDemo { public static void main(String[] args) { Function&lt;String, String&gt; function = (str) -&gt; {return str;}; System.out.println(function.apply(&quot;aaaaaaaaaa&quot;)); } } 2）Predicate 断定型接口 public class PredicateDemo { public static void main(String[] args) { Predicate&lt;String&gt; predicate = (str) -&gt; {return str.isEmpty();}; // false System.out.println(predicate.test(&quot;aaa&quot;)); // true System.out.println(predicate.test(&quot;&quot;)); } } 3）Suppier 供给型接口 /** * 供给型接口，只返回，不输入 */ public class Demo4 { public static void main(String[] args) { Supplier&lt;String&gt; supplier = ()-&gt;{return &quot;1024&quot;;}; System.out.println(supplier.get()); } } 4）Consummer 消费型接口 /** * 消费型接口 没有返回值！只有输入！ */ public class Demo3 { public static void main(String[] args) { Consumer&lt;String&gt; consumer = (str)-&gt;{ System.out.println(str); }; consumer.accept(&quot;abc&quot;); } } 13. Stream 流式计算 /** * Description： * 题目要求： 用一行代码实现 * 1. Id 必须是偶数 * 2.年龄必须大于23 * 3. 用户名转为大写 * 4. 用户名倒序 * 5. 只能输出一个用户 * * @author jiaoqianjin * Date: 2020/8/12 14:55 **/ public class StreamDemo { public static void main(String[] args) { User u1 = new User(1, &quot;a&quot;, 23); User u2 = new User(2, &quot;b&quot;, 23); User u3 = new User(3, &quot;c&quot;, 23); User u4 = new User(6, &quot;d&quot;, 24); User u5 = new User(4, &quot;e&quot;, 25); List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // lambda、链式编程、函数式接口、流式计算 list.stream() .filter(user -&gt; {return user.getId()%2 == 0;}) .filter(user -&gt; {return user.getAge() &gt; 23;}) .map(user -&gt; {return user.getName().toUpperCase();}) .sorted((user1, user2) -&gt; {return user2.compareTo(user1);}) .limit(1) .forEach(System.out::println); } } 14. ForkJoin ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！ 大数据中：MapReduce 核心思想-&gt;把大任务拆分为小任务！ 1）ForkJoin 特点： 工作窃取！ 实现原理是：双端队列！从上面和下面都可以去拿到任务进行执行！ 2）如何使用ForkJoin? 1、通过ForkJoinPool来执行 2、计算任务 execute(ForkJoinTask&lt;?&gt; task) 3、计算类要去继承ForkJoinTask； ForkJoin 的计算类 package com.marchsoft.forkjoin; import java.util.concurrent.RecursiveTask; /** * Description： * * @author jiaoqianjin * Date: 2020/8/13 8:33 **/ public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; { private long star; private long end; /** 临界值 */ private long temp = 1000000L; public ForkJoinDemo(long star, long end) { this.star = star; this.end = end; } /** * 计算方法 * @return */ @Override protected Long compute() { if ((end - star) &lt; temp) { Long sum = 0L; for (Long i = star; i &lt; end; i++) { sum += i; } return sum; }else { // 使用ForkJoin 分而治之 计算 //1 . 计算平均值 long middle = (star + end) / 2; ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(star, middle); // 拆分任务，把线程压入线程队列 forkJoinDemo1.fork(); ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle, end); forkJoinDemo2.fork(); long taskSum = forkJoinDemo1.join() + forkJoinDemo2.join(); return taskSum; } } } 测试类 package com.marchsoft.forkjoin; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.stream.LongStream; /** * Description： * * @author jiaoqianjin * Date: 2020/8/13 8:43 **/ public class ForkJoinTest { private static final long SUM = 20_0000_0000; public static void main(String[] args) throws ExecutionException, InterruptedException { test1(); test2(); test3(); } /** * 使用普通方法 */ public static void test1() { long star = System.currentTimeMillis(); long sum = 0L; for (long i = 1; i &lt; SUM ; i++) { sum += i; } long end = System.currentTimeMillis(); System.out.println(sum); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;----------------------&quot;); } /** * 使用ForkJoin 方法 */ public static void test2() throws ExecutionException, InterruptedException { long star = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, SUM); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); Long along = submit.get(); System.out.println(along); long end = System.currentTimeMillis(); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;-----------&quot;); } /** * 使用 Stream 流计算 */ public static void test3() { long star = System.currentTimeMillis(); long sum = LongStream.range(0L, 20_0000_0000L).parallel().reduce(0, Long::sum); System.out.println(sum); long end = System.currentTimeMillis(); System.out.println(&quot;时间：&quot; + (end - star)); System.out.println(&quot;-----------&quot;); } } .parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。 15. 异步回调 Future 设计的初衷：对将来的某个事件结果进行建模！ 其实就是前端 --&gt; 发送ajax异步请求给后端 但是我们平时都使用CompletableFuture （1）没有返回值的runAsync异步回调 public static void main(String[] args) throws ExecutionException, InterruptedException { // 发起 一个 请求 System.out.println(System.currentTimeMillis()); System.out.println(&quot;---------------------&quot;); CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;{ //发起一个异步任务 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;.....&quot;); }); System.out.println(System.currentTimeMillis()); System.out.println(&quot;------------------------------&quot;); //输出执行结果 System.out.println(future.get()); //获取执行结果 } （2）有返回值的异步回调supplyAsync //有返回值的异步回调 CompletableFuture&lt;Integer&gt; completableFuture=CompletableFuture.supplyAsync(()-&gt;{ System.out.println(Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(2); int i=1/0; } catch (InterruptedException e) { e.printStackTrace(); } return 1024; }); System.out.println(completableFuture.whenComplete((t, u) -&gt; { //success 回调 System.out.println(&quot;t=&gt;&quot; + t); //正常的返回结果 System.out.println(&quot;u=&gt;&quot; + u); //抛出异常的 错误信息 }).exceptionally((e) -&gt; { //error回调 System.out.println(e.getMessage()); return 404; }).get()); whenComplete: 有两个参数，一个是t 一个是u T：是代表的 正常返回的结果； U：是代表的 抛出异常的错误信息； 如果发生了异常，get可以获取到exceptionally返回的值； 16. JMM 1）对Volatile 的理解 Volatile 是 Java 虚拟机提供 轻量级的同步机制 1、保证可见性 2、不保证原子性 3、禁止指令重排 如何实现可见性 volatile变量修饰的共享变量在进行写操作的时候回多出一行汇编： 0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24**:lock** addl $0×0,(%esp); Lock前缀的指令在多核处理器下会引发两件事情。 1）将当前处理器缓存行的数据写回到系统内存。 2）这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。 多处理器总线嗅探： 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。 2）什么是JMM？ JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！ 关于JMM的一些同步的约定： 1、线程解锁前，必须把共享变量立刻刷回主存； 2、线程加锁前，必须读取主存中的最新值到工作内存中； 3、加锁和解锁是同一把锁； 线程中分为 工作内存、主内存 8种操作: Read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用； load（载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中； Use（使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令； assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中； store（存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用； write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中； lock（锁定）：作用于主内存的变量，把一个变量标识为线程独占状态； unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定； JMM对这8种操作给了相应的规定： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 遇到问题：程序不知道主存中的值已经被修改过了！； 17. volatile 1）保证可见性 public class JMMDemo01 { // 如果不加volatile 程序会死循环 // 加了volatile是可以保证可见性的 private volatile static Integer number = 0; public static void main(String[] args) { //main线程 //子线程1 new Thread(()-&gt;{ while (number==0){ } }).start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } //子线程2 new Thread(()-&gt;{ while (number==0){ } }).start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } number=1; System.out.println(number); } } 2）不保证原子性 原子性：不可分割； 线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。 /** * 不保证原子性 * number &lt;=2w * */ public class VDemo02 { private static volatile int number = 0; public static void add(){ number++; //++ 不是一个原子性操作，是两个~3个操作 // } public static void main(String[] args) { //理论上number === 20000 for (int i = 1; i &lt;= 20; i++) { new Thread(()-&gt;{ for (int j = 1; j &lt;= 1000 ; j++) { add(); } }).start(); } while (Thread.activeCount()&gt;2){ //main gc Thread.yield(); } System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number); } } 如果不加lock和synchronized ，怎么样保证原子性？ 使用原子类 public class VDemo02 { private static volatile AtomicInteger number = new AtomicInteger(); public static void add(){ // number++; number.incrementAndGet(); //底层是CAS保证的原子性 } public static void main(String[] args) { //理论上number === 20000 for (int i = 1; i &lt;= 20; i++) { new Thread(()-&gt;{ for (int j = 1; j &lt;= 1000 ; j++) { add(); } }).start(); } while (Thread.activeCount()&gt;2){ //main gc Thread.yield(); } System.out.println(Thread.currentThread().getName()+&quot;,num=&quot;+number); } } 这些类的底层都直接和操作系统挂钩！是在内存中修改值。 Unsafe类是一个很特殊的存在； 原子类为什么这么高级？ 3）禁止指令重排 什么是指令重排？ 我们写的程序，计算机并不是按照我们自己写的那样去执行的 源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行 处理器在进行指令重排的时候，会考虑数据之间的依赖性！ int x=1; //1 int y=2; //2 x=x+5; //3 y=x*x; //4 //我们期望的执行顺序是 1_2_3_4 可能执行的顺序会变成2134 1324 //可不可能是 4123？ 不可能的 可能造成的影响结果：前提：a b x y这四个值 默认都是0 线程A 线程B x=a y=b b=1 a=2 正常的结果： x = 0; y =0; 线程A 线程B b=1 a=2 x=a y=b 可能在线程A中会出现，先执行b=1,然后再执行x=a； 在B线程中可能会出现，先执行a=2，然后执行y=b； 那么就有可能结果如下：x=2; y=1. volatile可以避免指令重排： volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。 内存屏障：CPU指令。作用： 1、保证特定的操作的执行顺序； 2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性） 4）总结 volatile可以保证可见性； 不能保证原子性 由于内存屏障，可以保证避免指令重排的现象产生 面试官：那么你知道在哪里用这个内存屏障用得最多呢？单例模式 18. 玩转单例模式 饿汉式、DCL懒汉式 1）饿汉式 /** * 饿汉式单例 */ public class Hungry { /** * 可能会浪费空间 */ private byte[] data1=new byte[1024*1024]; private byte[] data2=new byte[1024*1024]; private byte[] data3=new byte[1024*1024]; private byte[] data4=new byte[1024*1024]; private Hungry(){ } private final static Hungry hungry = new Hungry(); public static Hungry getInstance(){ return hungry; } } 2）DCL懒汉式 //懒汉式单例模式 public class LazyMan { private static boolean key = false; private LazyMan(){ synchronized (LazyMan.class){ if (key==false){ key=true; } else{ throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); } } System.out.println(Thread.currentThread().getName()+&quot; ok&quot;); } private volatile static LazyMan lazyMan; //双重检测锁模式 简称DCL懒汉式 public static LazyMan getInstance(){ //需要加锁 if(lazyMan==null){ synchronized (LazyMan.class){ if(lazyMan==null){ lazyMan=new LazyMan(); /** * 1、分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 * * 就有可能出现指令重排问题 * 比如执行的顺序是1 3 2 等 * 我们就可以添加volatile保证指令重排问题 */ } } } return lazyMan; } //单线程下 是ok的 //但是如果是并发的 public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { //Java中有反射 // LazyMan instance = LazyMan.getInstance(); Field key = LazyMan.class.getDeclaredField(&quot;key&quot;); key.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); //无视了私有的构造器 LazyMan lazyMan1 = declaredConstructor.newInstance(); key.set(lazyMan1,false); LazyMan instance = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(lazyMan1); System.out.println(instance == lazyMan1); } } 3）静态内部类 //静态内部类 public class Holder { private Holder(){ } public static Holder getInstance(){ return InnerClass.holder; } public static class InnerClass{ private static final Holder holder = new Holder(); } } 单例不安全, 因为反射 4）枚举 //enum 是什么？ enum本身就是一个Class 类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { EnumSingle instance1 = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class); declaredConstructor.setAccessible(true); //java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;() EnumSingle instance2 = declaredConstructor.newInstance(); System.out.println(instance1); System.out.println(instance2); } } 使用枚举，我们就可以防止反射破坏了。 枚举类型的最终反编译源码： public final class EnumSingle extends Enum { public static EnumSingle[] values() { return (EnumSingle[])$VALUES.clone(); } public static EnumSingle valueOf(String name) { return (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name); } private EnumSingle(String s, int i) { super(s, i); } public EnumSingle getInstance() { return INSTANCE; } public static final EnumSingle INSTANCE; private static final EnumSingle $VALUES[]; static { INSTANCE = new EnumSingle(&quot;INSTANCE&quot;, 0); $VALUES = (new EnumSingle[] { INSTANCE }); } } 19. 深入理解CAS 1）什么是CAS？ 大厂必须深入研究底层！！！！修内功！操作系统、计算机网络原理、组成原理、数据结构 public class casDemo { //CAS : compareAndSet 比较并交换 public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); //boolean compareAndSet(int expect, int update) //期望值、更新值 //如果实际值 和 我的期望值相同，那么就更新 //如果实际值 和 我的期望值不同，那么就不更新 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); //因为期望值是2020 实际值却变成了2021 所以会修改失败 //CAS 是CPU的并发原语 atomicInteger.getAndIncrement(); //++操作 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); } } Unsafe 类 ! 2）总结 CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。 缺点： 循环会耗时； 一次性只能保证一个共享变量的原子性； 它会存在ABA问题 CAS：ABA问题？(狸猫换太子) 线程1：期望值是1，要变成2； 线程2：两个操作： 1、期望值是1，变成3 2、期望是3，变成1 所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1； public class casDemo { //CAS : compareAndSet 比较并交换 public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); //boolean compareAndSet(int expect, int update) //期望值、更新值 //如果实际值 和 我的期望值相同，那么就更新 //如果实际值 和 我的期望值不同，那么就不更新 System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); //因为期望值是2020 实际值却变成了2021 所以会修改失败 //CAS 是CPU的并发原语 // atomicInteger.getAndIncrement(); //++操作 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); } } 20. 原子引用 解决ABA问题，对应的思想：就是使用了乐观锁~ 带版本号的 原子操作！ Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。 带版本号的原子操作 package com.marchsoft.lockdemo; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicStampedReference; /** * Description： * * @author jiaoqianjin * Date: 2020/8/12 22:07 **/ public class CASDemo { /**AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 * 正常在业务操作，这里面比较的都是一个个对象 */ static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) { new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;a1=&gt;&quot; + stamp); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // 修改操作时，版本号更新 + 1 atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp()); // 重新把值改回去， 版本号更新 + 1 System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp()); }, &quot;a&quot;).start(); // 乐观锁的原理相同！ new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;b1=&gt;&quot; + stamp); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1, 3, stamp, stamp + 1)); System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp()); }, &quot;b&quot;).start(); } } 21. 各种锁的理解 1）公平锁，非公平锁 公平锁：非常公平，不能插队，必须先来后到 /** * Creates an instance of {@code ReentrantLock}. * This is equivalent to using {@code ReentrantLock(false)}. */ public ReentrantLock() { sync = new NonfairSync(); } 非公平锁：非常不公平，允许插队，可以改变顺序 /** * Creates an instance of {@code ReentrantLock} with the * given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 2）可重入锁 Synchonized 锁 public class Demo01 { public static void main(String[] args) { Phone phone = new Phone(); new Thread(()-&gt;{ phone.sms(); },&quot;A&quot;).start(); new Thread(()-&gt;{ phone.sms(); },&quot;B&quot;).start(); } } class Phone{ public synchronized void sms(){ System.out.println(Thread.currentThread().getName()+&quot;=&gt; sms&quot;); call();//这里也有一把锁 } public synchronized void call(){ System.out.println(Thread.currentThread().getName()+&quot;=&gt; call&quot;); } } Lock 锁 //lock public class Demo02 { public static void main(String[] args) { Phone2 phone = new Phone2(); new Thread(()-&gt;{ phone.sms(); },&quot;A&quot;).start(); new Thread(()-&gt;{ phone.sms(); },&quot;B&quot;).start(); } } class Phone2{ Lock lock=new ReentrantLock(); public void sms(){ lock.lock(); //细节：这个是两把锁，两个钥匙 //lock锁必须配对，否则就会死锁在里面 try { System.out.println(Thread.currentThread().getName()+&quot;=&gt; sms&quot;); call();//这里也有一把锁 } catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } } public void call(){ lock.lock(); try { System.out.println(Thread.currentThread().getName() + &quot;=&gt; call&quot;); }catch (Exception e){ e.printStackTrace(); } finally { lock.unlock(); } } } lock锁必须配对，相当于lock和 unlock 必须数量相同； 在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁； 3）自旋锁 spinlock public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 自我设计自旋锁 public class SpinlockDemo { // 默认 // int 0 //thread null AtomicReference&lt;Thread&gt; atomicReference=new AtomicReference&lt;&gt;(); //加锁 public void myLock(){ Thread thread = Thread.currentThread(); System.out.println(thread.getName()+&quot;===&gt; mylock&quot;); //自旋锁 while (!atomicReference.compareAndSet(null,thread)){ System.out.println(Thread.currentThread().getName()+&quot; ==&gt; 自旋中~&quot;); } } //解锁 public void myUnlock(){ Thread thread=Thread.currentThread(); System.out.println(thread.getName()+&quot;===&gt; myUnlock&quot;); atomicReference.compareAndSet(thread,null); } } public class TestSpinLock { public static void main(String[] args) throws InterruptedException { ReentrantLock reentrantLock = new ReentrantLock(); reentrantLock.lock(); reentrantLock.unlock(); //使用CAS实现自旋锁 SpinlockDemo spinlockDemo=new SpinlockDemo(); new Thread(()-&gt;{ spinlockDemo.myLock(); try { TimeUnit.SECONDS.sleep(3); } catch (Exception e) { e.printStackTrace(); } finally { spinlockDemo.myUnlock(); } },&quot;t1&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ spinlockDemo.myLock(); try { TimeUnit.SECONDS.sleep(3); } catch (Exception e) { e.printStackTrace(); } finally { spinlockDemo.myUnlock(); } },&quot;t2&quot;).start(); } } 运行结果： t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。。。 4）死锁 package com.ogj.lock; import java.util.concurrent.TimeUnit; public class DeadLock { public static void main(String[] args) { String lockA= &quot;lockA&quot;; String lockB= &quot;lockB&quot;; new Thread(new MyThread(lockA,lockB),&quot;t1&quot;).start(); new Thread(new MyThread(lockB,lockA),&quot;t2&quot;).start(); } } class MyThread implements Runnable{ private String lockA; private String lockB; public MyThread(String lockA, String lockB) { this.lockA = lockA; this.lockB = lockB; } @Override public void run() { synchronized (lockA){ System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockA+&quot;===&gt;get&quot;+lockB); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lockB){ System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockB+&quot;===&gt;get&quot;+lockA); } } } } 如何解开死锁 1、使用jps定位进程号，jdk的bin目录下： 有一个jps 命令：jps -l 2、使用jstack 进程进程号 找到死锁信息 一般情况信息在最后： ","link":"https://ganhan999.github.io/post/Java JUC并发编程/"},{"title":"中等5. 最长回文子串","content":"题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; &quot;&quot;&quot; 动态规划，如果bab是回文，俺么ababa也是，把整个矩阵都填满，首先是对角线，然后慢慢扩散。 &quot;&quot;&quot; #我的做法： class Solution: def longestPalindrome(self, s: str) -&gt; str: n = len(s) dp = [[False] * n for _ in range(n)] ans = &quot;&quot; # 枚举子串的长度 l+1 for l in range(n): # 枚举子串的起始位置 i，这样可以通过 j=i+l 得到子串的结束位置 for i in range(n): j = i + l if j &gt;= len(s): break if l == 0: dp[i][j] = True elif l == 1: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (dp[i + 1][j - 1] and s[i] == s[j]) if dp[i][j] and l + 1 &gt; len(ans): ans = s[i:j+1] return ans &quot;&quot;&quot; #大神做法1 根据回文子串的定义，枚举所有长度大于等于 22 的子串，依次判断它们是否是回文； 在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”； 在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。 class Solution: # 暴力匹配（超时） def longestPalindrome(self, s: str) -&gt; str: # 特判 size = len(s) if size &lt; 2: return s max_len = 1 res = s[0] # 枚举所有长度大于等于 2 的子串 for i in range(size - 1): for j in range(i + 1, size): if j - i + 1 &gt; max_len and self.__valid(s, i, j): max_len = j - i + 1 res = s[i:j + 1] return res def __valid(self, s, left, right): # 验证子串 s[left, right] 是否为回文串 while left &lt; right: if s[left] != s[right]: return False left += 1 right -= 1 return True &quot;&quot;&quot; #大神做法2 中心扩散法 我们可以设计一个方法，兼容以上两种情况： 1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数； 2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。 class Solution: def longestPalindrome(self, s: str) -&gt; str: size = len(s) if size &lt; 2: return s # 至少是 1 max_len = 1 res = s[0] for i in range(size): palindrome_odd, odd_len = self.__center_spread(s, size, i, i) palindrome_even, even_len = self.__center_spread(s, size, i, i + 1) # 当前找到的最长回文子串 cur_max_sub = palindrome_odd if odd_len &gt;= even_len else palindrome_even if len(cur_max_sub) &gt; max_len: max_len = len(cur_max_sub) res = cur_max_sub return res def __center_spread(self, s, size, left, right): &quot;&quot;&quot; left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数 right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数 &quot;&quot;&quot; i = left j = right while i &gt;= 0 and j &lt; size and s[i] == s[j]: i -= 1 j += 1 return s[i + 1:j], j - i - 1 ","link":"https://ganhan999.github.io/post/5、最长回文子串/"},{"title":"中等3. 无重复字符的最长子串","content":"题目 给出两个 非空 的链表用来表示两个非负的整数。 其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 本体思路 遍历每一个元素，选出最长子串。 #我的做法： class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: # 哈希集合，记录每个字符是否出现过 occ = set() n = len(s) # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans = -1, 0 for i in range(n): if i != 0: # 左指针向右移动一格，移除一个字符 occ.remove(s[i - 1]) while rk + 1 &lt; n and s[rk + 1] not in occ: # 不断地移动右指针 occ.add(s[rk + 1]) rk += 1 # 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk - i + 1) return ans &quot;&quot;&quot; 大神做法1： 用一个暂时存储匹配的子串来判断子串大小，如果出现重复的字符，找到重复的字符然后向后匹配。 class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: # 使用一个辅助变量来暂时存储匹配的子串 ans = '' tep = '' for i in s: # 遍历，若不重复则记录该字符 if i not in tep: tep += i # 如果遇到了已经存在的字符，则找到该字符所在位置，删除该字符，并保留该位置之后的子串，并把当前字符加入到最后，完成更新 else: tep = tep[tep.index(i)+1:] tep += i # 如果是当前最长的，就替换掉之前存储的最长子串 if len(tep) &gt; len(ans): ans = tep return len(ans) &quot;&quot;&quot; 大神做法2： 动态规划 根据例子的思路推广至一般的情况： 给出一个字符串Si，已知它的最长子串长度为Li，如果在Si的末尾追加一个字符C， 即Si+1=Si+C，那么Si+1的最长子串是多少？ 很容易想到： lengthOfLongestSubString(Si+1)=max(Li,len(C结尾的无重复子串)) class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if s == '': return 0 if len(s) == 1: return 1 def find_left(s, i): tmp_str = s[i] j = i - 1 while j &gt;= 0 and s[j] not in tmp_str: tmp_str += s[j] j -= 1 return len(tmp_str) length = 0 for i in range(0, len(s)): length = max(length, find_left(s, i)) return length ","link":"https://ganhan999.github.io/post/3、无重复字符的最长子串/"},{"title":"中等2. 两数相加","content":"题目 给出两个 非空 的链表用来表示两个非负的整数。 其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 本体思路 因为两个数字相加会产生进位，所以使用i来保存进位。 则当前位的值为(l1.val + l2.val + i) % 10 则进位值为(l1.val + l2.val + i) / 10 建立新node，然后将进位传入下一层。 #我的做法： class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def DFS(l1,l2,i): if not l1 and not l2 and not i: return None s=(l1.val if l1 else 0)+(l2.val if l2 else 0)+i node=ListNode(s%10) node.next=DFS(l1.next if l1 else None,l2.next if l2 else None,s//10) return node return DFS(l1,l2,0) ","link":"https://ganhan999.github.io/post/2、两数相加/"},{"title":"190、颠倒二进制位","content":"题目 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 本体思路 从最后一位开始遍历，每次都将最后一位放到它该去的地方 #我的做法： class Solution: def reverseBits(self, n): ret, power = 0, 31 while n: ret += (n &amp; 1) &lt;&lt; power#n &amp; 1表示最后一位，&lt;&lt; power表示左移多少位 n = n &gt;&gt; 1 power -= 1 return ret &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 首先，我们将原来的 32 位分为 2 个 16 位的块。 然后我们将 16 位块分成 2 个 8 位的块。 然后我们继续将这些块分成更小的块，直到达到 1 位的块。 在上述每个步骤中，我们将中间结果合并为一个整数，作为下一步的输入。 class Solution: def reverseBits(self, n): n = (n &gt;&gt; 16) | (n &lt;&lt; 16) n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8) n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4) n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2) n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1) return n &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 转str，再reverse，再转回来 class Solution: def reverseBits(self, n: int) -&gt; int: a=list(bin(n))[2:] num=32-len(a) a.reverse() b=&quot;&quot;.join(a)+'0'*num return int(b,base=2) ","link":"https://ganhan999.github.io/post/190、颠倒二进制位/"},{"title":"Java注解和反射","content":"注解Annotation 内置注解 @override:定义重写声明 @Deprecated：表示不鼓励使用 @SuppressWarnings：抑制警告信息 使用 1.@SuppressWarnings（“all”） 2.@SuppressWarnings（“unchecked”） 3.@SuppressWarnings（value={“unchecked”,“deprecation”}） package First; import java.util.ArrayList; import java.util.List; public class Demo01 extends Object{ //@Override 重写的注解 @Override public String toString() { return &quot;Demo01{}&quot;; } //@Deprecated 不推荐程序员使用 但是可以使用 一般有更好的方法 @Deprecated public static void test(){ System.out.println(&quot;Deprecated&quot;); } @SuppressWarnings(&quot;all&quot;) //下方未使用的警告不再提示 public static void test02(){ List list = new ArrayList(); } public static void main(String[] args) { test(); } } 元注解 meta-annotation 自定义注解 @interface package First; import java.lang.annotation.*; //@MyAnnotation 定义注解目标为方法 故不可以使用 public class Test02 { @MyAnnotation//定义注解目标为方法 故可以使用 public void test(){ } } //@Target 表示我们的注解可以用在那些地方 值为ElementType @Target(value = ElementType.METHOD) //@Retention 表示我们的注解可以用在哪些地方 //runtime运行时&gt;class&gt;sourcejava @Retention(value = RetentionPolicy.RUNTIME) //@Documented 表示是否我们的注解生成在JAVAdoc中 @Documented @Inherited //表示子类可以继承注解 @interface MyAnnotation{} package First; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class Test03 { @MyAnnotation03(&quot;当场注解&quot;) @MyAnnotation02(age = 10,name = &quot;alin&quot;)//参数顺序可以调换 必许带参数名 public void test03(){ } } @Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation0 2{ //参数定义 参数类型 参数名() String name() default &quot;&quot;;//default 进行默认赋值 int age() default 0; int id() default -1;//表示不存在 String[] students() default {&quot;青岛大学&quot;,&quot;南京邮电大学&quot; }; } @Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation03{ String value();//一个参数时 最好命名为value 命名为value时 在使用此注解时可以不加value } 反射Reflection package Reflection; public class Demo01 { public static void main(String[] args) throws ClassNotFoundException { //通过反射获取类的Class类型 Class c1 = Class.forName(&quot;Reflection.User&quot;); Class c2 = Class.forName(&quot;Reflection.User&quot;); Class c3 = Class.forName(&quot;Reflection.User&quot;); //一个类只有一个Class对象 故c1 c2 c3 hashcode相同 //一个类被加载之后 类的整个结构都会被封装在Class对象中 System.out.println(c1.hashCode()); System.out.println(c1.hashCode()); System.out.println(c1.hashCode()); } } //实体类 pojo entity class User{ String name; int age; int id; public User() { } public User(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, id=&quot; + id + '}'; } } Class类 获得class的方法 package Reflection; public class Demo02 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(); System.out.println(&quot;这个人是:&quot;+person.name); //通过对象获得class Class c1 = person.getClass(); System.out.println(c1.hashCode()); //通过类获得class Class c2 = Student.class; System.out.println(c2.hashCode()); //通过forname获得class Class c3 = Class.forName(&quot;Reflection.Student&quot;); System.out.println(c3.hashCode()); //通过内置函数的包装类获得class Class c4 = Integer.TYPE; System.out.println(c4); //获得父类的class Class c5 = c1.getSuperclass(); System.out.println(c5); } } class Person{ public String name; public Person() { } public Person(String name) { this.name = name; } } class Student extends Person{ public Student() { this.name=&quot;学生&quot;; } } class Teacher extends Person{ public Teacher() { this.name = &quot;教师&quot;; } } 这个人是:学生 460141958 460141958 460141958 int class Reflection.Person 有Class对象 package Reflection; import java.net.InterfaceAddress; import java.util.Enumeration; //拥有class对象的类型 public class Demo03 { public static void main(String[] args) { Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = Enumeration.class; Class c6 = Integer.class; Class c7 = Override.class; Class c8 = Void.class; Class c9 = void.class; Class c10 = Class.class; System.out.println(c1 ); System.out.println(c2 ); System.out.println(c3 ); System.out.println(c4 ); System.out.println(c5 ); System.out.println(c6 ); System.out.println(c7 ); System.out.println(c8 ); System.out.println(c9 ); System.out.println(c10); //当类型和维数相同时只有一个class对象 int[] a = new int[10]; int[] b = new int[100]; System.out.println(a.getClass().hashCode()); System.out.println(b.getClass().hashCode()); } } class java.lang.Object interface java.lang.Comparable class [Ljava.lang.String; class [[I interface java.util.Enumeration class java.lang.Integer interface java.lang.Override class java.lang.Void void class java.lang.Class 加载类class package Reflection; public class Demo04 { public static void main(String[] args) { A a = new A(); System.out.println(A.m); } } /* 1.加载到内存，会产生一个类对应Class对象在堆区 2.链接，在栈中产生 main m=0; 3.初始化 &lt;clinit&gt;{ System.out.println(&quot;A类静态代码块初始化&quot;); m=300; m=100; 静态 按顺序执行的 若把 int m =100 ;放上面 则为300； } */ class A{ static { System.out.println(&quot;A类静态代码块初始化&quot;); m=300; } /* m=300; m=100; 覆盖上方300 */ static int m =100; public A() { System.out.println(&quot;A类的无参构造器&quot;); } } A类静态代码块初始化 A类的无参构造器 100 123456789101112131415161718192021222324252627282930313233343536373839 类的初始化 package Reflection; public class Demo05 { static { System.out.println(&quot;Main类被调用了&quot;); } public static void main(String[] args) throws ClassNotFoundException { //1.创建对象 若父类没初始化 先初始化父类 //Son son = new Son(); /* Main类被调用了 父类被加载 子类被加载了 100 */ //2.通过反射 //Class c1 = Class.forName(&quot;Reflection.Son&quot;);//Main类被调用 父类被加载 子类被加载了 //3.调用静态 //System.out.println(Son.m);//Main类被调用了 父类被加载 子类被加载了 200 //被动引用 //子类引用父类静态变量 //System.out.println(Son.b);//Main类被调用了 父类被加载 100 //数组定义类引用 //Son[] a1 = new Son[5]; Main类被调用了 //引用常量 //System.out.println(Son.M); Main类被调用了 1 } } class Father{ static { System.out.println(&quot;父类被加载&quot;); //int b=10; } static int b =100; } class Son extends Father{ static { System.out.println(&quot;子类被加载了&quot;); m=300; } static int m=200; static final int M=1; } 类加载器 package Reflection; public class Demo06 { public static void main(String[] args) throws ClassNotFoundException { //获得系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获得系统类加载器的父类--&gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获得扩展类加载器的父类--&gt;根加载器（c/c++）无法直接获得 ClassLoader parent1 = parent.getParent(); System.out.println(parent1); //测试当前类由哪个加载器产生 ClassLoader classLoader = Class.forName(&quot;Reflection.Demo06&quot;).getClassLoader(); System.out.println(classLoader); //测试jdk类 classLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classLoader); //如何获得系统类加载器的加载路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); /* D:\\Java\\jdk1.8.0_261\\jre\\lib\\charsets.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\deploy.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\access-bridge-64.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\cldrdata.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\dnsns.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\jaccess.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\jfxrt.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\localedata.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\nashorn.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\sunec.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\sunjce_provider.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\sunmscapi.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\sunpkcs11.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\ext\\zipfs.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\javaws.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\jce.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\jfr.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\jfxswt.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\jsse.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\management-agent.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\plugin.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\resources.jar; D:\\Java\\jdk1.8.0_261\\jre\\lib\\rt.jar; D:\\Program Files\\IDEA\\IntelliJ IDEA Community Edition 2020.2.2\\Annotation\\out\\production\\Annotation; D:\\Program Files\\IDEA\\IntelliJ IDEA Community Edition 2020.2.2\\lib\\idea_rt.jar */ //双亲委派机制 //当你定义的与根加载器中有类重复 为保证安全 仍使用根加载器中的类 } } sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@1b6d3586 null sun.misc.Launcher$AppClassLoader@18b4aac2 null 双亲委派机制: 当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 获取类的运行时状态 package Reflection; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class Demo07 { public static void main(String[] args) throws Exception { Class c1 = Class.forName(&quot;Reflection.User&quot;); //User user = new User(); c1 =User.Class(); System.out.println(c1.getName());//获取包名加类名 System.out.println(c1.getSimpleName());//获取类名 //获取属性 Field[] fields = c1.getFields();//获得public属性 for (Field field:fields) { System.out.println(field); } fields = c1.getDeclaredFields();//获得全部属性 for (Field field:fields) { System.out.println(field); } //获得指定属性 System.out.println(c1.getDeclaredField(&quot;name&quot;)); //获取方法 Method[] methods = c1.getMethods();//获得当前类与父类的public方法 for (Method method : methods) { System.out.println(&quot;正常的&quot;+method); } methods =c1.getDeclaredMethods();//获得当前类的所有方法 for (Method method : methods) { System.out.println(&quot;getDeclaredMethods&quot;+method); } //获得指定方法 //加参数 处理重载 System.out.println(c1.getMethod(&quot;getId&quot;,null)); System.out.println(c1.getMethod(&quot;setName&quot;, String.class));//含参数需指定 //获取构造器 Constructor[] constructors = c1.getConstructors();//获得public构造器 for (Constructor constructor : constructors) { System.out.println(constructor); } constructors = c1.getDeclaredConstructors();//获得全部构造器 for (Constructor constructor : constructors) { System.out.println(constructor); } //获得指定构造器 System.out.println(c1.getConstructor(String.class,int.class,int.class)); } } Reflection.User User java.lang.String Reflection.User.name int Reflection.User.age int Reflection.User.id java.lang.String Reflection.User.name 正常的public java.lang.String Reflection.User.toString() 正常的public java.lang.String Reflection.User.getName() 正常的public int Reflection.User.getId() 正常的public void Reflection.User.setName(java.lang.String) 正常的public int Reflection.User.getAge() 正常的public void Reflection.User.setId(int) 正常的public void Reflection.User.setAge(int) 正常的public final void java.lang.Object.wait() throws java.lang.InterruptedException 正常的public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException 正常的public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException 正常的public boolean java.lang.Object.equals(java.lang.Object) 正常的public native int java.lang.Object.hashCode() 正常的public final native java.lang.Class java.lang.Object.getClass() 正常的public final native void java.lang.Object.notify() 正常的public final native void java.lang.Object.notifyAll() getDeclaredMethodspublic java.lang.String Reflection.User.toString() getDeclaredMethodspublic java.lang.String Reflection.User.getName() getDeclaredMethodspublic int Reflection.User.getId() getDeclaredMethodspublic void Reflection.User.setName(java.lang.String) getDeclaredMethodspublic int Reflection.User.getAge() getDeclaredMethodspublic void Reflection.User.setId(int) getDeclaredMethodspublic void Reflection.User.setAge(int) public int Reflection.User.getId() public void Reflection.User.setName(java.lang.String) public Reflection.User() public Reflection.User(java.lang.String,int,int) public Reflection.User() public Reflection.User(java.lang.String,int,int) public Reflection.User(java.lang.String,int,int) 动态创建对象 invoke setAccessible package Reflection; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class Demo08 { public static void main(String[] args) throws Exception { Class c1 = Class.forName(&quot;Reflection.User&quot;); //反射得到对象 //User user = (User) c1.newInstance();//调用无参构造器 new一个对象 高版本此方法已过时 使用c1.getDeclaredConstructor().newInstance() //System.out.println(user); //使用构造器 //Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); //User user1=(User)constructor.newInstance(&quot;小明&quot;,18,001); //System.out.println(user1); //反射调用普通方法 User user= (User) c1.newInstance(); //通过反射获取一个方法 Method setName = c1.getMethod(&quot;setName&quot;,String.class); //invoke 激活 （对象，&quot;方法的值&quot;） setName.invoke(user,&quot;ck&quot;); System.out.println(user.getName()); //通过反射操作属性 System.out.println(&quot;==========&quot;); User user1=(User)c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); name.setAccessible(true);//关闭安全检测 对私有属性可以操作 name.set(user1,&quot;小小&quot;); System.out.println(user1.getName()); } } ck ========== 小小 性能检测 package Reflection; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Demo09 { //普通调用 public static void test01(){ User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { user.getName(); } long endTime =System.currentTimeMillis(); System.out.println(&quot;普通调用10亿次耗费&quot;+(endTime-startTime)+&quot;ms&quot;); } //反射调用 public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user,null); } long endTime =System.currentTimeMillis(); System.out.println(&quot;反射调用10亿次耗费&quot;+(endTime-startTime)+&quot;ms&quot;); } //关闭安全检测 public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) { getName.invoke(user,null); } long endTime =System.currentTimeMillis(); System.out.println(&quot;关闭安全检测后反射调用10亿次耗费&quot;+(endTime-startTime)+&quot;ms&quot;); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { test01(); test02(); test03(); } } 普通调用10亿次耗费4ms 反射调用10亿次耗费2063ms 关闭安全检测后反射调用10亿次耗费1265ms 可以看出 反射的方式调用 耗时较久 获取泛型 package Reflection; import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.List; import java.util.Map; public class Demo10 { public void test01(Map&lt;String ,User&gt; map,List&lt;String&gt; list){ System.out.println(&quot;这不重要&quot;); } public Map&lt;String ,User&gt; test02(){ System.out.println(&quot;这不重要&quot;); return null; } public static void main(String[] args) throws NoSuchMethodException { Method method = Demo10.class.getDeclaredMethod(&quot;test01&quot;,Map.class,List.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); for (Type genericParameterType : genericParameterTypes) { System.out.println(genericParameterType); if(genericParameterType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } System.out.println(&quot;=========================&quot;); method = Demo10.class.getDeclaredMethod(&quot;test02&quot;); Type genericReturnType = method.getGenericReturnType(); if(genericReturnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } } java.util.Map&lt;java.lang.String, Reflection.User&gt; class java.lang.String class Reflection.User java.util.List&lt;java.lang.String&gt; class java.lang.String ========================= class java.lang.String class Reflection.User 通过反射获得注解 package Reflection; import java.lang.annotation.*; import java.lang.reflect.Field; public class Demo11 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(&quot;Reflection.Student2&quot;); //获得类的注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation); } //获得注解的值 Typekang typekang =(Typekang) c1.getAnnotation(Typekang.class); String value =typekang.value(); System.out.println(value); //获得指定注解的值 Field field = c1.getDeclaredField(&quot;name&quot;); Fieldkang fieldkang = field.getAnnotation(Fieldkang.class); System.out.println(fieldkang.columname()); System.out.println(fieldkang.type()); System.out.println(fieldkang.length()); } } @Typekang(&quot;db_Student&quot;) class Student2{ @Fieldkang(columname = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 10) private String name; @Fieldkang(columname = &quot;db_age&quot;,type = &quot;int&quot;,length = 10) private int age; @Fieldkang(columname = &quot;db_id&quot;,type = &quot;int&quot;,length = 10) private int id; public Student2(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } public Student2() { } @Override public String toString() { return &quot;Student2{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, id=&quot; + id + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } } @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Typekang{ String value(); } @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface Fieldkang{ String columname(); String type(); int length(); } @Reflection.Typekang(value=db_Student) db_Student db_name varchar ","link":"https://ganhan999.github.io/post/Java注解和反射/"},{"title":"172、阶乘后的零","content":"题目 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 本体思路 先计算阶乘，在计算尾数有多少个0 #我的做法： class Solution: def trailingZeroes(self, n: int) -&gt; int: n_factorial = 1 for i in range(2, n + 1): n_factorial *= i zero_count = 0 while n_factorial % 10 == 0: zero_count += 1 n_factorial //= 10 return zero_count &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 例如，如果 n=16，我们需要查看 1 到 16 之间所有数字的因子。 我们只对 2 和 5 有兴趣。包含 55 因子的数字是 {5，10，15} 包含因子 2 的数字是 {2、4、6、8、10、12、14、16} 因为只三个完整的对，因此 16! 后有三个零。 首先，我们可以注意到因子 2 数总是比因子 5 大。 为什么？因为每四个数字算作额外的因子 2， 但是只有每 25 个数字算作额外的因子 5。 因此我们可以删除计算因子 2 的过程 class Solution: def trailingZeroes(self, n: int) -&gt; int: zero_count = 0 for i in range(5, n + 1, 5): current = i while current % 5 == 0: zero_count += 1 current //= 5 return zero_count &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 根据大神做法1，把除以25、除以125、除以625……不能大于n的个数都算出来，相加就行。 class Solution: def trailingZeroes(self, n: int) -&gt; int: zero_count = 0 current_multiple = 5 while n &gt;= current_multiple: zero_count += n // current_multiple current_multiple *= 5 return zero_count ","link":"https://ganhan999.github.io/post/172、阶乘后的零/"},{"title":"Java多线程编程","content":"多线程 简介 任务 线程Thread 进程 Process多线程 多任务 看似同时进行多项任务 实际同一时间只能做一次 进程：执行程序的一次执行过程，动态概念 包含若干个线程 至少一个 多线程 是模拟出来的 切换速度快而已 线程是独立的执行路径 程序运行时，即使没有自己创建线程，后台也或有多个线程如 主线程，gc线程 进程中，如果包含多个线程，线程的运行由调度器安排调度，调度器与操作系统紧密相关，先后顺序不能人为干扰 main（）称之为主进程，为系统的入口，用于执行整个程序 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如CPU调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 创建进程 继承Thread类（重点） 使用runnable接口（重点） 了解callable接口 继承Thread类 package thread; //创建线程方式一: 继承Thread类,重写run()方法，start开启多线程 public class ThreadCreate extends Thread { @Override public void run() { for (int i = 0; i &lt; 20; i++) { System.out.println(i+&quot;我在看代码&quot;); } } public static void main(String[] args) { //main线程 主线程 //创建一个线程对象 ThreadCreate threadCreate = new ThreadCreate(); //调用start（）线程 threadCreate.start(); //threadCreate.run();普通方法 先调用&quot;我在看代码&quot;后&quot;我在跑程序&quot; for (int i = 0; i &lt; 2000; i++) { System.out.println(i+&quot;我在跑程序&quot;); } } } 总结：注意，线程开启不一定立即执行，由cpu调度执行 网图下载 package thread; import org.apache.commons.io.FileUtils; import javax.swing.*; import java.io.File; import java.io.IOException; import java.net.URL; public class ThreadCreate2 extends Thread{ private String url; private String name; public ThreadCreate2(String name,String url) { this.name = name; this.url=url; } @Override public void run() { WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.DownLoader(url,name); System.out.println(&quot;下载了文件为:&quot;+name); } public static void main(String[] args) { ThreadCreate2 t1 = new ThreadCreate2(&quot;1.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); ThreadCreate2 t2 = new ThreadCreate2(&quot;2.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); ThreadCreate2 t3 = new ThreadCreate2(&quot;3.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); t1.start(); t2.start(); t3.start(); } } class WebDownLoader { //下载方法 public void DownLoader(String url,String name) { try { FileUtils.copyURLToFile(new URL(url), new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;IO异常 download方法出现问题&quot;); } } } 下载了文件为:3.jpg 下载了文件为:1.jpg 下载了文件为:2.jpg 实现runnable接口 package thread; //创建线程2:实现runnable接口，重写run()方法 执行线程需要将runnable丢入 public class TestCreate3 implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 20; i++) { System.out.println(i+&quot;我在看代码&quot;); } } public static void main(String[] args) { //创建runnable接口的实现类对象 TestCreate3 testCreate3 = new TestCreate3(); //创建线程对象，通过线程对象来开启我们的线程 代理 new Thread(testCreate3).start(); for (int i = 0; i &lt; 20; i++) { System.out.println(i+&quot;我在执行多线程&quot;); } } } 0我在执行多线程 0我在看代码 1我在执行多线程 1我在看代码 2我在看代码 3我在看代码 总结: 继承Thread类 子类继承Thread类具备多线程能力 启动线程：子类对象。start() 不建议使用：避免oop单继承局限性 实现runnable接口 实现runnable接口具备多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 package thread; //多个线程同时操作一个对象 //买国车票例子 //发现问题：多个线程使用同一份资源 线程不安全 数据紊乱 public class TestThread2 implements Runnable{ //车票数 int ticketNums=10; @Override public void run() { while(true){ if(ticketNums&lt;=0){ break; } try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;张票&quot;); } } public static void main(String[] args) { TestThread2 ticket = new TestThread2(); new Thread(ticket,&quot;学生&quot;).start(); new Thread(ticket,&quot;打工者&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); } } 学生--&gt;拿到了第4张票 黄牛党--&gt;拿到了第4张票 打工者--&gt;拿到了第2张票 学生--&gt;拿到了第2张票 黄牛党--&gt;拿到了第1张票 龟兔赛跑 package thread; import com.sun.deploy.nativesandbox.NativeSandboxBroker; public class Race implements Runnable{ private static String winner;//胜利者 @Override public void run() { if(Thread.currentThread().getName().equals(&quot;兔子&quot;)){ for (int i = 2; i &lt;=100; i+=2) { boolean flag=gameover(i); if(flag){ break; } System.out.println(&quot;兔子跑了&quot;+i+&quot;步&quot;); if(i%50==0){ try { Thread.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } } } }else{ for (int i = 1; i &lt;= 100; i++) { boolean flag=gameover(i); if(flag){ break; } System.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;); } } } public boolean gameover(int step){ if(winner!=null){ return true; }else if(step&gt;=100){ winner=Thread.currentThread().getName(); System.out.println(&quot;winner is &quot;+winner); return true; }else{ return false; } } public static void main(String[] args) { Race race = new Race(); new Thread(race,&quot;兔子&quot;).start(); new Thread(race,&quot;乌龟&quot;).start(); } } winner is 乌龟 兔子跑了52步 龟兔都有希望获胜 但有个问题在于即便胜利者出现 有时还会有一个前进 这是因为用了if 后相当与两个线程 故有反应时间差吧 实现Callable 1.实现Callable,需要返回值类型 2.重写call方法，需要抛出异常 3.创建目标对象 4.创建执行服务：ExecutorService ser=Executors.newFixedThreadPool(1) 5.提交执行：Futureresult1=ser.submit(t1); 6.获取结果：Boolean r1 =result.get() 7.关闭服务:ser.shutdownNow(); package thread; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; public class TestCallable implements Callable&lt;Boolean&gt;{ private String url; private String name; public TestCallable(String name,String url) { this.name = name; this.url=url; } @Override public Boolean call() { WebDownLoader1 webDownLoader1 = new WebDownLoader1(); webDownLoader1.DownLoader(url,name); System.out.println(&quot;下载了文件为:&quot;+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(&quot;1.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); TestCallable t2 = new TestCallable(&quot;2.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); TestCallable t3 = new TestCallable(&quot;3.jpg&quot;,&quot;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2534506313,1688529724&amp;fm=26&amp;gp=0.jpg&quot;); //4.创建执行服务 ExecutorService ser= Executors.newFixedThreadPool(3); //5.提交执行 Future&lt;Boolean&gt; result1=ser.submit(t1); Future&lt;Boolean&gt; result2=ser.submit(t2); Future&lt;Boolean&gt; result3=ser.submit(t3); //6.获取结果 Boolean r1 =result1.get(); Boolean r2 =result1.get(); Boolean r3 =result1.get(); System.out.println(r1); System.out.println(r2); System.out.println(r3); //7.关闭服务: ser.shutdownNow(); } } class WebDownLoader1 { //下载方法 public void DownLoader(String url,String name) { try { FileUtils.copyURLToFile(new URL(url), new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;IO异常 download方法出现问题&quot;); } } } 下载了文件为:3.jpg 下载了文件为:2.jpg 下载了文件为:1.jpg true true true 好处：可以定义返回值 可以抛出异常 静态代理 自己简单改版 package thread; public class StaticProxy { public static void main(String[] args) { You you = new You(); Weddingproxy weddingproxy = new Weddingproxy(); weddingproxy.Happy(); } } interface Marry{ public void Happy(); } class You implements Marry{ @Override public void Happy() { System.out.println(&quot;能与你深爱的人步入婚姻殿堂 这才是最幸福的吧&quot;); } } class Weddingproxy extends You implements Marry{ @Override public void Happy() { before(); super.Happy(); after(); } private void after() { System.out.println(&quot;婚礼结束 收尾款&quot;); } private void before() { System.out.println(&quot;布置婚礼，安排工作&quot;); } } 官方正版 package thread; public class StaticProxy2 { public static void main(String[] args) { You1 you1 = new You1(); Weddingproxy1 weddingproxy1 = new Weddingproxy1(you1); weddingproxy1.Happy(); } } interface Marry1{ public void Happy(); } class You1 implements Marry{ @Override public void Happy() { System.out.println(&quot;能与你深爱的人步入婚姻殿堂 这才是最幸福的吧&quot;); } } class Weddingproxy1 implements Marry{ private Marry target; public Weddingproxy1(Marry target) { this.target = target; } @Override public void Happy() { before(); this.target.Happy(); after(); } private void after() { System.out.println(&quot;婚礼结束 收尾款&quot;); } private void before() { System.out.println(&quot;布置婚礼，安排工作&quot;); } } 总结：代理对象可以做很多对象做不到的事情（回头看看静态10分后） lamda表达式 函数式编程 简化匿名内部类 函数式接口 ：接口中只包含一个抽象方法 对于函数式接口，可以通过lambda表达式来创建该接口的对象 package thread; public class lambda { //3.静态内部类 static class Like2 implements Ilike { @Override public void lambda() { System.out.println(&quot; i like lambda2&quot;); } } public static void main(String[] args) { Ilike like = new Like(); like.lambda(); Like2 like2 = new Like2(); like2.lambda(); //4.局部内部类 class Like3 implements Ilike { @Override public void lambda() { System.out.println(&quot; i like lambda3&quot;); } } like = new Like3(); like.lambda(); //5.匿名内部类 ,没有类的名字 借助接口 like = new Ilike() { @Override public void lambda() { System.out.println(&quot; i like lambda4&quot;); } }; like.lambda(); //6.lambda like= ()-&gt; { System.out.println(&quot; i like lambda5&quot;); }; like.lambda(); } } //1.函数式接口 interface Ilike{ void lambda(); } //2.实现类 class Like implements Ilike { @Override public void lambda() { System.out.println(&quot; i like lambda&quot;); } } 带参数 实际差不多 package thread; public class Lambda2 { static class Love2 implements Ilove{ @Override public void love(int a) { System.out.println(&quot;I LOVE YOU2 -&gt; &quot;+a); } } public static void main(String[] args) { class Love3 implements Ilove{ @Override public void love(int a) { System.out.println(&quot;I LOVE YOU3 -&gt; &quot;+a); } } Ilove love = new Love(); love.love(1); love = new Love2(); love.love(2); love = new Love3(); love.love(3); love = new Ilove() { @Override public void love(int a) { System.out.println(&quot;I LOVE YOU4 -&gt; &quot;+a); } }; love.love(4); love=(int a)-&gt;{ System.out.println(&quot;I LOVE YOU5 -&gt; &quot;+a); }; love.love(5); //简化1:去int love=(a)-&gt;{ System.out.println(&quot;I LOVE YOU6 -&gt; &quot;+a); }; love.love(6); //简化2：去小括号 love=a-&gt;{ System.out.println(&quot;I LOVE YOU7 -&gt; &quot;+a); }; love.love(7); //简化3:去花括号 love=a-&gt; System.out.println(&quot;I LOVE YOU8 -&gt; &quot;+a); love.love(8); } } interface Ilove{ void love(int a); } class Love implements Ilove{ @Override public void love(int a) { System.out.println(&quot;I LOVE YOU1 -&gt; &quot;+a); } } 总结： lambda表达式只能在有一行代码的情况下才能简化成一行，如果有多行，那么就用代码块（花括号）包裹 2.前提是函数式接口 3.多个参数也可去掉类型 要去掉参数都去掉 但要加小括号 线程状态 创建 就绪 运行 阻塞 停止 线程方法: setPriority :更改线程的优先级 static void sleep(long millis): 在指定的毫秒数内让当前执正在执行的线程休眠 void join()等待该线程终止 static void yield（）暂停当前正在执行的线程对象，并执行其他线程 void interrupt () 中断线程 不建议使用 boolean isAlive()测试线程是否处于活动状态 停止线程 不推荐使用JDK提供的stop()、destroy()方法【已废弃】 推荐线程自己停下来 建议使用一个标志位来终止变量 当flag=false ,则终止线程运行 package thread; //测试stop //1.建议线程正常停止---&gt;利用次数 不建议死循环 //2.建议使用标志位---》设置一个标志位 //3.不要使用stop、destroy等过时或者JDK不建议·使用的方法 public class ThreadStop implements Runnable { //设置一个标志位 private Boolean flag=true; @Override public void run() { int i=0; while(flag){ System.out.println(&quot;run...Thread&quot;+i++); } } public void stop(){ this.flag=false; } public static void main(String[] args) { ThreadStop threadStop = new ThreadStop(); new Thread(threadStop).start(); for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;main&quot;+i); if (i==900){ threadStop.stop(); System.out.println(&quot;线程停止&quot;); } } } } 线程休眠 sleep(时间) 指定当前阻塞的毫秒数； sleep存在异常InterruptedException sleep时间达到后进程进入就绪状态 sleep可以模拟网络延时 倒计时等 每一个对象都有一个锁 sleep不会释放锁 模拟网络延时：放大问题的发生性 见火车票的例子 模拟倒计时 package thread; import java.text.SimpleDateFormat; import java.util.Date; //模拟倒计时 public class ThreadSleep { public static void main(String[] args) { try { tendown(); } catch (InterruptedException e) { e.printStackTrace(); } //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取当前系统时间 while(true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tendown() throws InterruptedException { int num=10; while(true){ Thread.sleep(1000); System.out.println(num--); if(num&lt;=0){ break; } } } } 10 9 8 7 6 5 4 3 2 1 10:23:37 10:23:38 10:23:39 10:23:40 10:23:41 10:23:42 10:23:43 线程礼让 yield 礼让：让cpu调度 礼让不一定成功 package thread; //测试礼让线程 public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,&quot;a&quot;).start(); new Thread(myYield, &quot;b&quot;).start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;线程开始执行了&quot;); Thread.yield(); System.out.println(Thread.currentThread().getName()+&quot;线程结束了&quot;); } } (礼让失败) a线程开始执行了 a线程结束了 b线程开始执行了 b线程结束了 （礼让成功） a线程开始执行了 b线程开始执行了 a线程结束了 b线程结束了 线程状态观测 package thread; public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for (int i = 0; i &lt; 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;//&quot;); }); Thread.State state = thread.getState();//获得状态 System.out.println(state); thread.start(); state = thread.getState(); System.out.println(state); while(state!= Thread.State.TERMINATED) {//只要线程不终止 一直输出状态 Thread.sleep(1000); state = thread.getState(); System.out.println(state); } } } NEW RUNNABLE TIMED_WAITING TIMED_WAITING TIMED_WAITING TIMED_WAITING TIMED_WAITING // TERMINATED NEW RUNNABLE BLOCKED WAITING TERMINATED 死亡的线程不能再次start 线程的优先级 Priority 优先级 从1到10 使用以下方法来获取或改变优先级 getPriority() .setPriority() package thread; public class TestPrority { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority()); MyPrority myPrority = new MyPrority(); Thread t1 = new Thread(myPrority,&quot;t1&quot;); Thread t2 = new Thread(myPrority,&quot;t2&quot;); Thread t3 = new Thread(myPrority,&quot;t3&quot;); Thread t4 = new Thread(myPrority,&quot;t4&quot;); Thread t5 = new Thread(myPrority,&quot;t5&quot;); Thread t6 = new Thread(myPrority,&quot;t6&quot;); //先设优先级 后启动 t1.start(); t2.setPriority(3); t2.start(); t3.setPriority(7); t3.start(); t4.setPriority(10); t4.start(); /*t5.setPriority(-1);//低于边界1 抛出异常 t5.start(); t6.setPriority(11);//高于边界10 抛出异常 t6.start();*/ } } class MyPrority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority()); } } main--&gt;5 t1--&gt;5 t2--&gt;3 t3--&gt;7 t4--&gt;10//优先级并不能决定先后顺序 仍有cpu调度 优先级低只是意味获得调度的概率低 注意 建议在调用start()前设置优先级 守护线程（daemon） package thread; public class TestDaemon { public static void main(String[] args) { You2 you = new You2(); God god = new God(); Thread thread = new Thread(god); thread.setDaemon(true);//默认false true启动守护线程 thread.start(); new Thread(you).start(); } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(&quot;上帝永生&quot;); } } } class You2 implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 30000; i++) { System.out.println(&quot;你幸福的面对每天升起的太阳&quot;); } System.out.println(&quot;你没能再见到清晨的朝阳&quot;); } } 虚拟机必须确保用户线程执行完毕 不用等待守护线程执行完毕 线程同步（synchronized） 并发：同一个对象被多个线程同时操作 三大不安全实例 package thread.unsafe; public class UnsafeStation { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,&quot;学生&quot;).start(); new Thread(station,&quot;工人&quot;).start(); new Thread(station,&quot;黄牛党&quot;).start(); } } class BuyTicket implements Runnable{ //票 int ticketnums=10; Boolean flag=true; @Override public void run() { while(flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } //买票 public void buy() throws InterruptedException { if(ticketnums&lt;1){ flag =false; return; } Thread.sleep(100); System.out.println(Thread.currentThread().getName()+&quot;获得第&quot;+ticketnums--+&quot;张票&quot;); } } package thread.unsafe; public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100,&quot;结婚基金&quot;); Drawing you = new Drawing(account,50,&quot;你&quot;); Drawing girlfriend = new Drawing(account,100,&quot;girlfriend&quot;); you.start(); girlfriend.start(); } } //账户 class Account{ int accountMoney; String name; public Account(int accountMoney, String name) { this.accountMoney = accountMoney; this.name = name; } } //取钱 class Drawing extends Thread{ Account account; int drawMoney; int nowMoney; @Override public void run() { if(account.accountMoney-drawMoney&lt;0){ System.out.println(Thread.currentThread().getName()+account.name+&quot;余额不足&quot;); return; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } account.accountMoney=account.accountMoney-drawMoney; nowMoney=nowMoney+drawMoney; System.out.println(account.name+&quot;余额为&quot;+account.accountMoney); System.out.println(this.getName()+&quot;手里的钱&quot;+nowMoney); //Thread.currentThread().getName()=this.getName() } //取钱 public Drawing(Account account, int drawMoney,String name) { super(name); this.account = account; this.drawMoney = drawMoney; } } 结婚基金余额为-50 girlfriend手里的钱100 结婚基金余额为-50 你手里的钱50 package thread.unsafe; import java.util.ArrayList; import java.util.List; public class UnsafeList { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 100000; i++) { new Thread(() -&gt; { list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 99996 同步方法 关键字：synchronized 保证数据对象只能被方法访问 包括synchronized方法和synchronized块 synchronized 控制对对象的访问 每个对象对应一把锁 方法一旦执行 就独占该锁 锁的对象应该是变化的量，需要增添改 买车票 private synchronized void buy() throws InterruptedException { 把sleep放run里面 工人获得第10张票 黄牛党获得第9张票 学生获得第8张票 工人获得第7张票 黄牛党获得第6张票 学生获得第5张票 工人获得第4张票 学生获得第3张票 黄牛党获得第2张票 工人获得第1张票 安全 银行 使用块 public void run() { //synchronized块 synchronized (account) { if (account.accountMoney - drawMoney &lt; 0) { System.out.println(Thread.currentThread().getName() + account.name + &quot;余额不足&quot;); return; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } account.accountMoney = account.accountMoney - drawMoney; nowMoney = nowMoney + drawMoney; System.out.println(account.name + &quot;余额为&quot; + account.accountMoney); System.out.println(this.getName() + &quot;手里的钱&quot; + nowMoney); //Thread.currentThread().getName()=this.getName() } } 直接锁函数不行 直接锁函数锁Drawing类 但改变的是Account类 故不行 同步块：synchronized(obj){} obj称之为同步监视器 obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器 因为同步方法的同步监视器就是这个对象本身，就是this，或者class 同步监视器执行过程： 1.第一个线程访问，锁定同步监视器，执行其中代码 2.第二个线程访问，发现同步监视器被锁定，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问。发现同步监视器没有锁，然后锁定并访问 JUC package thread; import java.util.concurrent.CopyOnWriteArrayList; // 测试JUC安全类型的集合 public class TestJuc { public static void main(String[] args) throws InterruptedException { CopyOnWriteArrayList&lt;String&gt; list =new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) { new Thread(() -&gt;{ list.add(Thread.currentThread().getName()); }).start(); } Thread.sleep(3000); System.out.println(list.size()); } } 死锁 某一个同步块 同时拥有 &quot;两个以上对象的锁&quot;时，就会可能发生”死锁“的问题 package thread; //多个线程抱着对方需要的资源，然后形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0, &quot;灰姑娘&quot;); Makeup g2 = new Makeup(1, &quot;白雪公主&quot;); g1.start(); g2.start(); } } //口红 class Tipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //仅获得一份资源 static Tipstick tipstick =new Tipstick(); static Mirror mirror =new Mirror(); int choice; String girlName; public Makeup(int choice, String girlName) { this.choice = choice; this.girlName = girlName; } @Override public void run() { //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup() throws InterruptedException { if (choice==0){ synchronized (tipstick) {//获得口红的锁 System.out.println(this.girlName + &quot;获得口红&quot;); Thread.sleep(1000); synchronized (mirror) {//获得镜子的锁 System.out.println(this.girlName + &quot;获得镜子&quot;); } } }else{ synchronized (mirror) {//获得镜子的锁 System.out.println(this.girlName + &quot;获得镜子&quot;); Thread.sleep(2000); synchronized (tipstick) {//获得口红的锁 System.out.println(this.girlName + &quot;获得口红&quot;); } } } } } 灰姑娘获得口红 白雪公主获得镜子 僵持 将锁拿出来 package thread; //多个线程抱着对方需要的资源，然后形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0, &quot;灰姑娘&quot;); Makeup g2 = new Makeup(1, &quot;白雪公主&quot;); g1.start(); g2.start(); } } //口红 class Tipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //仅获得一份资源 static Tipstick tipstick =new Tipstick(); static Mirror mirror =new Mirror(); int choice; String girlName; public Makeup(int choice, String girlName) { this.choice = choice; this.girlName = girlName; } @Override public void run() { //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup() throws InterruptedException { if (choice==0){ synchronized (tipstick) {//获得口红的锁 System.out.println(this.girlName + &quot;获得口红&quot;); Thread.sleep(1000); } synchronized (mirror) {//获得镜子的锁 System.out.println(this.girlName + &quot;获得镜子&quot;); } }else{ synchronized (mirror) {//获得镜子的锁 System.out.println(this.girlName + &quot;获得镜子&quot;); Thread.sleep(2000); } synchronized (tipstick) {//获得口红的锁 System.out.println(this.girlName + &quot;获得口红&quot;); } } } } 灰姑娘获得口红 白雪公主获得镜子 白雪公主获得口红 灰姑娘获得镜子 弹幕说：锁不能嵌套？ 在理解理解。。。 Lock(锁) Lock对象 reentrantlock 不安全 package thread; //测试Lock public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2,&quot;a&quot;).start(); new Thread(testLock2,&quot;b&quot;).start(); new Thread(testLock2,&quot;c&quot;).start(); } } class TestLock2 extends Thread{ int sticknums=10; @Override public void run() { while(true){ if(sticknums&gt;0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+sticknums--); }else{ break; } } } } c9 b10 a10 b8 a6 c7 a5 c4 b4 b3 c2 a1 加锁 package thread; import java.util.concurrent.locks.ReentrantLock; //测试Lock public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2,&quot;a&quot;).start(); new Thread(testLock2,&quot;b&quot;).start(); new Thread(testLock2,&quot;c&quot;).start(); } } class TestLock2 extends Thread{ int sticknums=10; //加锁 private final ReentrantLock lock =new ReentrantLock(); @Override public void run() { while(true){ lock.lock(); try { if(sticknums&gt;0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+sticknums--); }else{ break; } } finally { lock.unlock(); } } } } a10 a9 a8 a7 a6 a5 a4 a3 a2 a1 因为sleep在锁里面 且等待时不会释放锁 故变为单线程执行 改进 ： 将sleep拿出锁 package thread; import java.util.concurrent.locks.ReentrantLock; //测试Lock public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2,&quot;a&quot;).start(); new Thread(testLock2,&quot;b&quot;).start(); new Thread(testLock2,&quot;c&quot;).start(); } } class TestLock2 extends Thread{ int sticknums=10; //加锁 private final ReentrantLock lock =new ReentrantLock(); @Override public void run() { while(true){ try { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } lock.lock(); if(sticknums&gt;0){ System.out.println(Thread.currentThread().getName()+sticknums--); }else{ break; } } finally { lock.unlock(); } } } } b10 c9 a8 b7 a6 c5 b4 a3 c2 b1 成功！！！！ Lock显示锁 synchronized 隐式锁 private final ReentrantLock lock =new ReentrantLock(); 线程协作 线程通信 均是Object类 都只能在同步方法或同步块中使用 wait():表示线程会一直等待，直到其他线程通知，与sleep不同，会释放锁 wait(long timeout)：指定等待的毫秒数 notify()唤醒一个处于等待的线程 notifyAll():唤醒同一个对象上所有的wait()方法的线程，优先级别高的线程优先调度 代码有些问题。。 感觉消费与生产次数不对 有时候出现连着10几次生产 希望以后的明白为什么 package thread.Communication; //消费者生产者模式 管程法 //生产者 消费者 产品 缓冲区 public class TestPc { public static void main(String[] args) { synContainer container = new synContainer(); Productor productor = new Productor(container); Consumer consumer = new Consumer(container); new Thread(productor).start(); new Thread(consumer).start(); } } //生产者 class Productor extends Thread{ synContainer container; public Productor(synContainer container) { this.container = container; } @Override public void run() { for (int i = 1; i &lt; 100; i++) { container.push(new Chicken(i)); System.out.println(&quot;生产了第&quot;+i+&quot;只鸡&quot;); } } } //消费者 class Consumer extends Thread{ synContainer container; public Consumer(synContainer container) { this.container = container; } @Override public void run() { for (int i = 1; i &lt; 100; i++) { System.out.println(&quot;消费了-&gt;&quot;+container.pop().id+&quot;只鸡&quot;); } } } //产品 鸡 class Chicken { int id;//产品标号 public Chicken(int id) { this.id = id; } } class synContainer { Chicken[] chickens=new Chicken[10]; int count=0; public synchronized void push(Chicken chicken) { while(count==chickens.length){//判断是否生产 如果已满 生产等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } chickens[count]= chicken; count++; this.notifyAll(); } public synchronized Chicken pop() { while (count==0){//判断是消费 如果为0 消费等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } count--; Chicken chicken = chickens[count]; this.notifyAll(); return chicken; } } package thread.Communication; public class TestPC2 { public static void main(String[] args) { Show show = new Show(); new Actor(show).start(); new Audience(show).start(); } } //演员 class Actor extends Thread{ Show show; public Actor(Show show) { this.show = show; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { if(i%5!=0){ this.show.play(&quot;快乐大本营播放中&quot;); }else{ this.show.play(&quot;广告投放中。。&quot;); } } } } //观众 class Audience extends Thread{ Show show; public Audience(Show show) { this.show = show; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { show.watch(); } } } //节目 class Show{ //演员表演 观众等待 //观众观看 演员等待 String video;//节目 boolean flag=true; //表演 public synchronized void play( String video) { if(!flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;演员表演了&quot; + video); //通知观众观看 this.notifyAll(); this.video = video; this.flag = !flag; } //收看 public synchronized void watch() { if(flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;观众收看了&quot; + video); //通知演员表演 this.notifyAll(); this.flag = !flag; } } 演员表演了广告投放中。。 观众收看了广告投放中。。 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了广告投放中。。 观众收看了广告投放中。。 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了广告投放中。。 观众收看了广告投放中。。 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了广告投放中。。 观众收看了广告投放中。。 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 演员表演了快乐大本营播放中 观众收看了快乐大本营播放中 信号灯法 看起来就舒服了些 大概是因为没有储存 线程池 储存提前创建的线程 使用时直接获取 实现重复利用 好处 提高响应速度（减少创建新线程的时间） 降低资源消耗 便于线程管理 corePoolSIze:核心池的大小 maximumPoolSIze:最大线程数 keepAliveTime: 线程没有任务时最多保持多长时间后会终止 package thread; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestPool { public static void main(String[] args) { //1.创建 ExecutorService service = Executors.newFixedThreadPool(10); //2.执行 service.execute(new MyTest()); service.execute(new MyTest()); service.execute(new MyTest()); service.execute(new MyTest()); //3.关闭 service.shutdown(); } } class MyTest implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } pool-1-thread-1 pool-1-thread-4 pool-1-thread-2 pool-1-thread-3 ","link":"https://ganhan999.github.io/post/Java多线程编程/"},{"title":"171、Excel表列序号","content":"题目 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 示例 1: 输入: &quot;A&quot; 输出: 1 示例 2: 输入: &quot;AB&quot; 输出: 28 示例 3: 输入: &quot;ZY&quot; 输出: 701 本体思路 26进制转10进制 #我的做法： class Solution: def titleToNumber(self, s: str) -&gt; int: ans = 0 lens = len(s) for i, s in enumerate(s): print(lens-i-1) ans = ans +(ord(s)-ord('A')+1)*26**(lens-i-1) return ans &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： ans*26相当于每次都往左边平移一位，给最右边一个位置 class Solution(object): def titleToNumber(self, s): ans = 0 for x in s: ans *= 26 ans += ord(x) - ord('A') + 1 return ans ","link":"https://ganhan999.github.io/post/171、Excel表列序号/"},{"title":"Java网络编程","content":"1.1、概述 信件： 打电话：---连接---接了---通话 TCP 发短信：---发送了就完事了---接收 UDP 计算机网络： 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确地定位网络上的一台主机：（端口），定位到这个计算机的某个资源。 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S 网络编程：TCP/IP C/S 1.2、网络通信的要素 如何实现网络上的通信？ 通信双方地址： （192.168.1.1）：局域网。。 ip： 端口号 规则：网络通信的协议： TCP/IP参考模型： HTTP：超文本传输协议 FTP:文件上传协议 小结： 1、网络编程中有两个主要的问题： 如何准确的定位到网络上的一台或者多台主机 找到主机之后如何进行通信 2、网络编程中的要素 IP和端口号 IP 网络通信协议 UDP，TCP 3、万物皆对象 1.3、IP ip地址：inetAddress 唯一定位一台网络上计算机 127.0.0.1：本机loaclhost Ip地址的分类 Ipv4/Ipv6 IPv4 127.00.1,四个字节组成，0-255，42亿~；30亿都在北美，亚洲四亿，2011年就用尽； IPV6：128位，8个无符号整数！ 公网（互联网）-私网（局域网） ABCD类地址 192.168.xx.xx专门给组织内部使用的 域名：记忆IP问题！ IP： package Second11_16; import java.net.InetAddress; import java.net.UnknownHostException; public class TestInetAddres { public static void main(String[] args) { try { //查询网站IP地址 InetAddress allByName = InetAddress.getByName(&quot;localhost&quot;); System.out.println(allByName); //常用方法： System.out.println(allByName.getHostAddress());//IP System.out.println(allByName.getHostName());//名字 System.out.println(allByName.getCanonicalHostName());//规范的名字 } catch (UnknownHostException e) { e.printStackTrace(); } } } 1.4、端口(port) 端口表示计算机上的一个程序的进程 不同的进程有不同的端口号！用来区分软件！ 被规定0-65535 TCP,UDP：65536*2 tcp:80,udp:80? 单个协议下，端口不能冲突、 端口分类： 公有端口0~1023 HTTP:80 https:443 FTP:21 Telent:23 程序注册端口：1024~49151 Tomcat: 8080 MySQL: 3306 Oracle： 1521 动态/私有：49152~65535 1、netstat -ano #查看所有的端口 2、netstat -ano|findstr &quot;9640&quot; # 查看指定的窗口 其中|是指先干后面的再在前面中找 3、tasklist|findstr &quot;8696&quot; #查看指定端口的进程 package Second11_16; import java.net.InetSocketAddress; public class TestInetSocketAddres { public static void main(String[] args) { InetSocketAddress inetSocketAddress1 = new InetSocketAddress(&quot;127.0.0.1&quot;, 8080); InetSocketAddress inetSocketAddress2 = new InetSocketAddress(&quot;localhost&quot;, 8080); System.out.println(inetSocketAddress1); System.out.println(inetSocketAddress2); System.out.println(inetSocketAddress2.getAddress()); System.out.println(inetSocketAddress2.getHostName());//地址 System.out.println(inetSocketAddress2.getPort());//端口 } } 1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议：速率，传输码率，代码结构，传输控制。。。。。。 问题：非常的复杂 大事化小：分层！ TCP/IP协议簇：实际上是一层协议 重要： TCP:用户传输协议 UDP:用户数据报协议 出名的协议： TCP： IP：网络互联协议 ps:应用层：QQ、微信；传输层：通信；网络层：分包；数据链路层：具体的传输：如光纤，海底电缆。。。。。。； TCP UDP对比： TCP：打电话 连接，稳定 三次握手、四次挥手 最少需要三次，才能保证稳定连接！ A；你愁啥？ B：瞅你咋地？ A：干一场！ A：我要走了 B：你真的要走了吗？ B：你真的真的要走了吗？ A：我真的要走了！ 客户端、服务端 传输完成，释放连接，效率低 UDP：发短信 不连接，不稳定 客户端、服务端：没有明确的界限 不管有没有准备好，都可以发给你。。。 导弹攻击 DDOS：洪水攻击！（饱和攻击） 1.6、TCP 有关socket的知识分享：https://www.cnblogs.com/dolphinx/p/3460545.html SeverSocket: 为了使客户能成功地连接到服务器，服务器必须建立一个ServerSocket 对象，该对象通过将客户端地套接字对象和服务器端地一个套接字对象连接起来，从而达到连接的目的。 客户端:(socket对象)socket(IP地址，端口) 服务器:(ServerSocket对象)serversocket(端口 )用ServerSocket.accept（）来建立一个和客户端的Socket对象相连接的Socket对象。 服务器端的输出流/输入流的目的地和客户端的输入流/输出流的源刚好相同。 进程堵塞 提升作用域 文件上传 服务器端： package lesson03; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TCPserver02 { public static void main(String[] args) throws IOException { //建立连接，创建服务 ServerSocket serverSocket= new ServerSocket(9900); // 监听客户端的连接 Socket socket = serverSocket.accept(); //创立输入流和文件输出流 InputStream is = socket.getInputStream(); // 文件输出 FileOutputStream fos = new FileOutputStream(new File(&quot;JTest3.png&quot;)); //创立缓冲区和写 byte[] buff=new byte[1024]; int len; while((len=is.read(buff))!=-1){ fos.write(buff,0,len); } //与客户端说我已经收到了 OutputStream os =socket.getOutputStream(); os.write(&quot;我已接收&quot;.getBytes()); //关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } /* 1、接收要read，所以要用inputStream 2、要把文件写给大家看，所以要fileoutputstream */ 客户端： package lesson03; import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; public class TCPclient02 { public static void main(String[] args) throws IOException { //建立连接 Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9900); //建立输出流和文件输入流 OutputStream os =socket.getOutputStream(); FileInputStream fis = new FileInputStream(new File(&quot;JavaKuangStudy/network programming/src/ImageData/Test.png&quot;)); //缓冲区之后 //需要转换格式 //写出文件 byte[] buff = new byte[1024];//划定空间 int len; while((len= fis.read(buff))!=-1){ os.write(buff,0,len); } //确定服务器接收完毕才能断开连接。 //发送成功后关闭输出流 //通知服务器我已经输出结束了 socket.shutdownOutput(); //接收来自服务端的消息，用数组流来输出 InputStream is = socket.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len1; byte[] buff1 = new byte[1024];//初始内存空间大小 while((len1=is.read(buff1))!=-1){ bos.write(buff1,0,len1); } System.out.println(bos.toString()); //关闭资源 bos.close(); is.close(); fis.close(); os.close(); socket.close(); } } /* 1、抛出异常 2、套接字的get输入输出流 3、通知服务器，我已经输出结束了：socket.shutdownOutput(); 4、while（（len=is.read(buff)）!=-1）{ bos.write(buff,0,len); 5、while和0-长度 } */ Tomcat 调试：consolehandler:GBK 服务端 自定义（S） Tomcat服务器(S)：Java后台开发用别人的服务器！ 客户端 自定义（C） 浏览器(B) 1.7、UDP 发短信：不用连接，需要知道对方的地址！ 发送消息 发送端 package Udp01; import java.net.*; //不需要连接服务器 public class UdpTest02 { public static void main(String[] args) throws Exception { //建立一个socket DatagramSocket socket=new DatagramSocket(); //建个包 InetAddress inetAddress=InetAddress.getByName(&quot;localhost&quot;); byte[] Str= &quot;你好&quot;.getBytes(); int port=9999; //数据，数据的长度起始，要发送给谁 DatagramPacket datagramPacket=new DatagramPacket(Str,0,Str.length,inetAddress,port); //发送包 socket.send(datagramPacket); //关闭流 socket.close(); } } 接收端： package Udp01; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的链接 public class UdpTest01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket=new DatagramSocket(9999); while (true) { //接收数据包 byte[] Strin = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(Strin, 0, Strin.length); //阻塞接收 socket.receive(datagramPacket); System.out.println(new String(datagramPacket.getData(), 0, datagramPacket.getLength())); //关闭链接 socket.close(); } } } 咨询 循环发送消息 发送方： package UDP.Udp02; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; public class UdpSin { public static void main(String[] args) throws Exception { DatagramSocket datagramSocket=new DatagramSocket(8888); while (true){ //准备数据，控制台读取System.in BufferedReader buf=new BufferedReader(new InputStreamReader(System.in)); //读取控制台输入的一行并把它转化为字符 String Buf=buf.readLine(); InetAddress inetAddress=InetAddress.getByName(&quot;localhost&quot;); DatagramPacket datagramPacket=new DatagramPacket(Buf.getBytes(),0,Buf.length(),inetAddress,9999 ); datagramSocket.send(datagramPacket); if(Buf.equals(&quot;bye&quot;)) break; } datagramSocket.close(); } } /* 1、BuffReader读取控制台字符时用readLine来读取一行 */ 接收方： package UDP.Udp02; import java.net.DatagramPacket; import java.net.DatagramSocket; public class UdpSin01 { public static void main(String[] args) throws Exception{ //建立链接 DatagramSocket datagramSocket = new DatagramSocket(9999); byte[] bufin = new byte[1024]; while (true) { //准备接收包裹 DatagramPacket datagramPacket = new DatagramPacket(bufin, 0, bufin.length); datagramSocket.receive(datagramPacket);//阻塞时接收包裹 byte[] data=datagramPacket.getData(); String msg=new String(data,0,data.length); System.out.println(msg); if(msg.equals(&quot;bye&quot;)){ break; } datagramSocket.close(); } } } /* 1、创建对象 while之外 2、接收包裹.getData */ 在线咨询：两个人都可以发送 发送端线程： package UDP.Run; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.InetSocketAddress; public class Sent implements Runnable{ DatagramSocket datagramSocket; DatagramPacket datagramPacket; private int fromPort; private String toIP; private int Toport; BufferedReader bufferedReader; String buf; public Sent(int fromPort, String toIP, int Toport) { this.fromPort = fromPort; this.toIP = toIP; this.Toport = Toport; try { this.datagramSocket = new DatagramSocket(fromPort); } catch (Exception e) { e.printStackTrace(); } } @Override public void run() { while(true){ try { bufferedReader=new BufferedReader(new InputStreamReader(System.in)); buf=bufferedReader.readLine(); byte[] buff=buf.getBytes(); datagramPacket= new DatagramPacket(buff,0,buff.length,new InetSocketAddress(this.toIP,this.Toport)); datagramSocket.send(datagramPacket); if (buf.equals(&quot;bye&quot;)){ break; } } catch (IOException e) { e.printStackTrace(); } } datagramSocket.close(); } } /*今日忘记 1、IP:String 2、DatagramSocket(端口) 2、BuffReader（输入流）； 3、发送要把String变成数组 */ 接收端线程： package UDP.Run; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Receive implements Runnable{ DatagramSocket datagramSocket; DatagramPacket datagramPacket; private String FromID; private int Port; public Receive(String fromID, int port) { this.FromID = fromID; this.Port = port; try { datagramSocket=new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { while (true) { try { byte[] buff = new byte[1024]; datagramPacket = new DatagramPacket(buff, 0, buff.length); datagramSocket.receive(datagramPacket); byte[] data=datagramPacket.getData(); String msg=new String(data,0,data.length); System.out.println(FromID + &quot;:&quot; +msg); if (datagramPacket.equals(&quot;bye&quot;)) { break; } } catch (IOException e) { e.printStackTrace(); } } datagramSocket.close(); } } //重新定义数组 学生端： package UDP.Run; import UDP.Run.Receive; import UDP.Run.Sent; public class Student { public static void main(String[] args) { new Thread(new Sent(7754,&quot;localhost&quot;,9999)).start(); new Thread(new Receive(&quot;老师：&quot;,7787)).start(); } } //线程要启动 老师端： package UDP.Run; import UDP.Run.Receive; import UDP.Run.Sent; public class Teacher { public static void main(String[] args) { new Thread(new Sent(7755,&quot;localhost&quot;,7787)).start(); new Thread(new Receive(&quot;学生：&quot;,9999)).start(); } } 1.8、URL https://www.baidu.com/ 统一资源定位符：定位资源，定位互联网上某一个资源 DNS域名解析 WWW.baidu import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; public class Url { public static void main(String[] args) throws IOException { URL url=new URL(&quot;https://m801.music.126.net/20201123231609/7a60a829f966abbdfc75ee0756ed0ff9/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/4916388353/e2fe/8be5/e1e6/c7614d21f4afc33120723d86e09d330d.m4a&quot;); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); InputStream in=urlConnection.getInputStream(); FileOutputStream Fout=new FileOutputStream(&quot;d.m4a&quot;); byte[] buff=new byte[1024]; int len; while ((len=in.read(buff))!=-1){ Fout.write(buff,0,len); } Fout.close(); in.close(); urlConnection.disconnect(); } } ","link":"https://ganhan999.github.io/post/Java 网络编程/"},{"title":"169、多数元素","content":"题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 本体思路 排序之后，找最中间这个就行了 #我的做法： class Solution: def majorityElement(self, nums: List[int]) -&gt; int: nums.sort() return nums[(1+len(nums)//2)-1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 摩尔投票法，只适合占一半以上的情况 这就相当于每个“多数元素”和其他元素两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。 无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。 class Solution(object): def majorityElement(self, nums: List[int]) -&gt; int: major = 0 count = 0 for n in nums: if count == 0: major = n if n == major: count = count + 1 else: count = count - 1 return major ","link":"https://ganhan999.github.io/post/169、多数元素/"},{"title":"168、Excel表列名称","content":"题目 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ... 示例 1: 输入: 1 输出: &quot;A&quot; 示例 2: 输入: 28 输出: &quot;AB&quot; 示例 3: 输入: 701 输出: &quot;ZY&quot; 本体思路 26进制转换，太尼玛离谱了，数字题。 举个例子，52除以26，一直除的话实际上是20，但是0没有对应的位子，所以拆成1 26，所以是AZ，后面借了前面一位 #我的做法： class Solution: def convertToTitle(self, n: int) -&gt; str: str='' if n&lt;=26: return chr(65+n-1) while n!=0: n, rightnum = divmod(n, 26) print(&quot;rightnum----&quot;,rightnum) if rightnum==0: str='Z'+str n=n-1#借一位 else: str=chr(65+rightnum-1)+str return str &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 先减一，再除（难以理解） class Solution: def convertToTitle(self, n: int) -&gt; str: eng = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; n -= 1 if n &lt; 26: return eng[n] return self.convertToTitle(n // 26) + eng[n % 26] ","link":"https://ganhan999.github.io/post/168、Excel表列名称/"},{"title":"Java Gui编程","content":"GUI 核心：Swing AWT 缺点：1.界面不美观2.需要jre环境 2.AWT 2.1Awt介绍 1.包含很多类和接口！GUI 2.元素：窗口 按钮 2.2组件和容器 frame package gui; import java.awt.*; public class TestFrame { public static void main(String[] args) { Frame frame = new Frame(&quot;这是我的第一个Java图像接口设置&quot;); //需要设置可见性 w h frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色color frame.setBackground(new Color(0, 253, 223)); //弹出初始位置 frame.setLocation(200,200); //设置大小不可变 frame.setResizable(false); } } 缺点:不可关闭 解决：停止java运行 package gui.lesson01; import java.awt.*; public class TestFrame02 { public static void main(String[] args) { MyFrame myFrame1 = new MyFrame(Color.blue, 100, 100, 200, 200); MyFrame myFrame2 = new MyFrame(Color.yellow, 300, 100, 200, 200); MyFrame myFrame3 = new MyFrame(Color.red, 100, 300, 200, 200); MyFrame myFrame4 = new MyFrame(Color.orange, 300, 300, 200, 200); } } class MyFrame extends Frame { static int id=0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(Color color,int x,int y,int w,int h){ super(&quot;Myframe+&quot;+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); } } panel package gui.lesson01; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //panel 面板可以看作一个空间，但不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //坐标 frame.setBackground(new Color(0xFFB700)); frame.setBounds(300,400,500,600); //panel 坐标 相对于frame panel.setBackground(Color.BLUE); panel.setBounds(100,200,300,300); //frame.add(panel) frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 system.exit(0)关闭 //适配器模式：adapted frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 可以关闭 布局管理器 流式布局 东西南北中 表格布局 package gui.lesson01; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件 button Button button1 = new Button(&quot;button1&quot;); Button button2 = new Button(&quot;button2&quot;); Button button3 = new Button(&quot;button2&quot;); //设置流式布局 //frame.setLayout(new FlowLayout(FlowLayout.LEFT));//靠左 //frame.setLayout(new FlowLayout(FlowLayout.RIGHT));//靠右 frame.setLayout(new FlowLayout());//居中 frame.setSize(200,200); //添加按钮 frame.add(button1); frame.add(button2); frame.add(button3); //frame可视化 frame.setVisible(true); //frame关闭 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.exit(0); } }); } } 东西南北中 package gui.lesson01; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(); Button earth = new Button(&quot;earth&quot;); Button west = new Button(&quot;west&quot;); Button south = new Button(&quot;south&quot;); Button north= new Button(&quot;north&quot;); Button center = new Button(&quot;center&quot;); frame.add(earth,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setSize(200,200); frame.setVisible(true); //监听 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.exit(0); } }); } } 表格grid package gui.lesson01; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(&quot;TestGridLayout&quot;); Button but1 = new Button(&quot;but1&quot;); Button but2 = new Button(&quot;but2&quot;); Button but3 = new Button(&quot;but3&quot;); Button but4 = new Button(&quot;but4&quot;); Button but5 = new Button(&quot;but5&quot;); Button but6 = new Button(&quot;but6&quot;); frame.setLayout(new GridLayout(3,2)); frame.add(but1); frame.add(but2); frame.add(but3); frame.add(but4); frame.add(but5); frame.add(but6); frame.pack();//java函数 寻找适合布局 frame.setVisible(true); } } 练习题 构思：1个 frame 2.4个面板 border 左button 中panel 右button package gui.lesson01; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestLesson { public static void main(String[] args) { Frame frame = new Frame(&quot;课堂练习&quot; ); frame.setSize(100,200); frame.setLocation(100,100); frame.setBackground(new Color(0, 253, 149)); frame.setLayout(new GridLayout(2,3)); Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); p1.add(new Button(&quot;EAST-1&quot;),BorderLayout.EAST); p1.add(new Button(&quot;WEST-1&quot;),BorderLayout.WEST); p2.add(new Button(&quot;p2-btn-1&quot;)); p2.add(new Button(&quot;p2-btn-2&quot;)); p1.add(p2,BorderLayout.CENTER); p3.add(new Button(&quot;EAST-2&quot;),BorderLayout.EAST); p3.add(new Button(&quot;WEST-2&quot;),BorderLayout.WEST); p4.add(new Button(&quot;p4-btn-1&quot;)); p4.add(new Button(&quot;p4-btn-2&quot;)); p4.add(new Button(&quot;p4-btn-3&quot;)); p4.add(new Button(&quot;p4-btn-4&quot;)); p3.add(p4,BorderLayout.CENTER); frame.add(p1); frame.add(p3); Button button3 = new Button(&quot;button3&quot;); Button button4 = new Button(&quot;button4&quot;); Button button5 = new Button(&quot;button5&quot;); Button button6 = new Button(&quot;button6&quot;); Button button7 = new Button(&quot;button7&quot;); Button button8 = new Button(&quot;button8&quot;); Button button9 = new Button(&quot;button9&quot;); Button button10 = new Button(&quot;button10&quot;); frame.pack(); frame.setVisible(true); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.exit(0); } }); } } 总结：1.frame是一个顶级窗口 2.panel 无法单独显示，必须添加到某个容器 3.布局管理器 1.流式 2.东西南北中 3.表格 4.大小、定位、背景颜色、可见性，监听！ 2.3.事件监听 事件监听：当某件事情发生的时候，干什么？ package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent { public static void main(String[] args) { Frame frame = new Frame(); Button button = new Button(); //因为，addActionListener()需要一个ActionListener,所以我们需要构造一个ActionListener MyActionListener myActionListener = new MyActionListener(); button.addActionListener(myActionListener); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;aaa&quot;); } } 多个按钮共享一个事件 package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent2 { public static void main(String[] args) { //两个按钮实现同一个监听 //开始 停止 Frame frame = new Frame(&quot;开始-停止&quot;); Button btn1 = new Button(&quot;start&quot;); Button btn2 = new Button(&quot;stop&quot;);; //可以显示的定义触发会返回的命令，如果不显式定义，则会走默认的值 //可以多个按钮只写一个监听器 btn1.setActionCommand(&quot;btn1-start&quot;); Mymonitor mymonitor = new Mymonitor(); btn1.addActionListener(mymonitor); btn2.addActionListener(mymonitor); frame.add(btn1,BorderLayout.EAST); frame.add(btn2,BorderLayout.WEST); close(frame); frame.pack(); frame.setVisible(true); } public static void close(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class Mymonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //getActionCommand()获得按钮信息 System.out.println(&quot;按钮被执行了:msg=&gt;&quot;+e.getActionCommand()); } } 2.4输入框 package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestText01 { public static void main(String[] args) { //启动！ new MyFrame1(); } } class MyFrame1 extends Frame{ public MyFrame1() { TextField textField = new TextField(); add(textField); //监听文本框输入的文字 //按下回车 就会触发这个输入框的事件 textField.addActionListener(new MyActionListener2()); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field=(TextField)e.getSource();//获得一些资源 System.out.println(field.getText());//获得输入框的文本 field.setText(&quot;&quot;);//null } } 2.5简易计算器 组合+内部类回顾 oop原则：组合&gt;继承 class A extends B{}//继承 class A { public B b; }//组合 12345 package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //建议计算器 public class TestCale { public static void main(String[] args) { new Calculator(); } } //计算器类 class Calculator extends Frame{ public Calculator() { //三个文本框 TextField num1 = new TextField(10);//字符数 TextField num2 = new TextField(10);//字符数 TextField num3 = new TextField(20);//字符数 //一个按钮 Button button = new Button(&quot;=&quot;); //一个标签 Label label = new Label(&quot;+&quot;); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); button.addActionListener(new MyCalcListener(num1,num2,num3)); pack(); setVisible(true); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //监听器类 class MyCalcListener implements ActionListener{ //获得三个变量 private TextField num1,num2,num3; public MyCalcListener(TextField num1,TextField num2 ,TextField num3) { this.num1=num1; this.num2=num2; this.num3=num3; } @Override public void actionPerformed(ActionEvent e) { //1.获得加数与被加数 int n1= Integer.parseInt(num1.getText()); int n2= Integer.parseInt(num2.getText()); //2.将两个数相加 放于第三个框 num3.setText(&quot;&quot;+(n1+n2)); //3.清空前两个框 num1.setText(&quot;&quot;); num2.setText(&quot;&quot;); } } 完全转为面向对象 package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算器 public class TestCale { public static void main(String[] args) { Calculator calculator = new Calculator(); calculator.loadFrame(); } } //计算器类 class Calculator extends Frame{ //属性 TextField num1,num2,num3; //方法 public void loadFrame(){ //三个文本框 num1 = new TextField(10);//字符数 num2 = new TextField(10);//字符数 num3 = new TextField(20);//字符数 //一个按钮 Button button = new Button(&quot;=&quot;); //一个标签 Label label = new Label(&quot;+&quot;); button.addActionListener(new MyCalcListener(this)); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); pack(); setVisible(true); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //监听器类 class MyCalcListener implements ActionListener{ //获得三个变量 Calculator calculator=null; public MyCalcListener(Calculator calculator) { this.calculator=calculator; } @Override public void actionPerformed(ActionEvent e) { //1.获得加数与被加数 int n1= Integer.parseInt(calculator.num1.getText()); int n2= Integer.parseInt(calculator.num2.getText()); //2.将两个数相加 放于第三个框 calculator.num3.setText(&quot;&quot;+(n1+n2)); //3.清空前两个框 calculator.num1.setText(&quot;&quot;); calculator.num2.setText(&quot;&quot;); } } 内部类 更好的包装 package gui.lesson01; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算器 public class TestCale { public static void main(String[] args) { Calculator calculator = new Calculator(); calculator.loadFrame(); } } //计算器类 class Calculator extends Frame{ //属性 TextField num1,num2,num3; //方法 public void loadFrame(){ //三个文本框 num1 = new TextField(10);//字符数 num2 = new TextField(10);//字符数 num3 = new TextField(20);//字符数 //一个按钮 Button button = new Button(&quot;=&quot;); //一个标签 Label label = new Label(&quot;+&quot;); button.addActionListener(new MyCalcListener()); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); pack(); setVisible(true); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } //监听器类 //内部类最大的优势可以畅通无阻的访问外部类 private class MyCalcListener implements ActionListener{ //获得三个变量 @Override public void actionPerformed(ActionEvent e) { //1.获得加数与被加数 int n1= Integer.parseInt(num1.getText()); int n2= Integer.parseInt(num2.getText()); //2.将两个数相加 放于第三个框 num3.setText(&quot;&quot;+(n1+n2)); //3.清空前两个框 num1.setText(&quot;&quot;); num2.setText(&quot;&quot;); } } } 2.6画笔paint package gui.lesson01; import java.awt.*; public class Testpaint { public static void main(String[] args) { new Mypaint().loadFrame(); } } class Mypaint extends Frame{ public void loadFrame(){ setBounds(200,300,400,500); setVisible(true); } @Override public void paint(Graphics g) { //选取颜色 //画笔可以画画 g.setColor(Color.red); g.drawOval(100,100,100,100); g.fillOval(50,50,50,50); g.setColor(Color.GREEN); g.drawRect(100,300,150,150); //养成习惯，画笔用完，将他还原为原来原色 g.setColor(Color.BLACK); } } 2.7鼠标监听 目的：点击鼠标 画点 package gui.lesson01; import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.util.ArrayList; import java.util.Iterator; //鼠标监听 public class TestMouseListener { public static void main(String[] args) { new MyFrame2(&quot;画图&quot;); } } class MyFrame2 extends Frame{ ArrayList points; //画画需要画笔 需要监听鼠标的位置，需要集合来储存这个点的位置 public MyFrame2(String title){ super(title); setBounds(200,200,300,400); //存鼠标的点 points = new ArrayList&lt;&gt;(); //鼠标监听器 在Frame this.addMouseListener(new MyMouselListenner()); setVisible(true); } @Override public void paint(Graphics g) { //画画监听鼠标事件 Iterator iterator = points.iterator(); while(iterator.hasNext()){ Point point =(Point)iterator.next(); g.setColor(Color.blue); g.fillOval(point.x,point.y,10,10); } } //添加一个点到界面上 public void addPoint(Point point){ points.add(point); } //适配器模式 private class MyMouselListenner extends MouseAdapter{ // 鼠标 按下 弹起 按住不动 @Override public void mousePressed(MouseEvent e) { MyFrame2 frame=(MyFrame2)e.getSource(); //我们点击的时候会产生一个点！frame.addpoint()没有方法 自己写 //这个点就是鼠标的点 frame.addPoint(new Point(e.getX(),e.getY())); //需要重画 frame.repaint(); } } } 2.8键盘监听 package gui.lesson01; import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer; import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; //键盘 public class TestKeyListener { public static void main(String[] args) { new KeyFrame(); } } class KeyFrame extends Frame{ public KeyFrame() { setBounds(10,10,100,200); setVisible(true); this.addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { int keyCode= e.getKeyCode(); System.out.println(keyCode); if(keyCode==KeyEvent.VK_UP) { System.out.println(&quot;你按了上键&quot;); } //根据按下不同操作，进行不同处理 } }); } } 2.9窗口监听 package gui.lesson01; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestWindowListener { public static void main(String[] args) { new MyWindowFrame(); } } class MyWindowFrame extends Frame { public MyWindowFrame() { setBounds(100, 100, 200, 300); setBackground(Color.blue); setVisible(true); //addWindowListener(new MyWindowListener()); this.addWindowListener(new WindowAdapter() { @Override public void windowOpened(WindowEvent e) { super.windowOpened(e); } @Override public void windowClosed(WindowEvent e) { super.windowClosed(e); } //激活窗口 @Override public void windowActivated(WindowEvent e) { MyWindowFrame source =(MyWindowFrame) e.getSource(); source.setTitle(&quot;被激活了&quot;); super.windowActivated(e); } @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.exit(0); } }); } } /*class MyWindowListener extends WindowAdapter{ @Override public void windowClosing(WindowEvent e) { setVisible(false);//隐藏窗口 通过按钮 隐藏当前窗口 System.exit(0);//正常退出，非正常推出1 } } }*/ 3.Swing 3.1 窗口 面板 package lesson02; import com.sun.javaws.util.JfxHelper; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJframe().init(); } } class MyJframe extends JFrame{ public void init(){ this.setVisible(true); this.setBounds(10,10,200,200); JLabel jLabel = new JLabel(&quot;欢迎&quot;); this.add(jLabel); //文本居中 jLabel.setHorizontalAlignment(0); Container contentPane = this.getContentPane();//获得容器 contentPane.setBackground(Color.blue); } } 3.2弹窗 package gui.lesson013; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setBounds(100,100,200,300); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //Jframe 放东西 容器 Container container =this.getContentPane(); //绝对布局 container.setLayout(null); //按钮 JButton button = new JButton(&quot;点击弹出一个弹窗&quot;); button.setBounds(30,30,200,50); //点击按钮会弹出一个弹窗 button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { //弹窗 new MyDialog(); } }); //加入容器 container.add(button); } public static void main(String[] args) { new DialogDemo(); } } //弹窗的窗口 class MyDialog extends JDialog{ public MyDialog() { this.setVisible(true); this.setBounds(100,100,500,500); Container container =this.getContentPane(); container.setLayout(null); //container.add(new Label(&quot;我去&quot;)); } } 3.3标签 new JLabel(&quot;xxx&quot;) 1 图标 Icon package gui.lesson013; import javax.swing.*; import java.awt.*; //图标，需要实现类，Frame 继承 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){}//无参构造 public IconDemo(int width,int height){ this.height=height; this.width=width; }//有参构造 public void init(){ IconDemo iconDemo = new IconDemo(30, 30); //图标放在标签，或按钮上 JLabel label = new JLabel(&quot;小图标黑点&quot;, iconDemo, SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,200,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,height,width); } @Override public int getIconWidth() { return this.width; } @Override public int getIconHeight() { return this.height; } } 图片Icon package gui.lesson013; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageIconDome extends JFrame { public ImageIconDome(){ JLabel jLabel = new JLabel(); URL url = ImageIconDome.class.getResource(&quot;萌狗.jpg&quot;);//获得当前包下的文件 ImageIcon imageIcon = new ImageIcon(url); jLabel.setIcon(imageIcon); jLabel.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(jLabel); setBounds(100,100,300,300); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new ImageIconDome(); } } 3.4面板 Jpanel package lesson02; import javax.swing.*; import java.awt.*; public class JpanelDemo extends JFrame { public JpanelDemo(){ Container container = this.getContentPane(); container.setLayout(new GridLayout(2,2,10,10)); JPanel panel1 = new JPanel(new GridLayout(2,2)); JPanel panel2 = new JPanel(new GridLayout(2,1)); JPanel panel3 = new JPanel(new GridLayout(3,1)); JPanel panel4 = new JPanel(new GridLayout(3,2)); panel1.add(new JButton(&quot;1&quot;)); panel1.add(new JButton(&quot;1&quot;)); panel1.add(new JButton(&quot;1&quot;)); panel1.add(new JButton(&quot;1&quot;)); panel2.add(new JButton(&quot;2&quot;)); panel2.add(new JButton(&quot;2&quot;)); panel3.add(new JButton(&quot;3&quot;)); panel3.add(new JButton(&quot;3&quot;)); panel3.add(new JButton(&quot;3&quot;)); panel4.add(new JButton(&quot;4&quot;)); panel4.add(new JButton(&quot;4&quot;)); panel4.add(new JButton(&quot;4&quot;)); panel4.add(new JButton(&quot;4&quot;)); panel4.add(new JButton(&quot;4&quot;)); panel4.add(new JButton(&quot;4&quot;)); container.add(panel1); container.add(panel2); container.add(panel3); container.add(panel4); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new JpanelDemo(); } } JScroll package lesson02; import javax.swing.*; import java.awt.*; public class JscrollDemo extends JFrame { public JscrollDemo(){ JTextArea jTextArea = new JTextArea(30,50); jTextArea.setText(&quot;初次见面 请多多关照&quot;); //Scrollpanel JScrollPane jScrollPane = new JScrollPane(jTextArea); Container container = this.getContentPane(); container.add(jScrollPane); this.setVisible(true); this.setBounds(100,200,300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new JscrollDemo(); } } 3.5按钮 普通按钮： package gui.lesson013; import javax.swing.*; import java.awt.*; import java.net.URL; public class JbuttonDemo extends JFrame { public JbuttonDemo(){ Container container = this.getContentPane(); URL resource = JbuttonDemo.class.getResource(&quot;萌狗.jpg&quot;); ImageIcon imageIcon = new ImageIcon(resource); JButton jButton = new JButton(); jButton.setIcon(imageIcon); jButton.setToolTipText(&quot;图片按钮&quot;); container.add(jButton); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new JbuttonDemo(); } } ! 单选按钮 Jradiobutton package gui.lesson013; import javax.swing.*; import java.awt.*; import java.net.URL; public class JbuttonDemo extends JFrame { public JbuttonDemo(){ Container container = this.getContentPane(); URL resource = JbuttonDemo.class.getResource(&quot;萌狗.jpg&quot;); ImageIcon imageIcon = new ImageIcon(resource); //单选框 JRadioButton radioButton01 = new JRadioButton(&quot;jbutton01&quot;); JRadioButton radioButton02 = new JRadioButton(&quot;jbutton02&quot;); JRadioButton radioButton03 = new JRadioButton(&quot;jbutton03&quot;); //单选框 每次只能选一个 分组 group ButtonGroup group = new ButtonGroup(); group.add(radioButton01); group.add(radioButton02); group.add(radioButton03); container.add(radioButton01,BorderLayout.CENTER); container.add(radioButton02,BorderLayout.NORTH); container.add(radioButton03,BorderLayout.SOUTH); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new JbuttonDemo(); } } 复选按钮JcheckBox package gui.lesson013; import javax.swing.*; import java.awt.*; import java.net.URL; public class JbuttonDemo extends JFrame { public JbuttonDemo(){ Container container = this.getContentPane(); container.setLayout(new FlowLayout()); URL resource = JbuttonDemo.class.getResource(&quot;萌狗.jpg&quot;); ImageIcon imageIcon = new ImageIcon(resource); //多选框 JCheckBox checkBox01 = new JCheckBox(&quot;工资&quot;); JCheckBox checkBox02 = new JCheckBox(&quot;头发&quot;); JCheckBox checkBox03 = new JCheckBox(&quot;感情&quot;); container.add(checkBox01); container.add(checkBox02); container.add(checkBox03); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new JbuttonDemo(); } } 3.6列表 下拉框JcomboBox package gui.Lesson04; import javafx.scene.control.ComboBox; import javax.swing.*; import java.awt.*; public class TestComboBoxDemo extends JFrame { public TestComboBoxDemo() { Container container = this.getContentPane(); JComboBox comboBox = new JComboBox(); comboBox.addItem(null); comboBox.addItem(&quot;正在热映&quot;); comboBox.addItem(&quot;已下架&quot;); comboBox.addItem(&quot;即将上映&quot;); container.add(comboBox); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new TestComboBoxDemo(); } } 列表框 package gui.Lesson04; import javafx.scene.control.ComboBox; import javax.swing.*; import java.awt.*; import java.util.Vector; public class TestComboBoxDemo extends JFrame { public TestComboBoxDemo() { Container container = this.getContentPane(); //String[] content={&quot;1&quot;,&quot;2&quot;,&quot;3&quot;}; Vector vector = new Vector(); JList jList = new JList(vector); vector.add(&quot;太清&quot;); vector.add(&quot;上清&quot;); vector.add(&quot;玉清&quot;); container.add(jList); this.setVisible(true); this.setSize(300,500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new TestComboBoxDemo(); } } 应用场景 选择地区，或者一些单个选项 列表，展示信息，一般是动态扩容 3.7文本框 文本框 package gui.Lesson04; import javax.swing.*; import java.awt.*; public class TestTextDemo01 extends JFrame { public TestTextDemo01() { Container container = this.getContentPane(); //container.setLayout(null); JTextField textField = new JTextField(&quot;hello&quot;); JTextField textField02 = new JTextField(&quot;world&quot;); container.add(textField,BorderLayout.WEST); container.add(textField02,BorderLayout.EAST); this.setVisible(true); this.setSize(300,300); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new TestTextDemo01(); } } 密码框Jpasswordfield package gui.Lesson04; import javax.swing.*; import java.awt.*; public class TestTextDemo01 extends JFrame { public TestTextDemo01() { Container container = this.getContentPane(); //container.setLayout(null); JPasswordField passwordField = new JPasswordField(&quot;asdhkj&quot;); //passwordField.setEchoChar('*'); container.add(passwordField); //container.add(textField02,BorderLayout.EAST); this.setVisible(true); this.setSize(300,300); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new TestTextDemo01(); } } 文本域 见弹窗处 贪吃蛇 帧 如果时间片足够小，就是动画，一秒30帧，一秒60帧。连起来是动画，拆开静态是图片！ 键盘监听 定时器Timer 四部：1.定义数据 2.画到画板 3.事件监听 package gui.game; import javax.swing.*; import java.net.URL; //数据中心 public class Date { public static URL headerURL=Date.class.getResource(&quot;statics/header.png&quot;); public static ImageIcon header= new ImageIcon(headerURL); public static URL bodyURL=Date.class.getResource(&quot;statics/body.png&quot;); public static ImageIcon body= new ImageIcon(bodyURL); public static URL upURL=Date.class.getResource(&quot;statics/up.png&quot;); public static ImageIcon up= new ImageIcon(upURL); public static URL downURL=Date.class.getResource(&quot;statics/down.png&quot;); public static ImageIcon down= new ImageIcon(downURL); public static URL rightURL=Date.class.getResource(&quot;statics/right.png&quot;); public static ImageIcon right= new ImageIcon(rightURL); public static URL leftURL=Date.class.getResource(&quot;statics/left.png&quot;); public static ImageIcon left= new ImageIcon(leftURL); public static URL foodURL=Date.class.getResource(&quot;statics/food.png&quot;); public static ImageIcon food= new ImageIcon(foodURL); } package gui.game; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.util.Random; //游戏面板 public class GamePanel extends JPanel implements KeyListener, ActionListener { //绘制画板，游戏中的所有东西，都是由这个画笔来画 //绘制静态蛇 int length;//蛇的长度 int[] snakeX=new int[600];//25*25为1格 int[] snakeY=new int[600];//25*25为1格 String fx;//方向 //游戏当前的状态 boolean isstart=false;//游戏 //定时器 //Timer timer=new Timer(80,this);//100ms执行一次 //食物坐标 int foodx; int foody; boolean isFail=false;//判定是否失败 Random random = new Random(); int score; int time=80; //定时器 public GamePanel() { init(); //获得焦点和键盘情况 this.setFocusable(true);//获得焦点情况 this.addKeyListener(this);//获得键盘情况 Timer timer=new Timer(time,this);//100ms执行一次 timer.start(); //初始化食物 foodx=25+25*random.nextInt(34); foody=75+25*random.nextInt(24); } public void init(){//初始化 length=3; snakeX[0]=100;snakeY[0]=100;//头 snakeX[1]=75;snakeY[1]=100;//第一个身体 snakeX[2]=50;snakeY[2]=100;//第二个身体 fx=&quot;R&quot;; score=0; } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); //绘制静态面板 this.setBackground(Color.white); Date.header.paintIcon(this,g,25,11);//广告栏 g.fillRect(25,75,850,600);//默认界面 //画食物 Date.food.paintIcon(this,g,foodx,foody); //把小蛇画上去 if(fx.equals(&quot;R&quot;)) { Date.right.paintIcon(this, g, snakeX[0], snakeY[0]);//蛇头初始化向右 }else if(fx.equals(&quot;L&quot;)) { Date.left.paintIcon(this, g, snakeX[0], snakeY[0]); }else if(fx.equals(&quot;U&quot;)) { Date.up.paintIcon(this, g, snakeX[0], snakeY[0]); }else if(fx.equals(&quot;D&quot;)) { Date.down.paintIcon(this, g, snakeX[0], snakeY[0]); } for (int i = 1; i &lt; length; i++) { Date.body.paintIcon(this,g,snakeX[i],snakeY[i]);//第一个身体 } //画积分 g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;,Font.BOLD,18)); g.drawString(&quot;长度&quot;+length,750,35); g.drawString(&quot;得分为&quot;+score,750,55); //游戏状态 if(!isstart){ g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;,Font.BOLD,40)); g.drawString(&quot;按下空格开始游戏&quot;,300,300); } if(isFail){ g.setColor(Color.RED); g.setFont(new Font(&quot;微软雅黑&quot;,Font.BOLD,40)); g.drawString(&quot;游戏失败,得分为：&quot;+score,300,300); } } @Override public void keyPressed(KeyEvent e) { int keyCode=e.getKeyCode();//获得按键是哪一个 if(keyCode==KeyEvent.VK_SPACE) { if(isFail){ isFail=false; init(); } isstart = !isstart;//取反 repaint(); } if(keyCode==KeyEvent.VK_UP &amp;&amp; fx != &quot;D&quot;) { fx=&quot;U&quot;; }else if(keyCode==KeyEvent.VK_DOWN &amp;&amp; fx != &quot;U&quot;) { fx=&quot;D&quot;; }else if(keyCode==KeyEvent.VK_LEFT &amp;&amp; fx != &quot;R&quot;){ fx=&quot;L&quot;; }else if(keyCode==KeyEvent.VK_RIGHT &amp;&amp; fx != &quot;L&quot;){ fx=&quot;R&quot;; } } //事件监听--固定事件来刷新 @Override public void actionPerformed(ActionEvent e) { if(isstart &amp;&amp; !isFail){ //右移 for(int i = length-1;i&gt;0;i--){ snakeX[i]= snakeX[i-1]; snakeY[i]= snakeY[i-1]; } //走向 if (fx.equals(&quot;R&quot;)) { snakeX[0] = snakeX[0] + 25; if (snakeX[0] &gt; 850) { snakeX[0] = 25; } }else if (fx.equals(&quot;L&quot;)) { snakeX[0] = snakeX[0] - 25; if (snakeX[0] &lt; 25) { snakeX[0] = 850; } }else if (fx.equals(&quot;U&quot;)) { snakeY[0] = snakeY[0] - 25; if (snakeY[0] &lt;75) { snakeY[0] = 650; } }else if (fx.equals(&quot;D&quot;)) { snakeY[0] = snakeY[0] + 25; if (snakeY[0] &gt; 650) { snakeY[0] = 75; } } //吃食物 if(snakeX[0]==foodx &amp;&amp; snakeY[0]==foody){ length++;//长度加一 foodx=25+25*random.nextInt(34); foody=75+25*random.nextInt(24); score++; } //失败判断 for (int i = 1; i &lt; length; i++) { if(snakeX[0]==snakeX[i] &amp;&amp; snakeY[0]==snakeY[i] ){ isFail=true; } } repaint();//重置页面 } } @Override public void keyReleased(KeyEvent e) { } @Override public void keyTyped(KeyEvent e) { } } package gui.game; import javax.swing.*; //主启动类 public class Game { public static void main(String[] args) { JFrame frame = new JFrame(); frame.setBounds(10,10,900,750);//计算得到 frame.setResizable(false); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //正常游戏应该在面板上 frame.add(new GamePanel()); frame.setVisible(true); } } 只是浅显的笔记 为了自己以后复习用 ","link":"https://ganhan999.github.io/post/Java Gui编程/"},{"title":"167、两数之和 II - 输入有序数组","content":"题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 本体思路 参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。 个人理解这种办法相较于方法一其实就是字典记录了 num1 和 num2 的值和位置，而省了再查找 num2 索引的步骤。 用枚举的方式，构造哈希表 #我的做法： class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: hashmap={} for i,j in enumerate(numbers): hashmap[j]=i for n,m in enumerate(numbers): number=hashmap.get(target-m) if number is not None and n!=number: return[n+1,number+1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 二分查找 class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for i in range(len(numbers)): target1 = target - numbers[i] left , right = i+1 , len(numbers) - 1 while left &lt;= right: mid = (left+right)//2 if target1 &lt; numbers[mid]: right = mid - 1 elif target1 &gt; numbers[mid]: left = mid + 1 else: return [i+1,mid+1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 双指针分别指向最左和最右元素，如果两边之和大于target，那么右指针左移，否则左指针右移。 class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left , right = 0 , len(numbers)-1 while left &lt;= right: s = numbers[left] + numbers[right] if s == target: return [left+1,right+1] elif s &lt; target: left += 1 else: right -= 1 ","link":"https://ganhan999.github.io/post/167、两数之和 II - 输入有序数组/"},{"title":"JavaIO流","content":"一、File 1.创建 package IO; import java.io.File; import java.io.IOException; public class File01 { public static void main(String[] args) { try { //创建一个文本文件 File file = new File(&quot;D:\\\\hh.txt&quot;); boolean flag=file.createNewFile();//文件已存在 则不会重新建立 System.out.println(flag?&quot;创建成功&quot;:&quot;创建失败&quot;); //创建文件夹 File file1 = new File(&quot;D:\\\\文件夹&quot;); boolean flag1 = file1.mkdir();//文件已存在 则不会重新建立 System.out.println(flag1?&quot;创建成功&quot;:&quot;创建失败&quot;); //创建多级文件 File file2 = new File(&quot;D:\\\\文件夹啊\\\\da\\\\呵呵&quot;); boolean flag2 = file2.mkdirs();//文件已存在 则不会重新建立 System.out.println(flag2?&quot;创建成功&quot;:&quot;创建失败&quot;); } catch (IOException e) { e.printStackTrace(); } } } 2.删除与查询 删除 delete() package IO; import java.io.File; public class File02 { public static void main(String[] args) { File file = new File(&quot;D:\\\\文件夹&quot;); boolean flag = file.delete(); System.out.println(flag?&quot;删除成功&quot;: &quot;删除失败&quot;); } } 查询 package IO; import java.io.File; import java.io.IOException; public class FIle03 { public static void main(String[] args) { File file = new File(&quot;D:\\\\文价夹啊&quot;); boolean flag=file.exists(); if(flag){ System.out.println(&quot;您的文件已经存在，不需创建&quot;); }else{ file.mkdir(); System.out.println(&quot;已创建&quot;); } //2.获取文件大小 File file1 = new File(&quot;D:\\\\000.txt&quot;); try { file1.createNewFile(); Long size=file1.length();//返回字节数 //length 字符串 .length() 获取字符个数 // 数组 .length属性 获取数组元素个数 // 集合 .size()方法 size 返回集合元素个数 System.out.println(&quot;size &quot;+size); //返回文件名 String name =file1.getName(); System.out.println(name); //获取路径 String path = file1.getPath(); System.out.println(path); } catch (IOException e) { e.printStackTrace(); } } } 3.递归 isDirectory()判断是否是文件夹 listFiles() 查询某个文件夹下的所有文件 package IO; import java.io.File; //递归找出文件夹中的所有文件 public class File04 { public static void showFile(String pathname) { File f1 = new File(pathname); //1.判断文件是否是文件夹 boolean flag = f1.isDirectory(); //选择文件夹下所有文件 if (flag) { File[] files = f1.listFiles(); if (files != null) { for (File tempFile : files) { boolean flag2 = tempFile.isDirectory(); if (flag2) { showFile(tempFile.getPath()); } else { String filePath2 = tempFile.getPath(); System.out.println(&quot;普通文件-------------&quot; + filePath2); } } } else { String filePath = f1.getPath(); System.out.println(&quot;普通文件-------------&quot; + filePath); } }else{ return; } } public static void main(String[] args) { File04.showFile(&quot;G:\\\\&quot;); } } //高级循环 造成的空指针异常 用if判断 if (files != null) { for (File tempFile : files) { //可使用普通循环 package IO; import java.io.File; //递归找出文件夹中的所有文件 public class File04 { public static void showFile(String pathname) { File f1 = new File(pathname); //1.判断文件是否是文件夹 boolean flag = f1.isDirectory(); //选择文件夹下所有文件 if (flag) { File[] files = f1.listFiles(); for (int i = 0; files!=null &amp;&amp; i &lt; files.length; i++) { boolean flag2 = files[i].isDirectory(); if (flag2) { showFile(files[i].getPath()); }else{ String filePath2 = files[i].getPath(); System.out.println(&quot;普通文件-------------&quot; + filePath2); } } } else { String filePath = f1.getPath(); System.out.println(&quot;普通文件-------------&quot; + filePath); } } public static void main(String[] args) { File04.showFile(&quot;G:\\\\&quot;); } } 二、IO：输入输出流 1.字节流 字节输入流 InputStream()字节输入流父类 FileInputStream() BurfferedInputStream() package IO; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; public class File05 { public static void main(String[] args) { //1.文件和程序之间 try { FileInputStream fls =new FileInputStream(&quot;D:\\\\000.txt&quot;); //2.读取数据 int ch=0; while ( (ch=fls.read()) != -1){ System.out.print((char)ch); } //int ch =fls.read();//返回值为-1 则读取完毕 // System.out.println(&quot;ch=&quot;+(char)ch); //关闭 fls.close(); } catch (Exception e) { e.printStackTrace(); } /* File file = new File(&quot;D:\\\\000.txt&quot;); if(file.exists() &amp;&amp; file.length()&gt;0){ try { FileInputStream fls =new FileInputStream(file); } catch (FileNotFoundException e) { e.printStackTrace(); } }*/ } } abc/adjkagfdhkfbk,seahgroiwyroiYwgTEDYUKAä¸­å›½ //读中文出现乱码 因为read只能返回一个字符 汉字占多个字符 字节输出流 可以读取一切文件 OutputStream()父类 FileOutputStream() BurfferedOutputStream() package IO; import java.io.FileNotFoundException; import java.io.FileOutputStream; public class File6 { public static void main(String[] args) { try { String data =&quot;hello my love&quot;; //输出 FileOutputStream fos = new FileOutputStream(&quot;D:\\\\000.txt&quot;,true); //如果文件不存在 则自动创建 同时 覆盖之前的内容 加true参数 则为追加 byte[] tempbyte = data.getBytes(); fos.write(tempbyte); //关闭 fos.close(); } catch (Exception e) { e.printStackTrace(); } } } 复制 package IO; import java.io.FileInputStream; import java.io.FileOutputStream; public class FIle07 { public static void main(String[] args) { try { FileInputStream fls =new FileInputStream(&quot;D:\\\\000.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;D:\\\\00.txt&quot;); //创建一个输出 int ch=0; while ( (ch=fls.read()) != -1){ fos.write(ch); } //关闭 fls.close(); fos.close(); } catch (Exception e) { e.printStackTrace(); } } } FileInputStream,FileOutputStream 效率较慢 故介绍BufferedInputStream, BufferedOutputStream 字节缓冲输入流/字节缓冲输出流 改写： package IO; import java.io.*; public class Buffer1 { public static void main(String[] args) { //建立连接 try { InputStream fis = new FileInputStream(&quot;D:\\\\000.txt&quot;); BufferedInputStream bis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream(&quot;D:\\\\001.txt&quot;); BufferedOutputStream bos = new BufferedOutputStream(fos); //一次 1024字节 byte[] bar =new byte[1024]; int len=0; while((len=bis.read(bar))!=-1) { System.out.println(len); String s = new String(bar); System.out.println(s); bos.write(bar, 0, len); } //关闭 bis.close(); fis.close(); bos.close(); fos.close(); } catch (Exception e) { e.printStackTrace(); } } } 24 hello worldhello my love 对于输入流 先关FileInputStream或BufferedInpytStream都可以 对于输出流 先关BufferedOutputStream 再关FileOutputStream 否则报错 Stream closed 2.字符流 读取纯文本文件比较方便，帮助我们处理乱码问题 字符输入流 reader父类 Filereader Bufferedreader package IO; import java.io.FileNotFoundException; import java.io.FileReader; public class File08 { public static void main(String[] args) { try { FileReader fr = new FileReader(&quot;D:\\\\00.txt&quot;); char[] car = new char[1024]; int len=0; while ((len = fr.read(car))!= -1) { String str = new String(car,0,len); System.out.println(str); } fr.close(); } catch (Exception e) { e.printStackTrace(); } } } hello worldhello my love中国//汉字不会乱码 Bufferedreader 与Filereader类似 字符输出流 Writer 父类 FileWriter BufferedWriter package IO; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class File09 { public static void main(String[] args) { try { FileReader fr = new FileReader(&quot;D:\\\\00.txt&quot;); FileWriter fw = new FileWriter(&quot;D:\\\\001.txt&quot;,true); char[] car =new char[1024]; int len=0; while ((len=fr.read(car))!=-1) { String str = new String(car,0,len); fw.write(str); } fr.close(); fw.close(); } catch (Exception e) { e.printStackTrace(); } } } ","link":"https://ganhan999.github.io/post/JavaIO流/"},{"title":"Java权限修饰符","content":"Java中有四种权限修饰符 public protected (default) private 同一个类 yes yes yes yes 同一个包 yes yes yes no 不同包子类 yes yes no no 不同包非子类 yes no no no Warning:(default)并不是关键字&quot;default&quot;,而是根本不写 知识点补充： Java语言4种访问权限修饰符 Java语言4种访问权限修饰符，但是仅有3个关键字，因为不写访问权限，在Java中被称为默认权限，或同包权限，本文中以(default)代替。下面按照权限从小到大的顺序对4种访问权限分别介绍 1、默认权限(default) 类，数据成员，构造方法，方法成员，都能够使用默认权限，即不写任何关键字。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。 2、受保护权限(protected) protected可以修饰数据成员，构造方法，方法成员，不能修饰类(此处指外部类，不考虑内部类)。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。 3、私有权限(private) private可以修饰数据成员，构造方法，方法成员，不能修饰类(此处指外部类，不考虑内部类)。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。 4、公共权限(public) public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。 有关Java语言的修饰符，需要注意的问题有如下几个： 1.并不是每个修饰符都可以修饰类(指外部类)，只有public和default可以。 2.所有修饰符都可以修饰数据成员，方法成员，构造方法。 3.为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private. 4.修饰符修饰的是“被访问”的权限。 private：仅对本类可见 缺省（不需修饰符）：对本包可见 protected：对本包及所有子类可见 public：对所有类可见 修饰符： * 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final * 抽象修饰符：abstract 类： * 权限修饰符：默认修饰符，public * 状态修饰符：final（最终类不能被继承） * 抽象修饰符：abstract 成员变量： * 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final 构造方法： * 权限修饰符：private，默认的，protected，public *私有构造方法的情况：当一个类中所有的方法都是静态的，就可以把构造方法私有 成员方法： * 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final * 抽象修饰符：abstract 除此以外的组合规则： * 成员变量：public static final * 成员方法： * public static * public abstract * public final ","link":"https://ganhan999.github.io/post/Java权限修饰符/"},{"title":"160、相交链表","content":"题目 编写一个程序，找到两个单链表相交的起始节点。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。. 本体思路 将所有A的节点记录在字典中，再用B去查找，如果找到了则返回节点 #我的做法： class MinStack: class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: if headA is None or headB is None: return None m = {} m = self.bianli(headA, m) ans = self.bianli(headB, m) return None if (isinstance(ans, dict)) else ans def bianli(self, head, m): while head: if m.get(head): return head m[head] = 1 head = head.next else: return m &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 用集合，但不是用字典，思路差不多 class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A = set() cur1 = headA cur2 = headB while cur1: A.add(cur1) cur1 = cur1.next while cur2: if cur2 in A: return cur2 cur2 = cur2.next return None &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 分别遍历两个链表，并记录两链表的长度差n，将出现两种情况， (1)让长链表先走n步 (2)再同时开始走，并对比两个链表的当前节点，节点相等时即为交点 (3)若没有交点，则在最后的Null处相交 class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: cur1 = headA cur2 = headB n = 0 while cur1: n += 1 cur1 = cur1.next while cur2: n -= 1 cur2 = cur2.next if cur1 != cur2: return None cur1 = headA if n &gt; 0 else headB cur2 = headB if cur1 == headA else headA n = abs(n) while n: n -= 1 cur1 = cur1.next while cur1 != cur2: cur1 = cur1.next cur2 = cur2.next return cur1 &quot;&quot;&quot;&quot;&quot;&quot; #大神做法3： 长短链表相互拼接，遇到相同节点跳出循环，该节点即为相交节点 class Solution: def getIntersectionNode(self, L1: ListNode, L2: ListNode) -&gt; ListNode: h1, h2 = L1, L2 while h1 is not h2: h1 = h1.next if h1 else L2 h2 = h2.next if h2 else L1 return h1 ","link":"https://ganhan999.github.io/post/160、相交链表/"},{"title":"Java集合","content":"集合 一、集合概念 概念：对象的容器，定义了对多个对象进行操作的常用方法 可实现数组的功能 和数组的区别： 数组长度固定 集合不固定 数组可以存储基本类型和引用类型 集合只能存放引用类型 Collection体系 父接口 特点： 代表一组任意类型的对象，无序、无下标、不能重复 方法： boolean add(Object obj） //添加一个对象 boolean addAll(Collection c)//将一个集合中的所有对象添加到此集合中 void clear()//清空此集合中的所有对象 boolean contains(Object o)//检查此集合是否包含o对象 boolean equals(Object o)//判断此对象 是否与指定对象 相等 boolean isEmpty()//判断此集合是否为空 boolean remove (Object o) //在此集合中移除o对象 int size()//返回此集合中的元素个数 Object[] toArray()//将此集合转为数组 Iterator iterator()//迭代 package Collection; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class Demo01 { public static void main(String[] args) { Collection collection =new ArrayList(); //添加元素 collection.add(&quot;香蕉&quot;); collection.add(&quot;橘子&quot;); collection.add(&quot;火龙果&quot;); //打印集合元素及个数 System.out.println(&quot;元素个数为:&quot;+collection.size()); System.out.println(collection); //遍历 //1.增强for Collection不能使用下标 System.out.println(&quot;====================&quot;); for(Object object:collection){ System.out.println(object); } //2.迭代器 专门用来遍历集合 System.out.println(&quot;======迭代器=======&quot;); Iterator it =collection.iterator(); while(it.hasNext()){//hasNext()判断下一个元素是否存在 String str = (String)it.next();//next()返回下一个元素 System.out.println(str); //collection.remove(str);//遍历时不能用remove方法移除 //it.remove();//可用迭代器remove移除 } //判断 System.out.println(collection.isEmpty()); System.out.println(collection.contains(&quot;西瓜&quot;)); //移除元素 collection.remove(&quot;橘子&quot;); System.out.println(&quot;元素个数为:&quot;+collection.size()); System.out.println(collection); //清空 collection.clear(); System.out.println(&quot;元素个数为:&quot;+collection.size()); System.out.println(collection); } } 元素个数为:3 [香蕉, 橘子, 火龙果] ==================== 香蕉 橘子 火龙果 ======迭代器======= 香蕉 橘子 火龙果 false false 元素个数为:2 [香蕉, 火龙果] 元素个数为:0 [] package Collection; public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } } package Collection; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class Demo02 { public static void main(String[] args) { //新建Collection对象 Collection collection = new ArrayList(); Student s1 = new Student(&quot;陈壹&quot;,21); Student s2 = new Student(&quot;陈贰&quot;,22); Student s3 = new Student(&quot;陈叁&quot;,21); //添加数据 collection.add(s1); collection.add(s2); collection.add(s3); collection.add(s3); System.out.println(&quot;元素个数为:&quot;+collection.size()); System.out.println(collection.toString()); //删除 //collection.remove(new Student(&quot;陈壹&quot;,21));new 对象不会删除原来列表 collection.remove(s3);//没有移除全部s3 删除一个 System.out.println(&quot;元素个数为:&quot;+collection.size()); System.out.println(collection.toString()); //遍历 //1.增强for for(Object object : collection){ Student s = (Student)object; System.out.println(s.toString()); } //2.迭代器 Iterator iterator= collection.iterator(); while(iterator.hasNext()){ Student s = (Student)iterator.next(); iterator.remove(); System.out.println(s.toString()); } System.out.println(collection.toString());//remove 删除完毕 //判断 System.out.println(collection.contains(s1)); System.out.println(collection.isEmpty()); } } 元素个数为:4 [Student{name='陈壹', age=21}, Student{name='陈贰', age=22}, Student{name='陈叁', age=21}, Student{name='陈叁', age=21}] 元素个数为:3 [Student{name='陈壹', age=21}, Student{name='陈贰', age=22}, Student{name='陈叁', age=21}] Student{name='陈壹', age=21} Student{name='陈贰', age=22} Student{name='陈叁', age=21} Student{name='陈壹', age=21} Student{name='陈贰', age=22} Student{name='陈叁', age=21} [] false true List 特点：有序 有下标 元素可以重复 方法 void add(int index , Object o)//在index处插入对象o boolean addAll(int index,Collection c)//将一个集合中的元素添加到index处 Object get(int index)//返回集合中指定位置的元素 LIst subList (int fromIndex ,int toIndex)//返回fromIndex 到toIndex的元素 package List; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.ListIterator; public class List01 { public static void main(String[] args) { //创建集合 List list =new ArrayList&lt;&gt;(); //1.添加元素 list.add(&quot;小米&quot;); list.add(&quot;三星&quot;); list.add(&quot;苹果&quot;); list.add(&quot;华为&quot;); System.out.println(&quot;元素个数为:&quot;+list.size()); System.out.println(list.toString()); //2.删除元素 //list.remove(&quot;三星&quot;); list.remove(0); System.out.println(&quot;元素个数为:&quot;+list.size()); System.out.println(list.toString()); //3.遍历 //1.for循环 System.out.println(&quot;=========1.for=========&quot;); for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } //2.增强for System.out.println(&quot;==========增强for=====&quot;); for (Object object: list){ System.out.println(object); } //迭代器 System.out.println(&quot;==========迭代器======&quot;); Iterator it=list.iterator(); while (it.hasNext()){ String s = (String)it.next(); System.out.println(s.toString()); } //list迭代器 可以前向 后向 遍历 可以增改 System.out.println(&quot;=========list迭代器======&quot;); ListIterator lit =list.listIterator(); System.out.println(&quot;=====从前往后========&quot;); while(lit.hasNext()){ System.out.println(lit.nextIndex()+&quot;:&quot;+lit.next()); } System.out.println(&quot;======从后往前====&quot;); while(lit.hasPrevious()){ System.out.println(lit.previousIndex()+&quot;:&quot;+lit.previous()); } } } 元素个数为:4 [小米, 三星, 苹果, 华为] 元素个数为:3 [三星, 苹果, 华为] =========1.for========= 三星 苹果 华为 ==========增强for===== 三星 苹果 华为 ==========迭代器====== 三星 苹果 华为 =========list迭代器====== =====从前往后======== 0:三星 1:苹果 2:华为 ======从后往前==== 2:华为 1:苹果 0:三星 package List; import java.util.ArrayList; import java.util.List; public class List02 { public static void main(String[] args) { List list =new ArrayList&lt;&gt;(); //添加数字 list.add(10); list.add(20); list.add(30); list.add(40); list.add(50); list.add(60); list.add(70); System.out.println(&quot;列表元素为:&quot;+list.size()); System.out.println(list.toString()); //删除元素 list.remove(6); System.out.println(&quot;列表元素为:&quot;+list.size()); System.out.println(list.toString()); //通过元素值移除元素 二种方法 list.remove((Object)60); System.out.println(&quot;列表元素为:&quot;+list.size()); System.out.println(list.toString()); list.remove(new Integer(50));//Collection类中 Student 不能通过new Student 删除 为什么？？？？ 因为 对equals定义不同 Student 是通过地址判断 需重写成判断name age 才可以这样删除 System.out.println(&quot;列表元素为:&quot;+list.size()); System.out.println(list.toString()); //补充 subList 含头不含尾 System.out.println(list.subList(1,3)); } } 列表元素为:7 [10, 20, 30, 40, 50, 60, 70] 列表元素为:6 [10, 20, 30, 40, 50, 60] 列表元素为:5 [10, 20, 30, 40, 50] 列表元素为:4 [10, 20, 30, 40] [20, 30] List 实现类 ArrayList: 数组结构实现 查询快 增删慢 运行效率快 线程不安全 Vector(了解): 数组结构实现 查询快 增删慢 运行效率慢 线程安全 LinkedList: 链表结构实现 增删快 查询慢 Arraylist: 储存结构-- 数组 package Collection; import java.util.Objects; public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } @Override /*public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); */ public boolean equals(Object o) { if(this==o){ return true; } if(this==null){ return false; } if(o instanceof Student){ Student s = (Student)o; if (this.name.equals(s.getName()) &amp;&amp; this.age==s.getAge()){ return true; } } return false; } } package Arraylist; import Collection.Student; import java.util.ArrayList; import java.util.Iterator; import java.util.ListIterator; public class Demo01 { public static void main(String[] args) { ///创建集合 ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;(); //添加元素 Student s1 = new Student(&quot;刘德华&quot;,59); Student s2 = new Student(&quot;郭富城&quot;,55); Student s3 = new Student(&quot;黎明&quot;,54); Student s4 = new Student(&quot;张学友&quot;,59); arrayList.add(s1); arrayList.add(s2); arrayList.add(s3); arrayList.add(s4); arrayList.add(s4); System.out.println(&quot;元素个数为:&quot;+arrayList.size()); System.out.println(arrayList.toString()); //删除元素 arrayList.remove(new Student(&quot;张学友&quot;,59));//重写equals方法 可以删除 System.out.println(&quot;元素个数为:&quot;+arrayList.size()); System.out.println(arrayList.toString()); //遍历元素 //1.增强for System.out.println(&quot;==========增强for===========&quot;); for (Object object:arrayList) { Student s =(Student)object; System.out.println(s.toString()); } //2.下标 for System.out.println(&quot;========普通for==============&quot;); for (int i = 0; i &lt; arrayList.size(); i++) { System.out.println(arrayList.get(i)); } //3.迭代器 // Iterator 迭代器 System.out.println(&quot;==============Iteraor迭代器===========&quot;); Iterator it =arrayList.iterator(); while(it.hasNext()){ Student s =(Student)it.next(); System.out.println(s.toString()); } //ListIterator 迭代器 System.out.println(&quot;==============ListIterator 前向迭代器===========&quot;); ListIterator lit = arrayList.listIterator(); while(lit.hasNext()){ Student s =(Student)lit.next(); System.out.println(s.toString()); } System.out.println(&quot;==============ListIterator 后向迭代器===========&quot;); while(lit.hasPrevious()){ Student s =(Student)lit.previous(); System.out.println(s.toString()); } //判断 System.out.println(arrayList.contains(s1)); System.out.println(arrayList.contains(new Student(&quot;郭富城&quot;,55)));//重写 equals } } 元素个数为:5 [Student{name='刘德华', age=59}, Student{name='郭富城', age=55}, Student{name='黎明', age=54}, Student{name='张学友', age=59}, Student{name='张学友', age=59}] 元素个数为:4 [Student{name='刘德华', age=59}, Student{name='郭富城', age=55}, Student{name='黎明', age=54}, Student{name='张学友', age=59}] ==========增强for=========== Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ========普通for============== Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ==============Iteraor迭代器=========== Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ==============ListIterator 前向迭代器=========== Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ==============ListIterator 后向迭代器=========== Student{name='张学友', age=59} Student{name='黎明', age=54} Student{name='郭富城', age=55} Student{name='刘德华', age=59} true true 源码分析 默认容量： DEFAULT_CAPACITY = 10 注意：如果没有向集合中添加元素 默认为0 添加任意元素 则为10 到达极限是 扩容为原来的1.5倍 存放元素的数组 elementData 实际元素个数 size add()方法： 源码 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } Vector: 数组 package Vector; import java.util.Enumeration; import java.util.Vector; public class Demo0 { public static void main(String[] args) { //创建集合 Vector&lt;Object&gt; vector = new Vector&lt;&gt;(); //添加元素 vector.add(&quot;香蕉&quot;); vector.add(&quot;橘子&quot;); vector.add(&quot;芒果&quot;); vector.add(&quot;西瓜&quot;); System.out.println(&quot;元素个数为:&quot;+vector.size()); System.out.println(vector.toString()); //遍历元素 枚举法 增强for等也可以 Enumeration elements = vector.elements(); while(elements.hasMoreElements()){ String s = (String) elements.nextElement(); System.out.println(s); } //判断 System.out.println(vector.contains(&quot;西瓜&quot;)); System.out.println(vector.isEmpty()); //其他方法 System.out.println(vector.firstElement()); System.out.println(vector.lastElement()); System.out.println(vector.elementAt(0)); //删除元素 vector.remove(0); System.out.println(vector.toString()); vector.remove(&quot;西瓜&quot;); System.out.println(vector.toString()); vector.clear(); System.out.println(vector.toString()); } } 元素个数为:4 [香蕉, 橘子, 芒果, 西瓜] 香蕉 橘子 芒果 西瓜 true false 香蕉 西瓜 香蕉 [橘子, 芒果, 西瓜] [橘子, 芒果] [] LinkedList: package LinkerList; import Collection.Student; import java.util.Iterator; import java.util.LinkedList; import java.util.ListIterator; public class Demo00 { public static void main(String[] args) { //创建集合 LinkedList linkedlist = new LinkedList&lt;&gt;(); //添加元素 Student s1 = new Student(&quot;刘德华&quot;,59); Student s2 = new Student(&quot;郭富城&quot;,55); Student s3 = new Student(&quot;黎明&quot;,54); Student s4 = new Student(&quot;张学友&quot;,59); linkedlist.add(s1); linkedlist.add(s2); linkedlist.add(s3); linkedlist.add(s4); System.out.println(&quot;元素个数:&quot;+linkedlist.size()); System.out.println(linkedlist.toString()); //遍历 //2.1for System.out.println(&quot;=========for============&quot;); for (int i = 0; i &lt; linkedlist.size(); i++) { System.out.println(linkedlist.get(i)); } //2.2增强for System.out.println(&quot;=======增强for============&quot;); for (Object obj : linkedlist){ Student s =(Student) obj; System.out.println(s.toString()); } //2.3迭代器 System.out.println(&quot;==========迭代器==========&quot;); Iterator it = linkedlist.iterator(); while(it.hasNext()){ Student s =(Student)it.next(); System.out.println(s.toString()); } //2.4LiseIterator 迭代器 System.out.println(&quot;========LiseIterator 迭代器=============&quot;); ListIterator lit = linkedlist.listIterator(); while(lit.hasNext()) { Student s = (Student) lit.next(); System.out.println(s.toString()); } //判断 System.out.println(linkedlist.contains(s1)); System.out.println(linkedlist.isEmpty()); //获取 linkedlist.get(0); //删除 linkedlist.remove(0); System.out.println(linkedlist.toString()); linkedlist.remove(new Student(&quot;郭富城&quot;,55)); System.out.println(linkedlist.toString()); linkedlist.clear(); System.out.println(linkedlist.toString()); } } 元素个数:4 [Student{name='刘德华', age=59}, Student{name='郭富城', age=55}, Student{name='黎明', age=54}, Student{name='张学友', age=59}] =========for============ Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} =======增强for============ Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ==========迭代器========== Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} ========LiseIterator 迭代器============= Student{name='刘德华', age=59} Student{name='郭富城', age=55} Student{name='黎明', age=54} Student{name='张学友', age=59} true false [Student{name='郭富城', age=55}, Student{name='黎明', age=54}, Student{name='张学友', age=59}] [Student{name='黎明', age=54}, Student{name='张学友', age=59}] [] 泛型 参数化类型 &lt;T。。。&gt;类型占位符 表示一种引用类型 好处 提高代码的重用性 防止类型转换异常，提高代码安全性 泛型类 语法 ： 类名后加&lt;T,E,K…&gt; T类型占位符 是一种引用类型 可以编写多个 package Mygeneric; public class Mygeneric&lt;T&gt; { //使用泛型 //1.创建变量 T t; //2.方法参数 public void show(T t){ // T t =new T(); 不可new对象 因为无法确定T的类型 this.t = t; System.out.println(t); } //3.泛型作为方法的返回值 public T getT(){ return t; } } package Mygeneric; import com.sun.org.glassfish.external.amx.AMX; public class TestGeneric { public static void main(String[] args) { //泛型为引用类型 不同泛型类型之间不能相互赋值 Mygeneric&lt;String&gt; mg1 = new Mygeneric&lt;String&gt;(); mg1.show(&quot;生活&quot;); System.out.println(mg1.t); String S = mg1.getT(); Mygeneric&lt;Integer&gt; mg2 = new Mygeneric&lt;Integer&gt;(); mg2.show(150); System.out.println(mg2.t); Integer i1 = mg2.getT(); //Mygeneric&lt;String&gt; mg1=mg2; 错误 } } 生活 生活 150 150 泛型接口 接口 package Mygeneric; public interface MyInterface &lt;T&gt;{ public static String name= &quot;泛型&quot;; T show(T t); } 实现类 1.实现时声明类型 package Mygeneric; public class MyInterface01 implements MyInterface&lt;String&gt; { @Override public String show(String s ) { System.out.println(s); System.out.println(); return s; } } 2.调用时声明类型 package Mygeneric; public class MyInterface02 &lt;T&gt; implements MyInterface&lt;T&gt;{ @Override public T show(T t) { System.out.println(t); return t; } } 测试类 package Mygeneric; public class MyTest { public static void main(String[] args) { MyInterface01 interface01 = new MyInterface01(); interface01.show(&quot;花好月圆&quot;); System.out.println(MyInterface.name); MyInterface02&lt;Integer&gt; interface02 = new MyInterface02&lt;Integer&gt;(); interface02.show(1314); } } 花好月圆 泛型 泛型 1314 泛型方法 public class MyGenericMethod { public &lt;T&gt; T show (T t){ System.out.println(&quot;泛型方法&quot;+t); return t; } } MyGenericMethod genericMethod = new MyGenericMethod(); genericMethod.show(&quot;huhuhu&quot;);//无需声明 类型 根据输入参数决定 genericMethod.show(200); genericMethod.show(3.14); 泛型方法huhuhu 泛型方法200 泛型方法3.14 转换异常 正常类 需要判断数据类型能否转换 package Mygeneric; import java.util.ArrayList; public class Demo0 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(&quot;huahua&quot;); arrayList.add(&quot;gugu&quot;); arrayList.add(120); arrayList.add(520); for (Object obj:arrayList) { String s =(String) obj; System.out.println(s); } } } huahua gugu Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Mygeneric.Demo0.main(Demo0.java:13) 使用泛型 使集合元素为统一类型 避免强类型转换异常 import java.util.ArrayList; public class Demo0 { public static void main(String[] args) { ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(&quot;huahua&quot;); arrayList.add(&quot;gugu&quot;); //arrayList.add(120); //arrayList.add(520); for (String str:arrayList) { System.out.println(str); } } } 使用泛型约束后 int类型元素就无法添加到集合了 避免使用强类型转换 Set集合 无序 无下标 元素不可重复 package Set; import java.lang.reflect.Array; import java.util.*; public class Demo01 { public static void main(String[] args) { //创建集合 Set&lt;String&gt; set = new HashSet&lt;&gt;(); //添加元素 set.add(&quot;华为&quot;); set.add(&quot;小米&quot;); set.add(&quot;三星&quot;); set.add(&quot;苹果&quot;); set.add(&quot;魅族&quot;); System.out.println(&quot;元素个数为:&quot;+set.size()); System.out.println(set.toString()); //遍历 //1.增强for for (String str:set) { System.out.println(str); } //迭代器 System.out.println(&quot;==========迭代器=========&quot;); Iterator it = set.iterator(); while(it.hasNext()){ String s =(String)it.next(); System.out.println(s); } //判断 System.out.println(set.contains(&quot;小米&quot;)); System.out.println(set.isEmpty()); //删除 set.remove(&quot;三星&quot;); System.out.println(set.toString()); set.clear(); System.out.println(set.toString()); } } 元素个数为:5 [苹果, 华为, 魅族, 小米, 三星] 苹果 华为 魅族 小米 三星 ==========迭代器========= 苹果 华为 魅族 小米 三星 true false [苹果, 华为, 魅族, 小米] [] 实现类 HashSet TreeSet HashSet 基于HashSet计算元素存放位置 当存入元素的哈希码相同时，会调用equals进行确认，若结果为true 则拒绝后者加入 存储位置 哈希表（数组加链表+红黑树） package Set.HashSet; import java.util.HashSet; import java.util.Iterator; public class Demo01 { public static void main(String[] args) { //创建集合 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); //添加元素 hashSet.add(&quot;刘亦菲&quot;); hashSet.add(&quot;杨幂&quot;); hashSet.add(&quot;刘诗诗&quot;); hashSet.add(&quot;唐嫣&quot;); hashSet.add(&quot;赵丽颖&quot;); //hashSet.add(&quot;赵丽颖&quot;);重复 不再添加 System.out.println(&quot;元素个数为:&quot;+hashSet.size()); System.out.println(hashSet.toString()); //遍历 System.out.println(&quot;=======增强for==========&quot;); for (String str:hashSet) { System.out.println(str); } //迭代器 System.out.println(&quot;============迭代器===========&quot;); Iterator it = hashSet.iterator(); while (it.hasNext()){ System.out.println(it.next()); } //判断 System.out.println(hashSet.contains(&quot;杨幂&quot;)); System.out.println(hashSet.isEmpty()); //删除元素 hashSet.remove(&quot;赵丽颖&quot;); System.out.println(hashSet.toString()); hashSet.clear(); System.out.println(hashSet.toString()); } } 元素个数为:5 [赵丽颖, 杨幂, 唐嫣, 刘亦菲, 刘诗诗] =======增强for========== 赵丽颖 杨幂 唐嫣 刘亦菲 刘诗诗 ============迭代器=========== 赵丽颖 杨幂 唐嫣 刘亦菲 刘诗诗 true false [杨幂, 唐嫣, 刘亦菲, 刘诗诗] [] 储存过程 (1)根据hashcode 计算保存的位置，如果此位置为空 则直接保存 非空 则第二步 (2)执行equals方法 如果equals方法为true 认为重复 false则链表 package Set.HashSet; import java.util.Objects; public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return &quot;Person{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } } package Set.HashSet; import java.util.HashSet; import java.util.Iterator; public class Demo02 { public static void main(String[] args) { HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;(); Person p1 = new Person(&quot;刘亦菲&quot;,33); Person p2 = new Person(&quot;杨幂&quot;,34); Person p3 = new Person(&quot;唐嫣&quot;,37); Person p4 = new Person(&quot;刘诗诗&quot;,33); Person p5 = new Person(&quot;赵丽颖&quot;,33); hashSet.add(p1); hashSet.add(p2); hashSet.add(p3); hashSet.add(p4); hashSet.add(p5); hashSet.add(new Person(&quot;赵丽颖&quot;,33));//重写后 由name age决定hashcode System.out.println(&quot;元素个数为:&quot;+hashSet.size()); System.out.println(hashSet.toString()); //遍历 System.out.println(&quot;==========增强for==========&quot;); for (Person person:hashSet) { System.out.println(person.toString()); } System.out.println(&quot;=========迭代器=====&quot;); Iterator it =hashSet.iterator(); while(it.hasNext()){ System.out.println(it.next()); } //判断 System.out.println(hashSet.contains(p2)); System.out.println(hashSet.contains(new Person(&quot;赵丽颖&quot;, 33))); System.out.println(hashSet.isEmpty()); //删除 hashSet.remove(p5); System.out.println(hashSet.toString()); hashSet.clear(); System.out.println(hashSet.toString()); } } 元素个数为:5 [Person{name='赵丽颖', age=33}, Person{name='刘诗诗', age=33}, Person{name='刘亦菲', age=33}, Person{name='杨幂', age=34}, Person{name='唐嫣', age=37}] ==========增强for========== Person{name='赵丽颖', age=33} Person{name='刘诗诗', age=33} Person{name='刘亦菲', age=33} Person{name='杨幂', age=34} Person{name='唐嫣', age=37} =========迭代器===== Person{name='赵丽颖', age=33} Person{name='刘诗诗', age=33} Person{name='刘亦菲', age=33} Person{name='杨幂', age=34} Person{name='唐嫣', age=37} true true false [Person{name='刘诗诗', age=33}, Person{name='刘亦菲', age=33}, Person{name='杨幂', age=34}, Person{name='唐嫣', age=37}] [] TreeSet 基于排列顺序实现元素不可重复 实现SortedSet接口 对集合元素自动排序 元素对象的类型必须实现Comparable接口，指定排列顺序 通过 CompareTo方法确认是否是重复元素 package Set.TreeSet; import Set.HashSet.Person; import java.util.Iterator; import java.util.TreeSet; public class DEmo01 { public static void main(String[] args) { //创建集合 TreeSet&lt;Person&gt; set = new TreeSet&lt;&gt;(); //添加元素 Person p1 = new Person(&quot;刘亦菲&quot;,33); Person p2 = new Person(&quot;杨幂&quot;,34); Person p3 = new Person(&quot;唐嫣&quot;,37); Person p4 = new Person(&quot;刘诗诗&quot;,33); Person p5 = new Person(&quot;赵丽颖&quot;,33); set.add(p1);//添加时 Person类必须实现Comparable接口 set.add(p2); set.add(p3); set.add(p4); set.add(p5); System.out.println(&quot;元素个数:&quot;+set.size()); System.out.println(set.toString()); //删除 remove set.remove(p5); System.out.println(&quot;元素个数:&quot;+set.size()); System.out.println(set.toString()); //遍历 System.out.println(&quot;=======增强for=====&quot;); for (Person person: set) { System.out.println(person); } System.out.println(&quot;======迭代器==========&quot;); Iterator it = set.descendingIterator();//倒序 while (it.hasNext()){ System.out.println(it.next()); } //判断 System.out.println(set.contains(p1)); System.out.println(set.isEmpty()); } } 元素个数:5 [Person{name='刘亦菲', age=33}, Person{name='刘诗诗', age=33}, Person{name='唐嫣', age=37}, Person{name='杨幂', age=34}, Person{name='赵丽颖', age=33}] 元素个数:4 [Person{name='刘亦菲', age=33}, Person{name='刘诗诗', age=33}, Person{name='唐嫣', age=37}, Person{name='杨幂', age=34}] =======增强for===== Person{name='刘亦菲', age=33} Person{name='刘诗诗', age=33} Person{name='唐嫣', age=37} Person{name='杨幂', age=34} ======迭代器========== Person{name='杨幂', age=34} Person{name='唐嫣', age=37} Person{name='刘诗诗', age=33} Person{name='刘亦菲', age=33} true false 还有一种定制比较器Comparator 不需要对对象类实现Comparable package Set.TreeSet; import Set.HashSet.Person; import java.util.Comparator; import java.util.TreeSet; public class DEMO02 { public static void main(String[] args) { TreeSet&lt;Person&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { int n1 = o1.getName().compareTo(o2.getName()); int n2 = o1.getAge()-o2.getAge(); return n1==0?n2:n1; } }); Person p1 = new Person(&quot;刘亦菲&quot;,33); Person p2 = new Person(&quot;杨幂&quot;,34); Person p3 = new Person(&quot;唐嫣&quot;,37); Person p4 = new Person(&quot;刘诗诗&quot;,33); Person p5 = new Person(&quot;赵丽颖&quot;,33); set.add(p1);//添加时 Person类必须实现Comparable接口 set.add(p2); set.add(p3); set.add(p4); set.add(p5); System.out.println(&quot;元素个数:&quot;+set.size()); System.out.println(set.toString()); } } 元素个数:5 [Person{name='刘亦菲', age=33}, Person{name='刘诗诗', age=33}, Person{name='唐嫣', age=37}, Person{name='杨幂', age=34}, Person{name='赵丽颖', age=33}] package Set.TreeSet; import sun.reflect.generics.tree.Tree; import java.util.Comparator; import java.util.Iterator; import java.util.TreeSet; public class Demo03 { public static void main(String[] args) { TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { int n1= o1.length()-o2.length(); int n2 = o1.compareTo(o2); return n1==0?n2:n1; } }); //添加元素 treeSet.add(&quot;qingdao&quot;); treeSet.add(&quot;zaozhuang&quot;); treeSet.add(&quot;tengzhou&quot;); treeSet.add(&quot;nanjing&quot;); treeSet.add(&quot;jinan&quot;); System.out.println(&quot;城市个数为:&quot;+treeSet.size()); System.out.println(treeSet.toString()); //遍历 //增强for System.out.println(&quot;=======增强for=========&quot;); for (String str:treeSet) { System.out.println(str); } //迭代 System.out.println(&quot;==========迭代器=====&quot;); Iterator iterator = treeSet.descendingIterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } //判断 System.out.println(treeSet.contains(&quot;jinan&quot;)); System.out.println(treeSet.isEmpty()); //删除 System.out.println(treeSet.remove(&quot;jinan&quot;)); treeSet.clear(); } } 城市个数为:5 [jinan, nanjing, qingdao, tengzhou, zaozhuang] =======增强for========= jinan nanjing qingdao tengzhou zaozhuang ==========迭代器===== zaozhuang tengzhou qingdao nanjing jinan true false true Map Map: 存储键值对 键不能重复，值可以重复 无序 package Map; import java.util.HashMap; import java.util.Map; import java.util.Set; public class Demo0 { public static void main(String[] args) { //添加元素 Map&lt;String,String&gt; map =new HashMap&lt;&gt;(); map.put(&quot;没头脑&quot;,&quot;不高兴&quot;); map.put(&quot;汤姆&quot;,&quot;杰瑞&quot;); map.put(&quot;喜羊羊&quot;,&quot;美羊羊&quot;); map.put(&quot;喜羊羊&quot;,&quot;灰太狼&quot;); map.put(&quot;虹猫&quot;,&quot;蓝兔&quot;); System.out.println(&quot;键值对个数:&quot;+map.size()); System.out.println(map.toString()); Map&lt;String,String&gt; map2 =new HashMap&lt;&gt;(); map2.putAll(map);//复制全部 System.out.println(&quot;键值对个数:&quot;+map2.size()); System.out.println(map2.toString()); //判断 System.out.println(map.containsKey(&quot;没头脑&quot;));//判断是否包含键 System.out.println(map.containsValue(&quot;蓝兔&quot;));//判断是否包含值 System.out.println(map.isEmpty()); //迭代 System.out.println( &quot;=============keyset迭代========&quot;); for (String key:map.keySet()) { System.out.println(key+&quot;--&gt;&quot;+map.get(key)); } //entryset迭代 System.out.println(&quot;============entryset迭代=============&quot;); //Set&lt;Map.Entry&lt;String,String&gt;&gt; entry=map.entrySet(); for(Map.Entry&lt;String,String&gt; entry:map.entrySet()){ System.out.println(entry); } //视图 System.out.println(map.entrySet());//返回映射对 System.out.println(map.keySet());//返回键 System.out.println(map.values());//返回值 //其他 System.out.println(map.get(&quot;汤姆&quot;));//返回键对应值 } } 键值对个数:4 {虹猫=蓝兔, 没头脑=不高兴, 喜羊羊=灰太狼, 汤姆=杰瑞} 键值对个数:4 {虹猫=蓝兔, 没头脑=不高兴, 喜羊羊=灰太狼, 汤姆=杰瑞} true true false =============keyset迭代======== 虹猫--&gt;蓝兔 没头脑--&gt;不高兴 喜羊羊--&gt;灰太狼 汤姆--&gt;杰瑞 ============entryset迭代============= 虹猫=蓝兔 没头脑=不高兴 喜羊羊=灰太狼 汤姆=杰瑞 [虹猫=蓝兔, 没头脑=不高兴, 喜羊羊=灰太狼, 汤姆=杰瑞] [虹猫, 没头脑, 喜羊羊, 汤姆] [蓝兔, 不高兴, 灰太狼, 杰瑞] 杰瑞 实现类 HashMap 默认容量16 0.75 扩容 package Map.HashMap; import java.util.Objects; public class Student { private String name; private int StuTo; public Student(String name, int stuTo) { this.name = name; StuTo = stuTo; } public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getStuTo() { return StuTo; } public void setStuTo(int stuTo) { StuTo = stuTo; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, StuTo=&quot; + StuTo + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Student)) return false; Student student = (Student) o; return StuTo == student.StuTo &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, StuTo); } } package Map.HashMap; import java.util.HashMap; import java.util.Map; import java.util.Set; public class Demo00 { public static void main(String[] args) { //创建集合 HashMap&lt;Student, String&gt; students = new HashMap&lt;Student, String&gt;(); //添加元素 Student s1 = new Student(&quot;周杰伦&quot;,20200001); Student s2 = new Student(&quot;林俊杰&quot;,20200002); Student s3 = new Student(&quot;王力宏&quot;,20200003); Student s4 = new Student(&quot;张杰&quot;,20200004); Student s5 = new Student(&quot;薛之谦&quot;,20200005); students.put(s1,&quot;屋顶&quot;); students.put(s2,&quot;一眼万年&quot;); students.put(s3,&quot;真的爱你&quot;); students.put(s4,&quot;天下&quot;); students.put(s5,&quot;其实&quot;); students.put(new Student(&quot;薛之谦&quot;,20200005),&quot;其实&quot;);//重写hashcode和equals后 由name StuTo判断相等 System.out.println(&quot;歌手与其作品:&quot;+students.size()); System.out.println(students.toString());//无序排列 //迭代 System.out.println(&quot;==========keySet=======&quot;); for (Student student:students.keySet()) { System.out.println(student+&quot;--&gt;&quot;+students.get(student)); } System.out.println(&quot;=========EntrySet=============&quot;); for (Map.Entry&lt;Student,String&gt; entry: students.entrySet()){ System.out.println(entry); } //判断 System.out.println(students.containsKey(s1)); System.out.println(students.containsValue(&quot;认真的雪&quot;)); //删除 System.out.println(students.remove(s1));//删除键 返回值 System.out.println(students.toString());//无序排列 System.out.println(students.remove(s2,&quot;江南&quot;)); System.out.println(students.remove(s2,&quot;一眼万年&quot;)); students.clear(); System.out.println(students.toString());//无序排列 } } 歌手与其作品:5 {Student{name='张杰', StuTo=20200004}=天下, Student{name='周杰伦', StuTo=20200001}=屋顶, Student{name='林俊杰', StuTo=20200002}=一眼万年, Student{name='薛之谦', StuTo=20200005}=其实, Student{name='王力宏', StuTo=20200003}=真的爱你} ==========keySet======= Student{name='张杰', StuTo=20200004}--&gt;天下 Student{name='周杰伦', StuTo=20200001}--&gt;屋顶 Student{name='林俊杰', StuTo=20200002}--&gt;一眼万年 Student{name='薛之谦', StuTo=20200005}--&gt;其实 Student{name='王力宏', StuTo=20200003}--&gt;真的爱你 =========EntrySet============= Student{name='张杰', StuTo=20200004}=天下 Student{name='周杰伦', StuTo=20200001}=屋顶 Student{name='林俊杰', StuTo=20200002}=一眼万年 Student{name='薛之谦', StuTo=20200005}=其实 Student{name='王力宏', StuTo=20200003}=真的爱你 true false 屋顶 {Student{name='张杰', StuTo=20200004}=天下, Student{name='林俊杰', StuTo=20200002}=一眼万年, Student{name='薛之谦', StuTo=20200005}=其实, Student{name='王力宏', StuTo=20200003}=真的爱你} false true {} 刚创建hashmap table=null size=0 传入一个元素后 size=1&lt;&lt;4(16) 当传输到16*0.75=12时 扩容到原来2倍64 以此类推 Hashtable properties TreeMap package Map.TreeMap; import Map.HashMap.Student; import java.util.Comparator; import java.util.Map; import java.util.TreeMap; public class Demo00 { public static void main(String[] args) { //创建集合 用定制比较器 或使类实现 Comparable TreeMap&lt;Student, String&gt; students = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { int n1 = o1.getName().compareTo(o2.getName()); int n2 = o1.getStuTo()-o2.getStuTo(); return n1==0?n2:n1; } }); Student s1 = new Student(&quot;周杰伦&quot;,20200001); Student s2 = new Student(&quot;林俊杰&quot;,20200002); Student s3 = new Student(&quot;王力宏&quot;,20200003); Student s4 = new Student(&quot;张杰&quot;,20200004); Student s5 = new Student(&quot;薛之谦&quot;,20200005); students.put(s1,&quot;屋顶&quot;); students.put(s2,&quot;一眼万年&quot;); students.put(s3,&quot;真的爱你&quot;); students.put(s4,&quot;天下&quot;); students.put(s5,&quot;其实&quot;); students.put(new Student(&quot;薛之谦&quot;,20200005),&quot;其实&quot;);//重写hashcode和equals后 由name StuTo判断相等 System.out.println(&quot;歌手与其作品:&quot;+students.size()); System.out.println(students.toString());//无序排列 //迭代 System.out.println(&quot;=======keySet()=========&quot;); for (Student key:students.keySet()) { System.out.println(key+&quot;----------&quot;+students.get(key)); } System.out.println(&quot;============entrySet()===========&quot;); for(Map.Entry&lt;Student,String&gt; entry: students.entrySet()){ System.out.println(entry.getKey()+&quot;------&quot;+entry.getValue()); } ///判断 System.out.println(students.containsKey(s1)); System.out.println(students.containsValue(&quot;认真的雪&quot;)); System.out.println(students.isEmpty()); //移除 students.remove(s1); System.out.println(&quot;歌手与其作品:&quot;+students.size()); students.clear(); System.out.println(&quot;歌手与其作品:&quot;+students.size()); } } 歌手与其作品:5 {Student{name='周杰伦', StuTo=20200001}=屋顶, Student{name='张杰', StuTo=20200004}=天下, Student{name='林俊杰', StuTo=20200002}=一眼万年, Student{name='王力宏', StuTo=20200003}=真的爱你, Student{name='薛之谦', StuTo=20200005}=其实} =======keySet()========= Student{name='周杰伦', StuTo=20200001}----------屋顶 Student{name='张杰', StuTo=20200004}----------天下 Student{name='林俊杰', StuTo=20200002}----------一眼万年 Student{name='王力宏', StuTo=20200003}----------真的爱你 Student{name='薛之谦', StuTo=20200005}----------其实 ============entrySet()=========== Student{name='周杰伦', StuTo=20200001}------屋顶 Student{name='张杰', StuTo=20200004}------天下 Student{name='林俊杰', StuTo=20200002}------一眼万年 Student{name='王力宏', StuTo=20200003}------真的爱你 Student{name='薛之谦', StuTo=20200005}------其实 true false false 歌手与其作品:4 歌手与其作品:0 Collections package Collections; import java.lang.reflect.Array; import java.util.*; public class Demo01 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //添加元素 list.add(20); list.add(6); list.add(12); list.add(25); list.add(30); System.out.println(&quot;元素个数:&quot; + list.size()); System.out.println(list.toString()); //排列 Collections.sort(list); System.out.println(list.toString()); //二叉树查找 排序之后 int s = Collections.binarySearch(list, 20);//存在返回索引值 不存在为负 System.out.println(s); //倒序 Collections.reverse(list); System.out.println(list); //乱序 Collections.shuffle(list); System.out.println(list); //copy复制 List&lt;Integer&gt; list1 = new ArrayList(); for (int i = 0; i &lt; list.size(); i++) { list1.add(0); } Collections.copy(list1,list);//IndexOutOfBoundsException 要求复制的列表大小一致 System.out.println(list1); //其他 //list转为数组 System.out.println(&quot;===list转为数组===&quot;); Integer[] array = list.toArray(new Integer[0]);//参数小于list元素个数时 得到的数组大小为list.size 大于则为参数大小 其余以null填充 System.out.println(Arrays.toString(array)); System.out.println(array.length); //数组转为列表 System.out.println(&quot;====数组转为列表========&quot;); String[] singer= {&quot;邓紫棋&quot;,&quot;毛不易&quot;,&quot;廖俊涛&quot;}; //数组转为的列表为受限列表 不能添加或删除 List list2= Arrays.asList(singer); System.out.println(list2); //基本类型转换时 需要用包装类型 //int[] i1= {10,20,100,200}; //List&lt;int&gt; list3 =Arrays.asList(i1); 报错 Integer[] i1= {10,20,100,200}; List&lt;Integer&gt; list3 =Arrays.asList(i1); System.out.println(list3); } } 元素个数:5 [20, 6, 12, 25, 30] [6, 12, 20, 25, 30] 2 [30, 25, 20, 12, 6] [20, 25, 6, 30, 12] [20, 25, 6, 30, 12] ===list转为数组=== [20, 25, 6, 30, 12] 5 ====数组转为列表======== [邓紫棋, 毛不易, 廖俊涛] [10, 20, 100, 200 数组特点：大小固定，只能存储相同数据类型的数据 集合特点：大小可动态扩展，可以存储各种类型的数据 ","link":"https://ganhan999.github.io/post/Java集合/"},{"title":"Java多态","content":"1.多态概述 多态是继封装、继承之后，面向对象的第三大特性。 多态现实意义理解： 现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。 Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 3.多态体现为父类引用变量可以指向子类对象。 4.前提条件：必须有子父类关系。 *注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。* 5.多态的定义与使用格式 ​ 定义格式：父类类型 变量名=new 子类类型(); 6.理解: ​ 多态是同一个行为具有多个不同表现形式或形态的能力。 ​ 多态就是同一个接口，使用不同的实例而执行不同操作。 2.多态中成员的特点 多态成员变量：编译运行看左边 ​ Fu f=new Zi(); ​ System.out.println(f.num);//f是Fu中的值，只能取到父中的值 2.多态成员方法：编译看左边，运行看右边 ​ Fu f1=new Zi(); ​ System.out.println(f1.show());//f1的门面类型是Fu,但实际类型是Zi,所以调用的是重写后的方法。 3.instanceof关键字 作用：用来判断某个对象是否属于某种数据类型。 注意： 返回类型为布尔类型 使用案例： Fu f1=new Zi(); Fu f2=new Son(); if(f1 instanceof Zi){ System.out.println(&quot;f1是Zi的类型&quot;); } else{ System.out.println(&quot;f1是Son的类型&quot;); } 4.多态的转型 多态的转型分为向上转型和向下转型两种 向上转型：多态本身就是向上转型过的过程 ​ 使用格式：父类类型 变量名=new 子类类型(); ​ 适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型 ​ 使用格式：子类类型 变量名=（子类类型） 父类类型的变量； ​ 适用场景：当要使用子类特有功能时。 5.多态案例： 例1：（理解多态，可以重点看这个案例） package day0524; public class demo04 { public static void main(String[] args) { People p=new Stu(); p.eat(); //调用特有的方法 Stu s=(Stu)p; s.study(); //((Stu) p).study(); } } class People{ public void eat(){ System.out.println(&quot;吃饭&quot;); } } class Stu extends People{ @Override public void eat(){ System.out.println(&quot;吃水煮肉片&quot;); } public void study(){ System.out.println(&quot;好好学习&quot;); } } class Teachers extends People{ @Override public void eat(){ System.out.println(&quot;吃樱桃&quot;); } public void teach(){ System.out.println(&quot;认真授课&quot;); } } 例2： 请问题目运行结果是什么？ package day0524; public class demo1 { public static void main(String[] args) { A a=new A(); a.show(); B b=new B(); b.show(); } } class A{ public void show(){ show2(); } public void show2(){ System.out.println(&quot;A&quot;); } } class B extends A{ public void show2(){ System.out.println(&quot;B&quot;); } } class C extends B{ public void show(){ super.show(); } public void show2(){ System.out.println(&quot;C&quot;); } } 答案：A B ","link":"https://ganhan999.github.io/post/Java多态/"},{"title":"155、最小栈","content":"题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt; 返回 -2. 本体思路 利用列表，生成栈 #我的做法： class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stack=[] def push(self, x: int) -&gt; None: self.stack.append(x) def pop(self) -&gt; None: if len(self.stack)&gt;0: self.stack.pop() def top(self) -&gt; int: if len(self.stack)&gt;0: return self.stack[-1] def getMin(self) -&gt; int: return min(self.stack) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： push()方法： 每当push()新值进来时，如果 小于等于 min_stack栈顶值， 则一起push()到min_stack，即更新了栈顶最小值； pop()方法： 判断将pop()出去的元素值是否是min_stack栈顶元素值（即最小值）， 如果是则将min_stack栈顶元素一起pop()，这样可以保证min_stack栈顶元素始终是stack中的最小值。 getMin()方法： 返回min_stack栈顶即可。 min_stack作用分析： min_stack等价于遍历stack所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈。 相当于给stack中的降序元素做了标记，每当pop()这些降序元素，min_stack会将相应的栈顶元素 pop()出去，保证其栈顶元素始终是stack中的最小元素。 class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -&gt; None: self.stack.append(x) if not self.min_stack or x &lt;= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -&gt; None: if self.stack.pop() == self.min_stack[-1]: self.min_stack.pop() def top(self) -&gt; int: return self.stack[-1] def getMin(self) -&gt; int: return self.min_stack[-1] ","link":"https://ganhan999.github.io/post/155、最小栈/"},{"title":"Java三大修饰符","content":"一、abstract 具备某种对象的特征，但不完整，例如animal就是一个抽象的概念，现实生活中没有生物叫做动物，所以animal不应该被创建成对象。 用abstract修饰的类，不能被new出对象，不能独立存在。 abstract class Animal{ String breed; int age; String sex; public void eat(){ System.out.println(&quot;动物吃&quot;); } } 此类不能被new出来 1.抽象类的作用 可被子类继承，提供共性属性和方法。 可声明为引用，更加自然的使用多态。 抽象父类，可作为子类的组成部分，依附于子类对象存在，由父类共性+子类独有组成完整的子类对象。 2.抽象方法 父类提供的方法很难满足子类不同需求，如不定义，则表示所有动物都不会吃、睡。如定义，略显多余，多数会被子类覆盖。 也就是抽象方法的定义不具体实现功能，但在子类必须实现其特有的方法，且抽象方法必须在抽象类之中。 public abstract class Animal{ String breed; int age; String sex; public abstract void eat(); } 子类中必须重写eat方法，或者子类也是抽象类，可以不重写eat方法。 二、static 1.静态属性 正常的对象的实例属性是单个对象所独有的，不会影响到其他对象。 用static修饰的属性是静态属性（类属性)，它属性整个类共有的属性。 public class Student{ static int count; } 在调用时要使用如下方式调用 Student.count;//通过具体的对象也可以访问，但不建议。静态属性在内存中只有一份，且存在与方法区之中 应用 可用来统计这个类的对象被创建多少次。 2.静态方法 Arrays.copyOf(); Arrays.sort();//即类名.静态方法名 静态方法特点 静态方法允许直接访问静态成员。 静态方法不能直接访问非静态成员。 静态方法中不允许使用this或是super关键字 静态方法可以继承，不能重写、没有多态。 3.静态代码块 class Myclss{ static String s=&quot;静态属性&quot;; static{ System.out.println(s); } public static void method(){ } 类加载时，触发静态代码块的执行（仅一次），在静态属性初始化之后执行 作用：可谓静态属性赋值，过必要的初始行为。 类加载 JVM首次使用某个类时，需通过CLASSPATH查找该类的.class文件，从硬盘加载到内存中。 将.class文件中对类的描述信息加载到内存中，进行保存。 加载时机： 创建对象 创建子类对象(父类也被加载) 访问静态属性 调用静态方法 主动加载：Class.forName(“全限定名”); 三、final 1.概念 最后的，不可更改的 2.用法 final可修饰的内容为 类（最终类）不可被继承 String、Math、System均为final修饰的类，不可被继承 方法（最终方法）不能被覆盖或重写 变量（最终变量）常量 final修饰类和方法 可以用来修饰你认为功能实现已经完善的方法，或者最低的类别（不可以在被继承的类），这样子类只可以使用被final修饰的方法，而不能重写。 final修饰变量 被修饰变量值不能被改变（常量），只能被赋值一次。 实例常量 就是给实例变量加上final修饰符，变成常量，被修饰的实例常量不在提供默认值，必须手动赋予初始值。 赋值的时机：显示初始化，构造方法。 注意：如果在构造方法中为实例常量赋值，必须保证所有的构造方法都能对其正确赋值。（也就是实例变量如果没赋默认值，就要在所有构造方法中为其赋予正确值。 静态常量 为静态变量增加final变成静态常量 赋值的时机： 可在初始化时赋值，也可在静态代码块赋值。 即被final修饰过的变量，必须想办法在本类赋值，要不没有默认值，且只能赋值一次。 对象常量 final int num=100; final修饰基本类型时，值不可变 final Student s=new Student(); 修饰引用类型时：地址不可以改变，里面的元素可改变，例如数组中的值，但数组对象不可改变。 4、总结 三个修饰符 abstact，final，static abstract可放在定义类和方法前，被修饰的类可被继承，不能被new出对象来，抽象方法必须在抽象类中，且如果子类也是抽象类可以不用重写方法，如果子类不是抽象类，必须重写方法。 final修饰的类和方法，必须是最后一个，不可已被继承，不可以被重写，变量都变成了常量，只可以赋值一次，且必须赋值，赋值之后不可以更改，基本类型常量，值不能变，引用类型的，地址不可以改变。如果同时是静态的，可以在静态代码块赋值。 static就理解成类加载后一直在内存中存在，没有final修饰的情况下，如果不赋值是有默认值的。在其他类中可通过类名.方法名/变量名赋值或修改。 ","link":"https://ganhan999.github.io/post/Java三个修饰符/"},{"title":"Java 常用类","content":"1、内部类 内部类编译后也会生成独立的字节码文件，也就是class文件 内部类可以直接访问外部类的私有成员，而不破坏封装 可以为外部类提供必要的内部功能组件 1.1成员内部类 在类的内部定义，与实例变量、实例方法同级别的类 外部类的一个实例方法，创建内部类对象时，必须依赖外部类对象 Outer out=new Outer(); Inner inner=out.new Inner()； 当外部类、内部类存在重名属性时，会优先访问内部类属性 System.out.println(Outer.this.name);//访问外部类属性 成员内部类不能定义静态成员，但是可以包括静态常量 1.2静态内部类 不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员 与外部类同级别 Outer.Inner inner=onew Outer.Inner()； 只有内部类才能用static修饰 1.3局部内部类 定义在外部类方法中，作用范围和创建对象范围仅限于方法 局部变量和局部内部类不能加修饰符 局部内部类不能定义静态成员，但是可以包括静态常量 1.4匿名内部类 使用匿名内部类优化（相当于创建了一个局部内部类) 没有类名的局部内部类（一切特征都与局部内部类相同） 必须继承一个父类或者接口 定义类、实现类、创建对象的语法合并，只能创建一个该类的对象 2、Object类 getClass()方法 反射中有详细讲解 返回class对象 hashCode()方法 返回对象的哈希码值 哈希值根据对象的地址或字符串或数字使用hash算法 计算出来的int类型的数值 一般情况下相同对象返回相同的哈希值 toString 返回字符串表示 可以根据需求 覆盖 重写前 Object01.Student@1b6d3586 Object01.Student@4554617c equals() 比较是不是同一地址 finalize（）回收垃圾 package Object01; import java.util.Objects; public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Student)) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override protected void finalize() throws Throwable { System.out.println(this.name+&quot;对象已被删除&quot;); } } package Object01; public class HashCode { public static void main(String[] args) { Student s1 = new Student(&quot;age&quot;,20); Student s2 = new Student(&quot;bbb&quot;,22); Class class1 = s1.getClass(); Class class2 = s1.getClass(); if(class1 == class2){ System.out.println(&quot;s1 s2 同类型&quot;); }else{ System.out.println(&quot;s1 s2 不同类型&quot;); } System.out.println(&quot;=======================&quot;); Student s3 =s1; int h1 = s1.hashCode(); int h2 =s2.hashCode(); int h3 =s3.hashCode(); int ch1=class1.hashCode(); int ch2=class1.hashCode(); System.out.println(h1); System.out.println(h2); System.out.println(h3); System.out.println(ch1); System.out.println(ch2); System.out.println(&quot;================&quot;); System.out.println(s1.toString()); System.out.println(s2.toString()); System.out.println(&quot;=====================&quot;); Student s4 = new Student(&quot;小明&quot;,17); Student s5 = new Student(&quot;小明&quot;,17); if(s4.equals(s5)){ System.out.println(&quot;s4 s5 相同&quot;); }else { System.out.println(&quot;s4 s5 不同&quot;); } new Student(&quot;小明&quot;,17); new Student(&quot;小红&quot;,17); new Student(&quot;小张&quot;,17); new Student(&quot;小王&quot;,17); System.out.println(&quot;回收&quot;); System.gc(); } } s1 s2 同类型 ======================= 2992822 3017717 2992822 460141958 460141958 ================ 未重写前 Object01.Student@2DAAB6//2DAAB6哈希值 16进制 转化10进制为2992822 Object01.Student@2E0BF5 Student{name='age', age=20} Student{name='bbb', age=22} ===================== s4 s5 相同//重写前 不同 回收 小王对象已被删除 小张对象已被删除 小红对象已被删除 小明对象已被删除 3、包装类 java中八种数据类型对应的包装类型 为了方便 byte------Byte short-------Short int-------Integer long------Long float------Float double------Double boolean -----Boolean char-------Character public class Bao { public static void main(String[] args) { //类型转换：装箱 基本类型转为引用类型 System.out.println(&quot;装箱&quot;); int num1=10; Integer integer1 = new Integer(num1); Integer integer2 = Integer.valueOf(num1); System.out.println(integer1); System.out.println(integer2); //类型转换：拆箱 引用类型转为基本类型 System.out.println(&quot;拆箱&quot;); Integer integer3 = new Integer(100); int num2 =integer3.intValue(); System.out.println(num2); //JDK1.5以后 int age=30; //自动装箱 System.out.println(&quot;自动装箱&quot;); Integer integer4=age; System.out.println(integer4); //自动拆箱 System.out.println(&quot;自动拆箱&quot;); int age2 = integer4; System.out.println(age2); //基本类型与字符串的转换 //1.基本类型转为字符串 int n1=100; //1.1使用+号 String s1 = n1+&quot;&quot;; //使用Integer的toString String s2 =Integer.toString(n1); String s3=Integer.toString(n1,16);//转为16进制 System.out.println(s1); System.out.println(s2); System.out.println(s3); System.out.println(&quot;=============&quot;); //字符串转为基本类型 String str = &quot;150&quot;; int n2 = Integer.parseInt(str);//str中只能为数字 System.out.println(n2); //boolean字符串转基本类型 &quot;true&quot;--&gt;true 非&quot;true&quot;--&gt;false String str2 =&quot;true&quot;; boolean b1 = Boolean.parseBoolean(str2); boolean b2 = Boolean.parseBoolean(&quot;str2&quot;); System.out.println(b1); System.out.println(b2); } } 装箱 10 10 拆箱 100 自动装箱 30 自动拆箱 30 100 100 64 ============= 150 true false //Integer 缓冲区 Cache (-128,127) public class Cache { public static void main(String[] args) { Integer i1 = new Integer(100); Integer i2 = new Integer(100); System.out.println(i1==i2);//在堆里 故内存地址不同 Integer i3 = 100;//自动装箱 本质是valueOf函数 Integer i4 = 100; System.out.println(i3==i4); Integer i5 = 200; Integer i6 = 200; System.out.println(i5==i6); } } false true false //valueof源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } static final int low = -128; static final int high=127; 4、String类 字符串是常量 创建后不可改 字符串 字面值储存在字符串池 可以共享 String s =“hello”: 产生一个对象，字符串池中储存 String s = new String(“hello”):产生两个对象，堆池各一个 public class Ste01 { public static void main(String[] args) { String name=&quot;hello&quot;;//&quot;hello&quot;常量储存在常量池 name=&quot;zhangsan&quot;;//&quot;zhangsan&quot;赋值给name变量 并没有修改数据 而是重新在池中开辟内存 String name2=&quot;zhangsan&quot;;//池中已有”zhangsan“ 可直接赋值 此时 name name2指向相同 //另一种 String str =new String(&quot;java&quot;); String str2 = new String(&quot;java&quot;); System.out.println(str==str2); System.out.println(str.equals(str2)); } } false true import java.util.Arrays; public class Ste01 { public static void main(String[] args) { String name=&quot;hello&quot;;//&quot;hello&quot;常量储存在常量池 name=&quot;zhangsan&quot;;//&quot;zhangsan&quot;赋值给name变量 并没有修改数据 而是重新在池中开辟内存 String name2=&quot;zhangsan&quot;;//池中已有”zhangsan“ 可直接赋值 此时 name name2指向相同 //另一种 String str =new String(&quot;java&quot;); String str2 = new String(&quot;java&quot;); System.out.println(str==str2); System.out.println(str.equals(str2)); System.out.println(&quot;======================&quot;); String content = &quot;java是世界上最好的java语言,很多人都在学java&quot;; System.out.println(content.length()); System.out.println(content.charAt(0)); System.out.println(content.contains(&quot;php&quot;)); System.out.println(Arrays.toString(content.toCharArray())); System.out.println(content.indexOf(&quot;java&quot;)); System.out.println(content.indexOf(&quot;java&quot;,4)); System.out.println(content.lastIndexOf(&quot;java&quot;)); System.out.println(&quot;=================&quot;); String str3=&quot; Hello World &quot;; System.out.println(str3.trim()); System.out.println(str3.toUpperCase()); System.out.println(str3.toLowerCase()); System.out.println(str3.endsWith(&quot;ld &quot;)); System.out.println(str3.startsWith(&quot; Hello&quot;)); System.out.println(&quot;================&quot;); System.out.println(content.replace(&quot;java&quot;, &quot;php&quot;)); String str4= &quot;有时候,,有时候 宁愿相信一切有尽头 , 梦一场&quot;; String[] arr=str4.split(&quot;[ ,]+&quot;);//[ ,]表示空格 ， 都可以作为分裂标志 +则是说明个数没有影响 多次当一次使用 for (String s : arr) { System.out.println(s); } System.out.println(&quot;======补充=========&quot;); String str5 =&quot;hello&quot;; String str6 =&quot;Hello&quot;; System.out.println(str5.equals(str6)); System.out.println(str5.equalsIgnoreCase(str6));//忽略大小写 String str7 =&quot;abc&quot;; String str8 =&quot;xyz&quot;; System.out.println(str7.compareTo(str8)); } } false true ====================== 28 j false [j, a, v, a, 是, 世, 界, 上, 最, 好, 的, j, a, v, a, 语, 言, ,, 很, 多, 人, 都, 在, 学, j, a, v, a] 0 11 24 ================= Hello World HELLO WORLD hello world true true ================ php是世界上最好的php语言,很多人都在学php 有时候 有时候 宁愿相信一切有尽头 梦一场 ======补充========= false true -23 java ———————————————————— public class Str02 { public static void main(String[] args) { String str =&quot;this is a text&quot;; String[] arr = str.split(&quot; &quot;); for (String s : arr) { System.out.println(s); } String replace = str.replace(&quot;text&quot;, &quot;practice&quot;); System.out.println(replace); //奉行的是插入 String str2=arr[0]+&quot; &quot;+arr[1]+&quot; &quot;+arr[2]+&quot; easy &quot;+arr[3]; System.out.println(str2); //同样效果 String replace2 = str.replace(&quot;text&quot;, &quot;easy&quot;); String str5=replace2+&quot; text&quot;; System.out.println(str5); //我想的愚蠢方法 String[] arr2 = str2.split(&quot;&quot;); int t = str2.indexOf(&quot;this&quot;); int is_a = str2.indexOf(&quot;is a&quot;); int a = str2.indexOf(&quot;a&quot;); int e = str2.indexOf(&quot;easy&quot;); int text = str2.indexOf(&quot;text&quot;); int[] arr3={t,is_a,a,e,text}; for (int i : arr3) { arr2[i]= arr2[i].toUpperCase(); } String str3=&quot;&quot;; for (String s : arr2) { str3+=s; } System.out.println(str3); //方便一些 for(int i=0;i&lt;arr.length;i++){ char first =arr[i].charAt(0); char upperfirst = Character.toUpperCase(first); String news=upperfirst+arr[i].substring(1); System.out.print(news+&quot; &quot;); } } } this is a text this is a practice this is a easy text this is a easy text This Is A Easy Text This Is A Text StringBuffer:可变字符串 JDK1.0 运行效率慢 线程安全 StringBuilder:可变字符串 JDK5.0 运行效率快 线程不安全 单线程效果好 比起String 效率高 节省内存 用法相同 package Object01; public class Str03 { public static void main(String[] args) { //StringBuffer sb = new StringBuffer(); StringBuilder sb = new StringBuilder(); //1.添加append sb.append(&quot;first &quot;); System.out.println(sb.toString()); sb.append(&quot;second &quot;); System.out.println(sb); sb.append(&quot;third &quot;); System.out.println(sb); //2.插入insert sb.insert(0,&quot;zero &quot;); System.out.println(sb.toString()); //3.替换 replace sb.replace(0,5,&quot;hello&quot;);//含头不含尾 System.out.println(sb.toString()); //删除 delete sb.delete(0,5); System.out.println(sb.toString()); sb.delete(0,sb.length()); System.out.println(sb.length()); } } first first second first second third zero first second third hellofirst second third first second third 0 public class Test { public static void main(String[] args) { String s = &quot;&quot;; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 99999; i++) { s+=i; } long end =System.currentTimeMillis(); System.out.println(&quot;用时:&quot;+(end-start)); StringBuffer sb = new StringBuffer(); long start1= System.currentTimeMillis(); for (int i = 0; i &lt; 99999; i++) { sb.append(i); } long end1 =System.currentTimeMillis(); System.out.println(&quot;用时:&quot;+(end1-start1)); StringBuilder sb2 = new StringBuilder(); long start2= System.currentTimeMillis(); for (int i = 0; i &lt; 99999; i++) { sb2.append(i); } long end2 =System.currentTimeMillis(); System.out.println(&quot;用时:&quot;+(end2-start2)); } } 用时:16933 用时:13 用时:6 5、BigDicimal double long 保存时存在误差 为近似存储； double d1=1.0; double d2=0.9; System.out.println(d1-d2)//0.09999999 double d1=1.4; double d2=0.5; System.out.println((d1-d2)/0.9)//0.9999999 BigDicimal:精确存储 实行浮点数的精确计算 创建对象时要用字符串形式 HALF.UP四舍五入 package Object01; import java.math.BigDecimal; import java.math.RoundingMode; public class BigDecimal02 { public static void main(String[] args) { double b1=0.9; double b2=1.0; double b3=(1.4-0.5); System.out.println(b2-b1); System.out.println(b3/b1); BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;); BigDecimal bd2 = new BigDecimal(&quot;0.9&quot;); System.out.println(bd1.add(bd2)); System.out.println(bd1.subtract(bd2)); System.out.println(bd1.multiply(bd2)); System.out.println(new BigDecimal(&quot;1.4&quot;).subtract(new BigDecimal(&quot;0.5&quot;)).divide(new BigDecimal(&quot;0.9&quot;))); //System.out.println(new BigDecimal(&quot;10&quot;).divide(new BigDecimal(&quot;3&quot;))); 除不尽 没指定保留位数 System.out.println(new BigDecimal(&quot;10&quot;).divide(new BigDecimal(&quot;3&quot;),3, RoundingMode.HALF_UP));//RoundingMode.HALF_UP四舍五入 } } 0.09999999999999998 0.9999999999999999 1.9 0.1 0.90 1 3.333 6、Data类 package Object01; import java.util.Date; public class data { public static void main(String[] args) { //1.今天 Date date1 = new Date(); System.out.println(date1.toString()); System.out.println(date1.toLocaleString()); //2.昨天 Date data2 =new Date(date1.getTime()-(60*60*24*1000)); System.out.println(data2.toLocaleString()); //方法 after before System.out.println(date1.after(data2)); System.out.println(date1.before(data2)); //compareTo System.out.println(date1.compareTo(data2));//date1大于date2为1 小于为-1 等于为0 //相等 System.out.println(date1.equals(data2)); } } Sun Nov 15 21:36:29 CST 2020 2020-11-15 21:36:29 2020-11-14 21:36:29 true false 1 false 7、Calendar package Object01; import java.util.Calendar; public class calendar { public static void main(String[] args) { //获取现在时间 Calendar calendar1= Calendar.getInstance(); System.out.println(calendar1.getTime().toLocaleString()); //获取时间信息 int year=calendar1.get(Calendar.YEAR); //设定月份为0到11 int month =calendar1.get(Calendar.MONTH); int day =calendar1.get(Calendar.DAY_OF_MONTH); int hour = calendar1.get(Calendar.HOUR_OF_DAY);//HOUR_OF_DAY表示24小时制 HOUR表示12小时进制 int minute =calendar1.get(Calendar.MINUTE); int second =calendar1.get(Calendar.SECOND); System.out.println(year+&quot;年&quot;+(month+1)+&quot;月&quot;+day+&quot;日&quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;); //修改时间 calendar1.set(Calendar.DAY_OF_MONTH,5);//设置 为5号 System.out.println(calendar1.getTime().toLocaleString()); //add修改时间 Calendar calendar2= Calendar.getInstance(); System.out.println(calendar2.getTime().toLocaleString()); calendar2.add(Calendar.DAY_OF_MONTH,-1); System.out.println(calendar2.getTime().toLocaleString()); //补充 int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH); int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH); System.out.println(max); System.out.println(min); } } 2020-11-15 21:59:02 2020年11月15日21时59分2秒 2020-11-5 21:59:02 2020-11-15 21:59:02 2020-11-14 21:59:02 30 1 8、SimpleDataFormat package Object01; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.SimpleTimeZone; public class simpleDataFormat { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date date = new Date(); //格式化 时间转为字符串 String format = sdf.format(date); System.out.println(format); //解析 Date date1 = sdf.parse(&quot;2020年1月24日 10:00:01&quot;);//注意与sdf 参数格式一致 System.out.println(date1); } } 2020年11月15日 22:09:30 Fri Jan 24 10:00:01 CST 2020java 9、System类 package Object01; import java.util.Arrays; public class System1 { public static void main(String[] args) { int[] arr ={10,25,41,13,14,5,34,14}; int[] dest =new int[8]; System.arraycopy(arr,0,dest,0,arr.length);//五个参数 被copy数组 开始位置 新数组 开始位置 copy长度 for (int i : dest) { System.out.print(i+&quot;\\t&quot;); } //Arrays.copyOf() 本质使用System.arraycopy() 说明System.arraycopy()效率高 //计时 System.out.println(); int result=0; long start =System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) { for (int j = 0; j &lt; 1000; j++) { result=i*j; } } System.out.println(result); long end =System.currentTimeMillis(); System.out.println(&quot;用时:&quot;+(end-start)); //gc回收 new Student(&quot;aaa&quot;,18); new Student(&quot;bbb&quot;,18); new Student(&quot;ccc&quot;,18); System.gc(); //exit退出jvm 后面不再执行 System.exit(0); System.out.println(&quot;到此为止！！！&quot;); } } 10 25 41 13 14 5 34 14 998001 用时:5 ccc对象已被删除 bbb对象已被删除 aaa对象已被删除 ","link":"https://ganhan999.github.io/post/Java类/"},{"title":"141、环形链表","content":"题目 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置 （索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 本体思路 给head一个属性，flag记录被遍历过的元素，如果发现被遍历过一次，那么就表示有回路 #我的做法： class Solution: def hasCycle(self, head: ListNode) -&gt; bool: while head: try: if head.flag==1: return True except: head.flag=1 head=head.next else: return False &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 哈希表，和我的方法差不多 class Solution: def hasCycle(self, head: ListNode) -&gt; bool: # 1. python map m = {} while head: if m.get(head): return True m[head] = 1 head = head.next return False &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 枚举时添加一个慢一拍的指针，如果有环最终两个指针会相遇，可能会很慢啊 class Solution: def singleNumber(nums): return sum(set(nums))*2-sum(nums) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法3 链表中最多10000个节点，超过10000就是有环 class Solution: def hasCycle(self, head: ListNode) -&gt; bool: # 3. 计数 10000 count = 0 while head and count &lt;= 10000: count += 1 head = head.next return count &gt; 10000 ","link":"https://ganhan999.github.io/post/141、环形链表/"},{"title":"JavaSE基础4","content":"面向对象 1、抛出异常 public static int[] sort(int[] array) throws IOException{ } 2、非静态方法和静态方法 如果设置的是static静态方法，可以直接类.方法名 如果设置的是非静态方法，则需要实例化对象，使用new static静态方法是和类一起加载的，而非静态方法是类实例化之后才存在的 3、构造方法（构造器） 一个类即使什么都不写，也会存在一个方法 构造器和类名要相同，没有返回值，也不能使用void 作用：实例化初始值 使用new关键字，本质是在调用构造器 默认有一个无参构造器 alt＋insert可以快捷生成构造器 4、封装 高内聚，低耦合* public/private 公有属性和私有属性（相等于python中的__name) 属性私有,利用get/set方法操作私有属性 public String getName() { return this.name; } public void setName(String name) { return this.name=name; } 5、继承 extends关键词 public、protexted、default、private ctrl+H打开继承树 私有的东西无法被继承 默认执行父类的无参构造（隐藏代码，super（）） 调用父亲的构造器，必须要在子类构造器的第一行 this同理 6、super关键字 只能指代父类对象 指代父类的构造方法，只能放在首行 super和this不能同时调用构造行数 super必须只能出现在子类的方法或者构造方法中 注意 子类必须通过super关键字调用父类有参数的构造函数 使用super调用父类构造器的语句必须是子类构造器的第一条语句 如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用父类的构造器，则java编译器将报告错误 子类实例化时，默认调用父类的无参构造方法（不管子类的构造器有没有参数，因为子类继承的是父类的属性和方法，只调用父类的无参构造器就可以继承父类的属性和方法，因此不会调用父类的有参构造器），再调用子类的有参/无参构造器。 7、this vs super关键字 代表对象不同：this:本身调用者这个对象 super：代表父类对象的应用 前提不用: this:没有继承也能使用 super：只能在继承条件下才能使用 构造方法不同 this（）；本类的构造 super（）；父类的构造 8、方法重写 B b =new A()//父类的引用指向了字类 这里B是A的父类 如果是静态方法，那么方法的调用只和左边的类型有关，这里指的是B // 如果是非静态方法，那么子类重写了父类的方法，重写只和非静态方法有关 //重写的关键词一定要是public 重写：需要有继承关系，字类重写父类的方法 方法名必须相同 参数列表必须相同 修饰符范围，子类可以比父类大但不能大 public&gt;protected&gt;default&gt;private 抛出的异常，子类可以比父类小但不能小 重写，子类的方法和父类必须要一致，方法体不同 为什么需要重写？ 父类的功能，子类不一定需要，或者不一定满足 ALt+Insert：override 9、多态 Student s1=new Student();//能调用自己的或者父类的 Person s2=new Student();//可以指向子类，但是不能调用子类独有的方法 Object s3=new Student(); 多态注意事项 多态是方法的多态，属性没有多态 父类和子类，有联系，类型转换异常！ClassCastException 存在条件：继承关系，方法需要重写，父类的引用指向子类对象。 比如：Parent parent = new Child();类型是Parent，指向Child对象，当使用多态方式调用方法时，首先检查父类中是否有 X() 方法，如果没有则编译错误；如果有，再去调用子类的 X() 方法 static、final、private方法均不能被重写，所以就没有多态 9、instanceof 关键字 public class Application { public static void main(String[] args) { // Object&gt;String //Object&gt;Person&gt;Student //Object&gt;Person&gt;Teacher //System.out.println( X instanceof Y);//X Y 是否有继承关系 Object object = new Student(); System.out.println(object instanceof Student);//object 指向Student 故为True System.out.println(object instanceof Person);//True System.out.println(object instanceof Object);//True System.out.println(object instanceof Teacher);//False System.out.println(object instanceof String);//false System.out.println(&quot;=========================&quot;); Person object2 = new Student(); System.out.println(object2 instanceof Student);//True System.out.println(object2 instanceof Person);//True System.out.println(object2 instanceof Object);//True System.out.println(object2 instanceof Teacher);//False //System.out.println(object2 instanceof String); //编译错误 // 感觉是obj的指向类型 判断 true or false // obj的类型决定能否比较 System.out.println(&quot;=========================&quot;); Person object3 = new Person(); System.out.println(object3 instanceof Student);//False System.out.println(object3 instanceof Person);//True System.out.println(object3 instanceof Object);//True System.out.println(object3 instanceof Teacher);//False //System.out.println(object3 instanceof String); //编译错误 System.out.println(&quot;=========================&quot;); Student object4 = new Student(); System.out.println(object4 instanceof Student);//True System.out.println(object4 instanceof Person);//True System.out.println(object4 instanceof Object);//True //System.out.println(object4 instanceof Teacher);//编译错误 //System.out.println(object4 instanceof String); //编译错误 } } 10、类型转换 父类引用 指向子类的对象 子类转化为父类 向上转型 ，可能会丢失自己的一些方法 类转化为子类 向下转型 需强型转换 方便代码使用 //类型之间的转化： 父 子 //高 低 Person obj =new Student(); //obj.go();编译报错 无法使用 //student 将这个obj转化为Student 则go可以使用 //父类Person 转化为子类 Student Student student =(Student) obj; student.go(); ((Student)obj).go(); 11、代码块执行顺序 public class ap { { System.out.println(&quot;匿名代码块&quot;);//2 赋初值 } static { System.out.println(&quot;静态代码块&quot;);//1 只执行一次 } public ap(){ System.out.println(&quot;构造方法&quot;);//3 } public static void main(String[] args) { ap A = new ap(); System.out.println(&quot;======&quot;); ap B = new ap(); } } /* 输出为: 静态代码块 匿名代码块 构造方法 ====== 匿名代码块 构造方法 静态代码块只执行一次 / 12、static关键字补充 //静态导入包 import static java.lang.Math.random //final 修饰的类不能被继承 断子绝孙 13、抽象类 package Demo05; //抽象类： 类 extends: 单继承~ （接口可以多继承） public abstract class Action { //约束 有人帮我们实现 //抽象方法 只有方法名字 没有方法的实现 public abstract void doSomeThing(); //约束 不能new产生 必须通过子类来实现它 //抽象类中可以写普通方法 //抽象方法必须在抽象类中 public void say(){ System.out.println(&quot;say&quot;); } //抽象的抽象 约束 //思考题？ 不能 new 存在构造器吗 以及 存在的意义 抽象出来 提高开发效率 } package Demo05; //抽象类的所有方法 继承了他的子类 都必须重写它的抽象方法，除非这个类也是抽象类，就让子子类重写 public class A1 extends Action{ @Override public void doSomeThing() { } } package Demo05; public abstract class Action { public Action() { } public abstract void doSomeThing(); public void say() { System.out.println(&quot;say&quot;); } } //说明有 构造器 不能new抽象类，只能靠子类实现它：约束 抽象类可以写普通方法 抽象方法必须在抽象类中 抽象类有构造器 14、接口 普通类：只有具体实现 抽象类：具体实现和规范 接口：只有规范！自己无法写方法 面向接口编程 实现约束和实现分离 接口本质是契约 interface关键字 package Demo02; public interface UserService { //可以常量 public static final int AGE =99; //接口中的所有定义都是抽象的 public abstract void add(String name); void delete(String name); void update(String name); void query(String name); } package Demo02; public interface TimeService { void timer(); } package Demo02; //抽象类： expends //类 可以实现接口 implements 接口 //实现接口的类 就需要重写类中的方法 alt+enter public class UserServiceImp implements UserService,TimeService{ @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } @Override public void timer() { } } 作用： 1.约束 2.定义一些方法 让不同人来实现 3.public abstract 4.public static final 5.接口不能被使用 接口中没有构造方法 6.implement可以实现多个接口 7.必须重写接口的方法 15、内部类 //成员内部类 package Demo3; public class Outer { private int id; public void out(){ System.out.println(&quot;这是外部类的方法&quot;); } public class Inner{ public void in(){ System.out.println(&quot;这是内部类的方法&quot;); } //获得外部类的私有属性 public void getId(){ System.out.println(id); } } } package Demo3; public class Application { public static void main(String[] args) { Outer outer = new Outer(); //通过外部类来实例化 内部类 Outer.Inner inner= outer.new Inner(); inner.in(); inner.getId(); } } ----------- 这是内部类的方法 0 ----------- //局部内部类:定义在内部类方法中 故应用范围仅在此方法中 package D1; public class Outer02 { private String name = &quot;张三&quot;; private static int age = 10; public void show(){ String address = &quot;南京&quot;; class Inner{ private String tel = &quot;18888888888&quot;; private String email = &quot;zhangsan@163.com&quot;; public void show2(){ System.out.println(name);//Outer.this.name System.out.println(age);//Outer.age System.out.println(tel);//this.tel System.out.println(email); //访问方法中的变量 只能访问常量 jdk1.7之前 需要加上final 1.8之后默认 System.out.println(address); } } //address = &quot;深圳&quot;; 此处若修改 Inner类中将无法使用 address 因为 address不为常量了 Inner inner = new Inner(); inner.show2(); } } package D1; public class Test02 { public static void main(String[] args) { Outer02 outer02 = new Outer02(); outer02.show(); } } -------- 张三 10 18888888888 zhangsan@163.com 南京 -------- //匿名内部类 ： 必须继承一个接口或者父类 public static void main(String[] args){ Usb usb = new Usb{ @override public void show(){ System.out.println(&quot;匿名内部类&quot;)； } } usb.show(); } 16、异常 检查性异常：用户错误或问题引发的异常 编译时不能简单忽略的 运行时异常 ：可能被程序员避免的异常 运行时异常出现 编译时被忽略 错误Error：脱离程序员控制问题，在代码中通常被忽略 异常关键字：try、catch、finally、throw、throws package Demo07; public class Test { public static void main(String[] args) { int a=1; int b=0; try{//try 监控区域 if(b==0) {//throw throw new ArithmeticException();//主动抛出异常 } }catch(Error e){//捕获异常的参数从小到大 System.out.println(&quot;Error&quot;); } catch(Exception e){//捕获异常 System.out.println(&quot;Exception&quot;); }catch(Throwable t){ System.out.println(&quot;Throwable&quot;); } finally{//处理善后工作 可以没有 System.out.println(&quot;finally&quot;); } } } Exception finally //ctrl+alt+t可以弹出生成代码 17、自定义异常 自定义异常类 继承 Exception 创建自定义异常类 在方法中通过throw关键字抛出异常 用 try-catch语句捕获并处理 否则在方法声明处用throws抛出异常 在出现异常的方法的调用者中捕获并处理异常 package Demo07; public class MyException extends Exception{ //传递数字&gt;10; private int detail; public MyException(int a){ this.detail=a; } //toString:异常打印信息 public String toString(){ return &quot;MyException{&quot;+&quot;detail=&quot;+detail+&quot;}&quot;; } } public class Test { //可能存在异常的方法 static void test(int a) throws MyException { System.out.println(&quot;传递的函数为:&quot; + a); if (a &gt; 10) { throw new MyException(a);//抛出 } System.out.println(&quot;ok&quot;); } public static void main(String[] args) { try { test(11); } catch (MyException e) { System.out.println(&quot;MyException=&gt;&quot;+e); } } --------------------------------- 传递的函数为:11 MyException=&gt;MyException{detail=11} ---------------------------------- ","link":"https://ganhan999.github.io/post/JavaSE基础4/"},{"title":"136、只出现一次的数字","content":"题目 给定一个非空整数数组，除了某个元素只出现一次以外， 其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 本体思路 先排序，然后相同元素则会相邻。循环一次判断前一个元素是否等于后一个元素， 间隔一个判断一个即可，如果不相等就是想要的结果 #我的做法： class Solution: def singleNumber(nums): if len(nums)==1: #如果数组长度为1，则直接返回即可 return nums[0] nums.sort() #对数组进行排序，使其相同元素靠在一起 for i in range(1,len(nums),2): #循环数组，验证前后是否相同，由于原始出现两次，因此可跳跃判断 if nums[i-1] != nums[i]: return nums[i-1] if (i+2) == len(nums): #判断单一元素在排序后数组的最后面 return nums[-1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 由于目标元素只有一次，其他元素有多次， 因此，依次删除列表的元素，同一个元素删除两次，报错则为目标值。 class Solution: def singleNumber(nums): while True: d = nums[0] nums.remove(d) try: nums.remove(d) except: return d &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 方法三：一个元素出现一次、其他出现多次，那么数组求和，与去重后的和相差的就是目标值。 class Solution: def singleNumber(nums): return sum(set(nums))*2-sum(nums) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法3 0和任何数异或的结果都是这个数本身。 相同的数异或的结果为0。 这个数列里面除了一个数只出现了一次，其他数都出现了两次。 异或运算满足交换律和结合律。 因此从前往后依次异或即可。最终结果就是那个只出现一次的数。 比如 1 xor 1 xor 2 xor 3 xor 2 = (1 xor 1) xor (2 xor 2) xor 3 = 0 xor 0 xor 3 = 0 xor 3 = 3 from functools import reduce class Solution: def singleNumber(nums): return reduce(lambda x, y: x ^ y, nums) &quot;&quot;&quot; 下面是 reduce函数介绍 reduce() 函数会对参数序列中元素进行累积。 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作： 用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 注意：Python3.x reduce() 已经被移到 functools 模块里， 如果我们要使用，需要引入 functools 模块来调用 reduce() 函数： from functools import reduce from functools import reduce def add(x, y) : # 两数相加 return x + y sum1 = reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5 sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 &quot;&quot;&quot; ","link":"https://ganhan999.github.io/post/136、只出现一次的数字/"},{"title":"JavaSE基础3","content":"1、方法的定义 修饰符 返回值类型 方法名 （参数类型 参数名）{ 方法体 return 返回值； } java属于值传递 2、方法的重载 方法名一样 参数列表不一样（个数、类型、参数排列顺序） 返回类型可以不同 仅仅返回类型不同不足以成为重载 3、可变参数 在指定参数类型后加一个省略号… public static void printmax(double... numbers){} 4、数组的声明 dataType[] arrayRefVar//首选 dataType arrayRefVar[] //效果一样 array.length //获取数组长度 int[] nums; 5、Java内存分析 堆：存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用 栈：存放基本变量类型（包含这个基本类型的具体数值）；引用对象的变量（会存放这个引用在堆里面的具体地址） 方法区：可以被所有线程共享；包含所有class和static变量 数组本身就是对象，Java中对象都在堆中，因此数组无论保存原始类型或者其他对象类型，数组对象本身是在堆中。 6、数组的初始化 //静态初始化:创建＋赋值 int[] a={1,2,3}; //动态初始化:包含默认初始化，默认值都为0 int[] b=new int[10]; b[0]=10 7、数组小结 数组是相同数据类型（数据类型可以为任意类型）的有序集合 数组也是对象，数组元素相当于对象的成员变量 数组的长度是确定的，不可变。如果越界，则报ArrayIndexOutofBounds 8、遍历数组 1.for循环，最常见 2.利用foreach 3.利用jdk自带的方法 --&gt; java.util.Arrays.toString() 9、流程 if语句 for(int array:arrays){ System.out.println(array);//无下标 } for(int i=0;i&lt;arrays.length;i++){ System.out.print(arrays[i]+&quot;&quot;); } public static void printArray(int[] arrays){ //形参是数组 } 10、多维数组 int[][] array={{1,2},{3,4}}; for (int i=0;i&lt;array.length,i++){ for (int j=0;j&lt;array[i].length,j++){ System.out.println(array[i][j]); } } 11、Arrays类 import java.util.Arrays int[] a={1,2,3}; System.out.println(Arrays.toString(a));//打印数组Arrays.toString() Arrays.sort(a)//排序 12、冒泡排序 package jichu; import java.util.Arrays; public class while1 { public static void main(String[] args) { int[] a={1,2,3,4,1,3,2}; int[] sort=sort(a); System.out.println(Arrays.toString(sort)); } public static int[] sort(int[] array){ int temp=0; for (int i=0;i&lt;array.length;i++){ boolean flag=false; for (int j=0;j&lt;array.length-i-1;j++){ if(array[j+1]&lt;array[j]){ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; flag=true; } } if(flag==false){ break; } } return array; } } ","link":"https://ganhan999.github.io/post/JavaSE基础3/"},{"title":"125、验证回文串","content":"题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: &quot;A man, a plan, a canal: Panama&quot; 输出: true 示例 2: 输入: &quot;race a car&quot; 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 把不是字母和数字的字符全部去掉，然后转大写，再比较反转和原来的字符串是否相等 #我的做法： class Solution: def isPalindrome(self, s: str) -&gt; bool: if not s: return True li=list([val for val in s if val.isalnum()])#去掉除字母和数字以外的字符 li=&quot;&quot;.join(li).upper()#转大写 return li==li[::-1] &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 正则表达式 class Solution: def isPalindrome(self, s: str) -&gt; bool: s = re.sub(r'[^a-z0-9]', '', s.strip().lower()) return s == s[::-1] ","link":"https://ganhan999.github.io/post/125、验证回文串/"},{"title":"JavaSE基础2","content":"1、注释 单行注释 多行注释 文档注释 public class HelloWorld { public static void main(String[] args) { //单行注释 System.out.println(&quot;Hello World!&quot;); /* 多行注释 多行注释 */ //JavaDoc：文档注释 /** */ /** *@Description Helloworld *@Author Ganhan */ } } 2、标识符 所有标识符都应该以字母(A-Z,a-z)，美元符($)，或者下划线(_)开始 标识符是大小写敏感的 3、数据类型 强类型语言（Java是强类型语言） 要求变量的使用要严格符合规定，所有变量都需要先定义再使用 弱类型语言 public class shujuleixing { public static void main(String[] args) { //八大基本数据类型 //整数 int num=10; short num1=20; byte num2=30; long num3=40L;//long类型后面加一个L //小数：浮点数 float num4=50.1F;//最好完全避免用浮点数进行比较 double num5=3.1415; //字符 char name ='g'; //字符串,String不是关键字，他是一个类 //String name=&quot;ganhan&quot;; //布尔值：是非 boolean flag=true; boolean flag1= false; } } 4、类型转换 byte,short,char--&gt;int--&gt;long--&gt;float--&gt;double 5、变量 static double pi=3.14//类变量 int age//在方法内是局部变量，需要初始化，在方法外是实例变量，默认值为false 6、运算符 package jichu; public class yunsuanfu { public static void main(String[] args) { //二元运算符 //ctrl+D：复制当前行到下一行 int a=10; int b=21; int c=30; int d=40; System.out.println(a + b); System.out.println(a - b); System.out.println(a * b); System.out.println(b % a); System.out.println(a / b); System.out.println(a/(double)b); long a1=12312312l; int b1=123; short c1=10; byte d1=12; System.out.println(a1 + b1 + c1 + d1);//Long System.out.println(b1 + c1 + d1);//Int System.out.println(c1 + d1);//Int int a3=10; int b3=10; System.out.println(a3 &gt; b3); System.out.println(a3 == b3); System.out.println(a3 != b3); //++ -- 自增 自减 一元运算符 int a4=3; int b4=a4++;//后加1 int c4=++a;//先加1 System.out.println(a4); System.out.println(b4); System.out.println(c4); //幂运算 double pow=Math.pow(2,3); System.out.println(pow); //与或非 boolean a5=true; boolean b5=false; System.out.println(a5 &amp;&amp; b5); System.out.println(a5 || b5); System.out.println(!(a5 &amp;&amp; b5)); //位运算 /* A=0011 1100 B=0000 1101 A&amp;B=0000 1100 A|B=0011 1101 A^B=0011 0001(异或) ~B=1111 0010 2*8怎么算最快 &lt;&lt;左移 &gt;&gt;右移 左移一位就是×2 右移一位就是÷2 */ //扩展运算符 int a6=10; int b6=20; a6+=b6;//a6=a6+b6 System.out.println(a6); //字符串连接符 System.out.println(&quot;&quot;+a6+b6);//3020 System.out.println(a6+b6+&quot;&quot;);//50 //条件运算符 //三元运算符 //x?y:z //如果x为真。那么y，否则z int score=80; String type=score &lt;60 ?&quot;不及格&quot;:&quot;及格&quot;; System.out.println(type); } } 7、包机制 一般用公司域名倒置作为包名 package是定义包 利用import导入包的对象 import语句要在package下方 import com.kuang.base.*表示导入这个包下的所有类！ 8、JavaDoc javadoc命令就是用来生成自己的api文档 9、流程 Scanner对象 Scannerl类来获取用户的输入 if语句 //Scanner s=new Scanner(System.in); package jichu; import java.util.Scanner; public class shuru { public static void main(String[] args) { //创建一个扫描器对象，用于接收键盘传入数据 Scanner scanner=new Scanner(System.in); System.out.println(&quot;使用next方法接收：&quot;); //判断用户有没有输入字符串 if (scanner.hasNext())//hasNextline:以enter为结束 hasNext：以空格为结束 { //使用next方法接收 String str=scanner.next();//nextLine System.out.println(&quot;输出的内容是：&quot;+str); } scanner.close(); } } package jichu; import java.util.Scanner; public class shuru1 { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int m=0; double sum=0; while (scanner.hasNextDouble()){ double x= scanner.nextDouble(); m++; sum+=x; System.out.println(&quot;你输入了第&quot;+m+&quot;个数,然后当前结果sum为&quot;+sum); } System.out.println(m+&quot;个数的和为&quot;+sum); System.out.println(m+&quot;个数的平均数为&quot;+(sum/m)); scanner.close() } } swicth语句 package jichu; public class switchtext { public static void main(String[] args) { char grade='C'; switch (grade){ case 'A': System.out.println(&quot;优秀&quot;); break;//可选 穿透 case 'B': System.out.println(&quot;良好&quot;); break; case 'C': System.out.println(&quot;合格&quot;); case 'D': System.out.println(&quot;不合格&quot;); default://可选 System.out.println(&quot;没什么&quot;); } } } while语句 while(){ } -------------------------- do{ }while(); -------------------------- for(;;){ } -------------------- for(;){ } ","link":"https://ganhan999.github.io/post/JavaSE基础2/"},{"title":"122、买卖股票的最佳时机II","content":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 动态规划，如果第二天降价了，我前一天就卖出去，就永远不会亏！ #我的做法： class Solution: def maxProfit(self, prices: List[int]) -&gt; int: n = len(prices) if n == 0: return 0 # 边界条件 dp = [0] * n resent=prices[0] for i in range(1,n): if prices[i]&gt;resent: dp[i]=prices[i]-resent+dp[i-1] resent=prices[i] else: dp[i]=dp[i-1] resent = prices[i] return dp[-1] &quot;&quot;&quot;&quot;&quot;&quot; #我的做法2： 贪心算法 只要第二天比第一天赚了钱我就加上去。 class Solution: def maxProfit(self, prices: List[int]) -&gt; int: result = 0 n = len(prices) if n == 0: return result for i in range(n-1): result+=max(prices[i+1]-prices[i],0) return result ","link":"https://ganhan999.github.io/post/122、买卖股票的最佳时机II /"},{"title":"JavaSE基础1","content":"1、Markdown语法 #+语句表示标题，#越多表示标题级别越低 三级标题 两个**包夹着一段文字，表示黑体 黑体 两个*包夹着一段文字，表示斜体 斜体 两个***包夹着一段文字，表示黑斜体 黑斜体 一个&gt;表示引用 一个&gt;表示引用 三个-或者*表示分割线 一个!+[]+()表示图片 一个[]+()表示超链接 点击跳转到我的博客 数字＋.＋空格表示有序列表 A B A B |||表示表格 名字 性别 生日 张三 男 1991 用tab上面的三个点`表示代码 123 Hello 2、电脑常用快捷键 win+E 打开我的电脑 win+R 打开运行界面 shift+Del 永久删除 ctrl+shift+esc 任务管理器 3、Dos命令 打开CMD的方式： 开始+系统+命令提示符 win+R 输入cmd 打开控制台 在任意的文件夹下，按住shift＋鼠标右键，在此处打开命令行窗口 资源管理器的地址栏前面加上cmd路径 常用的Dos命令 #盘符切换 直接F: #查看当前目录下的所有文件 dir #切换目录 cd (change directory) cd /d 可以跨盘符切换 cd .. 返回上一级目录 cd 目录名 直接可以进入当前一下的目录 #清除屏幕 cls(clear screen) #退出终端 exit #查看电脑Ip ipconfig #打开应用 calc 打开计算机 mspaint 打开画图工具 notepad 打开记事本 #ping命令 ping www.baidu.com #文件操作命令 md 创建文件夹 cd&gt; 创建文件 del 删除文件 rd 删除文件夹(remove directory) 4、JDK、JRE、JVM JDK:Java Development Kit (Java 开发者工具) JRE:Java Runtime Environment (Java运行时环境)(JDK包括JRE) JVM:Java Virtual Machine (Java虚拟机) 5、Hello World！ public class Hello{ public static void main(String[] args){ System.out.print(&quot;Hello World!&quot;); } } #注意String要大写，注意分号，注意“”号 #cmd 当前目录 javac Hello.java java Hello javac java文件，会生成class文件 运行class文件，java class文件 6、编译和解释 解释就是一句一句翻译 编译就是全部翻译 Java是一种两种结合的语言 先经过编译生成class文件 再解释 ","link":"https://ganhan999.github.io/post/JavaSE基础1/"},{"title":"121、买卖股票的最佳时机","content":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次）， 设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 从第一天开始遍历，如果后一天与当前最小值的差值大于最大差值，那么就记录该差值，否则保持不变。 记得要随时改变最小值。 #我的做法： class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 minval=prices[0] maxans=0 for p in prices: minval=min(minval,p) maxans=max(maxans,p-minval) return maxans &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 动态规划 dp[i] 表示前 ii 天的最大利润，因为我们始终要使利润最大化，则： dp[i] = max(dp[i-1], prices[i]-minprice) class Solution: def maxProfit(self, prices: List[int]) -&gt; int: n = len(prices) if n == 0: return 0 # 边界条件 dp = [0] * n minprice = prices[0] for i in range(1,n): minprice=min(prices[i],minprice) dp[i]=max(dp[i-1],prices[i]-minprice) return dp[-1] ","link":"https://ganhan999.github.io/post/121、买卖股票的最佳时机/"},{"title":"Python算法入门 (动态规划)","content":"动态规划 1、斐波那契数列 # 子问题的重复计算 def fibnacci(n): if n == 1 or n == 2: return 1 else: return fibnacci(n-1) + fibnacci(n-2) # 动态规划（DP）的思想 = 递推式 + 重复子问题 def fibnacci_no_recurision(n): f = [0,1,1] if n &gt; 2: for i in range(n-2): num = f[-1] + f[-2] f.append(num) return f[n] print(fibnacci_no_recurision(100)) 2、最长公共子序列 def lcs_length(x, y): m = len(x) n = len(y) c = [[0 for _ in range(n+1)] for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if x[i-1] == y[j-1]: # i j 位置上的字符匹配的时候，来自于左上方+1 c[i][j] = c[i-1][j-1] + 1 else: c[i][j] = max(c[i-1][j], c[i][j-1]) return c[m][n] def lcs(x, y): m = len(x) n = len(y) c = [[0 for _ in range(n + 1)] for _ in range(m + 1)] b = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # 1 左上方 2 上方 3 左方 for i in range(1, m+1): for j in range(1, n+1): if x[i-1] == y[j-1]: # i j 位置上的字符匹配的时候，来自于左上方+1 c[i][j] = c[i-1][j-1] + 1 b[i][j] = 1 elif c[i-1][j] &gt; c[i][j-1]: # 来自于上方 c[i][j] = c[i-1][j] b[i][j] = 2 else: c[i][j] = c[i][j-1] b[i][j] = 3 return c[m][n], b def lcs_trackback(x, y): c, b = lcs(x, y) i = len(x) j = len(y) res = [] while i &gt; 0 and j &gt; 0: if b[i][j] == 1: # 来自左上方=&gt;匹配 res.append(x[i-1]) i -= 1 j -= 1 elif b[i][j] == 2: # 来自于上方=&gt;不匹配 i -= 1 else: # ==3 来自于左方=&gt;不匹配 j -= 1 return &quot;&quot;.join(reversed(res)) print(lcs_trackback(&quot;ABCBDAB&quot;, &quot;BDCABA&quot;)) 3、最大公约数 def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) def gcd2(a, b): while b &gt; 0: r = a % b a = b b = r return a print(gcd2(12,16)) 4、切木头问题 p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 21, 23, 24, 26, 27, 27, 28, 30, 33, 36, 39, 40] # p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30] def cut_rod_recurision_1(p, n): if n == 0: return 0 else: res = p[n] for i in range(1, n): res = max(res, cut_rod_recurision_1(p, i) + cut_rod_recurision_1(p, n-i)) return res def c1(p, n): return cut_rod_recurision_1(p, n) def cut_rod_recurision_2(p, n): if n == 0: return 0 else: res = 0 for i in range(1, n+1): res = max(res, p[i] + cut_rod_recurision_2(p, n-i)) return res def c2(p,n): return cut_rod_recurision_2(p, n) def cut_rod_dp(p, n): r = [0] for i in range(1, n+1): res = 0 for j in range(1, i+1): res = max(res, p[j] + r[i - j]) r.append(res) return r[n] def cut_rod_extend(p, n): r = [0] s = [0] for i in range(1, n+1): res_r = 0 # 价格的最大值 res_s = 0 # 价格最大值对应方案的左边不切割部分的长度 for j in range(1, i + 1): if p[j] + r[i - j] &gt; res_r: res_r = p[j] + r[i - j] res_s = j r.append(res_r) s.append(res_s) return r[n], s def cut_rod_solution(p, n): r, s = cut_rod_extend(p, n) ans = [] while n &gt; 0: ans.append(s[n]) n -= s[n] return ans r, s = cut_rod_extend(p,20) print(s) print(cut_rod_dp(p, 20)) print(cut_rod_solution(p, 20)) 5、分数相加 class Fraction: def __init__(self, a, b): self.a = a self.b = b x = self.gcd(a,b) self.a /= x self.b /= x def gcd(self, a, b): while b &gt; 0: r = a % b a = b b = r return a def zgs(self, a, b): # 12 16 -&gt; 4 # 3*4*4=48 x = self.gcd(a, b) return a * b / x def __add__(self, other): a = self.a b = self.b c = other.a d = other.b fenmu = self.zgs(b, d) fenzi = a * fenmu / b + c * fenmu / d return Fraction(fenzi, fenmu) def __str__(self): return &quot;%d/%d&quot; % (self.a, self.b) a = Fraction(1,3) b = Fraction(1,2) print(a+b) ","link":"https://ganhan999.github.io/post/Python算法入门4/"},{"title":"Python算法入门 (贪心算法)","content":"贪心算法 1、找零问题 t = [100, 50, 20, 5] def change(t, n): m = [0 for _ in range(len(t))] for i, money in enumerate(t): m[i] = n // money n = n % money return m, n print(change(t, 376)) 2、背包问题 goods = [(60, 10),(100, 20),(120, 30)] # 每个商品元组表示(价格, 重量) goods.sort(key=lambda x: x[0]/x[1], reverse=True) def fractional_backpack(goods, w): m = [0 for _ in range(len(goods))] total_v = 0 for i, (prize, weight) in enumerate(goods): if w &gt;= weight: m[i] = 1 total_v += prize w -= weight else: m[i] = w / weight total_v += m[i] * prize w = 0 break return total_v, m print(fractional_backpack(goods, 50)) 3、活动时间安排问题 #-----------------------方法1----------------------------# activities = [(1,4), (3,5), (0,6), (5,7), (3,9), (5,9), (6,10), (8,11), (8,12), (2,14), (12,16)] # 保证活动是按照结束时间排好序的 activities.sort(key=lambda x:x[1]) def activity_selection(a): res = [a[0]] for i in range(1, len(a)): if a[i][0] &gt;= res[-1][1]: # 当前活动的开始时间小于等于最后一个入选活动的结束时间 # 不冲突 res.append(a[i]) return res print(activity_selection(activities)) 4、组成最大数 from functools import cmp_to_key li = [32, 94, 128, 1286, 6, 71] def xy_cmp(x, y): if x+y &lt; y+x: return 1 elif x+y &gt; y+x: return -1 else: return 0 def number_join(li): li = list(map(str, li)) li.sort(key=cmp_to_key(xy_cmp)) return &quot;&quot;.join(li) print(number_join(li)) ","link":"https://ganhan999.github.io/post/Python算法入门3/"},{"title":"Python算法入门（数据结构）","content":"数据结构 1、栈 class Stack: def __init__(self):#初始化 self.stack = [] def push(self, element):#入栈 self.stack.append(element) def pop(self):#出栈 return self.stack.pop() def get_top(self):#获得栈顶的元素值 if len(self.stack) &gt; 0: return self.stack[-1] else: return None def is_empty(self):#判断是否为空栈 return len(self.stack) == 0 2、利用栈进行括号匹配 def brace_match(s): match = {'}':'{', ']':&quot;[&quot;, ')':'('} stack = Stack() for ch in s: if ch in {'(','[','{'}: stack.push(ch) else: #ch in {'}',']',')'} if stack.is_empty(): return False elif stack.get_top() == match[ch]: stack.pop() else: # stack.get_top() != match[ch] return False if stack.is_empty():#最后还要判断是否为空 return True else: return False print(brace_match('[{()}(){()}[]({}){}]')) print(brace_match('[]}')) 3、队列 #-----------------------方法1----------------------------# class Queue:#初始化 def __init__(self, size=100): self.queue = [0 for _ in range(size)] self.size = size self.rear = 0 # 队尾指针 self.front = 0 # 队首指针 def push(self, element):#入队 if not self.is_filled(): self.rear = (self.rear + 1) % self.size self.queue[self.rear] = element else: raise IndexError(&quot;Queue is filled.&quot;) def pop(self):#出队 if not self.is_empty(): self.front = (self.front + 1) % self.size return self.queue[self.front] else: raise IndexError(&quot;Queue is empty.&quot;) # 判断队空 def is_empty(self): return self.rear == self.front # 判断队满 def is_filled(self): return (self.rear + 1) % self.size == self.front q = Queue(5) for i in range(4): q.push(i) print(q.pop()) q.push(4) #-----------------------方法2----------------------------# from collections import deque q = deque([1,2,3,4,5], 5) q.append(6) # 队尾进队 print(q.popleft()) # 队首出队 4、链表 class Node:#定义一个链表节点 def __init__(self, item): self.item = item self.next = None def create_linklist_head(li):#头插法 head = Node(li[0]) for element in li[1:]: node = Node(element) node.next = head head = node return head def create_linklist_tail(li):#尾插法 head = Node(li[0]) tail = head for element in li[1:]: node = Node(element) tail.next = node tail = node return head def print_linklist(lk): while lk: print(lk.item, end=',') lk = lk.next lk = create_linklist_tail([1,2,3,6,8]) print_linklist(lk) 5、二叉树 class BiTreeNode: def __init__(self, data): self.data = data self.lchild = None # 左孩子 self.rchild = None # 右孩子 def pre_order(root):#先序遍历 if root: print(root.data, end=',') pre_order(root.lchild) pre_order(root.rchild) def in_order(root):#中序遍历 if root: in_order(root.lchild) print(root.data, end=',') in_order(root.rchild) def post_order(root):#后序遍历 if root: post_order(root.lchild) post_order(root.rchild) print(root.data, end=',') def level_order(root):# queue = deque() queue.append(root) while len(queue) &gt; 0: # 只要队不空 node = queue.popleft() print(node.data, end=',') if node.lchild: queue.append(node.lchild) if node.rchild: queue.append(node.rchild) a = BiTreeNode(&quot;A&quot;) b = BiTreeNode(&quot;B&quot;) c = BiTreeNode(&quot;C&quot;) d = BiTreeNode(&quot;D&quot;) e = BiTreeNode(&quot;E&quot;) f = BiTreeNode(&quot;F&quot;) g = BiTreeNode(&quot;G&quot;) e.lchild = a e.rchild = g a.rchild = c c.lchild = b c.rchild = d g.rchild = f root = e pre_order(root) print(&quot;&quot;) in_order(root) print(&quot;&quot;) post_order(root) print(&quot;&quot;) level_order(root) 6、二分查找树 class BiTreeNode: def __init__(self, data): self.data = data self.lchild = None # 左孩子 self.rchild = None # 右孩子 self.parent = None class BST: def __init__(self, li=None): self.root = None if li: for val in li: self.insert_no_rec(val) def insert(self, node, val): if not node: node = BiTreeNode(val) elif val &lt; node.data: node.lchild = self.insert(node.lchild, val) node.lchild.parent = node elif val &gt; node.data: node.rchild = self.insert(node.rchild, val) node.rchild.parent = node return node def insert_no_rec(self, val): p = self.root if not p: # 空树 self.root = BiTreeNode(val) return while True: if val &lt; p.data: if p.lchild: p = p.lchild else: # 左孩子不存在 p.lchild = BiTreeNode(val) p.lchild.parent = p return elif val &gt; p.data: if p.rchild: p = p.rchild else: p.rchild = BiTreeNode(val) p.rchild.parent = p return else: return def query(self, node, val): if not node: return None if node.data &lt; val: return self.query(node.rchild, val) elif node.data &gt; val: return self.query(node.lchild, val) else: return node def query_no_rec(self, val): p = self.root while p: if p.data &lt; val: p = p.rchild elif p.data &gt; val: p = p.lchild else: return p return None def pre_order(self, root): if root: print(root.data, end=',') self.pre_order(root.lchild) self.pre_order(root.rchild) def in_order(self, root): if root: self.in_order(root.lchild) print(root.data, end=',') self.in_order(root.rchild) def post_order(self, root): if root: self.post_order(root.lchild) self.post_order(root.rchild) print(root.data, end=',') def __remove_node_1(self, node): # 情况1：node是叶子节点 if not node.parent: self.root = None if node == node.parent.lchild: #node是它父亲的左孩子 node.parent.lchild = None else: #右孩子 node.parent.rchild = None def __remove_node_21(self, node): # 情况2.1：node只有一个左孩子 if not node.parent: # 根节点 self.root = node.lchild node.lchild.parent = None elif node == node.parent.lchild: node.parent.lchild = node.lchild node.lchild.parent = node.parent else: node.parent.rchild = node.lchild node.lchild.parent = node.parent def __remove_node_22(self, node): # 情况2.2：node只有一个右孩子 if not node.parent: self.root = node.rchild elif node == node.parent.lchild: node.parent.lchild = node.rchild node.rchild.parent = node.parent else: node.parent.rchild = node.rchild node.rchild.parent = node.parent def delete(self, val): if self.root: # 不是空树 node = self.query_no_rec(val) if not node: # 不存在 return False if not node.lchild and not node.rchild: #1. 叶子节点 self.__remove_node_1(node) elif not node.rchild: # 2.1 只有一个左孩子 self.__remove_node_21(node) elif not node.lchild: # 2.2 只有一个右孩子 self.__remove_node_22(node) else: # 3. 两个孩子都有 min_node = node.rchild while min_node.lchild: min_node = min_node.lchild node.data = min_node.data # 删除min_node if min_node.rchild: self.__remove_node_22(min_node) else: self.__remove_node_1(min_node) 7、二叉平衡树 class AVLNode(BiTreeNode): def __init__(self, data): BiTreeNode.__init__(self, data) self.bf = 0 class AVLTree(BST): def __init__(self, li=None): BST.__init__(self, li) def rotate_left(self, p, c): s2 = c.lchild p.rchild = s2 if s2: s2.parent = p c.lchild = p p.parent = c p.bf = 0 c.bf = 0 return c def rotate_right(self, p, c): s2 = c.rchild p.lchild = s2 if s2: s2.parent = p c.rchild = p p.parent = c p.bf = 0 c.bf = 0 return c def rotate_right_left(self, p, c): g = c.lchild s3 = g.rchild c.lchild = s3 if s3: s3.parent = c g.rchild = c c.parent = g s2 = g.lchild p.rchild = s2 if s2: s2.parent = p g.lchild = p p.parent = g # 更新bf if g.bf &gt; 0: p.bf = -1 c.bf = 0 elif g.bf &lt; 0: p.bf = 0 c.bf = 1 else: # 插入的是g p.bf = 0 c.bf = 0 return g def rotate_left_right(self, p, c): g = c.rchild s2 = g.lchild c.rchild = s2 if s2: s2.parent = c g.lchild = c c.parent = g s3 = g.rchild p.lchild = s3 if s3: s3.parent = p g.rchild = p p.parent = g # 更新bf if g.bf &lt; 0: p.bf = 1 c.bf = 0 elif g.bf &gt; 0: p.bf = 0 c.bf = -1 else: p.bf = 0 c.bf = 0 return g def insert_no_rec(self, val): # 1. 和BST一样，插入 p = self.root if not p: # 空树 self.root = AVLNode(val) return while True: if val &lt; p.data: if p.lchild: p = p.lchild else: # 左孩子不存在 p.lchild = AVLNode(val) p.lchild.parent = p node = p.lchild # node 存储的就是插入的节点 break elif val &gt; p.data: if p.rchild: p = p.rchild else: p.rchild = AVLNode(val) p.rchild.parent = p node = p.rchild break else: # val == p.data return # 2. 更新balance factor while node.parent: # node.parent不空 if node.parent.lchild == node: # 传递是从左子树来的，左子树更沉了 #更新node.parent的bf -= 1 if node.parent.bf &lt; 0: # 原来node.parent.bf == -1, 更新后变成-2 # 做旋转 # 看node哪边沉 g = node.parent.parent # 为了连接旋转之后的子树 x = node.parent # 旋转前的子树的根 if node.bf &gt; 0: n = self.rotate_left_right(node.parent, node) else: n = self.rotate_right(node.parent, node) # 记得：把n和g连起来 elif node.parent.bf &gt; 0: # 原来node.parent.bf = 1，更新之后变成0 node.parent.bf = 0 break else: # 原来node.parent.bf = 0，更新之后变成-1 node.parent.bf = -1 node = node.parent continue else: # 传递是从右子树来的，右子树更沉了 #更新node.parent.bf += 1 if node.parent.bf &gt; 0: # 原来node.parent.bf == 1, 更新后变成2 # 做旋转 # 看node哪边沉 g = node.parent.parent # 为了连接旋转之后的子树 x = node.parent # 旋转前的子树的根 if node.bf &lt; 0: # node.bf = 1 n = self.rotate_right_left(node.parent, node) else: # node.bf = -1 n = self.rotate_left(node.parent, node) # 记得连起来 elif node.parent.bf &lt; 0: # 原来node.parent.bf = -1，更新之后变成0 node.parent.bf = 0 break else: # 原来node.parent.bf = 0，更新之后变成1 node.parent.bf = 1 node = node.parent continue # 链接旋转后的子树 n.parent = g if g: # g不是空 if x == g.lchild: g.lchild = n else: g.rchild = n break else: self.root = n break tree = AVLTree([9,8,7,6,5,4,3,2,1]) tree.pre_order(tree.root) print(&quot;&quot;) tree.in_order(tree.root) 8、哈希表 class LinkList: class Node: def __init__(self, item=None): self.item = item self.next = None class LinkListIterator: def __init__(self, node): self.node = node def __next__(self): if self.node: cur_node = self.node self.node = cur_node.next return cur_node.item else: raise StopIteration def __iter__(self): return self def __init__(self, iterable=None): self.head = None self.tail = None if iterable: self.extend(iterable) def append(self, obj): s = LinkList.Node(obj) if not self.head: self.head = s self.tail = s else: self.tail.next = s self.tail = s def extend(self, iterable): for obj in iterable: self.append(obj) def find(self, obj): for n in self: if n == obj: return True else: return False def __iter__(self): return self.LinkListIterator(self.head) def __repr__(self): return &quot;&lt;&lt;&quot;+&quot;, &quot;.join(map(str, self))+&quot;&gt;&gt;&quot; # 类似于集合的结构 class HashTable: def __init__(self, size=101): self.size = size self.T = [LinkList() for i in range(self.size)] def h(self, k): return k % self.size def insert(self, k): i = self.h(k) if self.find(k): print(&quot;Duplicated Insert.&quot;) else: self.T[i].append(k) def find(self, k): i = self.h(k) return self.T[i].find(k) ht = HashTable() ht.insert(0) ht.insert(1) ht.insert(3) ht.insert(102) ht.insert(508) #print(&quot;,&quot;.join(map(str, ht.T))) print(ht.find(203)) 9、基数排序 def radix_sort(li): max_num=max(li) it=0 while 10**it &lt;=max_num: bucket=[[] for _ in range(10)] for var in li: # 987 it=1 987//10-&gt;98 98%10-&gt;8; it=2 987//100-&gt;9 9%10=9 digit=(var//10**it)%10 bucket[digit].append(var) li.clear() for buc in bucket: li.extend(buc) it=it+1 return li li = [3,4,2,1,5,6,8,7,9] print(li) print(radix_sort(li)) 10、迷宫问题 #-----------------------栈方法----------------------------# maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] dirs = [ lambda x,y: (x+1,y), lambda x,y: (x-1,y), lambda x,y: (x,y-1), lambda x,y: (x,y+1) ] def maze_path(x1,y1,x2,y2): stack = [] stack.append((x1, y1)) while(len(stack)&gt;0): curNode = stack[-1] # 当前的节点 if curNode[0] == x2 and curNode[1] == y2: # 走到终点了 for p in stack: print(p) return True # x,y 四个方向 x-1,y; x+1,y; x,y-1; x,y+1 for dir in dirs: nextNode = dir(curNode[0], curNode[1]) # 如果下一个节点能走 if maze[nextNode[0]][nextNode[1]] == 0: stack.append(nextNode) maze[nextNode[0]][nextNode[1]] = 2 # 2表示为已经走过 break else: maze[nextNode[0]][nextNode[1]] = 2 stack.pop() else: print(&quot;没有路&quot;) return False maze_path(1,1,8,8) #-----------------------队列方法----------------------------# from collections import deque maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] dirs = [ lambda x, y: (x + 1, y), lambda x, y: (x - 1, y), lambda x, y: (x, y - 1), lambda x, y: (x, y + 1) ] def print_r(path): curNode = path[-1] realpath = [] while curNode[2] == -1: realpath.append(curNode[0:2]) curNode = path[curNode[2]] realpath.append(curNode[0:2]) # 起点 realpath.reverse() for node in realpath: print(node) def maze_path_queue(x1, y1, x2, y2): queue = deque() queue.append((x1, y1, -1)) path = [] while len(queue) &gt; 0: curNode = queue.pop() path.append(curNode) if curNode[0] == x2 and curNode[1] == y2: # 终点 print_r(path) return True for dir in dirs: nextNode = dir(curNode[0], curNode[1]) if maze[nextNode[0]][nextNode[1]] == 0: queue.append((nextNode[0], nextNode[1], len(path) - 1)) # 后续节点进队，记录哪个节点带他来的 maze[nextNode[0]][nextNode[1]] = 2 # 标记为已经走过 else: print(&quot;没有路&quot;) return False maze_path_queue(1, 1, 8, 8) ","link":"https://ganhan999.github.io/post/Python算法入门2/"},{"title":"119、杨辉三角 II ","content":"题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 示例: 输入: 3 输出: [1,3,3,1] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 判断i是不是这一层，再输出 #我的做法： class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: if rowIndex == 0: return [1] if rowIndex == 1: return [1, 1] li = [[1], [1, 1]] i = 3 while True: new = [] for j in range(i - 2): new.append(li[i - 2][j] + li[i - 2][j + 1]) new.insert(0, 1) new.append(1) li.append(new) if rowIndex == i - 1: return li[i - 1] i = i + 1 &quot;&quot;&quot;&quot;&quot;&quot; #我的做法2： 深度优先遍历，因为每找到一个左右节点，层数就加一层，记录层数depth，将depth作为下标。 class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: res = [] i = 0 while True: res.append([1] * (i + 1)) for j in range(1, i): res[i][j] = res[i - 1][j - 1] + res[i - 1][j] if rowIndex==i: return res[i] i=i+1 ","link":"https://ganhan999.github.io/post/119、杨辉三角 II /"},{"title":"118、杨辉三角","content":"题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 在每一层加完后，左右加上元素1 #我的做法： class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows==0: return [] if numRows==1: return [[1]] if numRows==1: return [[1],[1,1]] li = [[1], [1, 1]] for i in range(3,numRows+1): new=[] for j in range(i-2): new.append(li[i-2][j]+li[i-2][j+1]) new.insert(0, 1) new.append(1) li.append(new) return li &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 先生成都是1的一列，再通过代替获得。 class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: res = [] for i in range(numRows): res.append([1] * (i + 1)) for j in range(1, i): res[i][j] = res[i - 1][j - 1] + res[i - 1][j] return res ","link":"https://ganhan999.github.io/post/118、杨辉三角/"},{"title":"112、 路径总和","content":"题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径， 这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 DFS,一直向下找到叶子节点，如果到叶子节点时sum == root.value，说明找到了一条符合要求的路径 #我的做法： class Solution(object): def hasPathSum(self, root, sum): if not root: return False if not root.left and not root.right: return sum == root.val return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 回溯 这里的回溯指 利用 DFS 找出从根节点到叶子节点的所有路径， 只要有任意一条路径的和等于sum，就返回 True。 下面的代码并非是严格意义上的回溯法，因为没有重复利用 path 变量。 class Solution(object): def hasPathSum(self, root, sum): if not root: return False res = [] return self.dfs(root, sum, [root.val]) def dfs(self, root, target, path): if not root: return False#到末节点都还没有成功，那么就是False if sum(path) == target and not root.left and not root.right:#记录了到每一个节点路径长度 return True left_flag, right_flag = False, False if root.left: left_flag = self.dfs(root.left, target, path + [root.left.val]) if root.right: right_flag = self.dfs(root.right, target, path + [root.right.val]) return left_flag or right_flag &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： BFS使用队列保存遍历到每个节点时的路径和， 如果该节点恰好是叶子节点，并且路径和正好等于sum，说明找到了解 class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False que=collections.deque() que.append((root,root.val)) while que: node,path=que.popleft() if not node.left and not node.right and path==sum: return True if node.left: que.append((node.left,path+node.left.val)) if node.right: que.append((node.right, path + node.right.val)) return False #大神做法3： 栈 除了上面的 队列 解法以外，也可以使用 栈，同时保存节点和到这个节点的路径和。 但是这个解法已经不是 BFS。因为会优先访问 后进来 的节点，导致会把根节点的右子树访问结束之后， 才访问左子树。 可能会有朋友好奇很少见到这种写法，为什么代码可行？答案是：栈中同时保存了 (节点，路径和)，也就是说只要能把所有的节点访问一遍，那么就一定能找到正确的结果。 无论是用 队列 还是 栈，都是一种 树的遍历 方式，只不过访问顺序有所有不同罢了。 class Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False stack = [] stack.append((root, root.val)) while stack: node, path = stack.pop() if not node.left and not node.right and path == sum: return True if node.left: stack.append((node.left, path + node.left.val)) if node.right: stack.append((node.right, path + node.right.val)) return False ","link":"https://ganhan999.github.io/post/112、 路径总和/"},{"title":"Python算法入门（查找排序）","content":"查找排序 1、插入排序 def insert_sort(li): for i in range(1,len(li)): tmp=li[i] j=i-1 while j&gt;=0 and li[j]&gt;tmp: li[j+1]=li[j] j=j-1 li[j+1]=tmp return li li = [3,4,2,1,5,6,8,7,9] print(li) print(insert_sort(li)) 2、选择排序 #-----------------------方法1----------------------------# def select_sort_simple1(li): lnew=[] for i in range(len(li)): minval=min(li) lnew.append(minval) li.remove(minval) return lnew li = [3,4,2,1,5,6,8,7,9] print(li) print(select_sort_simple1(li)) #-----------------------方法2----------------------------# def select_sort1(li): for i in range(len(li)): minidx=i for j in range(i+1,len(li)): if li[j]&lt;li[minidx]: minidx=j li[minidx],li[i]=li[i],li[minidx] return li li = [3,4,2,1,5,6,8,7,9] print(li) print(select_sort1(li)) 3、冒泡排序 def bubble_sort1(li): for i in range(len(li)-1): changeflag=False for j in range(len(li) - i - 1): if li[j] &gt; li[j+1]: li[j],li[j+1]=li[j+1],li[j] changeflag=True if not changeflag: return li return li li = [3,4,2,1,5,6,8,7,9] print(li) print(bubble_sort1(li)) 4、希尔排序 def insert_sort_gap1(li, gap): for i in range(gap,len(li)): tmp=li[i] j=i-gap while j&gt;=0 and li[j]&gt;tmp: li[j+gap]=li[j] j=j-gap li[j+gap]=tmp return li def shell_sort1(li): d=len(li)//2 while d&gt;=1: li=insert_sort_gap1(li,d) d=d//2 return li li = [3,4,2,1,5,6,8,7,9] print(li) print(shell_sort1(li)) 5、快速排序 def partition(li, left, right): tmp = li[left] while left &lt; right: while left &lt; right and li[right] &gt;= tmp: right = right - 1 li[left] = li[right] while left &lt; right and li[left] &lt;= tmp: left = left + 1 li[right]=li[left] li[left] = tmp mid = left return mid def _quick_sort(li, left, right): if left&lt;right: # 至少两个元素 mid = partition1(li, left, right) _quick_sort(li, left, mid - 1) _quick_sort(li, mid + 1, right) return li li = [3, 4, 2, 1, 5, 6, 8, 7, 9] print(li) print(_quick_sort(li, 0, len(li)-1)) 6、归并排序 def merge(li, low, mid, high): i=low j=mid+1 ltmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: ltmp.append(li[i]) i=i+1 else: ltmp.append(li[j]) j=j+1 while i&lt;=mid: ltmp.append(li[i]) i=i+1 while j &lt;= high: ltmp.append(li[j]) j += 1 li[low:high+1]=ltmp return li def merge_sort(li, low, high): if low&lt;high: mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) merge(li,low,mid,high) return li li = [3,4,2,1,5,6,8,7,9] print(li) print(merge_sort(li,0,len(li)-1)) 7、计数排序 def count_sort(li, max_count=100): count=[0 for _ in range(max_count+1)] for val in li: count[val]=count[val]+1 li.clear() for ind,val in enumerate(count): for _ in range(val): li.append(ind) return li li = [3,4,2,1,5,6,8,7,9] print(li) print(count_sort(li)) 8、桶排序 def bucket_sort(li, n=100, max_num=10000): buckets=[[] for _ in range(n)] for var in li: i=min(var//(max_num//100),n-1) buckets[i].append(var) for j in range(len(buckets[i])-1, 0, -1): if buckets[i][j] &lt; buckets[i][j-1]: buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j] else: break sorted_li=[] for buc in buckets: sorted_li.extend(buc) return sorted_li li = [3,4,2,1,5,6,8,7,9] print(li) print(bucket_sort(li)) 9、基数排序 def radix_sort(li): max_num=max(li) it=0 while 10**it &lt;=max_num: bucket=[[] for _ in range(10)] for var in li: # 987 it=1 987//10-&gt;98 98%10-&gt;8; it=2 987//100-&gt;9 9%10=9 digit=(var//10**it)%10 bucket[digit].append(var) li.clear() for buc in bucket: li.extend(buc) it=it+1 return li li = [3,4,2,1,5,6,8,7,9] print(li) print(radix_sort(li)) 10、堆排序 #-----------------------方法1----------------------------# li = [3,4,2,1,5,6,8,7,9] print(li) heapq.heapify(li) #建堆 for i in range(len(li)): print(heapq.heappop(li), end=',') #-----------------------方法2----------------------------# def sift(li, low, high):#大根堆向下调整，前提是子树已经是标准的小根堆或者大根堆 &quot;&quot;&quot; :param li: 列表 :param low: 堆的根节点位置 :param high: 堆的最后一个元素的位置 :return: &quot;&quot;&quot; i = low # i最开始指向根节点 j = 2 * i + 1 # j开始是左孩子 tmp = li[low] # 把堆顶存起来 while j &lt;= high: # 只要j位置有数 if j + 1 &lt;= high and li[j+1] &gt; li[j]: # 如果右孩子有并且比较大 j = j + 1 # j指向右孩子 if li[j] &gt; tmp: li[i] = li[j] i = j # 往下看一层 j = 2 * i + 1 else: # tmp更大，把tmp放到i的位置上 li[i] = tmp # 把tmp放到某一级领导位置上 break else: li[i] = tmp # 把tmp放到叶子节点上 return li def heap_sort(li): n = len(li) for i in range((n-2)//2, -1, -1):#从最后一个父节点开始从后往前建立小根堆 # i表示建堆的时候调整的部分的根的下标 sift(li, i, n-1) # 建堆完成了 for i in range(n-1, -1, -1): # i 指向当前堆的最后一个元素 li[0], li[i] = li[i], li[0] sift(li, 0, i - 1) #i-1是新的high return li li = [3,4,2,1,5,6,8,7,9] print(li) print(heap_sort(li)) 11、寻找最大的前K个值 def sift(li, low, high):#小根堆向下调整 i = low j = 2 * i + 1 tmp = li[low] while j &lt;= high: if j + 1 &lt;= high and li[j+1] &lt; li[j]: j = j + 1 if li[j] &lt; tmp: li[i] = li[j] i = j j = 2 * i + 1 else: break li[i] = tmp def topk(li, k): # 1.建堆 heap = li[0:k] for i in range((k-2)//2, -1, -1): sift(heap, i, k-1) # 2.遍历，如果后续的值大于小根堆的最小值，那么就把他赋值给根节点，然后再堆排序 for i in range(k, len(li)-1): if li[i] &gt; heap[0]: heap[0] = li[i] sift(heap, 0, k-1) # 3.出数 for i in range(k-1, -1, -1): heap[0], heap[i] = heap[i], heap[0] sift(heap, 0, i - 1) return heap li = [3,4,2,1,5,6,8,7,9] print(li) print(topk(li, 3)) 12、线性查找 def linear_search(li, val): for ind, v in enumerate(li): if v == val: return ind else: return None li =[3,4,2,1,5,6,8,7,9] print(linear_search(li, 7)) 13、二分查找 def binary_search(li, val):#要有序 left = 0 right = len(li) - 1 while left &lt;= right: # 候选区有值 mid = (left + right) // 2 if li[mid] == val: return mid elif li[mid] &gt; val: # 带查找的值在mid左侧 right = mid - 1 else: # li[mid] &lt; val 带查找的值在mid右侧 left = mid + 1 else: return None li=[0,1,2,3,4,5,6,7,8,9] print(binary_search(li, 7)) 14、汉诺塔问题 随机删除并返回一个键值对 def hanoi(n, a, b, c): if n&gt;0: hanoi(n-1, a, c, b) print(&quot;moving from %s to %s&quot; % (a, c)) hanoi(n-1, b, a, c) hanoi(30, 'A', 'B', 'C') ","link":"https://ganhan999.github.io/post/Python算法入门/"},{"title":"111、二叉树的最小深度","content":"题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 DFS，递归大法，分情况讨论（节点为空，左右节点为空，仅左节点为空等等） #我的做法： class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 elif not root.left and not root.right: return 1 elif not root.left: return self.minDepth(root.right)+1 elif not root.right: return self.minDepth(root.left)+1 return 1+min(self.minDepth(root.left),self.minDepth(root.right)) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： BFS，看左右子树的节点谁先没有左右节点，就停止循环。 class Solution: dct = {} def isBalanced(self, root: TreeNode) -&gt; bool: if not root: return True def maxDepth(root: TreeNode) -&gt; int: if not root: return 0 if root not in self.dct: self.dct[root] = 1 + max(maxDepth(root.left), maxDepth(root.right)) return self.dct[root] tmp = maxDepth(root.left) - maxDepth(root.right) return abs(tmp)&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 在求取左右子节点时，判断子节点是否失衡， 如果失衡则无需求根节点的平衡度，向上通知提前退出递归。 因为-1表示递归提前退出或者失衡. 如果左子树已经出现了失衡状况，就只会遍历一半！！！ 在算深度的时候，就把平衡的条件给判定了。 class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 from collections import deque q = deque([(root, 1)]) while q: node, depth = q.popleft() if not node.left and not node.right: return depth if node.left: q.append((node.left, depth + 1)) print(depth) if node.right: q.append((node.right, depth + 1)) print(depth) return 0 ","link":"https://ganhan999.github.io/post/111、二叉树的最小深度/"},{"title":"110、平衡二叉树","content":"题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归每一个节点的平衡因子，如果绝对值小于2，那么就平衡。 用到了求最大深度的函数 #我的做法： class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if not root: return True return abs(self.height(root.right)-self.height(root.left))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) # 求高度 def height(self, node): if not node: return 0 return 1+max(self.height(node.right),self.height(node.left)) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 利用字典保存，最大深度的值，可以减少递归次数。 class Solution: dct = {} def isBalanced(self, root: TreeNode) -&gt; bool: if not root: return True def maxDepth(root: TreeNode) -&gt; int: if not root: return 0 if root not in self.dct: self.dct[root] = 1 + max(maxDepth(root.left), maxDepth(root.right)) return self.dct[root] tmp = maxDepth(root.left) - maxDepth(root.right) return abs(tmp)&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 在求取左右子节点时，判断子节点是否失衡， 如果失衡则无需求根节点的平衡度，向上通知提前退出递归。 因为-1表示递归提前退出或者失衡. 如果左子树已经出现了失衡状况，就只会遍历一半！！！ 在算深度的时候，就把平衡的条件给判定了。 class Solution: def height(self, root): if root is None: return 0 left = self.height(root.left) if left &lt; 0: return -1#左子树失衡 right = self.height(root.right) if right &lt; 0 : return -1#右子树失衡 if abs(left - right) &gt; 1: return -1#当前节点失衡 return max(left, right) + 1#平衡，继续递归 def isBalanced(self, root: TreeNode) -&gt; bool: return self.height(root) &gt;= 0 &quot;&quot;&quot;&quot;&quot;&quot; #大神做法3： 自底向上 通过直接判断左右子树高度，改变res参数，递归仍然会进行完毕 class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: self.res = True def helper(root): if not root: return 0 left = helper(root.left) + 1 right = helper(root.right) + 1 #print(right, left) if abs(right - left) &gt; 1: self.res = False return max(left, right) helper(root) return self.res ","link":"https://ganhan999.github.io/post/110、平衡二叉树/"},{"title":"108、将有序数组转换为二叉搜索树","content":"题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： ​ 0 ​ / \\ -3 9 / / -10 5 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 DFS，递归，用二分的思想。 #我的做法： class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: maxlength=len(nums) def DFS(left,right): if left&gt;right: return mid=(left+right)//2 root=TreeNode(nums[mid]) root.left=DFS(left,mid-1) root.right=DFS(mid+1, right) return root return DFS(0, maxlength-1) ","link":"https://ganhan999.github.io/post/108、将有序数组转换为二叉搜索树/"},{"title":"107、二叉树的层次遍历 II","content":"题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 ​ / 9 20 ​ / ​ 15 7 返回它的最大深度 3 。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 BFS，每一层都放在一个队列当中 #我的做法： class Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] que=deque([root]) l=[] while que: nextque=[] l1=[] while que: num=que.popleft() l1.append(num.val) if num.left: nextque.append(num.left) if num.right: nextque.append(num.right) l.append(l1) que=deque(nextque) l.reverse() return l &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 深度优先遍历，因为每找到一个左右节点，层数就加一层，记录层数depth，将depth作为下标。 class Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: res = [] def dfs(root, depth): if not root: return if len(res)&lt;depth+1:#每多一层那么就加一个元素列表 res.append([]) res[depth].append(root.val) dfs(root.left, depth+1) dfs(root.right, depth+1) dfs(root,0) return res[::-1] ","link":"https://ganhan999.github.io/post/107、二叉树的层次遍历 II/"},{"title":"树的BFS和DFS","content":"BFS class Solution: def tree(self, root: TreeNode) -&gt; bool: li=[] self.BFS(root,li) print(li) def BFS(self,tree,li): que=deque([tree]) while que: num=que.popleft() li.append(num.val) if num.left: que.append(num.left) if num.right: que.append(num.right) DFS(前序遍历) class Solution: def treec(self, root: TreeNode) -&gt; bool: li=[] self.pre(root,li) print(li) def pre(self,tree,li): if tree: li.append(tree.val) self.pre(root.left,li) self.pre(root.right,li) ","link":"https://ganhan999.github.io/post/树的BFS和DFS/"},{"title":"104、二叉树的深度","content":"题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 ​ / 9 20 ​ / ​ 15 7 返回它的最大深度 3 。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归大法 就相当于深度优先遍历了 画图，找到终止条件为空节点记录为0深度，递归本体是父节点的深度等于子节点的深度最大值加一。 #我的做法： class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: return self.ismirror(root, root) def ismirror(self, p1, p2): if not p1 and not p2: return True if not p1 or not p2: return False return p1.val == p2.val and self.ismirror(p1.right, p2.left) and self.ismirror(p2.right, p1.left) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 迭代方法。 广度优先遍历，也就是层次遍历，每一层便加1. class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 depth = 0 queue = deque([root]) while queue: depth += 1 # 保存下一层所有节点 next_layer = [] while queue: node = queue.popleft() if node.left: next_layer.append(node.left) if node.right: next_layer.append(node.right) queue = deque(next_layer) return depth ","link":"https://ganhan999.github.io/post/104、二叉树的深度/"},{"title":"101、对称二叉树","content":"题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 ​ 1 / 2 2 / \\ / 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: ​ 1 / 2 2 \\ 3 3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归大法 判断p1的左子树，和p2的右子树是否相等。 值得一提的是，需要将root也一分为二，这样就可以判断根节点了。 这是广度优先遍历了！ #我的做法： class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: return self.ismirror(root, root) def ismirror(self, p1, p2): if not p1 and not p2: return True if not p1 or not p2: return False return p1.val == p2.val and self.ismirror(p1.right, p2.left) and self.ismirror(p2.right, p1.left) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 不难发现 post_order 就是 pre_order的逆序，其实这也是对称二叉树的一个性质， 根据这一点就不难写出代码了。 前序遍历等于后序遍历的倒序，则为镜像！（妙啊） class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: bli = [] # 用来存左子树的前序遍历 fli = [] # 用来存右子树的后序遍历 if root == None: # 无根节点 return True if root and root.left == None and root.right == None: # 只有根节点 return True if root and root.left and root.right: self.pre_order(root.left, bli) self.post_order(root.right, fli) fli.reverse() # 将后序遍历的列表倒序 if bli == fli: return True else: return False def pre_order(self,root,li): # 二叉树的前序遍历 if root: li.append(root.val) self.pre_order(root.left,li) self.pre_order(root.right,li) elif root == None: li.append(None) def post_order(self,root,li): # 二叉树的后序遍历 if root: self.post_order(root.left,li) self.post_order(root.right,li) li.append(root.val) elif root == None: li.append(None) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 迭代方法。 BFS 使用一个队列，很多题解中的 BFS 都是放入了四次节点，一种更直观的做法是两两一组放入队列中。 在队列中同时取出两个节点left, right，判断这两个节点的值是否相等，然后把他们的孩子中按照(left.left, right.right) 一组，(left.right, right.left)一组放入队列中。 BFS做法需要把所有的节点都检查完才能确定返回结果True，除非提前遇到不同的节点值而终止返回False。 如图所示 class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True queue=collections.deque() queue.append((root.left,root.right))#注意这里只传递了一个参数，他们一起组成了迭代器 while queue: left,right=queue.popleft() if not left and not right: continue if not left or not right: return False if left.val!=right.val: return False queue.append((left.left,right.right)) queue.append((left.right,right.left)) return True ","link":"https://ganhan999.github.io/post/101、对称二叉树/"},{"title":"100、相同的树","content":"题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / 2 1 1 2 [1,2,1], [1,1,2] 输出: false &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归大法好。 一句话, 先想出口： 空的话怎么办？ 一个出口怎么办？ 通常情况下怎么处理当前元素, 同时减少问题规模？ #我的做法： class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 深度优先遍历，把遍历的数字加入数组中。 class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: resp, resq = [], [] self.DFS(p, resp) self.DFS(q, resq) return resp == resq def DFS(self, tree, res): if not tree: res.append('') return res.append(tree.val) self.DFS(tree.left, res) self.DFS(tree.right, res) ","link":"https://ganhan999.github.io/post/100、相同的树/"},{"title":"88、合并两个有序数组","content":"题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明： 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 输入： nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 提示： -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 nums1.length == m + n nums2.length == n &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 用内置方法sort即可，注意要原地操作，不能改变地址，所以要使用对象类型方法例如pop，append，extend #我的做法1： class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; lens=len(nums1) for i in range(lens-m): nums1.pop(-1)#不能直接切片 nums1.extend(nums2)#不能使用nums1+nums2 nums1.sort() for i in range(lens-len(nums1)): nums1.append(0) &quot;&quot;&quot;&quot;&quot;&quot; #我的做法2： 从nums2里面来一个，我就pop一个0。 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; a=0 popnum=0 while nums2 != []: if a&gt;=popnum+m: nums1.insert(a,nums2.pop(0)) nums1.pop(-1) a+=1 elif nums1[a]&lt;=nums2[0]: a+=1 else: nums1.insert(a,nums2.pop(0)) nums1.pop(-1) a+=1 popnum+=1 &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 啊！我没有想到直接替换，打扰了。 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: for i in range(n): nums1[m+i]=nums2[i] nums1.sort() &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 充分利用了原数组的有序性，从后面开始比较，直接插入对应的那个位置。 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while n: if m == 0: nums1[n-1] = nums2[n-1] n -= 1 continue if nums1[m-1] &lt; nums2[n-1]: nums1[m+n-1] = nums2[n-1] n -= 1 else: nums1[m+n-1] = nums1[m-1] m -= 1 ","link":"https://ganhan999.github.io/post/88、合并两个有序数组/"},{"title":"83、删除排序链表中的重复元素","content":"题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 删除链表操作而已。 #我的做法： class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: node = head#注意这里是引用地址，标记这初始地址，但是next是调用属性，所以操作node实际上就是改变了head链表，head还是一开始的地址，但是node已经不是了 while node and node.next:#注意先把node放前面，因为如果node为空，node会出现断路现象，保护后面next条件不报错 if node.val == node.next.val: node.next = node.next.next else: node = node.next return head#返回初始地址！所以不能用node &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 双指针算法 建议自己多画画图就知道了，用a来遍历整个链表，用head来改变整个链表。 class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head head_copy = head a = head while a: if a.val == head.val: a = a.next if a.next is None: if a.val == head.val: head.next = None else: head.next = a break else: head.next = a head = head.next return head_copy ","link":"https://ganhan999.github.io/post/83、删除排序链表中的重复元素/"},{"title":"70、爬楼梯","content":"题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 递归算法！（认真思考需要做执行操作） 注意缓存装饰器！ #我的做法： class Solution: @functools.lru_cache(100) # 缓存装饰器 def climbStairs(self, n: int) -&gt; int: if n==1: return 1 elif n==2: return 2 else: ans=self.climbStairs(n-1)+self.climbStairs(n-2)#记得加上对象self return ans &quot;&quot;&quot;&quot;&quot;&quot; #大神做法1： 斐波那契数列算法 公式如图所示 class Solution: def climbStairs(self, n: int) -&gt; int: res = (((1+5**0.5)/2)**(n+1)-((1-5**0.5)/2)**(n+1))/((5)**0.5) return int(res) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法2： 动态规划算法1，只存储前两个元素，减少了空间，空间复杂度O(1) class Solution: def climbStairs(self, n: int) -&gt; int: f1,f2=1,2 if n==1: return f1 if n==2: return f2 for i in range(n-2): f2,f1=f1+f2,f2 print(f1,f2) return f2 &quot;&quot;&quot;&quot;&quot;&quot; #大神做法3： 动态规划算法2，新建一个字典或者数组来存储以前的变量，空间复杂度O(n) class Solution: def climbStairs(self, n: int) -&gt; int: dp = {} dp[1] = 1 dp[2] = 2 for i in range(3,n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] ","link":"https://ganhan999.github.io/post/70、爬楼梯/"},{"title":"今天面基了百万粉丝up主！！！！！","content":"南昌之光！大胡子魏！ 从1万粉丝到114万粉丝，不用一年就办到了！ 而且我觉得他三观很正！非常喜欢他！ 今天参加了他的慈善拍卖会！ 我也贡献了200元的慈善金买了一幅画，我觉得这幅画很像我以前住的老房子！ 买到就是赚到！ ","link":"https://ganhan999.github.io/post/jin-tian-mian-ji-liao-bai-wan-fen-si-up-zhu/"},{"title":"69、x的平方根","content":"题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 二分法就完事了，比较简单（但是我一开始还是想穷举法，笨啊！） #我的做法： class Solution: def mySqrt(self, x: int) -&gt; int: low=0 high=x while low&lt;=high: mid=(low+high)//2 if mid**2&lt;=x: ans=mid low=mid+1 else: high=mid-1 return ans &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： √x=e的1/2lnx次方（有点蠢） class Solution: def mySqrt(self, x: int) -&gt; int: if x == 0: return 0 ans = int(math.exp(0.5 * math.log(x))) return ans + 1 if (ans + 1) ** 2 &lt;= x else ans ","link":"https://ganhan999.github.io/post/69、x的平方根/"},{"title":"今天送了全班很多一人一个布丁🍮","content":"阴差阳错hhhhhh 希望大家在之后的日子里能想到我 苟富贵勿相忘 ","link":"https://ganhan999.github.io/post/jin-tian-song-liao-quan-ban-hen-duo-yi-ren-yi-ge-bu-ding/"},{"title":"67、二进制求和","content":"题目 &quot;&quot;&quot; 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2: 输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 提示： 每个字符串仅由字符 '0' 或 '1' 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 先换成十进制然后换二进制，最后取一个[2:]，注意bin（）后返回的是一个字符串 #我的做法： class Solution: def addBinary(self, a: str, b: str) -&gt; str: anum=int(a,base=2) bnum=int(b,base=2) return (bin(anum+bnum)[2:]) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 非内置函数，利用二进制算法计算。 class Solution: def addBinary(self, a: str, b: str) -&gt; str: r, p = '', 0 d = len(b) - len(a) a = '0' * d + a b = '0' * -d + b for i, j in zip(a[::-1], b[::-1]):#这里是对二进制的掌握程度 s = int(i) + int(j) + p r = str(s % 2) + r p = s // 2 return '1' + r if p else r#如果最后p还是进位了，那么就往前面加1，否则就不加！ ","link":"https://ganhan999.github.io/post/67、二进制求和/"},{"title":"科目一97分 美滋滋","content":"今天看到好多人没过 还有点小紧张 我后面那个大叔还一直逼逼赖赖 今天开车司机叔叔也有点让我无语！ 气死了！ 午饭都冷了！ 😡 ","link":"https://ganhan999.github.io/post/ke-mu-yi-97-fen-mei-zi-zi/"},{"title":"61、加一","content":"题目 &quot;&quot;&quot; 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1] 提示： 1 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 转成数字后，加一，再转字符串，注意特殊情况！ #我的做法： class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: lens=len(digits) sum=0 sumlist=[] for i in range(lens): sum=10**(lens-i-1)*digits[i]+sum#转为数字 sum=sum+1 strnum=str(sum) for i in range(len(strnum)): sumlist.append(int(strnum[i]))#再转字符串 if lens-len(sumlist)==-1 or lens-len(sumlist)==0:#如果出现0，0，9变0，1，0的情况判断是否前面是不是有多余的0. return sumlist else: anum=lens-len(sumlist) for i in range(anum): sumlist.insert(0,0) return sumlist &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 从倒数第一个数字开始，如果数字为9，那么置为0，判断前一个如果不是9，那么就只要加上1就结束了！！ 如果是9呢，那么就继续置为0，以此类推。如果到第一个数字都还是9，那么置为0后，我们需要插入一个1。 class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: for i in range(len(digits)-1,-1,-1): if digits[i]!=9: digits[i] += 1 return digits else: digits[i] =0 digits.insert(0,1) return digits ''' 下面是join函数的介绍 Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 它只能用在字符串中！！！ 语法： join()方法语法： ‘sep’.join（strseq） strseq.join(sep) sep：分隔符，可以为空 strseq：字符串 下面是map函数的介绍 map() 会根据提供的函数对指定序列做映射。 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 语法： map() 函数语法： map(function, iterable, ...) &gt;&gt;&gt;def square(x) : # 计算平方数 ... return x ** 2 &gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 [1, 4, 9, 16, 25] &gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 [1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加 &gt;&gt;&gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19] ''' ","link":"https://ganhan999.github.io/post/66、加一/"},{"title":"Python集合运算汇总","content":"集合运算 集合的运算操作包括交集、并集、差集、补集，其中补集不适用于列表。 交集 无重复元素的列表 使用set进行交集计算。 1. 使用&amp;计算 lis1,lis2=[1,2],[1] print(list(set(lis1) &amp; set(lis2))) 输出为：[1] 12345 2. 使用intersection计算 lis1,lis2=[1,2],[1] print(list(set(lis1).intersection(lis2))) 输出为：[1] 12345 含重复元素列表 1. 列表推导式 lis1,lis2=[1,2,1],[1,2] print([v1 for v1 in lis1 if v1 in lis2]) 输出为：[1, 2, 1] 12345 2. filter过滤器 lis1,lis2=[1,2,1],[1,2] print(list(filter(lambda v: v in lis2,lis1))) 输出为：[1, 2, 1] 12345 并集 无重复元素列表 1. 使用 | lis1,lis2=[1,2],[3] print(list(set(lis1)|set(lis2))) 输出为：[1, 2, 3] 12345 2. 使用union lis1,lis2=[1,2],[3] print(list(set(lis1).union(lis2))) 输出为：[1, 2, 3] 12345 含重复元素列表 1. 使用+ lis1,lis2=[1,2,1],[3] print(lis1+lis2) 输出为：[1, 2, 1, 3] 12345 2. 使用extend lis1,lis2=[1,2,1],[3] lis1.extend(lis2) print(lis1) 输出为：[1, 2, 1, 3] 123456 差集 无重复元素列表 1. 使用^ 此方法与顺序无关，即所得结果是二者在彼此都不存在的元素 lis1,lis2=[1,2],[3] print(list(set(lis1)^set(lis2))) 输出为：[1,2,3] 12345 含重复元素列表 1. 使用difference lis1,lis2=[1,2,3],[3] print(list(set(lis1).difference(lis2))) 输出为：[1,2] 12345 2. 列表推导式 lis1,lis2=[1,2,1],[1,2] print([v1 for v1 in lis1 if v1 not in lis2]) 输出为：[] 12345 3. filter过滤器 lis1,lis2=[1,2,1],[1,2] print(list(filter(lambda v: v not in lis2,lis1))) 输出为：[] ","link":"https://ganhan999.github.io/post/Python集合运算汇总/"},{"title":"Python字典函数总结","content":"字典相关函数 字典中每个键值用冒号分隔，每个键值对之间用逗号分隔，格式如下，后面的函数以此举例 dict = {'name':'Bob', 'age':20, 'sex':'boy'} 1、len() 判断字典中元素的个数 len(dict) 输出结果：3 2、str() 以字符串的形式输出字典 str(dict) 输出结果： &quot;{'age': 20, 'name': 'Bob', 'sex': 'boy'}&quot; 3、clear() 删除字典内的所有元素 dict.clear() 输出结果： {} 4、items() 返回一个列表，列表中的元素是（键，值）元组 dict.items() python2中的输出结果： [('age', 20), ('name', 'Bob'), ('sex', 'boy')] python3中的输出结果为一个迭代器，可使用list()将其转换为列表： dict_items([('age', 20), ('name', 'Bob'), ('sex', 'boy')]) 5、get(key[, default]) 返回指定键的值，如果字典中不包含该键则返回default值 dict.get('name') print(dict.get('girlfriend')) dict.get('girlfriend', 'Linda') 输出结果: 'Bob' None 'Linda' 6、has_key(key) 该函数在python2中使用，如果字典中含有key则返回True，反之返回False dict.has_key('name') dict.has_key('girlfriend') 输出结果： True False 7、contains(key) 该函数在python3中使用，作用和has_key()相同 dict.__contains__('name') dict.__contains__('girlfriend') 输出结果： True False 8、fromkeys(seq[, value]) 用于创建新的字典，字典的键是seq序列中的每一个值，value是每个键对应的初始值 seq = ['a', 'b', 'c'] dict = {} dict1 = dict.fromkeys(seq) print(dict1) dict2 = dict.fromkeys(seq, 1) print(dict2) 输出结果： {'a': None, 'c': None, 'b': None} {'a': 1, 'c': 1, 'b': 1} 9、keys() 返回字典的键列表 dict.keys() python2中的输出结果： ['age', 'name', 'sex'] python3中的输出结果为一个迭代器，可使用list()将其转换为列表： dict_keys(['age', 'name', 'sex']) 10、values() 返回字典的值列表 dict.values() python2中的输出结果： [20, 'Bob', 'boy'] python3中的输出结果为一个迭代器，可使用list()将其转换为列表： dict_values([20, 'Bob', 'boy']) 11、setdefault(key[, default]) 和get()方法类似，返回指定键对应的值，如果key不在字典中则在字典中添加key，值为default dict.setdefault('name') dict.setdefault('girlfriend', 'Linda') print(dict) 输出结果： 'Bob' 'Linda' {'girlfriend': 'Linda', 'age': 20, 'name': 'Bob', 'sex': 'boy'} 12、update(dict2) 将dict2中的键值更新到目标字典中，如果两个字典中有相同key，则取dict2中的key dict2 = {'girlfriend':'Linda'} dict.update(dict2) print(dict) 输出结果： {'girlfriend': 'Linda', 'age': 20, 'name': 'Bob', 'sex': 'boy'} 13、pop(key[,default]) 删除字典中给定key和其所对应的值，返回值是key对应的值，如果key不在字典中则返回default值。 dict.pop('name') dict.pop('girlfriend','Linda') print(dict) 输出结果： 'Bob' 'Linda' {'age': 20, 'sex': 'boy'} 14、popitem() 随机删除并返回一个键值对 dict.popitem() print(dict) 输出结果： ('age', 20) {'name': 'Bob', 'sex': 'boy'} ","link":"https://ganhan999.github.io/post/Python字典函数汇总/"},{"title":"Python列表函数汇总","content":"list列表是Python内置的一种数据类型，本质是一种有序的集合，这里将会讲到list的具体的一些用法以及常见的函数 创建列表 语法：列表名 = [元素1，元素2，元素3…元素n] 说明：列表中的选项被称为元素，跟string类似，下标也是从0开始计数，一个列表中的数据类型可以各不相同。 创建列表代码如下： #创建空列表 list1 = [] #创建带有元素的列表 list2 = [10, 20, 30, 10] print(list2) #[10, 20, 30, 10] list3 = [33, &quot;good&quot;, True, 10.32] print(list3) #[33, 'good', True, 10.32] 1234567 列表元素的访问 列表的取值 语法：列表名[索引] 功能：访问list列表中元素值 list4 = [22, 33, 12, 32, 45] #下标从0开始，最大值为len(list4)-1 print(list4[0]) #22 123 注意：当索引值大于len(list4)-1的时候，会出现以下错误： IndexError: list index out of range 1 这个错误就是下标越界【下标超出了可表示的范围】 列表元素的替换 语法：列表名[下标] = 值 功能：更改列表元素的值 list4 = [22, 33, 12, 32, 45] list4[0] = &quot;hello&quot; print(list4) #['hello', 33, 12, 32, 45] 123 列表的操作 列表组合 语法： list3 = list1 + list2，如下代码： list1 = [1, 2, 3] list2 = ['hello','yes','no'] print(list1+list2) #[1, 2, 3, 'hello', 'yes', 'no'] 123 列表重复 语法： list2 = list1 * n，如下代码： list1 = [1, 2, 3] print(list1*3) #[1, 2, 3, 1, 2, 3, 1, 2, 3] 12 判断元素是否在列表中 语法：x in list1 若存在则返回True，否则返回False，如下代码： list1 = [1, 2, 3] print(1 in list1) #True 12 列表截取 语法：list1[start:end] 表示获取从开始下标到结束下标的所有元素[start, end)。若不指定start，则默认从0开始截取，截取到指定位置；若不指定end，则从指定位置开始截取，截取到末尾结束。如下代码： list1 = [1, 2, 3, 'hello', 'yes', 'no'] print(list1[2:4]) #[3, 'hello'] 12 二维列表 语法：list = [list1,list2,…,listn] 创建二维列表，即列表中的元素还是列表,如下代码： list1 = [[1, 2, 3],[2, 3, 4],[5, 4, 9]] 1 二维列表取值 语法：list1[n][m] 注意：n代表list列表中第n个列表（下标从0开始），m代表list列表第n个列表中的第m个元素 list1 = [[1, 2, 3],[2, 3, 4],[5, 4, 9]] print(list1[1][1]) #3 12 常见函数的使用 1. list.append(元素/列表) 功能：在列表中末尾添加新的元素【在原本的列表中追加元素】 注意：append()中的值可以是列表也可以是普通元素 list1 = [3, 4, 6] list1.append(6) print(list1) #[3, 4, 6, 6] 123 2. list.extend(列表) 功能：在列表的末尾一次性追加另外一个列表中的多个值 注意：extend()中的值只能是列表/元组[一个可迭代对象]，不能是元素 list1 = [1,2,3] list2 = [3, 4,5] list1.extend(list2) print(list1) #[1, 2, 3, 3, 4, 5] 1234 3. list.insert(下标值, 元素/列表) 功能：在下标处插入元素，不覆盖原本的数据，原数据向后顺延 注意：插入的数据可以是元素也可以为列表 list1 = [1,2,3] list1.insert(1,0) print(list1) #[1, 0, 2, 3] list1.insert(1,[2, 4, 8]) print(list1) #[1, [2, 4, 8], 0, 2, 3] 12345 4. list.pop(下标值) 功能：移除列表中指定下标处的元素(默认移除最后一个元素)，并返回移除的数据 list1 = [1, [2, 4, 8], 0, 2, 3] print(list1.pop()) #3 print(list1.pop(2)) #0 print(list1) #[1, [2, 4, 8], 2] 1234 5. list.remove(元素) 功能：移除列表中的某个元素第一个匹配结果 list1 = [1, 2, 3] list1.remove(2) print(list1) #[1, 3] 123 6. list.clear() 功能：清除列表中所有的数据 list1 = [1, 2, 3] list1.clear() print(list1) #[] 123 7. list.index(object[, start][, stop]) 功能：从指定的范围的列表中找出某个值第一匹配的索引值 ；若不指定范围，则默认是整个列表 list1 = [1, 2, 3] print(list1.index(2)) #1 12 注意：若在列表中找不到这个元素，则会报错。如下： list1 = [1, 2, 3] print(list1.index(4)) ValueError: 4 is not in list 1234 8. list.count(元素) 功能：查看元素在列表中出现的次数 list1 = [1, 2, 3, 1] print(list1.count(1)) #2 12 9. len(list) 功能： 获取元素列表个数 list1 = [1, 2, 3, 1] print(len(list1)) #4 12 10. max(list) 功能： 获取列表中的最大值 list1 = [1, 2, 3, 1] print(max(list1)) #3 12 11. min(list) 功能：获取列表中的最小值 list1 = [1, 2, 3, 1] print(min(list1)) #1 12 12. list.reverse() 功能：将列表中的元素倒叙，操作原列表，不返回新的列表 list1 = [1, 2, 3, 1] list1.reverse() print(list1) #[1, 3, 2, 1] 123 13. list.sort(reverse=False) 功能：将list中的元素进行升序排列【默认reverse=False】，当reverse为True的时候，降序排列。 list1 = [1, 2, 3, 1] list1.sort() print(list1) #[1, 1, 2, 3] 123 14. list(元组) 功能：将元组转为列表 list1 = list((1, 2, 3, 4)) print(list1) #[1, 2, 3, 4] 12 拷贝 1. 赋值拷贝/引用拷贝 语法： list2 = list1 list1 = [1, 2, 3, 1] list2 = list1 print(list2) #[1, 2, 3, 1] print(id(list1)) #43148104 print(id(list2)) #43148104 12345 注意：赋值拷贝为引用拷贝，类似于快捷方式 2. 浅拷贝 用法：list2 = list1.copy() list1 = [1, 2, 3, 1] list2 = list1.copy() print(list2) #[1, 2, 3, 1] print(id(list2)) #35534216 print(id(list1)) #36332360 12345 注意：只适用于一维列表。 不完全内存拷贝，对于一维列表重新开辟了一块内存空间，但若出现二维列表的情况下，因为二维列表存放在一维列表中存放的是列表的地址，因此，若出现二维列表相当于间接的引用了同一块内存区域。 3.深拷贝 import copy list2 = copy.deepcopy(list1) 完全内存拷贝，相当于将list1中的所有列表中元素重新复制了一份，对于多维的也重新开辟了内存空间，因此它不会出现内存共用的情况。 import copy list1 = [1,2,3,4,[1,2,3,4]] list2 = copy.deepcopy(list1) list2[-1][-1] =&quot;hello&quot; print(list1) #[1, 2, 3, 4, [1, 2, 3, 4]] print(list2) #[1, 2, 3, 4, [1, 2, 3, 'hello']] print(id(list1)) #43225864 print(id(list2)) #43227144 123456789 列表的遍历 使用for循环遍历列表 for x in list1 循环体 12 功能：for循环主要用于遍历列表 遍历：指的是依次访问列表中的每一个元素，获取每个下标对应的元素值 说明：按照顺序获取列表中的每个元素，赋值给变量名，再执行语句，如此循环往复，直到取完列表中所有的元素为止 list1 = ['hello', 78, '你好', 'good'] for item in list1: print(item,end=' ') #hello 78 你好 good 12345 使用while循环遍历列表[使用下标循环] index = 0 while index &lt; len(list1): 循环体 index += 1 1234 具体代码如下： list1 = ['hello', 78, '你好', 'good'] index = 0 while index &lt; len(list1): print(list1[index],end=' ') index += 1 #hello 78 你好 good 1234567 同时遍历下标与元素 for index,value in enumerate(list1): 循环体 12 enumerate()[枚举]函数用于一个可遍历的数据对象(如列表,元组或者字符串)组合为一个索引序列，同时列出数据与数据下标，一般使用在for循环中 enumerate(obj, [start =0]) obj:一个可迭代对象 start:下标起始位置 123 具体代码实现如下： list1 = ['hello', 78, '你好', 'good'] for index,item in enumerate(list1): print(index, item) 123 运行结果如下： 0 hello 1 78 2 你好 3 good ","link":"https://ganhan999.github.io/post/Python列表函数汇总/"},{"title":"Python字符串函数汇总","content":"目录 1.0 capitalize()函数 2.0 title()函数 3.0 swapcase()函数 4.0 lower()函数 5.0 upper()函数 6.0 casefold()函数 7.0 center()函数 8.0 ljust()函数 9.0 rjust()函数 10.0 zfill()函数 11.0 count(）函数 12.0 encode()函数 13.0 decode()函数 14.0 expandtabs()函数 15.0 find()函数 16.0 rfind()函数 17.0 index()函数 18.0 rindex()函数 19.0 format()函数 20.0 format_map()函数 21.0 endswith()函数 22.0 startswith()函数 23.0 isalnum()函数 24.0 isalpha()函数 25.0 isdecimal()函数 26.0 isdigit()函数 27.0 isidentifier()函数 28.0 islower()函数 29.0 isupper()函数 30.0 isnumeric()函数 31.0 isprintable()函数 32.0 isspace()函数 33.0 istitle()函数 34.0 strip()函数 35.0 lstrip()函数 36.0rstrip()函数 37.0 maketrans()函数 38.0 translate()函数 39.0 partition()函数 40.0 rpartition()函数 41.0 split()函数 42.0 rsplit()函数 43.0 splitlines()函数 44.0 join()函数 45.0 replace()函数 解决英文单词大小写问题： 1.0 capitalize()函数 描述：将字符串的第一个字母变成大写，其余字母变为小写。 语法：str.capitalize() —&gt; str 返回字符串 程序示例： str1 = &quot;i Love python&quot; str2 = &quot; i Love python&quot; #字母i前有空格 str3 = &quot;I Love python&quot; print(str1.capitalize()) print(str2.capitalize()) print(str3.capitalize()) 程序运行结果： I love python i love python I love python 2.0 title()函数 描述：返回一个满足标题格式的字符串。即所有英文单词首字母大写，其余英文字母小写。 语法：str.title() -&gt; str 返回一个字符串 程序示例： str = &quot;i love python&quot; print(str.title()) #将字符串str的所有单词首字母大写，其余字母小写 程序运行结果： I Love Python 3.0 swapcase()函数 描述：将字符串str中的大小写字母同时进行互换。即将字符串str中的大写字母转换为小写字母，将小写字母转换为大写字母。 语法：str.swapcase() -&gt; str 返回字符串 程序示例： str1 = &quot;I Love PYTHON&quot; str2 = &quot;我爱python Python pYTHON&quot; print(str1.swapcase()) #将字符串str1中的大写字母转为小写字母，小写字母转换为大写字母。 print(str2.swapcase()) 程序运行结果： i lOVE python 我爱PYTHON pYTHON Python 4.0 lower()函数 描述：将字符串中的所有大写字母转换为小写字母。 语法：str.lower() -&gt; str 返回字符串 程序示例： str1 = &quot;I Love Python&quot; str2 = &quot;Groß - α&quot; #德语 大写α print(str1.casefold()) print(str1.lower()) print(str2.casefold()) print(str2.lower()) 程序运行结果： i love python i love python gross - α groß - α *注意 lower()函数和casefold()函数的区别：* lower() 方法只对ASCII编码，即‘A-Z’有效，对于其它语言中把大写转换为小写的情况无效，只能用 casefold() 函数。 5.0 upper()函数 描述：将字符串中的所有小写字母转换为大写字母。 语法： str.upper() -&gt; str 返回字符串 程序示例： str1 = &quot;i love python&quot; #全为小写字母 str2 = &quot;I Love Python&quot; #所有单词首字母大写 print(str1.upper()) print(str2.upper()) 程序运行结果： I LOVE PYTHON I LOVE PYTHON 6.0 casefold()函数 描述：将字符串中的所有大写字母转换为小写字母。也可以将非英文 语言中的大写转换为小写。 注意 **lower()函数和casefold()函数的区别：**lower() 方法只对ASCII编码，即‘A-Z’有效，对于其它语言中把大写转换为小写的情况无效，只能用 casefold() 函数。 语法：str.casefold() -&gt; str 返回字符串 程序示例： str1 = &quot;I Love Python&quot; str2 = &quot;Groß - α&quot; #德语 大写α print(str1.casefold()) print(str1.lower()) print(str2.casefold()) print(str2.lower()) 程序运行结果： i love python i love python gross - α groß - α 解决字符串填充问题： 7.0 center()函数 描述：返回一个长度为width,两边用fillchar(单字符)填充的字符串，即字符串str居中，两边用fillchar填充。若字符串的长度大于width,则直接返回字符串str。 语法：str.center(width , &quot;fillchar&quot;) -&gt; str 返回字符串 注意：引号不可省 width —— 指定字符串长度。 fillchar —— 要填充的单字符，默认为空格。 程序示例： str = &quot;i love python&quot; print(str.center(20,&quot;*&quot;)) #指定字符串长度为20 用单字符&quot;*&quot;填充 print(str.center(1,&quot;*&quot;)) #指定字符串长度为1，小于原字符串的长度。 print(str.center(20,&quot;8&quot;)) print(str.center(20)) #fillchar 默认为空格 程序运行结果： ***i love python**** i love python 888i love python8888 i love python 8.0 ljust()函数 描述：返回一个原字符串左对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 语法： str.ljust(width, fillchar) -&gt; str 返回一个新的字符串 width —— 指定字符串的输出长度。 fillchar—— 将要填充的单字符，默认为空格。 程序示例： str = &quot;python&quot; print(str.ljust(30,&quot;*&quot;)) #指定宽度为30，填充字符为* print(str.ljust(30)) #指定宽度为30，填充字符默认为空格 print(str.ljust(30),&quot;1&quot;) #对比 程序运行结果： python************************ python python 1 9.0 rjust()函数 描述：返回一个原字符串右对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 语法： str.ljust(width, fillchar) -&gt; str 返回一个新的字符串 width —— 指定字符串的输出长度。 fillchar—— 将要填充的单字符，默认为空格。 程序示例： str = &quot;python&quot; print(str.rjust(30,&quot;*&quot;)) #指定宽度为30，填充字符为* print(str.rjust(30)) #指定宽度为30，填充字符默认为空格 print(&quot;1&quot;,str.rjust(30)) #对比 程序运行结果： ************************python python 1 python 10.0 zfill()函数 描述：返回指定长度的字符串，使原字符串右对齐，前面用0填充到指定字符串长度。 语法：str.zfill(width) -&gt; str 返回一个字符串 width —— 指定字符串的长度,但不能为空。若指定长度小于字符串长度，则直接输出原字符串。 程序示例： str = &quot;i love python&quot; print(str.zfill(30)) #指定字符串长度为30 print(str.zfill(2)) #指定字符串长度为2，小于原字符串长度。 print(str.zfill()) #参数width为空，报错. 程序运行结果： 00000000000000000i love python i love python --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-22-45e4baf7a246&gt; in &lt;module&gt;() 2 print(str.zfill(30)) #指定字符串长度为30 3 print(str.zfill(2)) #指定字符串长度为2，小于原字符串长度。 ----&gt; 4 print(str.zfill()) #参数width为空，报错. TypeError: zfill() takes exactly 1 argument (0 given) 解决统计字符次数问题： 11.0 count(）函数 描述：统计字符串里某个字符出现的次数。可以选择字符串索引的起始位置和结束位置。 语法：str.count(&quot;char&quot;, start,end) 或 str.count(&quot;char&quot;) -&gt; int 返回整数 str —— 为要统计的字符(可以是单字符，也可以是多字符)。 star —— 为索引字符串的起始位置，默认参数为0。 end —— 为索引字符串的结束位置，默认参数为字符串长度即len(str)。 程序示例： str = &quot;i love python,i am learning python&quot; print(str.count(&quot;i&quot;)) #star 和end 为默认参数 print(str.count(&quot;i&quot;,2)) # star值为2，end值为默认参数 print(str.count(&quot;i&quot;,2,5)) #star值为2，end值为5 print(str.count(&quot;am&quot;)) #多字符统计 程序运行结果： 3 2 0 1 解决编码问题： 12.0 encode()函数 描述：以指定的编码格式编码字符串，默认编码为 'utf-8'。 语法：str.encode(encoding='utf-8', errors='strict') -&gt; bytes (获得bytes类型对象) encoding 参数可选，即要使用的编码，默认编码为 'utf-8'。字符串编码常用类型有：utf-8,gb2312,cp936,gbk等。 errors 参数可选，设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个UnicodeEncodeError。 其它可能值有 'ignore', 'replace', 'xmlcharrefreplace'以及通过 codecs.register_error() 注册其它的值。 程序示例： str1 = &quot;我爱祖国&quot; str2 = &quot;I love my country&quot; print(&quot;utf8编码：&quot;,str1.encode(encoding=&quot;utf8&quot;,errors=&quot;strict&quot;)) #等价于print(&quot;utf8编码：&quot;,str1.encode(&quot;utf8&quot;)) print(&quot;utf8编码：&quot;,str2.encode(encoding=&quot;utf8&quot;,errors=&quot;strict&quot;)) print(&quot;gb2312编码：&quot;,str1.encode(encoding=&quot;gb2312&quot;,errors=&quot;strict&quot;))#以gb2312编码格式对str1进行编码，获得bytes类型对象的str print(&quot;gb2312编码：&quot;,str2.encode(encoding=&quot;gb2312&quot;,errors=&quot;strict&quot;)) print(&quot;cp936编码：&quot;,str1.encode(encoding=&quot;cp936&quot;,errors=&quot;strict&quot;)) print(&quot;cp936编码：&quot;,str2.encode(encoding=&quot;cp936&quot;,errors=&quot;strict&quot;)) print(&quot;gbk编码：&quot;,str1.encode(encoding=&quot;gbk&quot;,errors=&quot;strict&quot;)) print(&quot;gbk编码：&quot;,str2.encode(encoding=&quot;gbk&quot;,errors=&quot;strict&quot;)) 程序运行结果： utf8编码： b'\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe7\\xa5\\x96\\xe5\\x9b\\xbd' utf8编码： b'I love my country' gb2312编码： b'\\xce\\xd2\\xb0\\xae\\xd7\\xe6\\xb9\\xfa' gb2312编码： b'I love my country' cp936编码： b'\\xce\\xd2\\xb0\\xae\\xd7\\xe6\\xb9\\xfa' cp936编码： b'I love my country' gbk编码： b'\\xce\\xd2\\xb0\\xae\\xd7\\xe6\\xb9\\xfa' gbk编码： b'I love my country' *注：在python中encode和decode分别指编码和解码* 13.0 decode()函数 描述：以 *encoding* 指定的编码格式解码字符串，默认编码为字符串编码。 语法：str.decode(encoding='utf-8', errors='strict') encoding ——要使用的编码，如：utf-8,gb2312,cp936,gbk等。 errors ——设置不同解码错误的处理方案。默认为 'strict',意为编码错误引起一个 UnicodeDecodeError。 其它可能得值有 'ignore', 'replace'以及通过 codecs.register_error() 注册的1其它值。 程序示例： s = &quot;我爱祖国&quot; str1 = s.encode(encoding=&quot;utf-8&quot;,errors=&quot;strict&quot;) str2 = s.encode(&quot;gb2312&quot;) #编码错误的处理方案默认为&quot;strict&quot; str3 = s.encode(&quot;gbk&quot;) print(str1.decode(encoding=&quot;utf-8&quot;,errors=&quot;strict&quot;))#用utf-8的解码格式，解码str1. print(str1.decode(encoding=&quot;gbk&quot;,errors=&quot;ignore&quot;))##如果以gbk的解码格式对str1进行解码得，将无法还原原来的字符串内容 print(str1.decode(encoding=&quot;gbk&quot;,errors=&quot;strict&quot;)) print(str1.decode(encoding=&quot;gbk&quot;,errors=&quot;replace&quot;)) print(&quot;\\n&quot;) print(str2.decode(&quot;gb2312&quot;)) print(str3.decode(&quot;gbk&quot;)) 程序运行结果： 我爱祖国 鎴戠埍绁栧浗 鎴戠埍绁栧浗 鎴戠埍绁栧浗 我爱祖国 我爱祖国 *注：在python3.x中，encode()函数只能用于字符串类型，而decode()函数只能用于字节数据类型。* 程序示例中 str1,str2,str3都是字节数据类型(通过encode()函数把 字符串类型s 转换为字节数据类型)。 14.0 expandtabs()函数 描述：返回一个字符串的副本。使原字符串中的制表符（&quot;\\t&quot;）的使用空间变大。使用空格来扩展空间。 语法： str.expandtabs(tabsize=8) —&gt; str 返回字符串 tabsize 的默认值为8。tabsize值为0到7等效于tabsize=8。tabsize每增加1，原字符串中“\\t”的空间会多加一个空格。 程序示例： str = &quot;i love\\tpython&quot; print(str.expandtabs())#默认值为8 print(str.expandtabs(tabsize=8)) print(str.expandtabs()) print(str.expandtabs(2)) #tabsize值为0到7，与tabsize值为8相同 print(str.expandtabs(tabsize=2)) print(str.expandtabs(tabsize=9)) print(str.expandtabs(tabsize=10)) 程序运行结果： i love python i love python i love python i love python i love python i love python i love python 解决查找指定字符(子字符串)位置问题： 15.0 find()函数 描述：查找字符串中指定的子字符串sub第一次出现的位置，可以规定字符串的索引查找范围。若无则返回 -1。 语法：str.find(sub,start,end) -&gt; int 返回整数 sum —要索引的子字符串。 start —索引的起始位置。默认值为0。 end —索引的结束位置。默认值为字符串长度len(str)。 [start,end) 不包括end。 程序示例： str = &quot;i love python&quot; print(str.find(&quot;o&quot;)) #索引子字符串&quot;o&quot; print(str.find(&quot;0&quot;,4))#索引起始位置为4 索引范围为：ve python print(str.find(&quot;o&quot;,4,12))#索引起始位置为4,结束位置为12 索引范围为：ve pytho print(str.find(&quot;&quot;)) print(str.find(&quot; &quot;))#返回第一个空格出现的位置。 print(str.find(&quot;k&quot;)) #索引子字符串&quot;k&quot;,不存在，返回-1 程序运行结果： 3 -1 11 0 1 -1 16.0 rfind()函数 描述：查找字符串中指定的子字符串sub最后一次出现的位置，可以规定字符串的索引查找范围。若无则返回 -1。 语法：str.rfind(sub,start,end) -&gt; int 返回整数 sum —要索引的子字符串。 start —索引的起始位置。默认值为0。 end —索引的结束位置。默认值为字符串长度len(str)。 [start,end) 不包括end。 *注：rfind()函数用法与find()函数相似，rfind()函数返回指定子字符串最后一次出现的位置，find()函数返回指定子字符串第一次出现的位置。* 程序示例： str = &quot;i love python python&quot; print(str.rfind(&quot;o&quot;)) #默认索引整个字符串str print(str.rfind(&quot;o&quot;,11)) #索引范围为：on python print(str.rfind(&quot;o&quot;,0,12)) #索引范围为 i love pytho print(str.rfind(&quot;python&quot;)) #返回最后一次出现&quot;python&quot;的位置,即字母&quot;p&quot;最后一次出现的位置。 print(str.rfind(&quot;&quot;)) #等效于返回字符串str的长度。 print(str.rfind(&quot; &quot;))#返回最后一个空格出现的位置 print(str.rfind(&quot;2&quot;)) #字符串str中不存在字符&quot;2&quot;,返回值为 -1 程序运行结果： 18 18 11 14 20 13 -1 17.0 index()函数 描述：查找字符串中第一次出现的子字符串的位置，可以规定字符串的索引查找范围[star,end)。若无则会报错。 语法：str.index(sub, start, end) -&gt; int 返回整数 sub —— 查找的子字符串。 start —— 索引的起始位置，默认为0。 end —— 索引的结束位置，默认为字符串的长度。 [star,end) 程序示例： str = &quot;i love python&quot; print(str.index(&quot;o&quot;)) #默认索引整个字符串 print(str.index(&quot;o&quot;,4)) #索引 ve python print(str.index(&quot;o&quot;,4,12)) #索引 ve pytho print(str.index(&quot;love&quot;)) #索引多个字符 print(str.index(&quot;k&quot;)) #索引字符串不存在，报错 程序运行结果： 3 11 11 2 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-90-a880e13b1574&gt; in &lt;module&gt;() 4 print(str.index(&quot;o&quot;,4,12)) #索引 ve pytho 5 print(str.index(&quot;love&quot;)) #索引多个字符 ----&gt; 6 print(str.index(&quot;k&quot;)) ValueError: substring not found *注：index()函数和find()函数类似，但index()函数没有找到子字符串会报错。* 18.0 rindex()函数 描述：查找字符串中最后一次出现的子字符串的位置，可以规定字符串的索引查找范围[star,end)，若无则会报错。 语法：str.rindex(sub, start, end) -&gt; int 返回整数。 sub —— 查找的子字符串。 start —— 索引的起始位置，默认为0。 end —— 索引的结束位置，默认为字符串的长度。 [star,end) *注：rindex()函数用法与index()函数相似，rindex()函数返回指定子字符串最后一次出现的位置，index()函数返回指定子字符串第一次出现的位置。* 程序示例： str = &quot;i love python python&quot; print(str.rindex(&quot;p&quot;)) #默认索引整个字符串 print(str.rindex(&quot;o&quot;,5)) #索引的范围为：e python python print(str.rindex(&quot;o&quot;,5,13)) #索引范围为：e python print(str.rindex(&quot;python&quot;)) #返回最后一次出现&quot;python&quot;的位置,即字母&quot;p&quot;最后一次出现的位置。 print(str.rindex(&quot;k&quot;)) #索引字符串不存在，报错 len(str),str[5:13] 程序运行结果： 14 18 11 14 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-116-44cc5c1acea1&gt; in &lt;module&gt;() 4 print(str.rindex(&quot;o&quot;,5,13)) #索引范围为：e python 5 print(str.rindex(&quot;python&quot;)) #返回最后一次出现&quot;python&quot;的位置,即字母&quot;p&quot;最后一次出现的位置。 ----&gt; 6 print(str.rindex(&quot;k&quot;)) 7 len(str),str[5:13] ValueError: substring not found *解决格式化输出问题：* 19.0 format()函数 描述：返回一个格式化的字符串。 *语法：str.format(*args, *kwargs) ——&gt; str 返回字符串 [模板字符串].format(逗号分隔的参数) 或 {参数序号:格式控制标记}.format(逗号分隔的参数) 它是通过{}和:来代替%。 模板字符串是一个由槽(用大括号{}来表示)和字符串组成的字符串，用来控制字符串的显示效果。 大括号{}对应着format()中逗号分隔的参数。 format()基本用法 ： 语法：[模板字符串].format(逗号分隔的参数) 通过位置 程序示例： print(&quot;用法一:&quot;) print(&quot;一日之计在于{}&quot;.format(&quot;晨&quot;)) #如果模板字符串有多个槽{}，并且槽内没有指定的序号，则按照槽{}出现的顺序一一对应format()函数中的不同参数 print(&quot;用法二：&quot;) print(&quot;{}之计在于{}&quot;.format(&quot;一日&quot;,&quot;晨&quot;)) #也可以通过在槽{}中指定format()函数中参数的序号来使用，参数是从0开始编号的。 print(&quot;用法三：&quot;) print(&quot;{0}之计在于{1}&quot;.format(&quot;一日&quot;,&quot;晨&quot;)) print(&quot;{1}之计在于{0}&quot;.format(&quot;晨&quot;,&quot;一日&quot;)) # 如果想要在模板字符串中输出大括号(&quot;{}&quot;),则使用{{ 来表示 { 用 }} 来表示 } print(&quot;用法四：&quot;) print(&quot;{0}说得好：{{一{1}之计在于晨 一{2}之计在于春}}&quot;.format(&quot;俗话&quot;,&quot;日&quot;,&quot;年&quot;)) #如果模板字符串中出现的槽{}和format()函数中参数个数不一致， #则必须要在槽{}中使用序号来指定参数的使用，否者会产生IndexError的错误。 print(&quot;用法五：&quot;) print(&quot;{0}日之计在于晨, {0}年之计在于春&quot;.format(&quot;一&quot;)) print(&quot;{}日之计在于晨, {}年之计在于春&quot;.format(&quot;一&quot;)) #槽中没有指定参数序号，会报错。 程序运行结果： 用法一: 一日之计在于晨 用法二： 一日之计在于晨 用法三： 一日之计在于晨 一日之计在于晨 用法四： 俗话说得好：{一日之计在于晨 一年之计在于春} 用法五： 一日之计在于晨, 一年之计在于春 --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-20-5f7b4f063a3b&gt; in &lt;module&gt;() 19 print(&quot;用法五：&quot;) 20 print(&quot;{0}日之计在于晨, {0}年之计在于春&quot;.format(&quot;一&quot;)) ---&gt; 21 print(&quot;{}日之计在于晨, {}年之计在于春&quot;.format(&quot;一&quot;)) #槽中没有指定参数序号，会报错。 IndexError: tuple index out of range 通过关键字参数 程序示例： print(&quot;{year}之计在于{season}&quot;.format(year=&quot;一年&quot;,season=&quot;春&quot;)) 程序运行结果： 一年之计在于春 通过列表 程序示例： l = [&quot;一日&quot;,&quot;晨&quot;,&quot;一年&quot;,&quot;春&quot;] a = [&quot;一日&quot;,&quot;晨&quot;] b = [&quot;一年&quot;,&quot;春&quot;] print(&quot;{0[0]}之计在于{0[1]}, {0[2]}之计在于{0[3]}&quot;.format(l)) #format()函数中的参数可以是一个或多个列表，但要注意槽中序号的差异。 print(&quot;{0[0]}之计在于{0[1]}, {1[0]}之计在于{1[1]}&quot;.format(a,b)) 程序运行结果： 一日之计在于晨, 一年之计在于春 一日之计在于晨, 一年之计在于春 通过字典 程序示例： d1 = {&quot;year&quot;:&quot;一年&quot;,&quot;season&quot;:&quot;春&quot;} print(&quot; {year}之计在于{season}&quot;.format(**d1)) d2 = {&quot;time&quot;:[&quot;一日&quot;,&quot;一年&quot;],&quot;season&quot;:[&quot;晨&quot;,&quot;春&quot;]} print(&quot;{time[0]}之计在于{season[0]},{time[1]}之计在于{season[1]}&quot;.format(**d2)) 程序运行结果： 一年之计在于春 一日之计在于晨,一年之计在于春 format()函数格式控制方法： 语法：{参数序号:格式控制标记}.format(逗号分隔的参数) ： [填充] [对齐] [宽度] [,] [.精度] [类型] 引导符号 要填充的单个字符 &lt; 左对齐*&gt; 右对齐**^ 居中对齐* 设定槽的输出宽度 数字的千位分隔符**适用于整数和浮点数 *用于控制浮点数小数部分**的精度(长度)*或字符串的最大输出长度 整数类型：b,c,d,o,x,X**浮点数类型：e,E,f,% [填充]——只能填充单个字符。填充字符时，一定要选择对齐方式，否者会有 Invalid format specifier 的报错 [对齐]——默认对齐方式为左对齐。 [宽度]——指的是槽的输出宽度，当槽的实际宽度比槽的设定宽度大，则输出槽的实际宽度，否者按设定的宽度输出。 [类型]——解析如下表： 类型 描述 类型 描述 b 输出整数的二进制形式 e 输出浮点数对应的小写字母e的指数形式 c 输出整数对应的Unicode字符 E 输出浮点数对应的大写字母E的指数形式 d 输出整数的十进制形式 f 输出标准浮点数形式 o 输出整数的八进制形式 % 输出浮点数的百分比形式 x 输出整数的小写十六进制形式 X 输出整数的大写写十六进制形式 格式控制标记规则:[填充], [对齐], [宽度], [,], [.精度], [类型] 这六个规则是可以任意组合使用的，但要按以上顺序使用。不过一般可以分为两组。 一组为：[填充] [对齐] [宽度] 主要用于规范字符串的显示格式。 程序示例： s = &quot;厉害了，我的国&quot; print(&quot;{0:30}&quot;.format(s)) #默认为左对齐，宽度为30,序号0可省 print(&quot;{0:&gt;30}&quot;.format(s)) #右对齐 print(&quot;{0:*&gt;30}&quot;.format(s)) #填充*字符，右对齐 print(&quot;{0:*^30}&quot;.format(s)) #居中对齐 print(&quot;{0:*30}&quot;.format(s)) #填充字符时，没有选择对齐方式，会有 Invalid format specifier 的报错 程序运行结果： 厉害了，我的国 厉害了，我的国 ***********************厉害了，我的国 ***********厉害了，我的国************ --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-86-959132fb938a&gt; in &lt;module&gt;() 4 print(&quot;{0:*&gt;30}&quot;.format(s)) #填充*字符，右对齐 5 print(&quot;{0:*^30}&quot;.format(s)) #居中对齐 ----&gt; 6 print(&quot;{0:*30}&quot;.format(s)) #填充字符时，没有选择对齐方式，会有 Invalid format specifier 的报错 ValueError: Invalid format specifier 格式控制标记规则也可以用变量来表示，即用槽{}来指定对应的格式控制标记规则。 程序示例： s = &quot;厉害了，我的国&quot; a = &quot;*&quot; b = &quot;^&quot; c = 30 d = [&quot;&lt;&quot;,&quot;^&quot;,&quot;&gt;&quot;] print(&quot;{0:{1}{2}{3}}&quot;.format(s,a,b,c)) #居中对齐，宽度为30，填充字符为* print(&quot;{0:{1}{2[2]}{3}}&quot;.format(s,a,d,c))#右对齐，用列表选择对齐方式。 print(&quot;{0:{1}{2[0]}{3}}&quot;.format(s,a,d,c)) 程序运行结果： ***********厉害了，我的国************ ***********************厉害了，我的国 厉害了，我的国*********************** 另一组为：[,] [.精度] [类型] 主要于规范数字的输出格式和控制字符串的输出长度。 程序示例： print(&quot;{0:,}&quot;.format(123456789)) # 千位分隔符 print(&quot;{:,.3}&quot;.format(123456.123)) #保留3为有效数字 print(&quot;{:.3}&quot;.format(&quot;厉害了，我的国&quot;)) # 输出前三个字符 #输出整数类型的格式化规则： #print(&quot;输出整数的二进制形式:{0:b}\\n输出整数对应的Unicode字符:{0:c}\\n输出整数的十进制形式:{0:d}\\n输出整数的八进制形式:{0:o}\\n输出整数的小写十六进制形式:{0:x}\\n输出整数的大写写十六进制形式:{0:X}&quot;.format(123456)) # 等效于一下语句： print(&quot;输出整数的二进制形式: {:b}&quot;.format(123456)) print(&quot;输出整数对应的Unicode字符: {:c}&quot;.format(123456)) print(&quot;输出整数的十进制形式: {:d}&quot;.format(123456)) print(&quot;输出整数的八进制形式: {:o}&quot;.format(123456)) print(&quot;输出整数的小写十六进制形式: {:x}&quot;.format(123456)) print(&quot;输出整数的大写写十六进制形式: {:X}&quot;.format(123456)) #输出浮点数类型的格式化规则： print(&quot;输出浮点数对应的小写字母e的指数形式: {:e}&quot;.format(123456.123456)) print(&quot;输出浮点数对应的大写字母E的指数形式: {:E}&quot;.format(123456.123456)) print(&quot;输出标准浮点数形式: {:f}&quot;.format(123456.123456)) print(&quot;输出浮点数的百分比形式: {:%}&quot;.format(123456.123456)) #对比 [.精度]可以控制小数部分的输出长度 print(&quot;输出浮点数对应的小写字母e的指数形式: {:.3e}&quot;.format(123456.123456)) print(&quot;输出浮点数对应的大写字母E的指数形式: {:.3E}&quot;.format(123456.123456)) print(&quot;输出标准浮点数形式: {:.3f}&quot;.format(123456.123456)) print(&quot;输出浮点数的百分比形式: {:.3%}&quot;.format(123456.123456)) 程序运行结果： 123,456,789 1.23e+05 厉害了 输出整数的二进制形式: 11110001001000000 输出整数对应的Unicode字符: ? 输出整数的十进制形式: 123456 输出整数的八进制形式: 361100 输出整数的小写十六进制形式: 1e240 输出整数的大写写十六进制形式: 1E240 输出浮点数对应的小写字母e的指数形式: 1.234561e+05 输出浮点数对应的大写字母E的指数形式: 1.234561E+05 输出标准浮点数形式: 123456.123456 输出浮点数的百分比形式: 12345612.345600% 输出浮点数对应的小写字母e的指数形式: 1.235e+05 输出浮点数对应的大写字母E的指数形式: 1.235E+05 输出标准浮点数形式: 123456.123 输出浮点数的百分比形式: 12345612.346% 综合运用实例： 程序示例： print(&quot;{:*^30,.2f}&quot;.format(123456.1235))#用*字符填充，居中对齐，宽度为30，千位分隔符，保留小数点后两位，输出标准浮点数 s = &quot;一年有:&quot; a = 365.0000 b = &quot;天&quot; print(&quot;{0:*&gt;8}{1:,.1f}{2:*&lt;5}&quot;.format(s,a,b)) 程序运行结果： **********123,456.12********** ****一年有:365.0天**** 20.0 format_map()函数 描述：返回字符串的格式化版本。 语法：str.format_map(mapping) -&gt; str 返回字符串 程序示例： student = {&quot;name&quot;:[&quot;张三&quot;,&quot;李四&quot;],&quot;idcard&quot;:[1,2]} print(&quot;我的名字是{name[0]}，我的学号是{idcard[0]}&quot;.format_map(student)) print(&quot;我的名字是{name[0]}，我的学号是{idcard[1]}&quot;.format_map(student)) print([&quot;我的名字是{}，我的学号是{}&quot;.format(*x) for x in zip(student[&quot;name&quot;],student[&quot;idcard&quot;])]) #以列表的形式输出 print(&quot;我的名字是{}，我的学号是{}&quot;.format(*x) for x in zip(student[&quot;name&quot;],student[&quot;idcard&quot;])) print([&quot;我的名字是{}，我的学号是{}&quot;.format(*x) for x in zip(*map(student.get,[&quot;name&quot;,&quot;idcard&quot;]))]) #以列表的形式输出 print(&quot;我的名字是{}，我的学号是{}&quot;.format(*x) for x in zip(*map(student.get,[&quot;name&quot;,&quot;idcard&quot;]))) for i in range(len(student)): print(&quot;我的名字是{{name[0]}}，我的学号是{{idcard[0]}}&quot;.format(i).format_map(student)) # {{ }} 等效于{ } 程序运行结果： 我的名字是张三，我的学号是1 我的名字是张三，我的学号是2 ['我的名字是张三，我的学号是1', '我的名字是李四，我的学号是2'] &lt;generator object &lt;genexpr&gt; at 0x0000018F5E1CFF68&gt; ['我的名字是张三，我的学号是1', '我的名字是李四，我的学号是2'] &lt;generator object &lt;genexpr&gt; at 0x0000018F5E1CF200&gt; 我的名字是张三，我的学号是1 我的名字是张三，我的学号是1 解决判断问题(返回bool类型) 21.0 endswith()函数 描述：判断字符串是否以指定字符或子字符串结尾。 语法：str.endswith(&quot;suffix&quot;, start, end) 或 str[start,end].endswith(&quot;suffix&quot;) 用于判断字符串中某段字符串是否以指定字符或子字符串结尾。 —&gt; bool 返回值为布尔类型（True,False） suffix — 后缀，可以是单个字符，也可以是字符串，还可以是元组（&quot;suffix&quot;中的引号要省略，常用于判断文件类型）。 start —索引字符串的起始位置。 end — 索引字符串的结束位置。 str.endswith(suffix) star默认为0，end默认为字符串的长度len(str) 注意：空字符的情况。返回值通常为True 程序示例： str = &quot;i love python&quot; print(&quot;1:&quot;,str.endswith(&quot;n&quot;)) print(&quot;2:&quot;,str.endswith(&quot;python&quot;)) print(&quot;3:&quot;,str.endswith(&quot;n&quot;,0,6))# 索引 i love 是否以“n”结尾。 print(&quot;4:&quot;,str.endswith(&quot;&quot;)) #空字符 print(&quot;5:&quot;,str[0:6].endswith(&quot;n&quot;)) # 只索引 i love print(&quot;6:&quot;,str[0:6].endswith(&quot;e&quot;)) print(&quot;7:&quot;,str[0:6].endswith(&quot;&quot;)) print(&quot;8:&quot;,str.endswith((&quot;n&quot;,&quot;z&quot;)))#遍历元组的元素，存在即返回True，否者返回False print(&quot;9:&quot;,str.endswith((&quot;k&quot;,&quot;m&quot;))) #元组案例 file = &quot;python.txt&quot; if file.endswith(&quot;txt&quot;): print(&quot;该文件是文本文件&quot;) elif file.endswith((&quot;AVI&quot;,&quot;WMV&quot;,&quot;RM&quot;)): print(&quot;该文件为视频文件&quot;) else: print(&quot;文件格式未知&quot;) 程序运行结果： 1: True 2: True 3: False 4: True 5: False 6: True 7: True 8: True 9: False 该文件是文本文件 22.0 startswith()函数 描述：判断字符串是否以指定字符或子字符串开头。 语法：str.endswith(&quot;suffix&quot;, start, end) 或 str[start,end].endswith(&quot;suffix&quot;) 用于判断字符串中某段字符串是否以指定字符或子字符串结尾。 —&gt; bool 返回值为布尔类型（True,False） suffix — 后缀，可以是单个字符，也可以是字符串，还可以是元组（&quot;suffix&quot;中的引号要省略）。 start —索引字符串的起始位置。 end — 索引字符串的结束位置。 str.endswith(suffix) star默认为0，end默认为字符串的长度减一（len(str)-1）。 注意：空字符的情况。返回值通常也为True 程序示例： str = &quot;hello,i love python&quot; print(&quot;1:&quot;,str.startswith(&quot;h&quot;)) print(&quot;2:&quot;,str.startswith(&quot;l&quot;,2,10))# 索引 llo,i lo 是否以“n”结尾。 print(&quot;3:&quot;,str.startswith(&quot;&quot;)) #空字符 print(&quot;4:&quot;,str[0:6].startswith(&quot;h&quot;)) # 只索引 hello, print(&quot;5:&quot;,str[0:6].startswith(&quot;e&quot;)) print(&quot;6:&quot;,str[0:6].startswith(&quot;&quot;)) print(&quot;7:&quot;,str.startswith((&quot;h&quot;,&quot;z&quot;)))#遍历元组的元素，存在即返回True，否者返回False print(&quot;8:&quot;,str.startswith((&quot;k&quot;,&quot;m&quot;))) 程序运行结果： 1: True 2: True 3: True 4: True 5: False 6: True 7: True 8: False 23.0 isalnum()函数 描述：检测字符串是否由字母和数字组成。 语法：str.isalnum() -&gt; bool 返回值为布尔类型（True,False） str中至少有一个字符且所有字符都是字母或数字则返回 True,否则返回 False 程序示例： str1 = &quot;i love python 666&quot; #有空格，不全是字母或数字 str2 = &quot;python&quot; #全为字母 str3 = &quot;123&quot; #全为数字 str4 = &quot;python666&quot; #字母和数字的组合 print(str1.isalnum()) print(str2.isalnum()) print(str3.isalnum()) print(str4.isalnum()) 程序运行结果： False True True True 24.0 isalpha()函数 描述：检测字符串是否只由字母组成。 语法：str.isalpha() -&gt; bool 返回值为布尔类型（True,False） 字符串中至少有一个字符且所有字符都是字母则返回 True,否则返回 False。 程序示例： str1 = &quot;python&quot; #全为字母 str2 = &quot; python&quot; #存在空格 str3 = &quot;123&quot; #全为数字 str4 = &quot;python666&quot; #字母和数字的组合 print(str1.isalpha()) print(str2.isalpha()) print(str3.isalpha()) print(str4.isalpha() 程序运行结果： True False False False 25.0 isdecimal()函数 描述：检查字符串是否只包含十进制字符。该方法只存在于unicode对象中。 注意:定义一个十进制字符串，只需要在字符串前添加前缀 'u' 即可。 语法： str.isdecimal() -&gt; bool 返回值为布尔类型（True,False） 字符串中若只包含十进制字符返回True，否则返回False。 程序示例： str1 = u&quot;123456&quot; str2 = u&quot;python666&quot; str3 = &quot;123456&quot; str4 = &quot;python666&quot; print(str1.isdecimal()) print(str2.isdecimal()) print(str3.isdecimal()) print(str4.isdecimal()) 程序运行结果： True False True False 26.0 isdigit()函数 描述：检测字符串是否只由数字组成. 语法： str.isdigit() -&gt; bool 返回值为布尔类型（True,False） 字符串中至少有一个字符且所有字符都是数字则返回 True,否则返回 False。 注：能判断“①”，不能判断中文数字。但 isnumeric() 函数可以。 程序示例： str1 = &quot;python&quot; #全为字母 str2 = &quot; python&quot; #存在空格 str3 = &quot;123&quot; #全为数字 str4 = &quot;python666&quot; #字母和数字的组合 str5 = &quot;一二三四五六七&quot; #中文数字输出False str6 = &quot;①&quot; print(str1.isdigit()) print(str2.isdigit()) print(str3.isdigit()) print(str4.isdigit()) print(str5.isdigit()) print(str6.isdigit()) 程序运行结果： False False True False False True 27.0 isidentifier()函数 描述：判断str是否是有效的标识符。str为符合命名规则的变量，保留标识符则返回True,否者返回False。 语法：str.isidentifier() -&gt; bool 返回值为布尔类型（True,False） 程序示例： str1 = &quot;123&quot; #变量名为123 str2 = &quot;def&quot; #变量名为保留字 str3 = &quot;_123&quot; #变量名有下划线开头 str4 = &quot;student&quot;#变量名由字母开端 print(str1.isidentifier()) print(str2.isidentifier()) print(str3.isidentifier()) print(str4.isidentifier()) 程序运行结果： False True True True 28.0 islower**()函数** 描述：检测字符串中的字母是否全由小写字母组成。（字符串中可包含非字母字符） 语法：str.islower() -&gt; bool 返回值为布尔类型（True,False） 字符串中包含至少一个区分大小写的字符，且所有这些区分大小写的字符都是小写，则返回 True，否则返回 False。 程序示例： str1 = &quot;i love python&quot; #字符串中的字母全为小写 str2 = &quot;我爱python！&quot; #字符串中的字母全为小写，也存在非字母的字符 str3 = &quot;I love python&quot; #字符串中有大写字符 print(str1.islower()) print(str2.islower()) print(str3.islower()) 程序运行结果： True True False 29.0 isupper()函数 描述：检测字符串中的字母是否全由大写字母组成。（字符串中可包含非字母字符）。 语法：str.isupper() -&gt; bool 返回值为布尔类型（True,False） 字符串中包含至少一个区分大小写的字符，且所有这些区分大小写的字符都是大写，则返回 True，否则返回 False。 程序示例： str1 = &quot;I LOVE PYTHON&quot; #全为大写字母 str2 = &quot;i LOVE PYTHON&quot; #存在小写字母 str3 = &quot;我爱PYTHON&quot; #存在非字母的字符 print(str1.isupper()) print(str2.isupper()) print(str3.isupper()) 程序运行结果： True False True 30.0 isnumeric()函数 描述：测字符串是否只由数字组成。这种方法是只适用于unicode对象。 注：把一个字符串定义为Unicode，只需要在字符串前添加 前缀 'u' 语法：str.isnumeric() -&gt; bool 返回值为布尔类型（True,False） 字符串中只包含数字字符，则返回 True，否则返回 False。 与isdigit()函数类似，但isnumeric()函数可以判断中文数字，功能更强大。 程序示例： str1 = u&quot;123456&quot; #全为数字 str2 = &quot;123456&quot; str3 = &quot;python666&quot; #字母数字组合 str4 = &quot;一二三四五六&quot; #中文数字 str5 = &quot;①&quot; print(str1.isnumeric()) print(str2.isnumeric()) print(str3.isnumeric()) print(str4.isnumeric()) print(str5.isnumeric()) 程序运行结果： True True False True True 31.0 isprintable()函数 描述：判断字符串中是否有打印后不可见的内容。如：\\n \\t 等字符。 语法： str.isprintable() -&gt; bool 返回值为布尔类型（True,False） 若字符串中不存在\\n \\t 等不可见的内容，则返回True,否者返回False。 程序示例： str1 = &quot;i love python&quot; #不存在用print()打印后不可见的内容 str2 = &quot;i love python \\n&quot; #存在用print()打印后不可见的内容 \\n str3 = &quot;i love \\t python&quot; print(str1.isprintable()) print(str2.isprintable()) print(str3.isprintable()) 程序运行结果： True False False 32.0 isspace()函数 描述： 检测字符串是否只由空格组成。 语法：str.isspace() -&gt; bool 返回值为布尔类型（True,False） 若字符串中只包含空格，则返回 True，否则返回 False。 程序示例： str1 = &quot; &quot;#空格 str2 = &quot;i love python&quot; print(str1.isspace()) print(str2.isspace()) print(str2[1].isspace()) #字符串str2 的第二个字符为空格 程序运行结果： True False True 33.0 istitle()函数 描述：检测判断字符串中所有单词的首字母是否为大写，且其它字母是否为小写，字符串中可以存在其它非字母的字符。 语法：str.istitle() -&gt; bool 返回值为布尔类型（True,False） 若字符串中所有单词的首字母为大写，且其它字母为小写，则返回 True，否则返回 False. 程序示例： str1 = &quot;I Love Python&quot; #各单词的首字母均为大写，其余字母为小写 str2 = &quot;I love python&quot; str3 = &quot;I LOVE PYTHON&quot; str4 = &quot;我爱Python&quot; #存在其它非字母字符， print(str1.istitle()) print(str2.istitle()) print(str3.istitle()) print(str4.istitle()) 程序运行结果： True False False True 解决字符串两端： 34.0 strip()函数 描述：从字符串str中去掉在其左右两边chars中列出的字符。 注：chars传入的是一个字符数组，编译器去除两端所有相应的字符，直到出现第一个在chars中不匹配的字符。详看示例。 语法： str.strip(chars) -&gt; str 返回一个新的字符串 chars —— 要去除的字符 默认为空格或换行符。 程序示例： str = &quot;123456789321&quot; print(str.strip(&quot;123&quot;)) #除去123，对于字符串str右边，1 在 &quot;123&quot;中去除，2在&quot;123&quot;中去除，同理3也去除，但9不在&quot;123&quot;中,去除结束 str1 = &quot;my name is ymyyyy&quot; print(str1.strip(&quot;my&quot;)) #&quot;my&quot; 无空格，字母n前的空格不去掉。 print(str1.strip(&quot;my &quot;)) #&quot;my &quot;有空格，所以str1左边字母n前的空格被去掉。 程序运行结果： 456789 name is name is 35.0 lstrip()函数 描述：从字符串str中去掉在其左边chars中列出的字符。 注：chars传入的是一个字符数组，编译器去除两端所有相应的字符，直到出现第一个在chars中不匹配的字符。详看示例。 语法：str.lstrip(chars) -&gt; str 返回一个新的字符串 chars —— 要去除的字符 默认为空格或换行符。 程序示例： str1 = &quot;bacjabck123kluabc&quot; print(str1.lstrip(&quot;abc&quot;)) #只去掉左边的&quot;bac&quot;,左边第4个字符j不在&quot;abc&quot;中，去除结束 str2 = &quot;12578asdfgh12&quot; print(str2.lstrip(&quot;12&quot;)) #只去掉字符串str2左边的 12 程序运行结果： jabck123kluabc 578asdfgh12 36. rstrip()函数 描述：从字符串str中去掉在其右边chars中列出的字符。 注：chars传入的是一个字符数组，编译器去除两端所有相应的字符，直到出现第一个在chars中不匹配的字符。详看示例。 语法：str.rstrip(chars) -&gt; str 返回一个新的字符串 chars —— 要去除的字符 默认为空格或换行符。 程序示例： str1 = &quot;abcjabck123kluabcca&quot; print(str1.rstrip(&quot;abc&quot;)) #只去掉右边的&quot;abcca&quot;,右边第6个字符u不在&quot;abc&quot;中，去除结束 str2 = &quot;12578asdfgh11112&quot; print(str2.rstrip(&quot;12&quot;)) #只去掉字符串str2右边的 11112 程序运行结果： abcjabck123klu 12578asdfgh 解决 制表 翻译 问题： 37.0 maketrans()函数 描述：制作翻译表，删除表，常与translate()函数连用。 即：返回用于str.translate（）函数翻译的的转换表。 语法：maketrans(x, y=None, z=None, /) 返回可用于str.translate()函数的转换表 str.maketrans(x,y,z) #返回的是Unicode映射的字典。 bytes.maketrans(x,y) #返回的是bytes类型. bytearray.maketrans(x,y) #返回的是bytes类型。 如果只有一个参数x,它必须是一个字典且为Unicode形式的映射。 如果有两个参数x和y，它们必须是长度相等的字符串，并且在结果映射中，x中的每个字符都将映射到y中相同位置的字符(Unicode形式的映射)。 如果有三个参数x,y和z. x和y用法同上，z为指定要删除的字符串，其结果中的字符将一一映射为：None。 bytes.maketrans(x,y) 和 bytearray.maketrans(x,y) 必须要有x和y两个参数。 *注：z的长度可以和x和y不同。* str.maketrans(x,y,z)形式： 程序示例： s = &quot;123456789&quot; #只有参数x，且x为字典。 map1 = str.maketrans({&quot;1&quot;:&quot;a&quot;,&quot;2&quot;:&quot;b&quot;,&quot;3&quot;:&quot;c&quot;}) #单字符&quot;1&quot; &quot;2&quot; &quot;3&quot;对应的Unicode编码值分别为：49，50,51 #制作翻译表,将 字符串s 中的单字符&quot;1&quot;替换为单字符&quot;a&quot;，单字符&quot;2&quot;替换为单字符&quot;b&quot;,一一对应。 print(map1,type(map1),ord(&quot;1&quot;),ord(&quot;2&quot;),ord(&quot;3&quot;)) #map1返回的是一个Unicode形式映射的字典 #只有参数x和参数y map2 = str.maketrans(&quot;123&quot;,&quot;abc&quot;) #单字符&quot;1&quot; &quot;2&quot; &quot;3&quot;对应的Unicode编码值如上，单字符&quot;a&quot; &quot;b&quot; &quot;c&quot;对应的Unicode编码值分别为：97，98,99 #制作翻译表,将字符串s中的单字符&quot;1&quot;替换为单字符&quot;a&quot;，单字符&quot;2&quot;替换为单字符&quot;b&quot;,一一对应 print(map2,type(map2),ord(&quot;a&quot;),ord(&quot;b&quot;),ord(&quot;c&quot;))#map2返回的也是一个Unicode形式映射的字典 #有x,y,z三个参数 map3 = str.maketrans(&quot;123&quot;,&quot;abc&quot;,&quot;56k&quot;) #字符串&quot;123&quot;和&quot;abc&quot;含义如上。字符串&quot;567&quot;为 字符串s 要删除的字符,即制作删除表。 #单字符&quot;5&quot; &quot;6&quot; &quot;k&quot;对应的Unicode编码值分别为：53,54,107 print(map3,type(map3),ord(&quot;5&quot;),ord(&quot;6&quot;),ord(&quot;k&quot;)) #map3返回的也是一个Unicode形式映射的字典 程序运行结果： 49: 'a', 50: 'b', 51: 'c'} &lt;class 'dict'&gt; 49 50 51 {49: 97, 50: 98, 51: 99} &lt;class 'dict'&gt; 97 98 99 {49: 97, 50: 98, 51: 99, 53: None, 54: None, 107: None} &lt;class 'dict'&gt; 53 54 107 In [6]: bytes.maketrans(x,y)形式： 程序示例： map4 = bytes.maketrans(b&quot;123&quot;,b&quot;abc&quot;) print(type(b&quot;123&quot;),type(b&quot;abc&quot;),type(map4),map4) 程序运行结果： &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !&quot;#$%&amp;\\'()*+,-./0abc456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff' bytearray.maketrans(x,y)形式： 程序示例： map5 = bytearray.maketrans(b&quot;123&quot;,b&quot;abc&quot;) print(type(b&quot;123&quot;),type(b&quot;abc&quot;),type(map5),map5) 程序运行结果： &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !&quot;#$%&amp;\\'()*+,-./0abc456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff' 38.0 translate()函数 描述：过滤(删除)，翻译字符串。即根据maketrans()函数给出的字符映射转换表来转换字符串中的字符。 注：translate()函数是先过滤(删除)，再根据maketrans()函数返回的转换表来翻译。 语法：str.translate(table) -&gt; str 返回一个字符串 str.translate(table) bytes.translate(table, deletechars) bytearray.translate(table, deletechars) table —— 转换表，转换表是通过maketrans()函数转换而来。 deletechars —— 字符串中要过滤(删除)的字符。 程序示例： s = &quot;123456789abc&quot; s1 = b&quot;123456789abc&quot; #只有参数x，且x为字典。 map1 = str.maketrans({&quot;1&quot;:&quot;a&quot;,&quot;2&quot;:&quot;b&quot;,&quot;3&quot;:&quot;c&quot;}) #单字符&quot;1&quot; &quot;2&quot; &quot;3&quot;对应的Unicode编码值分别为：49，50,51 #制作翻译表,将 字符串s 中的单字符&quot;1&quot;替换为单字符&quot;a&quot;，单字符&quot;2&quot;替换为单字符&quot;b&quot;,一一对应。 print(map1,type(map1),ord(&quot;1&quot;),ord(&quot;2&quot;),ord(&quot;3&quot;)) #map1返回的是一个Unicode形式映射的字典 #只有参数x和参数y map2 = str.maketrans(&quot;123&quot;,&quot;abc&quot;) #单字符&quot;1&quot; &quot;2&quot; &quot;3&quot;对应的Unicode编码值如上，单字符&quot;a&quot; &quot;b&quot; &quot;c&quot;对应的Unicode编码值分别为：97，98,99 #制作翻译表,将字符串s中的单字符&quot;1&quot;替换为单字符&quot;a&quot;，单字符&quot;2&quot;替换为单字符&quot;b&quot;,一一对应 print(map2,type(map2),ord(&quot;a&quot;),ord(&quot;b&quot;),ord(&quot;c&quot;))#map2返回的也是一个Unicode形式映射的字典 #有x,y,z三个参数 map3 = str.maketrans(&quot;123&quot;,&quot;abc&quot;,&quot;56k&quot;) #字符串&quot;123&quot;和&quot;abc&quot;含义如上。字符串&quot;567&quot;为 字符串s 要删除的字符,即制作删除表。 #单字符&quot;5&quot; &quot;6&quot; &quot;k&quot;对应的Unicode编码值分别为：53,54,107 print(map3,type(map3),ord(&quot;5&quot;),ord(&quot;6&quot;),ord(&quot;k&quot;)) #map3返回的也是一个Unicode形式映射的字典 map4 = bytes.maketrans(b&quot;123&quot;,b&quot;abc&quot;) print(type(b&quot;123&quot;),type(b&quot;abc&quot;),type(map4),map4) print(&quot;\\n&quot;) map5 = bytearray.maketrans(b&quot;123&quot;,b&quot;abc&quot;) print(type(b&quot;123&quot;),type(b&quot;abc&quot;),type(map5),map5) print(&quot;\\n\\n&quot;) print(s.translate(map1)) #将 字符串s 中的&quot;123&quot; 分别替换为 &quot;abc&quot; print(s.translate(map2)) #将 字符串s 中的&quot;123&quot; 分别替换为 &quot;abc&quot; print(s.translate(map3)) #先将 字符串s 中的字符 &quot;5&quot;,&quot;6&quot; ,&quot;k&quot;过滤(删除)，再将 字符串s 中的&quot;123&quot; 分别翻译替换为 &quot;abc&quot; print(s1.translate(map4)) print(s1.translate(map5)) print(s1.translate(map4,b&quot;78b&quot;)) #先将s1中的b&quot;78b&quot; 过滤(删除)，再将 s1 中的b&quot;123&quot; 分别翻译替换为 b&quot;abc&quot; print(s1.translate(map5,b&quot;9&quot;)) #先将s1中的b&quot;9&quot; 过滤(删除)，再将 s1 中的b&quot;123&quot; 分别翻译替换为 b&quot;abc&quot; 程序运行结果： {49: 'a', 50: 'b', 51: 'c'} &lt;class 'dict'&gt; 49 50 51 {49: 97, 50: 98, 51: 99} &lt;class 'dict'&gt; 97 98 99 {49: 97, 50: 98, 51: 99, 53: None, 54: None, 107: None} &lt;class 'dict'&gt; 53 54 107 &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !&quot;#$%&amp;\\'()*+,-./0abc456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff' &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; &lt;class 'bytes'&gt; b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !&quot;#$%&amp;\\'()*+,-./0abc456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff' abc456789abc abc456789abc abc4789abc b'abc456789abc' b'abc456789abc' b'abc4569ac' b'abc45678abc' 解决分割字符串问题： 39.0 partition()函数： 描述：根据指定的分隔符(sep)将字符串进行分割。从字符串左边开始索引分隔符sep,索引到则停止索引。 语法： str.partition(sep) -&gt; (head, sep, tail) 返回一个三元元组，head:分隔符sep前的字符串，sep:分隔符本身，tail:分隔符sep后的字符串。 sep —— 指定的分隔符。 如果字符串包含指定的分隔符sep，则返回一个三元元组，第一个为分隔符sep左边的子字符串，第二个为分隔符sep本身，第三个为分隔符sep右边的子字符串。 如果字符串不包含指定的分隔符sep,仍然返回一个三元元组，第一个元素为字符串本身，第二第三个元素为空字符串 程序示例： str = &quot;https://www.baidu.com/&quot; print(str.partition(&quot;://&quot;)) #字符串str中存在sep&quot;://&quot; print(str.partition(&quot;,&quot;)) #字符串str中不存在sep&quot;,&quot;,返回了两个空字符串。 print(str.partition(&quot;.&quot;)) #字符串str中存在两个&quot;.&quot; 但索引到www后的&quot;.&quot; 停止索引。 print(type(str.partition(&quot;://&quot;))) #返回的是tuple类型， 即元组类型 程序运行结果： ('https', '://', 'www.baidu.com/') ('https://www.baidu.com/', '', '') ('https://www', '.', 'baidu.com/') &lt;class 'tuple'&gt; 40.0 rpartition()函数 描述：根据指定的分隔符(sep)将字符串进行分割。从字符串右边(末尾)开始索引分隔符sep,索引到则停止索引。 语法：str.rpartition(sep) -&gt; (head, sep, tail) 返回一个三元元组，head:分隔符sep前的字符串，sep:分隔符本身，tail:分隔符sep后的字符串。 sep —— 指定的分隔符。 如果字符串包含指定的分隔符sep，则返回一个三元元组，第一个为分隔符sep左边的子字符串，第二个为分隔符sep本身，第三个为分隔符sep右边的子字符串。 如果字符串不包含指定的分隔符sep,仍然返回一个三元元组，第一个元素为字符串本身，第二第三个元素为空字符串。 注：rpartition()函数与partition()函数用法相似，rpartition()函数从右边(末尾)开始索引，partition()函数从左边开始索引。 程序示例： str = &quot;https://www.baidu.com/&quot; print(str.rpartition(&quot;://&quot;)) #字符串str中存在sep&quot;://&quot; print(str.rpartition(&quot;,&quot;)) #字符串str中不存在sep&quot;,&quot;,返回了两个空字符串。 print(str.rpartition(&quot;.&quot;)) #字符串str中存在两个&quot;.&quot; 但索引是从右边(末尾)开始，索引到du后的&quot;.&quot; 停止索引。 print(type(str.partition(&quot;://&quot;))) #返回的也是tuple类型， 即元组类型 程序运行结果： ('https', '://', 'www.baidu.com/') ('', '', 'https://www.baidu.com/') ('https://www.baidu', '.', 'com/') &lt;class 'tuple'&gt; 41.0 split()函数 描述：拆分字符串。通过指定分隔符sep对字符串进行分割，并返回分割后的字符串列表。 语法： str.split(sep=None, maxsplit=-1) -&gt; list of strings 返回 字符串列表 或str.split(sep=None, maxsplit=-1)[n] sep —— 分隔符，默认为空格,但不能为空即(&quot;)。 maxsplit —— 最大分割参数，默认参数为-1。 [n] —— 返回列表中下标为n的元素。列表索引的用法。 程序示例： str1 = &quot;i love python&quot; str2 = &quot;https://www.baidu.com&quot; str3 = &quot;script&lt;i love python&gt;script&quot; str4 = &quot;i \\n love \\n python&quot; print(str1.split()) #默认空格分割。 print(str2.split(&quot;.&quot;))#以&quot;.&quot;为分隔符,maxsplit默认为-1 print(str2.split(&quot;.&quot;,-1)) #maxsplit为-1 print(str2.split(&quot;.&quot;,1)) #以&quot;.&quot;为分隔符,分割一次。 print(str2.split(&quot;.&quot;)[1]) #分割后，输出列表中下标为1的元素 print(str3.split(&quot;&lt;&quot;)[1].split(&quot;&gt;&quot;)[0]) print(str4.split(&quot;\\n&quot;)) #可用于去掉字符串中的&quot;\\n&quot; &quot;\\t&quot;等 程序运行结果： ['i', 'love', 'python'] ['https://www', 'baidu', 'com'] ['https://www', 'baidu', 'com'] ['https://www', 'baidu.com'] baidu i love python ['i ', ' love ', ' python'] 42.0 rsplit()函数 描述：拆分字符串。通过指定分隔符sep对字符串进行分割，并返回分割后的字符串列表,类似于split()函数，只不过 rsplit()函数是从字符串右边(末尾)开始分割。 语法： str.rsplit(sep=None, maxsplit=-1) -&gt; list of strings 返回 字符串列表 或str.rsplit(sep=None, maxsplit=-1)[n] sep —— 分隔符，默认为空格,但不能为空即(&quot;)。 maxsplit —— 最大分割参数，默认参数为-1。 [n] —— 返回列表中下标为n的元素。列表索引的用法。 程序示例： str = &quot;https://www.baidu.com&quot; print(str.rsplit()) #默认空格分割。 print(str.rsplit(&quot;.&quot;)) #以&quot;.&quot;为分隔符,maxsplit默认为-1 print(str.rsplit(&quot;.&quot;,1)) #以&quot;.&quot;为分隔符,分割一次。从字符串右边(末尾)开始分割。 print(str.rsplit(&quot;.&quot;,1)[1]) #分割后，输出列表中下标为1的元素 程序运行结果： ['https://www.baidu.com'] ['https://www', 'baidu', 'com'] ['https://www.baidu', 'com'] com 43.0 splitlines()函数 描述：按照('\\n', '\\r', \\r\\n'等)分隔，返回一个包含各行作为元素的列表，默认不包含换行符。 符号 描述 \\n 换行符 \\r 回车符 \\r\\n 回车+换行 语法：str.splitlines(keepends) -&gt; list of strings 返回 字符串列表 keepends —— 默认参数为False ，译为 不保留换行符。参数为True , 译为 保留换行符。 程序示例： s1 = &quot;&quot;&quot;i love python &quot;&quot;&quot; s2 = &quot;i\\nlove\\npython\\n&quot; #与s1等效。 s3 = &quot;123\\n456\\r789\\r\\nabc&quot; print(s1.splitlines(True)) print(s1.splitlines()) #keepends 默认为False print(s1.splitlines(False)) print(s2.splitlines()) print(s3.splitlines()) #遇到(&quot;\\n&quot; &quot;\\r&quot; &quot;\\r\\n&quot;等)即分隔。 程序运行结果： ['i\\n', 'love\\n', 'python\\n'] ['i', 'love', 'python'] ['i', 'love', 'python'] ['i', 'love', 'python'] ['123', '456', '789', 'abc'] 44.0 join()函数 描述：将iterable变量的每一个元素后增加一个str字符串。 语法： str.join(iterable) -&gt; str 返回字符串 即：返回一个以str作为分隔符，将iterable中的各元素合并连接成一个新的字符串。 str——分隔符。可以为空。 iterable—— 要连接的变量 ，可以是 字符串，元组，字典，列表等。 程序示例： #对列表进行操作 l = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] print(&quot; &quot;.join(l)) #以空格为分隔符 print(&quot;,&quot;.join(l)) #以逗号为分隔符 #对字符串进行操作 str = &quot;python&quot; print(&quot; &quot;.join(str)) #以空格为分隔符 print(&quot;,&quot;.join(str)) #以逗号为分隔符 #对字典进行操作 d = {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} print(&quot; &quot;.join(d)) #以空格为分隔符 print(&quot;,&quot;.join(d)) #以逗号为分隔符 #对元组进行操作 s = (&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) print(&quot; &quot;.join(s)) #以空格为分隔符 print(&quot;,&quot;.join(s)) #以逗号为分隔符 程序运行结果： 1 2 3 1,2,3 p y t h o n p,y,t,h,o,n b c a b,c,a 1 2 3 1,2,3 解决替换问题： 45.0 replace()函数： 描述：返回字符串str的副本，所有old子字符串被替换为new字符串。 语法：str.replace(old, new, count) -&gt; str 返回字符串str的副本 old —— 将被替换的子字符串。 new —— 新子字符串，用于替换old子字符串。 count —— 替换的次数，默认全部替换。 程序示例： s = &quot;i love python python &quot; print(s.replace(&quot;o&quot;,&quot;w&quot;)) #默认字符串中的全部&quot;o&quot; 全部替换为&quot;w&quot; print(s.replace(&quot;o&quot;,&quot;w&quot;,2)) #只替换掉前两个子字符串 &quot;o&quot; print(s.replace(&quot;python&quot;,&quot;c++&quot;)) #子字符串可以是多个字符。 print(s.replace(&quot;python&quot;,&quot;c++&quot;,1)) 程序运行结果： i lwve pythwn pythwn i lwve pythwn python i love c++ c++ i love c++ python ","link":"https://ganhan999.github.io/post/Python字符串函数汇总/"},{"title":"58、最后一个单词的长度","content":"题目 给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。 如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 示例: 输入: &quot;Hello World&quot; 输出: 5 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 我工作效率低的原因完全是因为有和力扣的题干一样语文为负分的产品经理 由于有这种情况发生输入:&quot;a &quot;，输出:1 我们先要把左右测的空格去掉。然后利用rfind函数找到最后一个&quot;&quot;在哪就行了。 #我的做法： class Solution: def lengthOfLastWord(self, s: str) -&gt; int: s=s.strip(&quot; &quot;) if &quot; &quot; in s: if set(s)!={&quot; &quot;}: inde=s.rfind(&quot; &quot;) return len(s)-inde-1 else: return 0 else: return len(s) &quot;&quot;&quot;&quot;&quot;&quot; #大神做法： 为了解决最后一个字符串后面还有空格，倒序查找就行，当没有字符 (len = 0) 时候，遇到空格就直接跳过。从有字符开始，每次不是空格就加 11，此时 len &gt; 0 再次遇到空格，直接 return就是结果。要注意原字符串为全都是空格组成的字符串的情况， 也就是倒序扫描到字符串的开头依旧没更新 len，因此在循环外还需要 return 这种情况 class Solution: def lengthOfLastWord(self, s: str) -&gt; int: length = 0 for i in range(len(s)-1, -1, -1): if length == 0 and s[i] == &quot; &quot;: continue if length != 0 and s[i] == &quot; &quot;: return length if s[i] != &quot; &quot;: length += 1 return length ","link":"https://ganhan999.github.io/post/58、最后一个单词的长度/"},{"title":"今天学到了分治和动态规划的初步过程","content":" 今天学到了分治和动态规划的初步过程，非常的开心，一定要记得多bug。 有些思想其实不难，要多思考就行。 （退了一个枕头，只亏了3元运费，挺好的）😏 ","link":"https://ganhan999.github.io/post/jin-tian-xue-dao-liao-fen-zhi-he-dong-tai-gui-hua-de-chu-bu-guo-cheng/"},{"title":"53、最大子序列","content":"题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 思路分析： 这就是动态规划吗！爱了爱了！ 先一步一步进行，为后一次做好准备。 基本思路就是遍历一遍，用两个变量，一个记录最大的和，一个记录当前的和。时空复杂度貌似还不错...... 如图所示 #我的做法： class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: sum=nums[0] ans=nums[0]#一开始就要给nums[0]，不然如果第一个数是负数就惨了 for i in range(len(nums)-1): num=nums[i+1] if sum&lt;=0: sum=num#小于零，就把前面的都不算 ans=max(sum,ans)#看是之前大还是现在大 else: sum=sum+num ans=max(sum,ans)#看是之前大还是现在大 return ans &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： 最简单的的动态规划！这才是最简单的！ class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: for i in range(1,len(nums)): nums[i] = max(nums[i-1]+nums[i],nums[i])#如果我前面加起来的值是一个正数，那么就继续加。 # 如果不是的话，抱歉我要从头开始了。 return max(nums) #复现成功！ &quot;&quot;&quot;&quot;&quot; 大神做法2： 分治思想 class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) # 递归终止条件 if n == 1: return nums[0] else: # 递归计算左半边最大子序和 max_left = self.maxSubArray(nums[0:len(nums) // 2]) # 递归计算右半边最大子序和 max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)]) # 计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加 # 以下条件是只有n&gt;1才会发生的 #拆分为二叉树的形式，递归求出每一个子树的最大值。 a=nums max_l = nums[len(nums) // 2 - 1] tmp = 0 for i in range(len(nums) // 2 - 1, -1, -1): tmp += nums[i] max_l = max(tmp, max_l) max_r = nums[len(nums) // 2] tmp = 0 for i in range(len(nums) // 2, len(nums)): tmp += nums[i] max_r = max(tmp, max_r) # 返回三个中的最大值 return max(max_right, max_left, max_l + max_r) #复现成功 ","link":"https://ganhan999.github.io/post/53、最大子序列/"},{"title":"38、外观数列","content":"题目 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列：countAndSay(1) = &quot;1&quot; countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1 11 21 1211 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot; 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot; 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot; 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot; 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。 要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 示例 1： 输入：n = 1 输出：&quot;1&quot; 解释：这是一个基本样例。 示例 2： 输入：n = 4 输出：&quot;1211&quot; 解释： countAndSay(1) = &quot;1&quot; countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot; countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot; countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot; &quot;&quot;&quot;&quot;&quot;&quot; 本体思路 利用递归的思想，如果当后一个元素不等于前一个元素停止计数，以此类推。主要是递归的思想要掌握！ #我的做法： class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if target in nums: return nums.index(target) else: nums.append(target) nums.sort(reverse=False) return nums.index(target) &quot;&quot;&quot;&quot;&quot;&quot; 大神做法1： 双指针探测 如图所示 class Solution: def countAndSay(self, n: int) -&gt; str: pre = '' cur = '1'#默认为“1” # 从第 2 项开始 for _ in range(1, n): # 这里注意要将 cur 赋值给 pre # 因为当前项，就是下一项的前一项。有点绕，尝试理解下 pre = cur # 这里 cur 初始化为空，重新拼接 cur = '' # 定义双指针 start，end start = 0 end = 0 # 开始遍历前一项，开始描述 while end &lt; len(pre): # 统计重复元素的次数，出现不同元素时，停止 # 记录出现的次数， while end &lt; len(pre) and pre[start] == pre[end]: end += 1 # 元素出现次数与元素进行拼接 cur += str(end - start) + pre[start] # 这里更新 start，开始记录下一个元素 start = end return cur #复现成功！ &quot;&quot;&quot;&quot;&quot; 大神做法2： 递归和迭代简单算法 #递归 def countAndSay(self, n: int) -&gt; str: if n == 1: return '1' s = self.countAndSay(n - 1) i, res = 0, '' for j, c in enumerate(s): if c != s[i]: res += str(j - i) + s[i]#后面使用 j - i 来统计相同元素的个数，这样最后会剩下最后一堆相同的数字。 i = j res += str(len(s) - i) + s[-1] # 所以最后一个元素莫忘统计 return res #迭代 def countAndSay(self, n: int) -&gt; str: res = '1'#默认为“1” for _ in range(n-1): # 控制循环次数 i, tmp = 0, '' for j, c in enumerate(res): if c != res[i]: tmp += str(j-i) + res[i] i = j res = tmp + str(len(res) - i) + res[-1] return res #复现成功！ &quot;&quot;&quot;&quot;&quot;&quot; Python递归的要点 1、一定要画图 2、在最前面写上递归停止的条件 3、在递归函数后面要写上你相对应的操作，并在最后写上return Python迭代的要点 1、利用while循环将递归变为非递归 递归和迭代的区别： 斐波那契数列的实现 【递归实现】 def fib(x): if x &lt;2: return 0 if x==0 else 1 else: return fib(x - 1) + fib(x - 2) print(fib(6)) 【迭代实现】 def fib(x): n1 = 1 n2 = 1 n3 = 1 while x-2 &gt; 0: n3 = n2 + n1 n1 = n2 n2 = n3 x -= 1 return n3 num = int(input('请输入一个正整数：')) print(fib(num)) ","link":"https://ganhan999.github.io/post/38、外观数列/"},{"title":"Python map() 函数","content":"描述 map() 会根据提供的函数对指定序列做映射。 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 语法 map() 函数语法： map(function, iterable, ...) 参数 function -- 函数 iterable -- 一个或多个序列 返回值 Python 2.x 返回列表。 Python 3.x 返回迭代器。 实例 以下实例展示了 map() 的使用方法： def square(x) : # 计算平方数 ... return x ** 2 ... map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 [1, 4, 9, 16, 25] map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 [1, 4, 9, 16, 25] 提供了两个列表，对相同位置的列表数据进行相加 map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19] ","link":"https://ganhan999.github.io/post/python-map-han-shu/"},{"title":"35、搜索插入位置","content":"题目 &quot;&quot;&quot; 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。 如果目标值不存在于数组中，返回它将会被按顺序插入的位置 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 &quot;&quot;&quot; 本体思路 利用python中index函数便可以直接找到，子字符串的初始位置。 #我的做法： class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if target in nums: return nums.index(target) else: nums.append(target) nums.sort(reverse=False) return nums.index(target) &quot;&quot;&quot; 大神做法1： 因为有序，所以只需要比较比它小的数的最大值 &quot;&quot;&quot; class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: return len([i for i in nums if i &lt; target]) #复现成功！ 大神做法2： 利用切片思想，循环len(haystack) - len(needle) + 1次 &quot;&quot;&quot; class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: low=0 high=len(nums) while(low&lt;high): mid=low+(high-low)//2# “ / ” 为浮点数除法，返回浮点结果 # “ // ” 表示整数除法，返回不大于结果的一个最大整数 if nums[mid] &gt; target: high=mid elif nums[mid]&lt;target: low=mid+1 else: return mid return low #复现成功！ &quot;&quot;&quot; &quot;&quot;&quot; Python如何对列表排序？ Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。 1）排序基础 简单的升序排序是非常容易的。只需要调用sorted()方法。它返回一个新的list，新的list的元素基于小于运算符(lt)来排序。 sorted([5, 2, 3, 1, 4]) [1, 2, 3, 4, 5] 你也可以使用list.sort()方法来排序，此时list本身将被修改。通常此方法不如sorted()方便，但是如果你不需要保留原来的list，此方法将更有效。 a = [5, 2, 3, 1, 4] a.sort() a [1, 2, 3, 4, 5] 另一个不同就是list.sort()方法仅被定义在list中，相反地sorted()方法对所有的可迭代序列都有效。 sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}) [1, 2, 3, 4, 5] 2）key参数/函数 从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写： sorted(&quot;This is a test string from Andrew&quot;.split(), key=str.lower) ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。 更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如： 复制代码 student_tuples = [ ('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10), ] sorted(student_tuples, key=lambda student: student[2]) # sort by age [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] &quot;&quot;&quot; Python如何在列表中增加元素？ append() 追加单个元素到List的尾部，只接受一个参数，参数可以是任何数据类型，被追加的元素在List中保持着原结构类型。 此元素如果是一个list，那么这个list将作为一个整体进行追加，注意append()和extend()的区别。 复制代码代码如下: list1=['a','b'] list1.append('c') list1 ['a', 'b', 'c'] extend() 将一个列表中每个元素分别添加到另一个列表中，只接受一个参数；extend()相当于是将list B 连接到list A上。 复制代码代码如下: list1 ['a', 'b', 'c'] list1.extend('d') list1 ['a', 'b', 'c', 'd'] insert() 将一个元素插入到列表中，但其参数有两个（如insert(1,”g”)），第一个参数是索引点，即插入的位置，第二个参数是插入的元素。 复制代码代码如下: list1 ['a', 'b', 'c', 'd'] list1.insert(1,'x') list1 ['a', 'x', 'b', 'c', 'd'] +加号，将两个list相加，会返回到一个新的list对象，注意与前三种的区别。前面三种方法（append, extend, insert）可对列表增加元素的操作，他们没有返回值，是直接修改了原数据对象。 注意：将两个list相加，需要创建新的list对象，从而需要消耗额外的内存，特别是当list较大时，尽量不要使用“+”来添加list，而应该尽可能使用List的append()方法。 复制代码代码如下: list1 ['a', 'x', 'b', 'c', 'd'] list2=['y','z'] list3=list1+list2 list3 ['a', 'x', 'b', 'c', 'd', 'y', 'z'] &quot;&quot;&quot; ","link":"https://ganhan999.github.io/post/35、搜索插入位置/"},{"title":"11.8杂记","content":"体测起来之后直接废人一个 跪了TAT 今天Python算法书终于到了 舒服的很 opencv库真有点意思 老师讲的也不错 之后就是算法 然后就是狂神 yyds了！ ","link":"https://ganhan999.github.io/post/11.8杂记/"},{"title":"体测结束了","content":"今天又迎来了一年一度的体测，这也是我在大学生涯中最后一次体测，居然1000米又摸鱼了一回。 本来以为不累的，午睡睡一觉还是起不来哈哈哈哈（淦） 今天就要开始学习opencv了，争取早点看完 然后再学python和算法。 之后就是我的开发大法好了！ 兄弟们冲！ 😋 ","link":"https://ganhan999.github.io/post/ti-ce-jie-shu-liao/"},{"title":"28、实现 strStr()","content":"题目 &quot;&quot;&quot; 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 &quot;&quot;&quot; 本体思路 利用python中find函数便可以直接找到，子字符串的初始位置。 #我的做法： class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: lens=len(nums) i=0 if lens==0: return 0 while i&lt;=lens-1: if val in nums: inde=nums.index(val) nums.pop(inde) print() else: i=i+1 return len(nums) &quot;&quot;&quot; 大神做法1： 双指针法：题意可以理解为直接修改前k个数，因此无需删除操作 &quot;&quot;&quot; class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if not needle: return 0 return haystack.find(needle) #复现成功！ 大神做法2： 利用切片思想，循环len(haystack) - len(needle) + 1次 &quot;&quot;&quot; class Solution: def strStr(self, haystack: 'str', needle: 'str') -&gt; 'int': for i in range(0, len(haystack) - len(needle) + 1): if haystack[i:i + len(needle)] == needle: return i return -1 #复现成功！ &quot;&quot;&quot; &quot;&quot;&quot; 下面是find函数的介绍 &quot;&quot;&quot; ","link":"https://ganhan999.github.io/post/28、 实现 strStr()/"},{"title":"27、移除元素","content":"题目 &quot;&quot;&quot; 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 &quot;&quot;&quot; 本体思路 如果val在列表中，那么就使用index函数得到他的位置，然后再进行一个一个的pop，比较简单 #我的做法： class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: lens=len(nums) i=0 if lens==0: return 0 while i&lt;=lens-1: if val in nums: inde=nums.index(val) nums.pop(inde) print() else: i=i+1 return len(nums) &quot;&quot;&quot; 大神做法1： 双指针法：题意可以理解为直接修改前k个数，因此无需删除操作 &quot;&quot;&quot; class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: for i in range(nums.count(val)): nums.remove(val) return len(nums) #复现成功！ 大神做法2： 双指针其实就是两个数，分别代表两个index，表示数组中第几个数的意思。 比如这里，我们让a代表一个index，b代表一个index 然后我们让a一直往后移动，相当于nums[a]从数组第一个数遍历到最后一个数。 当且仅当我们发现nums[a] != val的时候，我们把这个数拷贝到b指向的位置， 默认b是从0开始的，然后b += 1指向下一个位置。 &quot;&quot;&quot; class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: a = 0 b = 0 while a &lt; len(nums): if nums[a] != val: nums[b] = nums[a] b += 1 a += 1 return b #复现成功！ &quot;&quot;&quot; ","link":"https://ganhan999.github.io/post/27、移除元素/"},{"title":"边缘检测算子汇总","content":"边缘检测 边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括：深度上的不连续、表面方向不连续、物质属性变化和场景照明变化。 检测思路 图像的边缘有方向和幅度两种属性。边缘通常可以通过一阶导数或二阶导数检测得到。一阶导数是以最大值作为对应的边缘的位置，而二阶导数则以过零点作为对应边缘的位置。 Roberts 算子 Roberts算子又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。 下面给出Roberts算子的模板，在像素点P5处 x 和 y 方向上的梯度大小gx和gy opencv代码为： # -*- coding: utf-8 -*- import cv2 import numpy as np import matplotlib.pyplot as plt # 读取图像 img = cv2.imread('zxp.jpg') img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB 方便后面显示 # 灰度化处理图像 grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Roberts算子 kernelx = np.array([[-1, 0], [0, 1]], dtype=int) kernely = np.array([[0, -1], [1, 0]], dtype=int) x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx) y = cv2.filter2D(grayImage, cv2.CV_16S, kernely) # 转uint8 absX = cv2.convertScaleAbs(x) absY = cv2.convertScaleAbs(y) Roberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0) # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示图形 # titles = [u'原始图像', u'Roberts算子'] # images = [img_RGB, Roberts] # for i in range(2): # plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray') # plt.title(titles[i]) # plt.xticks([]), plt.yticks([]) # plt.show() # 显示图形 plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭 plt.subplot(122),plt.imshow(Roberts, cmap=plt.cm.gray ),plt.title('Roberts算子'), plt.axis('off') plt.show() 运行结果如下： Prewitt 算子 Prewitt算子是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用3 x 3模板对区域内的像素值进行计算，而Robert算子的模板为2 x 2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像. 其计算公式如下所示： &quot;&quot;&quot; opencv代码为: # -*- coding: utf-8 -*- import cv2 import numpy as np import matplotlib.pyplot as plt # 读取图像 img = cv2.imread('zxp.jpg') img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 灰度化处理图像 grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Prewitt算子 kernelx = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]], dtype=int) kernely = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]], dtype=int) x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx) y = cv2.filter2D(grayImage, cv2.CV_16S, kernely) # 转uint8 absX = cv2.convertScaleAbs(x) absY = cv2.convertScaleAbs(y) Prewitt = cv2.addWeighted(absX, 0.5, absY, 0.5, 0) # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示图形 # titles = [u'原始图像', u'Prewitt算子'] # images = [img_RGB, Prewitt] # for i in range(2): # plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray') # plt.title(titles[i]) # plt.xticks([]), plt.yticks([]) # plt.show() # 显示图形 plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭 plt.subplot(122),plt.imshow(Prewitt, cmap=plt.cm.gray ),plt.title('Prewitt算子'), plt.axis('off') plt.show() 运行结果如下： Sobel 算子 Sobel算子是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。 Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。 Sobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中dx表示水平方向dy表示为垂直方向。 例如，下面给出Sobel算子的模板，在像素点P5处x和y方向上的梯度大小gx和gy分别计算为： opencv代码如下： # -*- coding: utf-8 -*- import cv2 import numpy as np import matplotlib.pyplot as plt # 读取图像 img = cv2.imread('zxp.jpg') img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 灰度化处理图像 grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Sobel算子 x = cv2.Sobel(grayImage, cv2.CV_16S, 1, 0) # 对x求一阶导 y = cv2.Sobel(grayImage, cv2.CV_16S, 0, 1) # 对y求一阶导 absX = cv2.convertScaleAbs(x) absY = cv2.convertScaleAbs(y) Sobel = cv2.addWeighted(absX, 0.5, absY, 0.5, 0) # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['SimHei'] # # 显示图形 # titles = [u'原始图像', u'Sobel算子'] # images = [lenna_img, Sobel] # for i in xrange(2): # plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray') # plt.title(titles[i]) # plt.xticks([]), plt.yticks([]) # plt.show() # 显示图形 plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭 plt.subplot(122),plt.imshow(Sobel, cmap=plt.cm.gray ),plt.title('Sobel算子'), plt.axis('off') plt.show() 运行结果如下: Laplacian 算子 拉普拉斯(Laplacian) 算子是n维欧几里德空间中的一个二阶微分算子，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素。 其中，Laplacian算子四邻域模板如下所示： ​ Laplacian算子的八邻域模板如下所示： ​ 通过Laplacian算子的模板可以发现： 1）当邻域内像素灰度相同时，模板的卷积运算结果为0； 2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数； 3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。 opencv代码如下： # -*- coding: utf-8 -*- import cv2 import numpy as np import matplotlib.pyplot as plt # 读取图像 img = cv2.imread('zxp.jpg') img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 灰度化处理图像 grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 拉普拉斯算法 dst = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=3) Laplacian = cv2.convertScaleAbs(dst) # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['SimHei'] # # 显示图形 # titles = [u'原始图像', u'Laplacian算子'] # images = [lenna_img, Laplacian] # for i in xrange(2): # plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray') # plt.title(titles[i]) # plt.xticks([]), plt.yticks([]) # plt.show() # 显示图形 plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭 plt.subplot(122),plt.imshow(Laplacian, cmap=plt.cm.gray ),plt.title('Laplacian算子'), plt.axis('off') plt.show() 运行结果如下： Canny算子 Canny边缘检测算子是一种多级检测算法。1986年由John F. Canny提出，同时提出了边缘检测的三大准则： 低错误率的边缘检测：检测算法应该精确地找到图像中的尽可能多的边缘，尽可能的减少漏检和误检。 最优定位：检测的边缘点应该精确地定位于边缘的中心。 图像中的任意边缘应该只被标记一次，同时图像噪声不应产生伪边缘。 Canny边缘检测算法的实现较为复杂,主要分为以下步骤： 高斯模糊 计算梯度幅值和方向 非极大值 抑制 滞后阈值 &quot;&quot;&quot; cv2.Canny(image, # 输入原图（必须为单通道图） threshold1, threshold2, # 较大的阈值2用于检测图像中明显的边缘 [, edges[, apertureSize[, # apertureSize：Sobel算子的大小 L2gradient ]]]) # 参数(布尔值)： true： 使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放）， false：使用L1范数（直接将两个方向导数的绝对值相加）。 &quot;&quot;&quot; import cv2 import numpy as np original_img = cv2.imread(&quot;qingwen.png&quot;, 0) # canny(): 边缘检测 img1 = cv2.GaussianBlur(original_img,(3,3),0) canny = cv2.Canny(img1, 50, 150) # 形态学：边缘检测 _,Thr_img = cv2.threshold(original_img,210,255,cv2.THRESH_BINARY)#设定红色通道阈值210（阈值影响梯度运算效果） kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5)) #定义矩形结构元素 gradient = cv2.morphologyEx(Thr_img, cv2.MORPH_GRADIENT, kernel) #梯度 cv2.imshow(&quot;original_img&quot;, original_img) cv2.imshow(&quot;gradient&quot;, gradient) cv2.imshow('Canny', canny) cv2.waitKey(0) cv2.destroyAllWindows() 运行结果如下： LOG 算子 OG （ Laplacian of Gaussian ） 边缘检测算子是 David Courtnay Marr 和 Ellen Hildreth 在 1980 年共同提出的，也称为 Marr &amp; Hildreth 算子，它根据图像的信噪比来求检测边缘的最优滤波器。该算法首先对图像做高斯滤波，然后再求其拉普拉斯（ Laplacian ）二阶导数，根据二阶导数的过零点来检测图像的边界，即通过检测滤波结果的零交叉（ Zero crossings ）来获得图像或物体的边缘。 LOG 算子实际上是把 Gauss 滤波和 Laplacian 滤波结合了起来，先平滑掉噪声，再进行边缘检测。 LOG 算子与视觉生理中的数学模型相似，因此在图像处理领域中得到了广泛的应用。 它具有抗干扰能力强，边界定位精度高，边缘连续性好，能有效提取对比度弱的边界等特点。 常见的 LOG 算子是5 x 5的模板 LOG 算子到中心的距离与位置加权系数的关系曲线像墨西哥草帽的剖面，所以 LOG 算子也叫墨西哥草帽滤波器。 opencv代码如下： import cv2 as cv import matplotlib.pyplot as plt # 读取图像 img = cv.imread(&quot;maliao.jpg&quot;) rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB) gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY) # 先通过高斯滤波降噪 gaussian = cv.GaussianBlur(gray_img, (3, 3), 0) # 再通过拉普拉斯算子做边缘检测 dst = cv.Laplacian(gaussian, cv.CV_16S, ksize=3) LOG = cv.convertScaleAbs(dst) # 用来正常显示中文标签 plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示图形 titles = ['原始图像', 'LOG 算子'] images = [rgb_img, LOG] for i in range(2): plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]), plt.yticks([]) plt.show() 运行结果如下: DOG 算子 DoG算子是高斯函数的差分，具体到图像中，就是将图像在不同参数下的高斯滤波结果相减，得到差分图。DoG算子的表达式如下： 其中 k−1是个常数，不影响极值点的检测，LoG算子和DoG算子的函数波形对比如下图所示，由于高斯差分的计算更加简单，因此可用DoG算子近似替代LoG算子。 ","link":"https://ganhan999.github.io/post/边缘检测算子汇总/"},{"title":"26、删除排序数组中的重复项","content":"题目 &quot;&quot;&quot; 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 &quot;&quot;&quot; 本体思路 因为是有序序列，只需要前一个与后一个比较即可，并不麻烦 #我的做法： class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i=0 if len(nums)==0 or len(nums)==1: return len(nums) else: while(i&lt;len(nums)-1): if nums[i]==nums[i+1]: nums.pop(i) else: i=i+1 return len(nums) &quot;&quot;&quot; 大神做法： 双指针法：题意可以理解为直接修改前k个数，因此无需删除操作 &quot;&quot;&quot; class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: a = 0 b = 1 while b &lt; len(nums): if nums[b] == nums[a]: b += 1 else: a += 1 nums[a] = nums[b] return a+1 #复现成功！ python中关于删除list中的某个元素，一般有三种方法:remove、pop、del： 1.remove: 删除单个元素，删除首个符合条件的元素，按值删除 举例说明: &gt;&gt;&gt; str=[1,2,3,4,5,2,6] &gt;&gt;&gt; str.remove(2) &gt;&gt;&gt; str [1, 3, 4, 5, 2, 6] 2.pop: 删除单个或多个元素，按位删除(根据索引删除) &gt;&gt;&gt; str=[0,1,2,3,4,5,6] &gt;&gt;&gt; str.pop(1) #pop删除时会返回被删除的元素 &gt;&gt;&gt; str [0, 2, 3, 4, 5, 6] &gt;&gt;&gt; str2=['abc','bcd','dce'] &gt;&gt;&gt; str2.pop(2) 'dce' &gt;&gt;&gt; str2 ['abc', 'bcd'] 3.del：它是根据索引(元素所在位置)来删除 举例说明: &gt;&gt;&gt; str=[1,2,3,4,5,2,6] &gt;&gt;&gt; del str[1] &gt;&gt;&gt; str [1, 3, 4, 5, 2, 6] &gt;&gt;&gt; str2=['abc','bcd','dce'] &gt;&gt;&gt; del str2[1] &gt;&gt;&gt; str2 ['abc', 'dce'] 除此之外，del还可以删除指定范围内的值。 &gt;&gt;&gt; str=[0,1,2,3,4,5,6] &gt;&gt;&gt; del str[2:4] #删除从第2个元素开始，到第4个为止的元素(但是不包括尾部元素) &gt;&gt;&gt; str [0, 1, 4, 5, 6] del 也可以删除整个数据对象(列表、集合等) &gt;&gt;&gt; str=[0,1,2,3,4,5,6] &gt;&gt;&gt; del str &gt;&gt;&gt; str #删除后，找不到对象 ","link":"https://ganhan999.github.io/post/26、删除排序数组中的重复项/"},{"title":"21、合并两个有序列表","content":"题目 &quot;&quot;&quot; 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 &quot;&quot;&quot; 本体思路 创建一个新链表，将小的那个值依次填入新链表的next中，直到一个链表为空后，直接将另外一个链表填入新链表的next中。 值得一提的是必须需要建立一个哑节点，不然新链表在执行的时候端点会跑到后面去。 这道题非常类似与归并排序 #我的做法： # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: newlist=ListNode(0)#起始值为0，没有任何意义，下一个next才是开始。 yajiedian = newlist#哑巴节点 while l1 and l2 : if l1.val&lt;=l2.val: newlist.next=l1#可以使用这样更快的方式运行 node.next,l1 = l1,l1.next l1=l1.next else: newlist.next=l2#node.next,l2 = l2,l2.next l2=l2.next newlist=newlist.next if l1: newlist.next=l1 else: newlist.next=l2 return yajiedian.next &quot;&quot;&quot; 大神做法： 利用递归，把最小的那个值取出来赋给L1，然后到最后会有一个链表为空，于是把那个链表直接赋给l1 &quot;&quot;&quot; class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 递归 if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = self.mergeTwoLists(l1.next, l2) return l1 or l2 #复现成功！ python没有指针哪来的链表？ class Node(object): #节点 def __init__(self, val): self.val = val#节点的值 self.next = None#节点的指针（指向下一个Node） 在大神做法中，print出来的链表形式是这样的。 None ListNode{val: 4, next: ListNode{val: 4, next: None}} ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}} ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}} ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}}} ListNode{val: 1, next: ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 4, next: None}}}}}} python链表介绍 #链表的初始化 class Node(object): &quot;&quot;&quot;节点&quot;&quot;&quot; def __init__(self, elem): self.elem = elem self.next = None #链表封装的一系列操作 class SingleLinkList(object): &quot;&quot;&quot;单链表&quot;&quot;&quot; def __init__(self, node=None): self.__head = node def is_empty(self): &quot;&quot;&quot;链表是否为空&quot;&quot;&quot; return self.__head == None def length(self): &quot;&quot;&quot;链表长度&quot;&quot;&quot; # cur游标，用来移动遍历节点 cur = self.__head # count记录数量 count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot; cur = self.__head while cur != None: print(cur.elem, end=&quot; &quot;) cur = cur.next print(&quot;&quot;) def add(self, item): &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot; node = Node(item) node.next = self.__head self.__head = node def append(self, item): &quot;&quot;&quot;链表尾部添加元素, 尾插法&quot;&quot;&quot; node = Node(item) if self.is_empty(): self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def insert(self, pos, item): &quot;&quot;&quot;指定位置添加元素 :param pos 从0开始 &quot;&quot;&quot; if pos &lt;= 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: pre = self.__head count = 0 while count &lt; (pos-1): count += 1 pre = pre.next # 当循环退出后，pre指向pos-1位置 node = Node(item) node.next = pre.next pre.next = node def remove(self, item): &quot;&quot;&quot;删除节点&quot;&quot;&quot; cur = self.__head pre = None while cur != None: if cur.elem == item: # 先判断此结点是否是头节点 # 头节点 if cur == self.__head: self.__head = cur.next else: pre.next = cur.next break else: pre = cur cur = cur.next def search(self, item): &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot; cur = self.__head while cur != None: if cur.elem == item: return True else: cur = cur.next return False ","link":"https://ganhan999.github.io/post/21、合并两个有序链表/"},{"title":"20、有效的括号","content":"题目 &quot;&quot;&quot; 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true &quot;&quot;&quot; 本体思路 这个题显然就要用到栈的知识，如果输入的是一个右边括号，如果他与栈顶的元素不对应时，则返回False，如果对应则弹出， 直到操作结束，判断栈是否为空。 #我的做法： class Solution: def isValid(self, s: str) -&gt; bool: dic={')':'(',']':'[','}':'{'} stack=[] for ele in s: if stack and ele in dic: if dic[ele]==stack[-1]: stack.pop() else:return False else: stack.append(ele) return not stack &quot;&quot;&quot; 大神做法： 对于正确的来说，每次都能去掉一对括号，最后就成了空 &quot;&quot;&quot; class Solution: def isValid(self, s: str) -&gt; bool: while '{}' in s or '()' in s or '[]' in s: s = s.replace('{}', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' #复现成功！ 如何使列表最后一个元素弹出 总结： 以上三种方法未在内存处理上进行测试，唯一区别，pop方法和del方法如果对空列表进行操作，会报错中断执行，切片方法不会因此报错，继续保持空列表向下运行 ","link":"https://ganhan999.github.io/post/20、有效的括号/"},{"title":"科目一心得","content":"心得个鬼，就一直刷一直刷，刷到你能每次模拟考都过90为止！ 气死我了为什么我第一次每次都过不了90！ 明天一定一次过90！😤😤😤 ","link":"https://ganhan999.github.io/post/ke-mu-yi-xin-de/"},{"title":"14、最长公共前缀","content":"题目 &quot;&quot;&quot; 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 &quot;&quot;&quot; 本体思路 首先样例可能有 🌰1、&quot;a&quot;,&quot;b&quot; 🌰2、&quot;a&quot;,&quot;&quot; 🌰3、&quot;ab&quot;,&quot;a&quot; 🌰4、&quot;abbba&quot;,&quot;abbba&quot; 🌰5、&quot;&quot; 这几种特殊情况，首先分析，如果空列表，就直接输出“”,例如🌰5。 其次如果出现🌰2这种情况，那么就要算出最小值如果是0，那么输出“”。 先算出最大可能前缀为a( (min(strs, key=lambda i: len(i)))) ，然后遍历所有列表的元素ele，进行比较。 注意如果出现了🌰4，那么就需要在最后return strs[0][:i+1]。 其他情况下return strs[0][:i]，因为比较完的下一个不是相同前缀。 以后一定要记得先举例子分析！！！！ #我的做法（超级傻逼，遇到了很多困难）： class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs : return '' a = (min(strs, key=lambda i: len(i))) n = len(a) if n==0 : return a for i in range(n): c=strs[0][i] for ele in strs: if ele[i]==c: continue else: break else: continue return strs[0][:i] return strs[0][:i+1] &quot;&quot;&quot; 大神做法： python两种让你拍大腿的解法，时间复杂度你想象不到，短小精悍。 1、利用python的max()和min()，在Python里字符串是可以比较的， 按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。 所以只需要比较最大最小的公共前缀就是整个数组的公共前缀(太妙了！！！） 2、利用python的zip函数，把str看成list然后把输入看成二维数组， 左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素 长度大于1之前的就是公共前缀（天才，灵活运用函数！） &quot;&quot;&quot; class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return &quot;&quot; s1 = min(strs)#利用ASCII码，最大和最小的比就行了。天才！ s2 = max(strs) for i,x in enumerate(s1): if x != s2[i]: return s2[:i] return s1 #复现成功！ class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return &quot;&quot; ss = list(map(set, zip(*strs)))#这里zip(*strs)是一个迭代器，如果list出来则是 # [('a', 'a', 'a'), ('b', 'b', 'b'), ('b', 'a', 'c'), ('a', 'a', 'a')] #相当于二维数组左对齐，然后用set map一下，就变成”a“，”b“，”b，a，c“，”a“。然后算出长度就行了。 res = &quot;&quot; for i, x in enumerate(ss): x = list(x) if len(x) &gt; 1: break res = res + x[0] return res #复现成功！ 如何跳出双重循环？ for i in range(5): for j in range(5): print(i, j) if i == 3 and j == 3: break else: continue break 下面是zip函数的介绍 下面是 enumerate函数介绍 ","link":"https://ganhan999.github.io/post/14、最长公共前缀 /"},{"title":"比特图像分层","content":"常见的256级灰度图片中，每个像素灰度值由8个比特组成，分别将这8个比特分离，形成8幅新的图片，称为比特图像分层。 举个🌰： 有一副四个像素（2*2）的图像，像素值分别为1，2，3，4： 这些值转换为二进制为（扩充为8位）：1（00000001）2（00000010）3（00000011）4（00000100） 则这幅图像的8个比特层图像为： 实例： 读取图片数据： import cv2 import numpy as np import matplotlib.pyplot as plt #更改为需要的图片路径 img = cv2.imread(r'1.png',0) h,w = img.shape[0],img.shape[1] #处理过程 new_img = np.zeros((h,w,8)) for i in range(h): for j in range(w): n = str(np.binary_repr(img[i,j],8)) for k in range(8): new_img[i,j,k] = n[k] #依次显示 for i in range(8): cv2.imshow('image',new_img[:,:,i]) cv2.waitKey(0) 结果如下(比特层数递增，最后一张是原图)： ","link":"https://ganhan999.github.io/post/比特平面分层/"},{"title":"13、罗马数字转整数","content":"题目 &quot;&quot;&quot; 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 &quot;&quot;&quot; 本体思路 这题懂了就非常简单。首先建立一个HashMap来映射符号和值，然后对字符串从左到右来， 如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 以此类推到最左边的数，最终得到的结果即是答案 #我的做法： class Solution: def romanToInt(self, s: str) -&gt; int: a = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,&quot;0&quot;:0} lens = len(s) print('lens=',lens) sum = 0 s=s+&quot;0&quot; print(s) if lens == 1: return sum + a[s[0]] for i in range(lens): if a[s[i]] &lt; a[s[i+1]] : sum = sum - a[s[i]]#前面比后面大 就取负数 else : sum=sum+a[s[i]] return sum &quot;&quot;&quot; 大神做法： if i&lt;lens-1 and a[s[i]] &lt; a[s[i+1]]:#把i&lt;lens-1放前面，可以导致后面的断路！ &quot;&quot;&quot; class Solution: def romanToInt(self, s: str) -&gt; int: a = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} lens = len(s) print('lens=',lens) sum = 0 for i in range(lens): if i&lt;lens-1 and a[s[i]] &lt; a[s[i+1]]:#把i&lt;lens-1放前面，可以导致后面的断路！ sum = sum - a[s[i]] else : sum=sum+a[s[i]] return sum #复现成功！ ","link":"https://ganhan999.github.io/post/13、罗马数字转整数/"},{"title":"9、回文数","content":"题目 &quot;&quot;&quot; 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot;&quot;&quot; &quot;&quot;&quot; #我的做法： class Solution: def isPalindrome(self, x: int) -&gt; bool: x1=x y=0 if x&lt;0: return False while(x!=0): y=y*10+x%10 x=int(x/10) return y==x1#精髓啊！ &quot;&quot;&quot; 大神做法： &quot;&quot;&quot; class Solution: def isPalindrome(self, x: int) -&gt; bool: return str(x) == str(x)[::-1]#str(x)[::-1]是反转数 #复现成功！ ","link":"https://ganhan999.github.io/post/9、回文数/"},{"title":"7、整数反转","content":"题目 &quot;&quot;&quot; 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&quot;&quot;&quot; &quot;&quot;&quot; #我的做法： class Solution1: def reverse(self, x: int) -&gt; int: lis=str(x) lis=list(lis) if lis[0]=='-': lis1=lis[1:] lis1.reverse() lis1=list('-')+lis1 else: lis1=lis[:] lis1.reverse() result =int( &quot;&quot;.join(lis1)) if -2**31&lt;result&lt;2**31-1: return result return 0 &quot;&quot;&quot; #我的做法2 &quot;&quot;&quot; class Solution2: def reverse(self, x: int) -&gt; int: flag=0 y=0 if x&lt;0: flag=1 x=abs(x) while(x!=0): y=y*10+x%10 x=int(x/10) if (-2 ** 31 &lt; y &lt; 2 ** 31 - 1) is False: return 0 return 0-y if flag==1 else y ","link":"https://ganhan999.github.io/post/7、整数反转/"},{"title":"1、两数之和","content":"题目 &quot;&quot;&quot; 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 &quot;&quot;&quot; #我的做法： class Solution: def twoSum(self,nums,target): len1=len(nums) for i in range(len1): j=i+1 for j in range(j,len1): if nums[i]+nums[j]==target: return [i,j] return [0,0] &quot;&quot;&quot; 大神做法： 参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。 个人理解这种办法相较于方法一其实就是字典记录了 num1 和 num2 的值和位置，而省了再查找 num2 索引的步骤。 用枚举的方式，构造哈希表 &quot;&quot;&quot; class Solution: def twoSum(self,nums, target): hashmap={} for i,j in enumerate(nums): hashmap[j]=i for n,m in enumerate(nums): number=hashmap.get(target-m) if number is not None and n!=number: return[n,number] return[0,0] #复现成功！ ","link":"https://ganhan999.github.io/post/1、两数之和/"},{"title":"今天是记录博客的第一天","content":"从今天开始当一个长远打算的人 但是目前我还是没有想好 到底是考公、算法、开发、读博当老师？ 纠结的离谱🤡 ","link":"https://ganhan999.github.io/post/今天是记录博客的第一天/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://ganhan999.github.io/post/hello-gridea/"}]}
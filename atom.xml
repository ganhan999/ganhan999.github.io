<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-04-03T12:57:37.937Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[530、二叉搜索树的最小绝对差]]></title>
        <id>https://ganhan999.github.io/post/530、二叉搜索树的最小绝对差/</id>
        <link href="https://ganhan999.github.io/post/530、二叉搜索树的最小绝对差/">
        </link>
        <updated>2021-04-03T11:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p>输入：</p>
<p>1<br>
<br>
3<br>
/<br>
2</p>
<p>输出：<br>
1</p>
<p>解释：<br>
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>中序遍历 然后记录每一次的最小差值</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">#大神做法1
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getMinimumDifference(self, root: TreeNode) -&gt; int:
        #初始化，最小值赋值为无穷大，last_value记录上一个节点的值
        min_value, last_value = float(&quot;inf&quot;), -1
        def pengding_num(val):
            nonlocal min_value, last_value
            #第一个节点赋值给last_value
            if last_value == -1:
                last_value = val
            else:
                #每次求差的绝对值的最小值，更新
                min_value = min(min_value, abs(val - last_value))
                last_value = val
        #中序遍历
        def mid_order(root):
            nonlocal min_value, last_value
            if root:
                mid_order(root.left)
                #处理当前节点
                pengding_num(root.val)
                mid_order(root.right)
        mid_order(root)
        return min_value
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[521、最长特殊序列 Ⅰ]]></title>
        <id>https://ganhan999.github.io/post/521、最长特殊序列 Ⅰ/</id>
        <link href="https://ganhan999.github.io/post/521、最长特殊序列 Ⅰ/">
        </link>
        <updated>2021-04-03T10:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>
「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br>
子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>
输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p>示例 1：<br>
输入: &quot;aba&quot;, &quot;cdc&quot;<br>
输出: 3<br>
解释: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)，两者均为自身的子序列且不是对方的子序列。</p>
<p>示例 2：<br>
输入：a = &quot;aaa&quot;, b = &quot;bbb&quot;<br>
输出：3</p>
<p>示例 3：<br>
输入：a = &quot;aaa&quot;, b = &quot;aaa&quot;<br>
输出：-1</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>简单来说就是a，b不相等的话就返回a，b最长的长度，否则就-1</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findLUSlength(self, a: str, b: str) -&gt; int:
        return max(len(a),len(b)) if a!=b else -1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[520、检测大写字母]]></title>
        <id>https://ganhan999.github.io/post/520、检测大写字母/</id>
        <link href="https://ganhan999.github.io/post/520、检测大写字母/">
        </link>
        <updated>2021-04-02T10:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个单词，你需要判断单词的大写使用是否正确。</p>
<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>
<p>全部字母都是大写，比如&quot;USA&quot;。<br>
单词中所有字母都不是大写，比如&quot;leetcode&quot;。<br>
如果单词不只含有一个字母，只有首字母大写，比如&quot;Google&quot;。<br>
否则，我们定义这个单词没有正确使用大写字母。</p>
<p>示例 1:<br>
输入: &quot;USA&quot;<br>
输出: True</p>
<p>示例 2:<br>
输入: &quot;FlaG&quot;<br>
输出: False</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>每种情况都判断一遍</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        if word == word.capitalize():
            return True
        elif word == word.upper():
            return True
        elif word == word.lower():
            return True
        else:
            return False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[509、斐波那契数]]></title>
        <id>https://ganhan999.github.io/post/509、斐波那契数/</id>
        <link href="https://ganhan999.github.io/post/509、斐波那契数/">
        </link>
        <updated>2021-04-02T09:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>斐波那契数，通常用F(n) 表示，形成的序列称为 斐波那契数列 。该数列由0 和 1 开始，<br>
后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1)= 1<br>
F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>
给你 n ，请计算 F(n) 。</p>
<p>示例 1：<br>
输入：2<br>
输出：1<br>
解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p>
<p>示例 2：<br>
输入：3<br>
输出：2<br>
解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p>
<p>示例 3：<br>
输入：4<br>
输出：3<br>
解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def fib(self, n: int) -&gt; int:
        if n &lt;= 1:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>动态规划</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def fib(self, n: int) -&gt; int:
        data = [0, 1]
        for i in range(n-1):
            data.append(data[-2] + data[-1])
        return data[n]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>递推+动态规划 节省空间</p>
<h1 id="大神做法2-2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def fib(self, n: int) -&gt; int:
        a, b = 0, 1
        for i in range(n):
            a, b = b, a + b
        return a
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[507、完美数]]></title>
        <id>https://ganhan999.github.io/post/507、完美数/</id>
        <link href="https://ganhan999.github.io/post/507、完美数/">
        </link>
        <updated>2021-04-01T05:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>对于一个正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。</p>
<p>给定一个整数n，如果是完美数，返回 true，否则返回 false</p>
<p>示例 1：<br>
输入：28<br>
输出：True<br>
解释：28 = 1 + 2 + 4 + 7 + 14<br>
1, 2, 4, 7, 和 14 是 28 的所有正因子。</p>
<p>示例 2：<br>
输入：num = 6<br>
输出：true</p>
<p>示例 3：<br>
输入：num = 496<br>
输出：true</p>
<p>示例 4：<br>
输入：num = 8128<br>
输出：true</p>
<p>示例 5：<br>
输入：num = 2<br>
输出：false</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>对于数字1:直接返回False<br>
我们只需要判断2-int(sqrt(num))+1的数，全部累加：判断total == num：</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def checkPerfectNumber(self, num: int) -&gt; bool:
        # 对于数字1:直接返回`False`
        if num == 1:
            return False
        # 计数从1开始
        total = 1
        # 我们只需要判断`2-int(sqrt(num))+1`的数，全部累加
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                # 这里total要加上i和num // i
                total += (i + num // i)
        return total == num
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[506、相对名次]]></title>
        <id>https://ganhan999.github.io/post/506、相对名次/</id>
        <link href="https://ganhan999.github.io/post/506、相对名次/">
        </link>
        <updated>2021-03-31T05:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给出N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。<br>
前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;）。</p>
<p>(注：分数越高的选手，排名越靠前。)</p>
<p>示例 1:<br>
输入: [5, 4, 3, 2, 1]<br>
输出: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]<br>
解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (&quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;).<br>
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>如果直接排序是不行的，因为会丢失老的索引。 因此我用了一个 pairs 数组，<br>
来维护一个 nums -&gt; 索引的映射。之后对 paris 进行降序排列即可。由于我事先保存了老的索引信息，因此是没有问题的。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findRelativeRanks(self, nums: List[int]) -&gt; List[str]:
        pairs = []
        for i in range(len(nums)):
            pairs.append([nums[i], i])
        pairs.sort(key=lambda a: a[0], reverse=True)
        for i in range(len(nums)):
            if i == 0:
                nums[pairs[i][1]] = &quot;Gold Medal&quot;
            if i == 1:
                nums[pairs[i][1]] = &quot;Silver Medal&quot;
            if i == 2:
                nums[pairs[i][1]] = &quot;Bronze Medal&quot;
            if i &gt; 2:
                nums[pairs[i][1]] = str(i + 1)
        return nums
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[504、七进制数]]></title>
        <id>https://ganhan999.github.io/post/504、七进制数/</id>
        <link href="https://ganhan999.github.io/post/504、七进制数/">
        </link>
        <updated>2021-03-31T04:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个整数，将其转化为7进制，并以字符串形式输出。</p>
<p>示例 1:<br>
输入: 100<br>
输出: &quot;202&quot;</p>
<p>示例 2:<br>
输入: -7<br>
输出: &quot;-10&quot;</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def convertToBase7(self, num: int) -&gt; str:
        if num &lt; 0:
            return &quot;-&quot; + self.convertToBase7(-num)
        if num &lt; 7:
            return str(num)
        return self.convertToBase7(num // 7) + str(num % 7)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[501、二叉搜索树中的众数 ]]></title>
        <id>https://ganhan999.github.io/post/501、二叉搜索树中的众数 /</id>
        <link href="https://ganhan999.github.io/post/501、二叉搜索树中的众数 /">
        </link>
        <updated>2021-03-30T04:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>
结点右子树中所含结点的值大于等于当前结点的值<br>
左子树和右子树都是二叉搜索树<br>
例如：<br>
给定 BST [1,null,2,2],</p>
<p>1<br>
<br>
2<br>
/<br>
2<br>
返回[2].</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>中序遍历后再操作</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        ans = []
        base = None
        count = 0
        maxCount = 0

        def update(x):
            nonlocal base, count, maxCount, ans
            if x == base:
                count += 1
            else:
                base = x
                count = 1
            if count == maxCount:
                ans.append(x)
            elif count &gt; maxCount:
                maxCount = count
                ans.clear()
                ans.append(x)

        def midtraverse(node):
            if not node:
                return
            midtraverse(node.left)
            update(node.val)
            midtraverse(node.right)

        midtraverse(root)
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[500、键盘行]]></title>
        <id>https://ganhan999.github.io/post/500、键盘行/</id>
        <link href="https://ganhan999.github.io/post/500、键盘行/">
        </link>
        <updated>2021-03-30T03:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</p>
<p>美式键盘 中：<br>
第一行由字符 &quot;qwertyuiop&quot; 组成。<br>
第二行由字符 &quot;asdfghjkl&quot; 组成。<br>
第三行由字符 &quot;zxcvbnm&quot; 组成。</p>
<p>示例 1：<br>
输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]<br>
输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</p>
<p>示例 2：<br>
输入：words = [&quot;omk&quot;]<br>
输出：[]</p>
<p>示例 3：<br>
输入：words = [&quot;adsdf&quot;,&quot;sfd&quot;]<br>
输出：[&quot;adsdf&quot;,&quot;sfd&quot;]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>1.先将三行键盘分别存储在三个数组中<br>
2.利用两次for循环判断字母是否在对应的数组中，分别设置三个计数器如果在对应的键盘数组则计数器加一<br>
3.分别判断三个计数器的值是否和单词长度一样，如果有一个一样就说明这个单词的字母全部都在某一个键盘数组</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findWords(self, words: List[str]) -&gt; List[str]:
        array_1 = [&quot;q&quot;,&quot;w&quot;,&quot;e&quot;,&quot;r&quot;,&quot;t&quot;,&quot;y&quot;,&quot;u&quot;,&quot;i&quot;,&quot;o&quot;,&quot;p&quot;,&quot;Q&quot;,&quot;W&quot;,&quot;E&quot;,&quot;R&quot;,&quot;T&quot;,&quot;Y&quot;,&quot;U&quot;,&quot;I&quot;,&quot;O&quot;,&quot;P&quot;]
        array_2 = [&quot;A&quot;,&quot;S&quot;,&quot;D&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;a&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;]
        array_3 = [&quot;z&quot;,&quot;x&quot;,&quot;c&quot;,&quot;v&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;,&quot;Z&quot;,&quot;X&quot;,&quot;C&quot;,&quot;V&quot;,&quot;B&quot;,&quot;N&quot;,&quot;M&quot;]

        result = []
        for word in words:
            count_1 = 0
            count_2 = 0
            count_3 = 0
            for letter in word:
                if letter in array_1:
                    count_1 += 1
                if letter in array_2:
                    count_2 += 1
                if letter in array_3:
                    count_3 += 1
            if count_1==len(word) or count_2==len(word) or count_3 == len(word):
                result.append(word)
        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[496、下一个更大元素 I]]></title>
        <id>https://ganhan999.github.io/post/496、下一个更大元素 I/</id>
        <link href="https://ganhan999.github.io/post/496、下一个更大元素 I/">
        </link>
        <updated>2021-03-29T11:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你两个 没有重复元素 的数组nums1 和nums2，其中nums1是nums2的子集。</p>
<p>请你找出 nums1中每个元素在nums2中的下一个比其大的值。</p>
<p>nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1:<br>
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>
输出: [-1,3,-1]<br>
解释:<br>
对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>
对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>
对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>示例 2:<br>
输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>
输出: [3,-1]<br>
解释:<br>
对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>
对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>提示：<br>
1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000<br>
0 &lt;= nums1[i], nums2[i] &lt;= 104<br>
nums1和nums2中所有整数 互不相同<br>
nums1 中的所有整数同样出现在 nums2 中</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>单调栈的应用并不广泛，一般用来解决下一个更大元素的问题。<br>
对于单调栈问题，给定一个乱序的数组nums，返回一个索引数组res，<br>
res中存储着nums中元素对应的下一个更大元素的索引。例如，nums = [1, 3, 4, 2]，<br>
则单调栈算法会返回res = [1, 2, -1, -1]。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        stack = []
        idx_list = [-1] * len(nums2)
        for i in range(len(nums2)-1, -1, -1):
            while stack and nums2[i] &gt;= stack[-1]:
                stack.pop()
            idx_list[i] = -1 if not stack else stack[-1]
            stack.append(nums2[i])
        res = []
        for i in nums1:
            res.append(idx_list[nums2.index(i)])
        return res
</code></pre>
]]></content>
    </entry>
</feed>
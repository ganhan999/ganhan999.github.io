<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-03-26T03:16:13.929Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[459、重复的子字符串]]></title>
        <id>https://ganhan999.github.io/post/459、重复的子字符串/</id>
        <link href="https://ganhan999.github.io/post/459、重复的子字符串/">
        </link>
        <updated>2021-03-25T02:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>
输入: &quot;abab&quot;<br>
输出: True<br>
解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</p>
<p>示例 2:<br>
输入: &quot;aba&quot;<br>
输出: False</p>
<p>示例 3:<br>
输入: &quot;abcabcabcabc&quot;<br>
输出: True<br>
解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>如果s中包含重复的子字符串，那么说明s中至少包含两个子字符串，s+s至少包含4个字串，前后各去掉一位，查找s是否在新构建的字符串中。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        return s in (s+s)[1:-1]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>把两个字符串s拼接在一起，会有以下两种情况：</p>
<p>当s不是循环字符串时：<br>
第一次发现s的起点是在lens（s）</p>
<p>当s是循环字符串时：<br>
第一次发现s的起点是在小于lens（s）</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        return (s+s).find(s,1) != len(s)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[455、分发饼干]]></title>
        <id>https://ganhan999.github.io/post/455、分发饼干/</id>
        <link href="https://ganhan999.github.io/post/455、分发饼干/">
        </link>
        <updated>2021-03-23T02:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j]&gt;= g[i]，<br>
我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例1:<br>
输入: g = [1,2,3], s = [1,1]<br>
输出: 1<br>
解释:<br>
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>
所以你应该输出1。</p>
<p>示例2:<br>
输入: g = [1,2], s = [1,2,3]<br>
输出: 2<br>
解释:<br>
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>
你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>
所以你应该输出2.</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>排序+贪心算法<br>
1、对每个值进行倒序排序<br>
2、保障让每一个饼干刚好满足当前的小朋友，就可以使得最后满足的人数最多。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:
        ##典型的贪心算法：先排序，倒序最好。让最大饼干的满足最贪心的小朋友，如果当前的饼干不能满足当前的小朋友，就找下一个小朋友看是否能满足
        gi = 0 ## g:小朋友的胃口，也就是贪心值
        si = 0 ## s:饼干值
        g.sort(reverse=True) ##倒序输出
        s.sort(reverse=True)
        res = 0
        lens_g = len(g)
        lens_s = len(s)
        while gi&lt;lens_g and si&lt;lens_s:
            if s[si]&gt;=g[gi]:
                res+=1
                si+=1
                gi+=1
            else:
                gi+=1 ##看一下小朋友的胃口是否能满足当前的饼干
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[453、最小操作次数使数组元素相等]]></title>
        <id>https://ganhan999.github.io/post/453、最小操作次数使数组元素相等/</id>
        <link href="https://ganhan999.github.io/post/453、最小操作次数使数组元素相等/">
        </link>
        <updated>2021-03-22T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。</p>
<p>示例：<br>
输入：<br>
[1,2,3]</p>
<p>输出：<br>
3<br>
解释：<br>
只需要3次操作（注意每次操作会增加两个元素的值）：<br>
[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>数学题</p>
<p>假设目前数组总和为sum，我们需要移动次数为m，那么整体数组总和将会增加m * (n - 1)，这里的n为数组长度，最后数组所有元素都相等为x，于是有：<br>
sum + m * (n - 1) = x * n (1)<br>
我们再设数组最小的元素为min_val，m = x - min_val，即 x = m + min_val带入(1)得：<br>
m = sum - min_val * n</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        return sum(nums) - len(nums) * min(nums)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[434、字符串中的单词数]]></title>
        <id>https://ganhan999.github.io/post/434、字符串中的单词数/</id>
        <link href="https://ganhan999.github.io/post/434、字符串中的单词数/">
        </link>
        <updated>2021-03-20T02:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p>示例:<br>
输入: &quot;Hello, my name is John&quot;<br>
输出: 5<br>
解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>内置算法</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def countSegments(self, s):
        return len(s.split())
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，<br>
就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），<br>
且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。<br>
相当于数空格的数量</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def countSegments(self, s):
        segment_count = 0
        for i in range(len(s)):
            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':
                segment_count += 1
        return segment_count
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[415、字符串相加]]></title>
        <id>https://ganhan999.github.io/post/415、字符串相加/</id>
        <link href="https://ganhan999.github.io/post/415、字符串相加/">
        </link>
        <updated>2021-03-19T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个字符串形式的非负整数num1 和num2，计算它们的和。</p>
<p>提示：</p>
<p>num1 和num2的长度都小于 5100<br>
num1 和num2 都只包含数字0-9<br>
num1 和num2 都不包含任何前导零<br>
你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>利用int函数</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        res = &quot;&quot;
        i, j, carry = len(num1) - 1, len(num2) - 1, 0
        while i &gt;= 0 or j &gt;= 0:
            n1 = int(num1[i]) if i &gt;= 0 else 0
            n2 = int(num2[j]) if j &gt;= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res = str(tmp % 10) + res
            i, j = i - 1, j - 1
        return &quot;1&quot; + res if carry else res
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>标准加法进位，主要理解一下ASCII转换。</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        i = len(num1) - 1
        j = len(num2) - 1
        res = &quot;&quot;
        carry = 0
        while i &gt;= 0 or j &gt;= 0:
            n1 = num1[i] if i &gt;= 0 else '0'
            n2 = num2[j] if j &gt;= 0 else '0'
            temp = ord(n1) + ord(n2) - 2 * ord('0') + carry
            cur = temp % 10
            carry = temp // 10
            res = chr(cur + 48) + res
            i -= 1
            j -= 1
        return '1' + res if carry != 0 else res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[414、第三大的数]]></title>
        <id>https://ganhan999.github.io/post/414、第三大的数/</id>
        <link href="https://ganhan999.github.io/post/414、第三大的数/">
        </link>
        <updated>2021-03-18T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</p>
<p>示例 1：<br>
输入：[3, 2, 1]<br>
输出：1<br>
解释：第三大的数是 1 。<br>
示例 2：</p>
<p>输入：[1, 2]<br>
输出：2<br>
解释：第三大的数不存在, 所以返回最大的数 2 。</p>
<p>示例 3：<br>
输入：[2, 2, 3, 1]<br>
输出：1<br>
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。<br>
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>转成字典再转列表再排序</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        nums = sorted(list(set(nums)))
        return nums[-1] if len(nums) &lt;= 2 else nums[-3]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>小顶堆</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        # time O(nlog3) = O(n), space O(n)
        nums = set(nums)
        if len(nums) &lt; 3:
            return max(nums)

        nums = list(nums)

        pq = []
        for n in nums:
            heapq.heappush(pq, n)
            if len(pq) &gt; 3:
                heapq.heappop(pq)

        return pq[0]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>快速排序<br>
最差的可能性， time O(n^2), space O(n)<br>
加入随机变量后, time O(n), space O(logn)<br>
一种减而治之的思想。搜索区域中是否匹配到k-1（topk的索引）<br>
partition 可以灵活应变，前面大后面小，或者前面小后面大。</p>
<h1 id="大神做法3">大神做法3：</h1>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        # time O(nlog3) = O(n), space O(n)
        nums = set(nums)
        if len(nums) &lt; 3:
            return max(nums)

        nums = list(nums)

        pq = []
        for n in nums:
            heapq.heappush(pq, n)
            if len(pq) &gt; 3:
                heapq.heappop(pq)
        return pq[0]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[412、Fizz Buzz]]></title>
        <id>https://ganhan999.github.io/post/412、Fizz Buzz/</id>
        <link href="https://ganhan999.github.io/post/412、Fizz Buzz/">
        </link>
        <updated>2021-03-17T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p>
<ol>
<li>
<p>如果n是3的倍数，输出“Fizz”；</p>
</li>
<li>
<p>如果n是5的倍数，输出“Buzz”；</p>
</li>
</ol>
<p>3.如果n同时是3和5的倍数，输出 “FizzBuzz”。</p>
<p>示例：</p>
<p>n = 15,</p>
<p>返回:<br>
[<br>
&quot;1&quot;,<br>
&quot;2&quot;,<br>
&quot;Fizz&quot;,<br>
&quot;4&quot;,<br>
&quot;Buzz&quot;,<br>
&quot;Fizz&quot;,<br>
&quot;7&quot;,<br>
&quot;8&quot;,<br>
&quot;Fizz&quot;,<br>
&quot;Buzz&quot;,<br>
&quot;11&quot;,<br>
&quot;Fizz&quot;,<br>
&quot;13&quot;,<br>
&quot;14&quot;,<br>
&quot;FizzBuzz&quot;<br>
]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>初始化一个空的答案列表。<br>
遍历 1 ... N1...N。<br>
对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。<br>
如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。<br>
如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。<br>
如果以上都不行，把这个数加入答案列表。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        ans=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:ans.append('FizzBuzz')
            elif i%3==0:ans.append('Fizz')
            elif i%5==0:ans.append('Buzz')
            else:ans.append(str(i))
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[409、最长回文串]]></title>
        <id>https://ganhan999.github.io/post/409、最长回文串/</id>
        <link href="https://ganhan999.github.io/post/409、最长回文串/">
        </link>
        <updated>2021-03-17T09:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>
在构造过程中，请注意区分大小写。比如&quot;Aa&quot;不能当做一个回文字符串。</p>
<p>注意:<br>
假设字符串的长度不会超过 1010。</p>
<p>示例 1:<br>
输入:<br>
&quot;abccccdd&quot;</p>
<p>输出:<br>
7</p>
<p>解释:<br>
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>1.统计各字符次数，eg:&quot;ddsad&quot;:[3, 1, 1]<br>
2.统计两两配对的字符总个数，eg: {&quot;ddass&quot;:4,&quot;ddsss&quot;:4}<br>
3.判断是否有没配对的单字符，有结果加一。 eg: {&quot;ddss&quot;:4, &quot;ddhjSS&quot;:4+1}--&gt;{&quot;ddss&quot;:4, &quot;ddhjSS&quot;:5}</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[405、数字转换为十六进制数]]></title>
        <id>https://ganhan999.github.io/post/405、数字转换为十六进制数/</id>
        <link href="https://ganhan999.github.io/post/405、数字转换为十六进制数/">
        </link>
        <updated>2021-03-16T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用补码运算方法。</p>
<p>注意:<br>
十六进制中所有字母(a-f)都必须是小写。<br>
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。<br>
给定的数确保在32位有符号整数范围内。<br>
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</p>
<p>示例 1：<br>
输入:<br>
26<br>
输出:<br>
&quot;1a&quot;</p>
<p>示例 2：<br>
输入:<br>
-1<br>
输出:<br>
&quot;ffffffff&quot;</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>1、当正数时，直接循环右移4位（除以16也可以），直到商为0，再依次将余数字符串起来，逆序排列。<br>
2、当0时，直接返回0。<br>
3、当负数时，将其绝对值通过与（2的32次方减1）异或再加1，转化为对应的十进制正数，然后执第一步的操作。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def toHex(self, num: int) -&gt; str:
        stra = ''
        if num &lt; 0:
            num = (abs(num) ^ ((2 ** 32) - 1)) + 1
        elif num == 0:
            return '0'
        while (num &gt;&gt; 4) &gt; 0 or num &gt; 0:
            a = str(num &amp; 0xf)
            if a == '10': a = 'a'
            elif a == '11': a = 'b'
            elif a == '12': a = 'c'
            elif a == '13': a = 'd'
            elif a == '14': a = 'e'
            elif a == '15': a = 'f'
            stra += a
            num = num &gt;&gt; 4
        return ''.join(reversed(stra))
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>核心思想，使用位运算，每4位，对应1位16进制数字。</p>
<p>使用0xf(00...01111b)获取num的低4位。<br>
算数位移，其中正数右移左边补0，负数右移左边补1。</p>
<p>位移运算并不能保证num==0，需要使用32位int保证（对应16进制小于等于8位).大神做法1：</p>
<pre><code class="language-python">class Solution:
    def toHex(self, num: int) -&gt; str:
        if num==0:
            return &quot;0&quot;
        hex, ans = &quot;0123456789abcdef&quot;,  &quot;&quot;
        while num and len(ans) &lt; 8:
            ans = hex[num &amp; 0xf] + ans
            num &gt;&gt;=  4
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[404、左叶子之和]]></title>
        <id>https://ganhan999.github.io/post/404、左叶子之和/</id>
        <link href="https://ganhan999.github.io/post/404、左叶子之和/">
        </link>
        <updated>2021-03-15T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归 DFS</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:

        def dfs(root, flag=False):  # 初始化flag = False
            if not root: return 0  # 先判断root是否为None，否则下面的判断语句会报错
            if not root.right and not root.left and flag:  # 前两个条件保证是否是叶子节点，flag保证是否是左孩子
                return root.val  # 如果是左叶子结点就加上其值
            return dfs(root.right, False) + dfs(root.left, True)  # 递归root的左孩子并让flag = True, 右孩子flag = False

        return dfs(root)  # 返回结果
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>BFS 广度优先遍历  也是放一个标志位表示左节点</p>
<h1 id="大神做法1-2">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        def dfs(root, flag=False):  # 初始化flag = False
            if not root: return 0  # 先判断root是否为None，否则下面的判断语句会报错
            if not root.right and not root.left and flag:  # 前两个条件保证是否是叶子节点，flag保证是否是左孩子
                return root.val  # 如果是左叶子结点就加上其值
            return dfs(root.right, False) + dfs(root.left, True)  # 递归root的左孩子并让flag = True, 右孩子flag = False
        return dfs(root)  # 返回结果

</code></pre>
]]></content>
    </entry>
</feed>
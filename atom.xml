<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-04-16T11:43:58.222Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[628、三个数的最大乘积]]></title>
        <id>https://ganhan999.github.io/post/637、二叉树的层平均值/</id>
        <link href="https://ganhan999.github.io/post/637、二叉树的层平均值/">
        </link>
        <updated>2021-04-16T11:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<p>示例 1：<br>
输入：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
输出：[3, 14.5, 11]<br>
解释：<br>
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，counts 用于存储二叉树的每一层的节点数，<br>
totals 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 i 层，<br>
则将counts[i] 的值加 1，并将该节点的值加到 totals[i]。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        def dfs(root: TreeNode, level: int):
            if not root:
                return
            if level &lt; len(totals):
                totals[level] += root.val
                counts[level] += 1
            else:
                totals.append(root.val)
                counts.append(1)
            dfs(root.left, level + 1)
            dfs(root.right, level + 1)

        counts = list()
        totals = list()
        dfs(root, 0)
        return [total / count for total, count in zip(totals, counts)]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>使用广度优先搜索计算二叉树的层平均值。从根节点开始搜索，每一轮遍历同一层的全部节点，<br>
计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        averages = list()
        queue = collections.deque([root])
        while queue:
            total = 0
            size = len(queue)
            for _ in range(size):
                node = queue.popleft()
                total += node.val
                left, right = node.left, node.right
                if left:
                    queue.append(left)
                if right:
                    queue.append(right)
            averages.append(total / size)
        return averages
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java内存分析 转载]]></title>
        <id>https://ganhan999.github.io/post/Java内存分析/</id>
        <link href="https://ganhan999.github.io/post/Java内存分析/">
        </link>
        <updated>2021-04-16T02:18:25.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章将简单的说明下当我们运行Java程序时JVM（Java虚拟机）的内存分配情况。</p>
<p>首先我们先来感观的认识下几个名词：</p>
<ul>
<li>**栈：**一般来说，基本数据类型直接在栈中分配空间，局部变量（在方法代码段中定义的变量）也在栈中直接分配空间，当局部变量所在方法执行完成之后该空间便立刻被JVM回收，还有一种是引用数据类型，即我们通常所说的需要用关键字new创建出来的对象所对应的引用也是在栈空间中，此时，JVM在栈空间中给对象引用分配了一个地址空间（相当于一个门牌号，通过这个门牌号就可以找到你家），在堆空间中给该引用的对象分配一个空间，栈空间中的地址引用指向了堆空间中的对象区（通过门牌号找住址）；</li>
<li>**堆：**一般用来存放用关键字new出来的数据。</li>
</ul>
<p>接下来我们再通过一段程序来直观感受下程序运行时JVM的内存情况，</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0)😉</p>
<pre><code> 1 package demo;
 2 
 3 public class Student {
 4     private String name;
 5     private int age;
 6 
 7     public void study() {
 8         System.out.println(&quot;I love study!&quot;);
 9     }
10 
11     public String getName() {
12         return name;
13     }
14 
15     public void setName(String name) {
16         this.name = name;
17     }
18 
19     public int getAge() {
20         return age;
21     }
22 
23     public void setAge(int age) {
24         this.age = age;
25     }
26 }
</code></pre>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0)😉</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0)😉</p>
<pre><code> 1 package demo;
 2 
 3 public class StudentDemo {
 4     public static void main(String[] args) {
 5         Student student = new Student();
 6 
 7         System.out.println(student.getName() + &quot;:&quot; + student.getAge());
 8         student.setName(&quot;John&quot;);
 9         student.setAge(23);
10         System.out.println(student.getName() + &quot;:&quot; + student.getAge());
11         
12         student.study();
13         
14         Student student2 = student;
15         student2.setName(&quot;Jack&quot;);
16         student2.setAge(25);
17         System.out.println(student2.getName() + &quot;:&quot; + student2.getAge());
18         System.out.println(student.getName() + &quot;:&quot; + student.getAge());
19     }
20 }
</code></pre>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0)😉</p>
<p>当我们运行程序时，JVM会把Student类与StudentDemo类编译完然后加载到JVM中一个叫<strong>方法区</strong>的地方，类的成员变量与成员方法也被加载到方法区中，此时内存模型如下</p>
<figure data-type="image" tabindex="1"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003105022942-1624159483.png" alt="img" loading="lazy"></figure>
<p>可以看到study方法右边各有一个16进制的标记，而name与age变量没有，这是因为每个对象都有各自的成员变量，而类中的成员方法却可以被每个对象所共用，为了节省内存空间，JVM为方法分配了该标记（也叫内存地址）便于每个new出来的对象查找调用，接着JVM会自动寻找main方法，在栈中为main方法申请一个空间，这个过程也叫入栈，然后执行我们Student类中第5行代码</p>
<figure data-type="image" tabindex="2"><img src="https://images2015.cnblogs.com/blog/1023471/201706/1023471-20170628153219774-236253981.png" alt="img" loading="lazy"></figure>
<p>这时候，JVM在堆空间中分配一块内存给Student对象，并为其分配一个内存地址（如果对象的成员变量没有赋值，则JVM会为变量赋初始值），在栈中分配一块内存空间用于指向堆空间中的Student对象区的内存地址，此时内存模型如下</p>
<figure data-type="image" tabindex="3"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003105825942-1129813995.png" alt="img" loading="lazy"></figure>
<p>接着看代码第8行与第9行</p>
<figure data-type="image" tabindex="4"><img src="https://images2015.cnblogs.com/blog/1023471/201706/1023471-20170628152809383-1580114598.png" alt="img" loading="lazy"></figure>
<p>程序为student对象的成员变量赋值，JVM会根据student所指向的地址在堆内存中寻找Student类的变量，并为变量赋新的值</p>
<figure data-type="image" tabindex="5"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003110601582-847575839.png" alt="img" loading="lazy"></figure>
<p>第12行</p>
<figure data-type="image" tabindex="6"><img src="https://images2015.cnblogs.com/blog/1023471/201706/1023471-20170628153013664-299357383.png" alt="img" loading="lazy"></figure>
<p>这时student对象调用study方法，JVM在栈空间中为study方法申请了一块内存空间</p>
<figure data-type="image" tabindex="7"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003111014707-298237402.png" alt="img" loading="lazy"></figure>
<p>study方法执行完后，立即释放栈空间，代码第14行，</p>
<figure data-type="image" tabindex="8"><img src="https://images2015.cnblogs.com/blog/1023471/201706/1023471-20170628153044071-1135286478.png" alt="img" loading="lazy"></figure>
<p>student2对象的引用指向了student所指向的地址</p>
<figure data-type="image" tabindex="9"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003132857082-1194767868.png" alt="img" loading="lazy"></figure>
<p>代码15与16行</p>
<figure data-type="image" tabindex="10"><img src="https://images2015.cnblogs.com/blog/1023471/201706/1023471-20170628153131133-2077229308.png" alt="img" loading="lazy"></figure>
<p>为student2的变量赋值，由于student2与student指向了同一个地方，所以这时student对象中变量的值也被改变</p>
<figure data-type="image" tabindex="11"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003133148551-1299541357.png" alt="img" loading="lazy"></figure>
<p>到这，main方法中所有代码执行完毕，main方法所占用的栈空间也被回收，而堆空间等待GC回收</p>
<figure data-type="image" tabindex="12"><img src="https://images2015.cnblogs.com/blog/1023471/201610/1023471-20161003111448192-1689689689.png" alt="img" loading="lazy"></figure>
<p>代码执行结果如下：</p>
<pre><code>null:0
John:23
I love study!
Jack:25
Jack:25
</code></pre>
<p>写的较为简单，仅作为知识记录，欢迎指正！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[628、三个数的最大乘积]]></title>
        <id>https://ganhan999.github.io/post/628、三个数的最大乘积/</id>
        <link href="https://ganhan999.github.io/post/628、三个数的最大乘积/">
        </link>
        <updated>2021-04-15T10:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p>示例 1：<br>
输入：nums = [1,2,3]<br>
输出：6</p>
<p>示例 2：<br>
输入：nums = [1,2,3,4]<br>
输出：24</p>
<p>示例 3：<br>
输入：nums = [-1,-2,-3]<br>
输出：-6</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>首先将数组排序。<br>
如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。<br>
如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。<br>
综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def maximumProduct1(self, nums: List[int]) -&gt; int:
        nums.sort()
        a = nums[-1] * nums[-2] * nums[-3]
        b = nums[0] * nums[1] * nums[-1]
        return max(a, b)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[617、合并二叉树]]></title>
        <id>https://ganhan999.github.io/post/617、合并二叉树/</id>
        <link href="https://ganhan999.github.io/post/617、合并二叉树/">
        </link>
        <updated>2021-04-14T10:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例1:</p>
<p>输入:<br>
Tree 1                     Tree 2<br>
1                         2<br>
/ \                       / \<br>
3   2                   1   3<br>
/                           \   \<br>
5                             4   7<br>
输出:<br>
合并后的树:<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
5   4   7</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode:
        if not t1:
            return t2
        if not t2:
            return t1
        merged = TreeNode(t1.val + t2.val)
        merged.left = self.mergeTrees(t1.left, t2.left)
        merged.right = self.mergeTrees(t1.right, t2.right)
        return merged
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[606、根据二叉树创建字符串]]></title>
        <id>https://ganhan999.github.io/post/606、根据二叉树创建字符串/</id>
        <link href="https://ganhan999.github.io/post/606、根据二叉树创建字符串/">
        </link>
        <updated>2021-04-14T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。<br>
空节点则用一对空括号 &quot;()&quot; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例 1:<br>
输入: 二叉树: [1,2,3,4]<br>
1<br>
/   <br>
2     3<br>
/<br>
4</p>
<p>输出: &quot;1(2(4))(3)&quot;</p>
<p>解释: 原本将是“1(2(4)())(3())”，<br>
在你省略所有不必要的空括号对之后，<br>
它将是“1(2(4))(3)”。</p>
<p>示例 2:<br>
输入: 二叉树: [1,2,3,null,4]<br>
1<br>
/   <br>
2     3<br>
<br>
4</p>
<p>输出: &quot;1(2()(4))(3)&quot;<br>
解释: 和第一个示例相似，<br>
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        def func(node):
            if not node:
                return '()'
            l = func(node.left)
            r = func(node.right)
            if l == r == '()':
                return '(' + str(node.val) + ')'
            elif l != '()' and r == '()':
                return '(' + str(node.val) + l + ')'
            else:
                return '(' + str(node.val) + l + r + ')'

        return func(t)[1:-1]#去除第一个和最后一个括号
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[605、种花问题]]></title>
        <id>https://ganhan999.github.io/post/605、种花问题/</id>
        <link href="https://ganhan999.github.io/post/605、种花问题/">
        </link>
        <updated>2021-04-13T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数n ，能否在不打破种植规则的情况下种入n朵花？能则返回 true ，不能则返回 false。</p>
<p>示例 1：<br>
输入：flowerbed = [1,0,0,0,1], n = 1<br>
输出：true<br>
示例 2：</p>
<p>输入：flowerbed = [1,0,0,0,1], n = 2<br>
输出：false</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>连续三个0则可以种一盆花</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:
        flowerbed = [0] + flowerbed#前后都补0
        flowerbed = flowerbed + [0]#前后都补0
        for i in range(1, len(flowerbed) - 1):
            if flowerbed[i - 1] == 0 and flowerbed[i] == 0 and flowerbed[i + 1] == 0:
                n = n - 1
                flowerbed[i] = 1
        return n &lt;= 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[599、两个列表的最小索引总和]]></title>
        <id>https://ganhan999.github.io/post/599、两个列表的最小索引总和/</id>
        <link href="https://ganhan999.github.io/post/599、两个列表的最小索引总和/">
        </link>
        <updated>2021-04-12T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。<br>
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p>
<p>示例 1:<br>
输入:<br>
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>
[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]<br>
输出: [&quot;Shogun&quot;]<br>
解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p>
<p>示例 2:<br>
输入:<br>
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>
[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]<br>
输出: [&quot;Shogun&quot;]<br>
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>步骤：<br>
1、求两者交集<br>
2、第一次遍历，找到索引最小的<br>
3、第二次遍历，把索引最小对应餐厅加入结果中</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]:
        l1=set(list1)
        l2=set(list2)
        l12=l1&amp;l2
        res=[]
        tmp=float('inf')
        for i in l12:
            tmp=min(tmp,list1.index(i)+list2.index(i))
        for i in l12:
            if list1.index(i)+list2.index(i)==tmp:
                res.append(i)
        return res

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[598、范围求和 II]]></title>
        <id>https://ganhan999.github.io/post/598、范围求和 II/</id>
        <link href="https://ganhan999.github.io/post/598、范围求和 II/">
        </link>
        <updated>2021-04-11T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个初始元素全部为0，大小为 m*n 的矩阵M以及在M上的一系列更新操作。</p>
<p>操作用二维数组表示，其中的每个操作用一个含有两个正整数a 和 b 的数组表示，含义是将所有符合0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素M[i][j]的值都增加 1。</p>
<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<p>示例 1:</p>
<p>输入:<br>
m = 3, n = 3<br>
operations = [[2,2],[3,3]]<br>
输出: 4<br>
解释:<br>
初始状态, M =<br>
[[0, 0, 0],<br>
[0, 0, 0],<br>
[0, 0, 0]]</p>
<p>执行完操作 [2,2] 后, M =<br>
[[1, 1, 0],<br>
[1, 1, 0],<br>
[0, 0, 0]]</p>
<p>执行完操作 [3,3] 后, M =<br>
[[2, 2, 1],<br>
[2, 2, 1],<br>
[1, 1, 1]]<br>
M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>短板效应</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -&gt; int:
        if not ops:
            return m*n
        a = min(map(lambda x: x[0], ops))
        b = min(map(lambda x: x[1], ops))
        return a*b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[594、最长和谐子序列]]></title>
        <id>https://ganhan999.github.io/post/594、最长和谐子序列/</id>
        <link href="https://ganhan999.github.io/post/594、最长和谐子序列/">
        </link>
        <updated>2021-04-10T04:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p>
<p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>
<p>示例 1：<br>
输入：nums = [1,3,2,2,5,2,3,7]<br>
输出：5<br>
解释：最长的和谐子序列是 [3,2,2,2,3]</p>
<p>示例 2：<br>
输入：nums = [1,2,3,4]<br>
输出：2</p>
<p>示例 3：<br>
输入：nums = [1,1,1,1]<br>
输出：0</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>利用哈希表存储数组中元素出现的次数<br>
遍历哈希表，如果当前元素+1也在哈希表中，那么计算两者次数之和，保留最大值</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findLHS(self, nums: List[int]) -&gt; int:
        dicts={}
        for i in nums:
            dicts[i]=dicts.get(i,0)+1
        res=0
        for i in dicts:
            if i+1 in dicts:
                res=max(res,dicts[i]+dicts[i+1])
        return res
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>首先将原数组排序，得到递增数组；<br>
然后遍历一遍数组，利用双指针实现类似滑动窗口的功能</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def findLHS(self, nums: List[int]) -&gt; int:
        nums.sort()
        left=0
        res=0
        for right in range(len(nums)):
            while nums[right]-nums[left]&gt;1:
                left+=1
            if nums[right]-nums[left]==1:
                res=max(res,right-left+1)
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[590、N 叉树的后序遍历]]></title>
        <id>https://ganhan999.github.io/post/590、N 叉树的后序遍历/</id>
        <link href="https://ganhan999.github.io/post/590、N 叉树的后序遍历/">
        </link>
        <updated>2021-04-09T12:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个 N 叉树，返回其节点值的 后序遍历 。<br>
N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
<p>进阶：<br>
递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>示例 1：<br>
输入：root = [1,null,3,2,4,null,5,6]<br>
输出：[5,6,3,2,4,1]</p>
<p>示例 2：<br>
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>
输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def preorder(self, root: 'Node') -&gt; List[int]:
        #保存节点值
        result = []
        #后序遍历
        def pre_order(root):
            #跟节点非空入队列递归遍历
            if root:
                #递归遍历
                for node in root.children:
                    pre_order(node)
                #节点值入队列
                result.append(root.val)
        pre_order(root)
        return result
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>迭代</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def postorder(self, root: 'Node') -&gt; List[int]:
        if not root:
            return []
        res = []
        stack = []
        stack.append(root)
        while stack:
            node = stack.pop()
            res.append(node.val)
            stack.extend(node.children)
        return res[::-1]
</code></pre>
]]></content>
    </entry>
</feed>
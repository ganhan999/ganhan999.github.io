<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-03-30T03:19:10.034Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[501、二叉搜索树中的众数 ]]></title>
        <id>https://ganhan999.github.io/post/501、二叉搜索树中的众数 /</id>
        <link href="https://ganhan999.github.io/post/501、二叉搜索树中的众数 /">
        </link>
        <updated>2021-03-30T04:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>
结点右子树中所含结点的值大于等于当前结点的值<br>
左子树和右子树都是二叉搜索树<br>
例如：<br>
给定 BST [1,null,2,2],</p>
<p>1<br>
<br>
2<br>
/<br>
2<br>
返回[2].</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>中序遍历后再操作</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        ans = []
        base = None
        count = 0
        maxCount = 0

        def update(x):
            nonlocal base, count, maxCount, ans
            if x == base:
                count += 1
            else:
                base = x
                count = 1
            if count == maxCount:
                ans.append(x)
            elif count &gt; maxCount:
                maxCount = count
                ans.clear()
                ans.append(x)

        def midtraverse(node):
            if not node:
                return
            midtraverse(node.left)
            update(node.val)
            midtraverse(node.right)

        midtraverse(root)
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[500、键盘行]]></title>
        <id>https://ganhan999.github.io/post/500、键盘行/</id>
        <link href="https://ganhan999.github.io/post/500、键盘行/">
        </link>
        <updated>2021-03-30T03:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</p>
<p>美式键盘 中：<br>
第一行由字符 &quot;qwertyuiop&quot; 组成。<br>
第二行由字符 &quot;asdfghjkl&quot; 组成。<br>
第三行由字符 &quot;zxcvbnm&quot; 组成。</p>
<p>示例 1：<br>
输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]<br>
输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</p>
<p>示例 2：<br>
输入：words = [&quot;omk&quot;]<br>
输出：[]</p>
<p>示例 3：<br>
输入：words = [&quot;adsdf&quot;,&quot;sfd&quot;]<br>
输出：[&quot;adsdf&quot;,&quot;sfd&quot;]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>1.先将三行键盘分别存储在三个数组中<br>
2.利用两次for循环判断字母是否在对应的数组中，分别设置三个计数器如果在对应的键盘数组则计数器加一<br>
3.分别判断三个计数器的值是否和单词长度一样，如果有一个一样就说明这个单词的字母全部都在某一个键盘数组</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findWords(self, words: List[str]) -&gt; List[str]:
        array_1 = [&quot;q&quot;,&quot;w&quot;,&quot;e&quot;,&quot;r&quot;,&quot;t&quot;,&quot;y&quot;,&quot;u&quot;,&quot;i&quot;,&quot;o&quot;,&quot;p&quot;,&quot;Q&quot;,&quot;W&quot;,&quot;E&quot;,&quot;R&quot;,&quot;T&quot;,&quot;Y&quot;,&quot;U&quot;,&quot;I&quot;,&quot;O&quot;,&quot;P&quot;]
        array_2 = [&quot;A&quot;,&quot;S&quot;,&quot;D&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;a&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;]
        array_3 = [&quot;z&quot;,&quot;x&quot;,&quot;c&quot;,&quot;v&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;,&quot;Z&quot;,&quot;X&quot;,&quot;C&quot;,&quot;V&quot;,&quot;B&quot;,&quot;N&quot;,&quot;M&quot;]

        result = []
        for word in words:
            count_1 = 0
            count_2 = 0
            count_3 = 0
            for letter in word:
                if letter in array_1:
                    count_1 += 1
                if letter in array_2:
                    count_2 += 1
                if letter in array_3:
                    count_3 += 1
            if count_1==len(word) or count_2==len(word) or count_3 == len(word):
                result.append(word)
        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[496、下一个更大元素 I]]></title>
        <id>https://ganhan999.github.io/post/496、下一个更大元素 I/</id>
        <link href="https://ganhan999.github.io/post/496、下一个更大元素 I/">
        </link>
        <updated>2021-03-29T11:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你两个 没有重复元素 的数组nums1 和nums2，其中nums1是nums2的子集。</p>
<p>请你找出 nums1中每个元素在nums2中的下一个比其大的值。</p>
<p>nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1:<br>
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>
输出: [-1,3,-1]<br>
解释:<br>
对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>
对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>
对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>示例 2:<br>
输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>
输出: [3,-1]<br>
解释:<br>
对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>
对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>提示：<br>
1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000<br>
0 &lt;= nums1[i], nums2[i] &lt;= 104<br>
nums1和nums2中所有整数 互不相同<br>
nums1 中的所有整数同样出现在 nums2 中</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>单调栈的应用并不广泛，一般用来解决下一个更大元素的问题。<br>
对于单调栈问题，给定一个乱序的数组nums，返回一个索引数组res，<br>
res中存储着nums中元素对应的下一个更大元素的索引。例如，nums = [1, 3, 4, 2]，<br>
则单调栈算法会返回res = [1, 2, -1, -1]。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        stack = []
        idx_list = [-1] * len(nums2)
        for i in range(len(nums2)-1, -1, -1):
            while stack and nums2[i] &gt;= stack[-1]:
                stack.pop()
            idx_list[i] = -1 if not stack else stack[-1]
            stack.append(nums2[i])
        res = []
        for i in nums1:
            res.append(idx_list[nums2.index(i)])
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[492、构造矩形]]></title>
        <id>https://ganhan999.github.io/post/492、构造矩形/</id>
        <link href="https://ganhan999.github.io/post/492、构造矩形/">
        </link>
        <updated>2021-03-29T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，<br>
你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。</p>
<p>要求：</p>
<ol>
<li>
<p>你设计的矩形页面必须等于给定的目标面积。</p>
</li>
<li>
<p>宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</p>
</li>
<li>
<p>长度 L 和宽度 W 之间的差距应当尽可能小。<br>
你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p>
</li>
</ol>
<p>示例：<br>
输入: 4<br>
输出: [2, 2]<br>
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。<br>
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>从中间的数开始找</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def constructRectangle(self, area: int) -&gt; List[int]:
    # 思路:先找到中间值，循环中间值 挨个找就ok
    # 其实还可以先把素数和平方数找出来，然后再找剩下的。
        two = area ** 0.5
        one = int(two)
        for i in range(one,0,-1):
            re = area/i
            if re % 1 == 0.0:
                return int(re),i
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[482、密钥格式化]]></title>
        <id>https://ganhan999.github.io/post/482、密钥格式化/</id>
        <link href="https://ganhan999.github.io/post/482、密钥格式化/">
        </link>
        <updated>2021-03-27T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。<br>
给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。<br>
给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p>示例 1：<br>
输入：S = &quot;5F3Z-2e-9-w&quot;, K = 4<br>
输出：&quot;5F3Z-2E9W&quot;<br>
解释：字符串 S 被分成了两个部分，每部分 4 个字符；<br>
注意，两个额外的破折号需要删掉。</p>
<p>示例 2：<br>
输入：S = &quot;2-5g-3-J&quot;, K = 2<br>
输出：&quot;2-5G-3J&quot;<br>
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>朴实无华解法</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -&gt; str:
        st = S.replace('-','').upper()
        a = len(st)
        if a == 0:
            return ''
        b = a%K
        if b == 0:
            c = (a//K) - 1
            b = K
        else:
            c = a//K
        s = st[:b]
        while c != 0:
            s += '-' + st[b:b+K]
            b = b+K
            c -= 1
        return s
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[485、最大连续 1 的个数]]></title>
        <id>https://ganhan999.github.io/post/485、最大连续 1 的个数/</id>
        <link href="https://ganhan999.github.io/post/485、最大连续 1 的个数/">
        </link>
        <updated>2021-03-27T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个二进制数组， 计算其中最大连续 1 的个数。</p>
<p>示例：<br>
输入：[1,1,0,1,1,1]<br>
输出：3<br>
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>为了得到数组中最大连续 1 的个数，需要遍历数组，并记录最大的连续 1 的个数和当前的连续 1 的个数。如果当前元素是 1，<br>
则将当前的连续 11 的个数加 11，否则，使用之前的连续 11 的个数更新最大的连续 1 的个数，并将当前的连续 1 的个数清零。</p>
<p>遍历数组结束之后，需要再次使用当前的连续 1 的个数更新最大的连续 1 的个数，<br>
因为数组的最后一个元素可能是 1，且最长连续 1 的子数组可能出现在数组的末尾，如果遍历数组结束之后不更新最大的连续 1 的个数，则会导致结果错误。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:
        maxCount = count = 0

        for i, num in enumerate(nums):
            if num == 1:
                count += 1
            else:
                maxCount = max(maxCount, count)
                count = 0

        maxCount = max(maxCount, count)
        return maxCount
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>记录零的位置</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        index = -1
        res = 0
        for i, num in enumerate(nums):
            if num == 0:
                index = i
            else:
                res = max(res, i - index)
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[476、数字的补数]]></title>
        <id>https://ganhan999.github.io/post/476、数字的补数/</id>
        <link href="https://ganhan999.github.io/post/476、数字的补数/">
        </link>
        <updated>2021-03-27T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给你一个正整数 num ，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>示例 1：<br>
输入：num = 5<br>
输出：2<br>
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</p>
<p>示例 2：<br>
输入：num = 1<br>
输出：0<br>
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>诸位遍历 把1换0 0换1</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findComplement(self, num: int) -&gt; int:
        num = bin(num)[2:] # 转二进制
        res = ''
        for i in range(len(num)):
            if num[i] == '0':res += '1'
            else:res += '0'
        # print (res,num)
        return int(res,2) # 转十进制
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>安排一个全1给它异或</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def findComplement(self, num: int) -&gt; int:
        bits = len(str(bin(num))) - 2
        return num ^ (2 ** bits - 1)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[463、岛屿的周长]]></title>
        <id>https://ganhan999.github.io/post/463、岛屿的周长/</id>
        <link href="https://ganhan999.github.io/post/463、岛屿的周长/">
        </link>
        <updated>2021-03-26T04:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。</p>
<p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。</p>
<p>计算这个岛屿的周长。</p>
<p>示例 1：<br>
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]<br>
输出：16<br>
解释：它的周长是上面图片中的 16 个黄色的边</p>
<p>示例 2：<br>
输入：grid = [[1]]<br>
输出：4</p>
<p>示例 3：<br>
输入：grid = [[1,0]]<br>
输出：4</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>直接遍历，如果当前值为1，加4（四条边），如果左边有1，减2（两条边重合），上面有1，减2。<br>
最后相加即可</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:
        res=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    res+=4
                    if i-1&gt;=0 and grid[i-1][j]==1:
                        res-=2
                    if j-1&gt;=0 and grid[i][j-1]==1:
                        res-=2
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[461、汉明距离]]></title>
        <id>https://ganhan999.github.io/post/461、汉明距离/</id>
        <link href="https://ganhan999.github.io/post/461、汉明距离/">
        </link>
        <updated>2021-03-26T03:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<br>
给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>注意：<br>
0 ≤ x, y &lt; 231.</p>
<p>示例:<br>
输入: x = 1, y = 4<br>
输出: 2</p>
<p>解释:<br>
1   (0 0 0 1)<br>
4   (0 1 0 0)<br>
↑   ↑<br>
上面的箭头指出了对应二进制位不同的位置。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>先异或 再数1</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        return bin(x ^ y).count('1')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[459、重复的子字符串]]></title>
        <id>https://ganhan999.github.io/post/459、重复的子字符串/</id>
        <link href="https://ganhan999.github.io/post/459、重复的子字符串/">
        </link>
        <updated>2021-03-25T02:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>
输入: &quot;abab&quot;<br>
输出: True<br>
解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</p>
<p>示例 2:<br>
输入: &quot;aba&quot;<br>
输出: False</p>
<p>示例 3:<br>
输入: &quot;abcabcabcabc&quot;<br>
输出: True<br>
解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>如果s中包含重复的子字符串，那么说明s中至少包含两个子字符串，s+s至少包含4个字串，前后各去掉一位，查找s是否在新构建的字符串中。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        return s in (s+s)[1:-1]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>把两个字符串s拼接在一起，会有以下两种情况：</p>
<p>当s不是循环字符串时：<br>
第一次发现s的起点是在lens（s）</p>
<p>当s是循环字符串时：<br>
第一次发现s的起点是在小于lens（s）</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        return (s+s).find(s,1) != len(s)
</code></pre>
]]></content>
    </entry>
</feed>
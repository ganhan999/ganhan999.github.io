<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-04-14T09:23:40.016Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[617、合并二叉树]]></title>
        <id>https://ganhan999.github.io/post/617、合并二叉树/</id>
        <link href="https://ganhan999.github.io/post/617、合并二叉树/">
        </link>
        <updated>2021-04-14T10:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例1:</p>
<p>输入:<br>
Tree 1                     Tree 2<br>
1                         2<br>
/ \                       / \<br>
3   2                   1   3<br>
/                           \   \<br>
5                             4   7<br>
输出:<br>
合并后的树:<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
5   4   7</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode:
        if not t1:
            return t2
        if not t2:
            return t1
        merged = TreeNode(t1.val + t2.val)
        merged.left = self.mergeTrees(t1.left, t2.left)
        merged.right = self.mergeTrees(t1.right, t2.right)
        return merged
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[606、根据二叉树创建字符串]]></title>
        <id>https://ganhan999.github.io/post/606、根据二叉树创建字符串/</id>
        <link href="https://ganhan999.github.io/post/606、根据二叉树创建字符串/">
        </link>
        <updated>2021-04-14T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。<br>
空节点则用一对空括号 &quot;()&quot; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例 1:<br>
输入: 二叉树: [1,2,3,4]<br>
1<br>
/   <br>
2     3<br>
/<br>
4</p>
<p>输出: &quot;1(2(4))(3)&quot;</p>
<p>解释: 原本将是“1(2(4)())(3())”，<br>
在你省略所有不必要的空括号对之后，<br>
它将是“1(2(4))(3)”。</p>
<p>示例 2:<br>
输入: 二叉树: [1,2,3,null,4]<br>
1<br>
/   <br>
2     3<br>
<br>
4</p>
<p>输出: &quot;1(2()(4))(3)&quot;<br>
解释: 和第一个示例相似，<br>
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        def func(node):
            if not node:
                return '()'
            l = func(node.left)
            r = func(node.right)
            if l == r == '()':
                return '(' + str(node.val) + ')'
            elif l != '()' and r == '()':
                return '(' + str(node.val) + l + ')'
            else:
                return '(' + str(node.val) + l + r + ')'

        return func(t)[1:-1]#去除第一个和最后一个括号
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[605、种花问题]]></title>
        <id>https://ganhan999.github.io/post/605、种花问题/</id>
        <link href="https://ganhan999.github.io/post/605、种花问题/">
        </link>
        <updated>2021-04-13T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数n ，能否在不打破种植规则的情况下种入n朵花？能则返回 true ，不能则返回 false。</p>
<p>示例 1：<br>
输入：flowerbed = [1,0,0,0,1], n = 1<br>
输出：true<br>
示例 2：</p>
<p>输入：flowerbed = [1,0,0,0,1], n = 2<br>
输出：false</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>连续三个0则可以种一盆花</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:
        flowerbed = [0] + flowerbed#前后都补0
        flowerbed = flowerbed + [0]#前后都补0
        for i in range(1, len(flowerbed) - 1):
            if flowerbed[i - 1] == 0 and flowerbed[i] == 0 and flowerbed[i + 1] == 0:
                n = n - 1
                flowerbed[i] = 1
        return n &lt;= 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[599、两个列表的最小索引总和]]></title>
        <id>https://ganhan999.github.io/post/599、两个列表的最小索引总和/</id>
        <link href="https://ganhan999.github.io/post/599、两个列表的最小索引总和/">
        </link>
        <updated>2021-04-12T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。<br>
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p>
<p>示例 1:<br>
输入:<br>
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>
[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]<br>
输出: [&quot;Shogun&quot;]<br>
解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p>
<p>示例 2:<br>
输入:<br>
[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>
[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]<br>
输出: [&quot;Shogun&quot;]<br>
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>步骤：<br>
1、求两者交集<br>
2、第一次遍历，找到索引最小的<br>
3、第二次遍历，把索引最小对应餐厅加入结果中</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]:
        l1=set(list1)
        l2=set(list2)
        l12=l1&amp;l2
        res=[]
        tmp=float('inf')
        for i in l12:
            tmp=min(tmp,list1.index(i)+list2.index(i))
        for i in l12:
            if list1.index(i)+list2.index(i)==tmp:
                res.append(i)
        return res

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[598、范围求和 II]]></title>
        <id>https://ganhan999.github.io/post/598、范围求和 II/</id>
        <link href="https://ganhan999.github.io/post/598、范围求和 II/">
        </link>
        <updated>2021-04-11T09:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个初始元素全部为0，大小为 m*n 的矩阵M以及在M上的一系列更新操作。</p>
<p>操作用二维数组表示，其中的每个操作用一个含有两个正整数a 和 b 的数组表示，含义是将所有符合0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素M[i][j]的值都增加 1。</p>
<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<p>示例 1:</p>
<p>输入:<br>
m = 3, n = 3<br>
operations = [[2,2],[3,3]]<br>
输出: 4<br>
解释:<br>
初始状态, M =<br>
[[0, 0, 0],<br>
[0, 0, 0],<br>
[0, 0, 0]]</p>
<p>执行完操作 [2,2] 后, M =<br>
[[1, 1, 0],<br>
[1, 1, 0],<br>
[0, 0, 0]]</p>
<p>执行完操作 [3,3] 后, M =<br>
[[2, 2, 1],<br>
[2, 2, 1],<br>
[1, 1, 1]]<br>
M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>短板效应</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -&gt; int:
        if not ops:
            return m*n
        a = min(map(lambda x: x[0], ops))
        b = min(map(lambda x: x[1], ops))
        return a*b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[594、最长和谐子序列]]></title>
        <id>https://ganhan999.github.io/post/594、最长和谐子序列/</id>
        <link href="https://ganhan999.github.io/post/594、最长和谐子序列/">
        </link>
        <updated>2021-04-10T04:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p>
<p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>
<p>示例 1：<br>
输入：nums = [1,3,2,2,5,2,3,7]<br>
输出：5<br>
解释：最长的和谐子序列是 [3,2,2,2,3]</p>
<p>示例 2：<br>
输入：nums = [1,2,3,4]<br>
输出：2</p>
<p>示例 3：<br>
输入：nums = [1,1,1,1]<br>
输出：0</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>利用哈希表存储数组中元素出现的次数<br>
遍历哈希表，如果当前元素+1也在哈希表中，那么计算两者次数之和，保留最大值</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findLHS(self, nums: List[int]) -&gt; int:
        dicts={}
        for i in nums:
            dicts[i]=dicts.get(i,0)+1
        res=0
        for i in dicts:
            if i+1 in dicts:
                res=max(res,dicts[i]+dicts[i+1])
        return res
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>首先将原数组排序，得到递增数组；<br>
然后遍历一遍数组，利用双指针实现类似滑动窗口的功能</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def findLHS(self, nums: List[int]) -&gt; int:
        nums.sort()
        left=0
        res=0
        for right in range(len(nums)):
            while nums[right]-nums[left]&gt;1:
                left+=1
            if nums[right]-nums[left]==1:
                res=max(res,right-left+1)
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[590、N 叉树的后序遍历]]></title>
        <id>https://ganhan999.github.io/post/590、N 叉树的后序遍历/</id>
        <link href="https://ganhan999.github.io/post/590、N 叉树的后序遍历/">
        </link>
        <updated>2021-04-09T12:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个 N 叉树，返回其节点值的 后序遍历 。<br>
N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
<p>进阶：<br>
递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>示例 1：<br>
输入：root = [1,null,3,2,4,null,5,6]<br>
输出：[5,6,3,2,4,1]</p>
<p>示例 2：<br>
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>
输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def preorder(self, root: 'Node') -&gt; List[int]:
        #保存节点值
        result = []
        #后序遍历
        def pre_order(root):
            #跟节点非空入队列递归遍历
            if root:
                #递归遍历
                for node in root.children:
                    pre_order(node)
                #节点值入队列
                result.append(root.val)
        pre_order(root)
        return result
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>迭代</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def postorder(self, root: 'Node') -&gt; List[int]:
        if not root:
            return []
        res = []
        stack = []
        stack.append(root)
        while stack:
            node = stack.pop()
            res.append(node.val)
            stack.extend(node.children)
        return res[::-1]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[589、N 叉树的前序遍历]]></title>
        <id>https://ganhan999.github.io/post/589、N 叉树的前序遍历/</id>
        <link href="https://ganhan999.github.io/post/589、N 叉树的前序遍历/">
        </link>
        <updated>2021-04-09T11:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个 N 叉树，返回其节点值的 前序遍历 。<br>
N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
<p>进阶：<br>
递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>示例 1：<br>
输入：root = [1,null,3,2,4,null,5,6]<br>
输出：[1,3,5,6,2,4]</p>
<p>示例 2：<br>
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def preorder(self, root: 'Node') -&gt; List[int]:
        res = []

        def helper(root):
            if not root:
                return
            res.append(root.val)
            for child in root.children:
                helper(child)

        helper(root)
        
        return res
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>迭代</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def preorder(self, root: 'Node') -&gt; List[int]:
        if root is None:
            return []
        stack = [root]                                  #初始化一个数据
        out = []
        while stack:
            temp = stack.pop()                          #先把栈顶的数据弹出来加入到 输出 集
            out.append(temp.val)
            if temp.children:                           #如果该元素有子节点children 则反转加入到 stack 里(因为是前序遍历)
                for item in temp.children[::-1]:
                    stack.append(item)
        return out
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[575、分糖果]]></title>
        <id>https://ganhan999.github.io/post/575、分糖果/</id>
        <link href="https://ganhan999.github.io/post/575、分糖果/">
        </link>
        <updated>2021-04-09T10:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<p>示例 1:<br>
输入: candies = [1,1,2,2,3,3]<br>
输出: 3<br>
解析: 一共有三种种类的糖果，每一种都有两个。<br>
最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p>
<p>示例 2 :<br>
输入: candies = [1,1,2,3]<br>
输出: 2<br>
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>如果种类超过一半，返回数组的一半<br>
如果种类没有超过一半，返回集合的长度</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def distributeCandies(self, candies: List[int]) -&gt; int:
        return len(set(candies)) if len(set(candies))&lt;len(candies)//2 else len(candies)//2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[572、另一个树的子树]]></title>
        <id>https://ganhan999.github.io/post/572、另一个树的子树/</id>
        <link href="https://ganhan999.github.io/post/572、另一个树的子树/">
        </link>
        <updated>2021-04-07T14:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个非空二叉树 s 和 t，检验s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。<br>
s 也可以看做它自身的一棵子树。</p>
<p>示例 1:<br>
给定的树 s:</p>
<p>​     3<br>
​    / \</p>
<p>4   5<br>
/ <br>
1   2<br>
给定的树 t：</p>
<p>4<br>
/ <br>
1   2<br>
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:<br>
给定的树 s：</p>
<p>​     3<br>
​    / \</p>
<p>4   5<br>
/ <br>
1   2<br>
/<br>
0<br>
给定的树 t：</p>
<p>4<br>
/ <br>
1   2<br>
返回 false。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>判断两个树是否相等的三个条件是与的关系，即：</p>
<p>当前两个树的根节点值相等；<br>
并且，s 的左子树和 t 的左子树相等；<br>
并且，s 的右子树和 t 的右子树相等。<br>
而判断 t 是否为 s 的子树的三个条件是或的关系，即：</p>
<p>当前两棵树相等；<br>
或者，t 是 s 的左子树；<br>
或者，t 是 s 的右子树。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution(object):
    def isSubtree(self, s, t):
        &quot;&quot;&quot;
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        if not s and not t:
            return True
        if not s or not t:
            return False
        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)

    def isSameTree(self, s, t):
        if not s and not t:
            return True
        if not s or not t:
            return False
        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)
</code></pre>
]]></content>
    </entry>
</feed>
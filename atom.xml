<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ganhan999.github.io/</id>
    <title>Gridea</title>
    <updated>2021-03-16T08:27:45.883Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ganhan999.github.io/"/>
    <link rel="self" href="https://ganhan999.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ganhan999.github.io/images/avatar.png</logo>
    <icon>https://ganhan999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[404、左叶子之和]]></title>
        <id>https://ganhan999.github.io/post/404、左叶子之和/</id>
        <link href="https://ganhan999.github.io/post/404、左叶子之和/">
        </link>
        <updated>2021-03-15T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>递归 DFS</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:

        def dfs(root, flag=False):  # 初始化flag = False
            if not root: return 0  # 先判断root是否为None，否则下面的判断语句会报错
            if not root.right and not root.left and flag:  # 前两个条件保证是否是叶子节点，flag保证是否是左孩子
                return root.val  # 如果是左叶子结点就加上其值
            return dfs(root.right, False) + dfs(root.left, True)  # 递归root的左孩子并让flag = True, 右孩子flag = False

        return dfs(root)  # 返回结果
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>BFS 广度优先遍历  也是放一个标志位表示左节点</p>
<h1 id="大神做法1-2">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        def dfs(root, flag=False):  # 初始化flag = False
            if not root: return 0  # 先判断root是否为None，否则下面的判断语句会报错
            if not root.right and not root.left and flag:  # 前两个条件保证是否是叶子节点，flag保证是否是左孩子
                return root.val  # 如果是左叶子结点就加上其值
            return dfs(root.right, False) + dfs(root.left, True)  # 递归root的左孩子并让flag = True, 右孩子flag = False
        return dfs(root)  # 返回结果

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[401、二进制手表]]></title>
        <id>https://ganhan999.github.io/post/401、二进制手表/</id>
        <link href="https://ganhan999.github.io/post/401、二进制手表/">
        </link>
        <updated>2021-03-15T09:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。</p>
<p>每个 LED 代表一个 0 或 1，最低位在右侧。</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>为了方便计算，分别设置了小时数组和分钟数组<br>
递归的四个参数分别代表：剩余需要点亮的灯数量，从索引index开始往后点亮灯，当前小时数，当前分钟数<br>
每次进入递归后，先判断当前小时数和分钟数是否符合要求，不符合直接return<br>
for循环枚举点亮灯的情况，从index枚举到10，每次枚举</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution(object):
    def readBinaryWatch(self, num: int) -&gt; List[str]:
        hours = [1, 2, 4, 8, 0, 0, 0, 0, 0, 0]
        minutes = [0, 0, 0, 0, 1, 2, 4, 8, 16, 32]
        res = []

        def backtrack(num, index, hour, minute):
            if hour &gt; 11 or minute &gt; 59:
                return
            if num == 0:
                res.append('%d:%02d' % (hour, minute))
                return
            for i in range(index, 10):
                backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i])

        backtrack(num, 0, 0, 0)
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[392、判断子序列]]></title>
        <id>https://ganhan999.github.io/post/392、判断子序列/</id>
        <link href="https://ganhan999.github.io/post/392、判断子序列/">
        </link>
        <updated>2021-03-09T11:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。<br>
（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p>
<p>进阶：<br>
如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>示例 1：<br>
输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;<br>
输出：true<br>
示例 2：<br>
输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;<br>
输出：false</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>双指针</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        n, m = len(s), len(t)
        i = j = 0
        while i &lt; n and j &lt; m:
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == n
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>动态规划</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        n, m = len(s), len(t)
        f = [[0] * 26 for _ in range(m)]
        f.append([m] * 26)

        for i in range(m - 1, -1, -1):
            for j in range(26):
                f[i][j] = i if ord(t[i]) == j + ord('a') else f[i + 1][j]

        add = 0
        for i in range(n):
            if f[add][ord(s[i]) - ord('a')] == m:
                return False
            add = f[add][ord(s[i]) - ord('a')] + 1

        return True
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>对索引二分查找</p>
<h1 id="大神做法3">大神做法3：</h1>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        hashmap = {}
        for i, c in enumerate(t):
            if c not in hashmap:
                hashmap[c] = [i]
            else:
                hashmap[c].append(i)

        j = 0
        for i in range(len(s)):
            c = s[i]
            if c not in hashmap:
                return False
            pos = self.find_left(hashmap[c], j)  # 二分搜索与c匹配的下一个索引，避免线性扫描
            if pos &gt;= len(hashmap[c]):#如果超过了 那么不可能匹配
                return False
            j = hashmap[c][pos] + 1
        return True

    def find_left(self, index, target):
        left, right = 0, len(index) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if index[mid] &lt; target:
                left = mid + 1
            else:
                right = mid - 1
        return left
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[389、找不同]]></title>
        <id>https://ganhan999.github.io/post/389、找不同/</id>
        <link href="https://ganhan999.github.io/post/389、找不同/">
        </link>
        <updated>2021-03-09T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
<p>示例 1：<br>
输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;<br>
输出：&quot;e&quot;<br>
解释：'e' 是那个被添加的字母。</p>
<p>示例 2：<br>
输入：s = &quot;&quot;, t = &quot;y&quot;<br>
输出：&quot;y&quot;</p>
<p>示例 3：<br>
输入：s = &quot;a&quot;, t = &quot;aa&quot;<br>
输出：&quot;a&quot;</p>
<p>示例 4：<br>
输入：s = &quot;ae&quot;, t = &quot;aea&quot;<br>
输出：&quot;a&quot;</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>首先将两个字符串合并为a<br>
在a中遍历，如果出现奇数次的字符即为不同的字符</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        a = &quot;&quot;.join([s,t])
        for ch in a:
            if a.count(ch) % 2 == 1:
                return ch
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>题目已说明，字符串 t 比字符串 s 多一个字母，那么我们可以先用数组统计 ss 的字符出现的次数。</p>
<p>然后开始遍历字符串 t，数组中对应字符的次数减 1。当数组中出现负数，那么代表对应的字符就是添加的字母。</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        # 长度为 26 的数组，用以统计字符出现次数
        str_count = [0] * 26
        # 先遍历 s，统计 s 中字符出现的次数
        for ch in s:
            str_count[ord(ch) - ord('a')] += 1
        # 再遍历 t，将出现字符对应次数减 1，
        # 当出现负值，表示对应的字符就是添加的字母
        for ch in t:
            str_count[ord(ch) - ord('a')] -= 1
            if str_count[ord(ch) - ord('a')] &lt; 0:
                return ch

        return ''
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>异或，最后的结果就是多出来的数字</p>
<h1 id="大神做法3">大神做法3：</h1>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        # 初始化 ans 为 0
        ans = 0
        # 对字符串 s 的字符进行异或
        for ch in s:
            ans ^= ord(ch)
        # 对字符串 t 的字符进行异或
        for ch in t:
            ans ^= ord(ch)
        # 最终结果转换为 ASCII 字符
        return chr(ans)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[387、字符串中的第一个唯一字符]]></title>
        <id>https://ganhan999.github.io/post/387、字符串中的第一个唯一字符/</id>
        <link href="https://ganhan999.github.io/post/387、字符串中的第一个唯一字符/">
        </link>
        <updated>2021-03-09T09:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>示例：<br>
s = &quot;leetcode&quot;<br>
返回 0</p>
<p>s = &quot;loveleetcode&quot;<br>
返回 2</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，<br>
我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回-1。</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        frequency = collections.Counter(s)
        for i, ch in enumerate(s):
            if frequency[ch] == 1:
                return i
        return -1
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c，<br>
如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足<br>
「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 -1）选择弹出队首的元素，直到队首元素「真的」只出现了<br>
一次或者队列为空。</p>
<p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回 -1，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        position = dict()
        q = collections.deque()
        n = len(s)
        for i, ch in enumerate(s):
            if ch not in position:
                position[ch] = i
                q.append((s[i], i))
            else:
                position[ch] = -1
                while q and position[q[0][0]] == -1:
                    q.popleft()
        return -1 if not q else q[0][1]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>异或，最后的结果就是多出来的数字</p>
<h1 id="大神做法3">大神做法3：</h1>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        # 初始化 ans 为 0
        ans = 0
        # 对字符串 s 的字符进行异或
        for ch in s:
            ans ^= ord(ch)
        # 对字符串 t 的字符进行异或
        for ch in t:
            ans ^= ord(ch)
        # 最终结果转换为 ASCII 字符
        return chr(ans)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[383、赎金信]]></title>
        <id>https://ganhan999.github.io/post/383、赎金信/</id>
        <link href="https://ganhan999.github.io/post/383、赎金信/">
        </link>
        <updated>2021-03-08T10:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom<br>
能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p>示例 1：<br>
输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;<br>
输出：false</p>
<p>示例 2：<br>
输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;<br>
输出：false</p>
<p>示例 3：<br>
输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;<br>
输出：true</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>首先利用collections.Counter 得到元素的计数集合<br>
再利用差集</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        hash_table_m = collections.Counter(magazine)
        hash_table_r = collections.Counter(ransomNote)

        &quot;&quot;&quot;for i in hash_table_r:
            if hash_table_r[i] &gt; hash_table_m[i]:
                return False
        return True&quot;&quot;&quot;
        return not hash_table_r - hash_table_m
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>得到ransomnote的计数集合，然后分析magazine中的元素计数是不是比ransomnote的计数集合的更少</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        a = dict(collections.Counter(ransomNote))
        for k, v in a.items():
            if magazine.count(k) &lt; v:
                return False
        return True
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[374、猜数字大小]]></title>
        <id>https://ganhan999.github.io/post/374、猜数字大小/</id>
        <link href="https://ganhan999.github.io/post/374、猜数字大小/">
        </link>
        <updated>2021-03-08T09:39:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>猜数字游戏的规则如下：<br>
每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。<br>
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，<br>
返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<p>-1：我选出的数字比你猜的数字小 pick &lt; num<br>
1：我选出的数字比你猜的数字大 pick &gt; num<br>
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num<br>
返回我选出的数字。</p>
<p>示例 1：<br>
输入：n = 10, pick = 6<br>
输出：6</p>
<p>示例 2：<br>
输入：n = 1, pick = 1<br>
输出：1</p>
<p>示例 3：<br>
输入：n = 2, pick = 1<br>
输出：1</p>
<p>示例 4：<br>
输入：n = 2, pick = 2<br>
输出：2</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>二分法</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l, r = 1, n
        # 二分查找
        while l &lt; r:
            mid = (l + r) &gt;&gt; 1
            check = guess(mid)
            if check &lt; 0:
                r = mid
            elif check &gt; 0:
                l = mid + 1
            else:
                return mid
        return l
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[367、有效的完全平方数]]></title>
        <id>https://ganhan999.github.io/post/367、有效的完全平方数/</id>
        <link href="https://ganhan999.github.io/post/367、有效的完全平方数/">
        </link>
        <updated>2021-03-08T09:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p>
<p>说明：不要使用任何内置的库函数，如 sqrt。</p>
<p>示例 1：<br>
输入：16<br>
输出：True</p>
<p>示例 2：<br>
输入：14<br>
输出：False&quot;</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>二分法</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        l, r = 1, num
        while l &lt; r:
            mid = (l + r) // 2
            if mid * mid &lt; num:
                l = mid + 1
            else:
                r = mid
        return l * l == num
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>牛顿迭代法</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        if num &lt; 2:
            return True

        x = num // 2
        while x * x &gt; num:
            x = (x + num // x) // 2
        return x * x == num
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[350、两个数组的交集 II]]></title>
        <id>https://ganhan999.github.io/post/350、两个数组的交集 II/</id>
        <link href="https://ganhan999.github.io/post/350、两个数组的交集 II/">
        </link>
        <updated>2021-03-07T14:34:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：<br>
输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>
输出：[2,2]</p>
<p>示例 2：<br>
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>
输出：[9,4]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>哈希表<br>
由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，<br>
其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。</p>
<p>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，<br>
对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。</p>
<p>为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        if len(nums1) &gt; len(nums2):
            return self.intersect(nums2, nums1)

        m = collections.Counter()
        for num in nums1:
            m[num] += 1

        intersection = list()
        for num in nums2:
            if (m.get(num, 0)) &gt; 0:
                intersection.append(num)
                m[num] -= 1
                if m[num] == 0:
                    m.pop(num)
        return intersection
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>排序加双指针</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1.sort()
        nums2.sort()
        length1, length2 = len(nums1), len(nums2)
        intersection = list()
        index1 = index2 = 0
        while index1 &lt; length1 and index2 &lt; length2:
            num1 = nums1[index1]
            num2 = nums2[index2]
            if num1 == num2:
                # 保证加入元素的唯一性
                intersection.append(num1)
                index1 += 1
                index2 += 1
            elif num1 &lt; num2:
                index1 += 1
            else:
                index2 += 1
        return intersection
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[349、两个数组的交集]]></title>
        <id>https://ganhan999.github.io/post/349、两个数组的交集/</id>
        <link href="https://ganhan999.github.io/post/349、两个数组的交集/">
        </link>
        <updated>2021-03-07T14:29:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：<br>
输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>
输出：[2]</p>
<p>示例 2：<br>
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>
输出：[9,4]</p>
<p>&quot;&quot;&quot;&quot;&quot;&quot;</p>
<h1 id="本体思路">本体思路</h1>
<p>取两个集合<br>
然后遍历短的集合元素 判断是否在另一个集合里面</p>
<h1 id="大神做法1">大神做法1：</h1>
<pre><code class="language-python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        return self.set_intersection(set1, set2)

    def set_intersection(self, set1, set2):
        if len(set1) &gt; len(set2):
            return self.set_intersection(set2, set1)
        return [x for x in set1 if x in set2]
</code></pre>
<p>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</p>
<p>排序加双指针</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，<br>
则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于上一个被存入的数字，将该数字添加到答案，<br>
同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
<h1 id="大神做法2">大神做法2：</h1>
<pre><code class="language-python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1.sort()
        nums2.sort()
        length1, length2 = len(nums1), len(nums2)
        intersection = list()
        index1 = index2 = 0
        while index1 &lt; length1 and index2 &lt; length2:
            num1 = nums1[index1]
            num2 = nums2[index2]
            if num1 == num2:
                # 保证加入元素的唯一性
                if not intersection or num1 != intersection[-1]:
                    intersection.append(num1)
                index1 += 1
                index2 += 1
            elif num1 &lt; num2:
                index1 += 1
            else:
                index2 += 1
        return intersection
</code></pre>
]]></content>
    </entry>
</feed>